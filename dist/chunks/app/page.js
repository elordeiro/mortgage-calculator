/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Festevaolordeiro%2FGitHub%2Fmortgage-calculator%2Fapp%2Fpage.tsx&server=false!":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Festevaolordeiro%2FGitHub%2Fmortgage-calculator%2Fapp%2Fpage.tsx&server=false! ***!
  \******************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRmVzdGV2YW9sb3JkZWlybyUyRkdpdEh1YiUyRm1vcnRnYWdlLWNhbGN1bGF0b3IlMkZhcHAlMkZwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MGNlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9lc3RldmFvbG9yZGVpcm8vR2l0SHViL21vcnRnYWdlLWNhbGN1bGF0b3IvYXBwL3BhZ2UudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Festevaolordeiro%2FGitHub%2Fmortgage-calculator%2Fapp%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/highcharts-react-official/dist/highcharts-react.min.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/highcharts-react-official/dist/highcharts-react.min.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n!function(t, e) {\n     true ? module.exports = e(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\")) : 0;\n}(\"undefined\" != typeof self ? self : void 0, function(t) {\n    return function(t) {\n        function e(n) {\n            if (r[n]) return r[n].exports;\n            var o = r[n] = {\n                i: n,\n                l: !1,\n                exports: {}\n            };\n            return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;\n        }\n        var r = {};\n        return e.m = t, e.c = r, e.d = function(t, r, n) {\n            e.o(t, r) || Object.defineProperty(t, r, {\n                configurable: !1,\n                enumerable: !0,\n                get: n\n            });\n        }, e.n = function(t) {\n            var r = t && t.__esModule ? function() {\n                return t.default;\n            } : function() {\n                return t;\n            };\n            return e.d(r, \"a\", r), r;\n        }, e.o = function(t, e) {\n            return Object.prototype.hasOwnProperty.call(t, e);\n        }, e.p = \"\", e(e.s = 0);\n    }([\n        function(t, e, r) {\n            \"use strict\";\n            function n() {\n                return n = Object.assign ? Object.assign.bind() : function(t) {\n                    for(var e = 1; e < arguments.length; e++){\n                        var r = arguments[e];\n                        for(var n in r)Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n                    }\n                    return t;\n                }, n.apply(this, arguments);\n            }\n            function o(t) {\n                return a(t) || i(t) || u(t) || c();\n            }\n            function c() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function u(t, e) {\n                if (t) {\n                    if (\"string\" == typeof t) return f(t, e);\n                    var r = Object.prototype.toString.call(t).slice(8, -1);\n                    return \"Object\" === r && t.constructor && (r = t.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? f(t, e) : void 0;\n                }\n            }\n            function i(t) {\n                if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n            }\n            function a(t) {\n                if (Array.isArray(t)) return f(t);\n            }\n            function f(t, e) {\n                (null == e || e > t.length) && (e = t.length);\n                for(var r = 0, n = new Array(e); r < e; r++)n[r] = t[r];\n                return n;\n            }\n            function s(t) {\n                \"@babel/helpers - typeof\";\n                return (s = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(t) {\n                    return typeof t;\n                } : function(t) {\n                    return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n                })(t);\n            }\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), r.d(e, \"HighchartsReact\", function() {\n                return d;\n            });\n            var p = r(1), l = r.n(p), y =  true ? p.useLayoutEffect : 0, d = Object(p.memo)(Object(p.forwardRef)(function(t, e) {\n                var r = Object(p.useRef)(), c = Object(p.useRef)(), u = Object(p.useRef)(t.constructorType), i = Object(p.useRef)(t.highcharts);\n                return y(function() {\n                    function e() {\n                        var e = t.highcharts || \"object\" === ( false ? 0 : s(window)) && window.Highcharts, n = t.constructorType || \"chart\";\n                        e ? e[n] ? t.options ? c.current = e[n](r.current, t.options, t.callback) : console.warn('The \"options\" property was not passed.') : console.warn('The \"constructorType\" property is incorrect or some required module is not imported.') : console.warn('The \"highcharts\" property was not passed.');\n                    }\n                    if (c.current) {\n                        if (!1 !== t.allowChartUpdate) if (t.constructorType !== u.current || t.highcharts !== i.current) u.current = t.constructorType, i.current = t.highcharts, e();\n                        else if (!t.immutable && c.current) {\n                            var n;\n                            (n = c.current).update.apply(n, [\n                                t.options\n                            ].concat(o(t.updateArgs || [\n                                !0,\n                                !0\n                            ])));\n                        } else e();\n                    } else e();\n                }, [\n                    t.options,\n                    t.allowChartUpdate,\n                    t.updateArgs,\n                    t.containerProps,\n                    t.highcharts,\n                    t.constructorType\n                ]), y(function() {\n                    return function() {\n                        c.current && (c.current.destroy(), c.current = null);\n                    };\n                }, []), Object(p.useImperativeHandle)(e, function() {\n                    return {\n                        get chart () {\n                            return c.current;\n                        },\n                        container: r\n                    };\n                }, []), l.a.createElement(\"div\", n({}, t.containerProps, {\n                    ref: r\n                }));\n            }));\n            e.default = d;\n        },\n        function(e, r) {\n            e.exports = t;\n        }\n    ]);\n}); //# sourceMappingURL=highcharts-react.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oaWdoY2hhcnRzLXJlYWN0LW9mZmljaWFsL2Rpc3QvaGlnaGNoYXJ0cy1yZWFjdC5taW4uanMiLCJtYXBwaW5ncyI6IjtBQUFBLENBQUMsU0FBU0EsQ0FBQyxFQUFDQyxDQUFDO0lBQUUsS0FBaURFLEdBQUNBLE9BQU9ELE9BQU8sR0FBQ0QsRUFBRUcsbUJBQU9BLENBQUMsbUZBQU8sS0FBRyxDQUEySjtBQUFBLEVBQUUsZUFBYSxPQUFPSyxPQUFLQSxPQUFLLFFBQUssU0FBU1QsQ0FBQztJQUFFLE9BQU8sU0FBU0EsQ0FBQztRQUFFLFNBQVNDLEVBQUVTLENBQUM7WUFBRSxJQUFHQyxDQUFDLENBQUNELEVBQUUsRUFBQyxPQUFPQyxDQUFDLENBQUNELEVBQUUsQ0FBQ1IsT0FBTztZQUFDLElBQUlVLElBQUVELENBQUMsQ0FBQ0QsRUFBRSxHQUFDO2dCQUFDRyxHQUFFSDtnQkFBRUksR0FBRSxDQUFDO2dCQUFFWixTQUFRLENBQUM7WUFBQztZQUFFLE9BQU9GLENBQUMsQ0FBQ1UsRUFBRSxDQUFDSyxJQUFJLENBQUNILEVBQUVWLE9BQU8sRUFBQ1UsR0FBRUEsRUFBRVYsT0FBTyxFQUFDRCxJQUFHVyxFQUFFRSxDQUFDLEdBQUMsQ0FBQyxHQUFFRixFQUFFVixPQUFPO1FBQUE7UUFBQyxJQUFJUyxJQUFFLENBQUM7UUFBRSxPQUFPVixFQUFFZSxDQUFDLEdBQUNoQixHQUFFQyxFQUFFZ0IsQ0FBQyxHQUFDTixHQUFFVixFQUFFaUIsQ0FBQyxHQUFDLFNBQVNsQixDQUFDLEVBQUNXLENBQUMsRUFBQ0QsQ0FBQztZQUFFVCxFQUFFVyxDQUFDLENBQUNaLEdBQUVXLE1BQUlRLE9BQU9DLGNBQWMsQ0FBQ3BCLEdBQUVXLEdBQUU7Z0JBQUNVLGNBQWEsQ0FBQztnQkFBRUMsWUFBVyxDQUFDO2dCQUFFQyxLQUFJYjtZQUFDO1FBQUUsR0FBRVQsRUFBRVMsQ0FBQyxHQUFDLFNBQVNWLENBQUM7WUFBRSxJQUFJ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QUMsT0FBT3hELEVBQUU0QyxPQUFPO3dCQUFBO3dCQUFFYSxXQUFVL0Q7b0JBQUM7Z0JBQUMsR0FBRSxFQUFFLEdBQUVHLEVBQUVxQixDQUFDLENBQUN3QyxhQUFhLENBQUMsT0FBTWpFLEVBQUUsQ0FBQyxHQUFFVixFQUFFc0UsY0FBYyxFQUFDO29CQUFDTSxLQUFJakU7Z0JBQUM7WUFBRztZQUFJVixFQUFFd0IsT0FBTyxHQUFDUDtRQUFDO1FBQUUsU0FBU2pCLENBQUMsRUFBQ1UsQ0FBQztZQUFFVixFQUFFQyxPQUFPLEdBQUNGO1FBQUM7S0FBRTtBQUFDLElBQzk2RyxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hpZ2hjaGFydHMtcmVhY3Qtb2ZmaWNpYWwvZGlzdC9oaWdoY2hhcnRzLXJlYWN0Lm1pbi5qcz82NzhiIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUocmVxdWlyZShcInJlYWN0XCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInJlYWN0XCJdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuSGlnaGNoYXJ0c1JlYWN0PWUocmVxdWlyZShcInJlYWN0XCIpKTp0LkhpZ2hjaGFydHNSZWFjdD1lKHQuUmVhY3QpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUobil7aWYocltuXSlyZXR1cm4gcltuXS5leHBvcnRzO3ZhciBvPXJbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W25dLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLGUpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIGUubT10LGUuYz1yLGUuZD1mdW5jdGlvbih0LHIsbil7ZS5vKHQscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LGUubj1mdW5jdGlvbih0KXt2YXIgcj10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gZS5kKHIsXCJhXCIscikscn0sZS5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxlLnA9XCJcIixlKGUucz0wKX0oW2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKCl7cmV0dXJuIG49T2JqZWN0LmFzc2lnbj9PYmplY3QuYXNzaWduLmJpbmQoKTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1hcmd1bWVudHNbZV07Zm9yKHZhciBuIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbikmJih0W25dPXJbbl0pfXJldHVybiB0fSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBvKHQpe3JldHVybiBhKHQpfHxpKHQpfHx1KHQpfHxjKCl9ZnVuY3Rpb24gYygpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfWZ1bmN0aW9uIHUodCxlKXtpZih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gZih0LGUpO3ZhciByPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09ciYmdC5jb25zdHJ1Y3RvciYmKHI9dC5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09cnx8XCJTZXRcIj09PXI/QXJyYXkuZnJvbSh0KTpcIkFyZ3VtZW50c1wiPT09cnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qocik/Zih0LGUpOnZvaWQgMH19ZnVuY3Rpb24gaSh0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZudWxsIT10W1N5bWJvbC5pdGVyYXRvcl18fG51bGwhPXRbXCJAQGl0ZXJhdG9yXCJdKXJldHVybiBBcnJheS5mcm9tKHQpfWZ1bmN0aW9uIGEodCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gZih0KX1mdW5jdGlvbiBmKHQsZSl7KG51bGw9PWV8fGU+dC5sZW5ndGgpJiYoZT10Lmxlbmd0aCk7Zm9yKHZhciByPTAsbj1uZXcgQXJyYXkoZSk7cjxlO3IrKyluW3JdPXRbcl07cmV0dXJuIG59ZnVuY3Rpb24gcyh0KXtcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7cmV0dXJuKHM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuZChlLFwiSGlnaGNoYXJ0c1JlYWN0XCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciBwPXIoMSksbD1yLm4ocCkseT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3AudXNlTGF5b3V0RWZmZWN0OnAudXNlRWZmZWN0LGQ9T2JqZWN0KHAubWVtbykoT2JqZWN0KHAuZm9yd2FyZFJlZikoZnVuY3Rpb24odCxlKXt2YXIgcj1PYmplY3QocC51c2VSZWYpKCksYz1PYmplY3QocC51c2VSZWYpKCksdT1PYmplY3QocC51c2VSZWYpKHQuY29uc3RydWN0b3JUeXBlKSxpPU9iamVjdChwLnVzZVJlZikodC5oaWdoY2hhcnRzKTtyZXR1cm4geShmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT10LmhpZ2hjaGFydHN8fFwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiOnMod2luZG93KSkmJndpbmRvdy5IaWdoY2hhcnRzLG49dC5jb25zdHJ1Y3RvclR5cGV8fFwiY2hhcnRcIjtlP2Vbbl0/dC5vcHRpb25zP2MuY3VycmVudD1lW25dKHIuY3VycmVudCx0Lm9wdGlvbnMsdC5jYWxsYmFjayk6Y29uc29sZS53YXJuKCdUaGUgXCJvcHRpb25zXCIgcHJvcGVydHkgd2FzIG5vdCBwYXNzZWQuJyk6Y29uc29sZS53YXJuKCdUaGUgXCJjb25zdHJ1Y3RvclR5cGVcIiBwcm9wZXJ0eSBpcyBpbmNvcnJlY3Qgb3Igc29tZSByZXF1aXJlZCBtb2R1bGUgaXMgbm90IGltcG9ydGVkLicpOmNvbnNvbGUud2FybignVGhlIFwiaGlnaGNoYXJ0c1wiIHByb3BlcnR5IHdhcyBub3QgcGFzc2VkLicpfWlmKGMuY3VycmVudCl7aWYoITEhPT10LmFsbG93Q2hhcnRVcGRhdGUpaWYodC5jb25zdHJ1Y3RvclR5cGUhPT11LmN1cnJlbnR8fHQuaGlnaGNoYXJ0cyE9PWkuY3VycmVudCl1LmN1cnJlbnQ9dC5jb25zdHJ1Y3RvclR5cGUsaS5jdXJyZW50PXQuaGlnaGNoYXJ0cyxlKCk7ZWxzZSBpZighdC5pbW11dGFibGUmJmMuY3VycmVudCl7dmFyIG47KG49Yy5jdXJyZW50KS51cGRhdGUuYXBwbHkobixbdC5vcHRpb25zXS5jb25jYXQobyh0LnVwZGF0ZUFyZ3N8fFshMCwhMF0pKSl9ZWxzZSBlKCl9ZWxzZSBlKCl9LFt0Lm9wdGlvbnMsdC5hbGxvd0NoYXJ0VXBkYXRlLHQudXBkYXRlQXJncyx0LmNvbnRhaW5lclByb3BzLHQuaGlnaGNoYXJ0cyx0LmNvbnN0cnVjdG9yVHlwZV0pLHkoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXtjLmN1cnJlbnQmJihjLmN1cnJlbnQuZGVzdHJveSgpLGMuY3VycmVudD1udWxsKX19LFtdKSxPYmplY3QocC51c2VJbXBlcmF0aXZlSGFuZGxlKShlLGZ1bmN0aW9uKCl7cmV0dXJue2dldCBjaGFydCgpe3JldHVybiBjLmN1cnJlbnR9LGNvbnRhaW5lcjpyfX0sW10pLGwuYS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsbih7fSx0LmNvbnRhaW5lclByb3BzLHtyZWY6cn0pKX0pKTtlLmRlZmF1bHQ9ZH0sZnVuY3Rpb24oZSxyKXtlLmV4cG9ydHM9dH1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGlnaGNoYXJ0cy1yZWFjdC5taW4uanMubWFwIl0sIm5hbWVzIjpbInQiLCJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJIaWdoY2hhcnRzUmVhY3QiLCJSZWFjdCIsInNlbGYiLCJuIiwiciIsIm8iLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJhc3NpZ24iLCJiaW5kIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJhIiwidSIsIlR5cGVFcnJvciIsImYiLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcnJheSIsInZhbHVlIiwieSIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIm1lbW8iLCJmb3J3YXJkUmVmIiwidXNlUmVmIiwiY29uc3RydWN0b3JUeXBlIiwiaGlnaGNoYXJ0cyIsIndpbmRvdyIsIkhpZ2hjaGFydHMiLCJvcHRpb25zIiwiY3VycmVudCIsImNhbGxiYWNrIiwiY29uc29sZSIsIndhcm4iLCJhbGxvd0NoYXJ0VXBkYXRlIiwiaW1tdXRhYmxlIiwidXBkYXRlIiwiY29uY2F0IiwidXBkYXRlQXJncyIsImNvbnRhaW5lclByb3BzIiwiZGVzdHJveSIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjaGFydCIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/highcharts-react-official/dist/highcharts-react.min.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Highcharts JS v11.3.0 (2024-01-10)\n *\n * (c) 2009-2024 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */ \n!function(t, e) {\n     true && module.exports ? (e.default = e, module.exports = t && t.document ? e(t) : e) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return e(t);\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n}( true ? window : 0, function(t) {\n    \"use strict\";\n    var e = {};\n    function i(e, i, s, o) {\n        e.hasOwnProperty(i) || (e[i] = o.apply(null, s), \"function\" == typeof CustomEvent && t.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n            detail: {\n                path: i,\n                module: e[i]\n            }\n        })));\n    }\n    return i(e, \"Core/Globals.js\", [], function() {\n        var e, i;\n        return (i = e || (e = {})).SVG_NS = \"http://www.w3.org/2000/svg\", i.product = \"Highcharts\", i.version = \"11.3.0\", i.win = void 0 !== t ? t : {}, i.doc = i.win.document, i.svg = i.doc && i.doc.createElementNS && !!i.doc.createElementNS(i.SVG_NS, \"svg\").createSVGRect, i.userAgent = i.win.navigator && i.win.navigator.userAgent || \"\", i.isChrome = -1 !== i.userAgent.indexOf(\"Chrome\"), i.isFirefox = -1 !== i.userAgent.indexOf(\"Firefox\"), i.isMS = /(edge|msie|trident)/i.test(i.userAgent) && !i.win.opera, i.isSafari = !i.isChrome && -1 !== i.userAgent.indexOf(\"Safari\"), i.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i.userAgent), i.isWebKit = -1 !== i.userAgent.indexOf(\"AppleWebKit\"), i.deg2rad = 2 * Math.PI / 360, i.hasBidiBug = i.isFirefox && 4 > parseInt(i.userAgent.split(\"Firefox/\")[1], 10), i.hasTouch = !!i.win.TouchEvent, i.marginNames = [\n            \"plotTop\",\n            \"marginRight\",\n            \"marginBottom\",\n            \"plotLeft\"\n        ], i.noop = function() {}, i.supportsPassiveEvents = function() {\n            let t = !1;\n            if (!i.isMS) {\n                let e = Object.defineProperty({}, \"passive\", {\n                    get: function() {\n                        t = !0;\n                    }\n                });\n                i.win.addEventListener && i.win.removeEventListener && (i.win.addEventListener(\"testPassive\", i.noop, e), i.win.removeEventListener(\"testPassive\", i.noop, e));\n            }\n            return t;\n        }(), i.charts = [], i.composed = [], i.dateFormats = {}, i.seriesTypes = {}, i.symbolSizes = {}, i.chartCount = 0, e;\n    }), i(e, \"Core/Utilities.js\", [\n        e[\"Core/Globals.js\"]\n    ], function(t) {\n        let e;\n        let { charts: i, doc: s, win: o } = t;\n        function r(e, i, s, n) {\n            let a = i ? \"Highcharts error\" : \"Highcharts warning\";\n            32 === e && (e = \"\".concat(a, \": Deprecated member\"));\n            let h = p(e), l = h ? \"\".concat(a, \" #\").concat(e, \": www.highcharts.com/errors/\").concat(e, \"/\") : e.toString();\n            if (void 0 !== n) {\n                let t = \"\";\n                h && (l += \"?\"), k(n, function(e, i) {\n                    t += \"\\n - \".concat(i, \": \").concat(e), h && (l += encodeURI(i) + \"=\" + encodeURI(e));\n                }), l += t;\n            }\n            C(t, \"displayError\", {\n                chart: s,\n                code: e,\n                message: l,\n                params: n\n            }, function() {\n                if (i) throw Error(l);\n                o.console && -1 === r.messages.indexOf(l) && console.warn(l);\n            }), r.messages.push(l);\n        }\n        function n(t, e) {\n            return parseInt(t, e || 10);\n        }\n        function a(t) {\n            return \"string\" == typeof t;\n        }\n        function h(t) {\n            let e = Object.prototype.toString.call(t);\n            return \"[object Array]\" === e || \"[object Array Iterator]\" === e;\n        }\n        function l(t, e) {\n            return !!t && \"object\" == typeof t && (!e || !h(t));\n        }\n        function d(t) {\n            return l(t) && \"number\" == typeof t.nodeType;\n        }\n        function c(t) {\n            let e = t && t.constructor;\n            return !!(l(t, !0) && !d(t) && e && e.name && \"Object\" !== e.name);\n        }\n        function p(t) {\n            return \"number\" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;\n        }\n        function u(t) {\n            return null != t;\n        }\n        function g(t, e, i) {\n            let s;\n            let o = a(e) && !u(i), r = (e, i)=>{\n                u(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || \"class\" !== i || (s = t.getAttribute(i + \"Name\")) : t.removeAttribute(i);\n            };\n            return a(e) ? r(i, e) : k(e, r), s;\n        }\n        function f(t) {\n            return h(t) ? t : [\n                t\n            ];\n        }\n        function m(t, e) {\n            let i;\n            for(i in t || (t = {}), e)t[i] = e[i];\n            return t;\n        }\n        function x() {\n            let t = arguments, e = t.length;\n            for(let i = 0; i < e; i++){\n                let e = t[i];\n                if (null != e) return e;\n            }\n        }\n        function y(e, i) {\n            t.isMS && !t.svg && i && u(i.opacity) && (i.filter = \"alpha(opacity=\".concat(100 * i.opacity, \")\")), m(e.style, i);\n        }\n        function b(t) {\n            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));\n        }\n        function v(t, e) {\n            return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));\n        }\n        (r || (r = {})).messages = [], Math.easeInOutSine = function(t) {\n            return -.5 * (Math.cos(Math.PI * t) - 1);\n        };\n        let S = Array.prototype.find ? function(t, e) {\n            return t.find(e);\n        } : function(t, e) {\n            let i;\n            let s = t.length;\n            for(i = 0; i < s; i++)if (e(t[i], i)) return t[i];\n        };\n        function k(t, e, i) {\n            for(let s in t)Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);\n        }\n        function M(t, e, i) {\n            function s(e, i) {\n                let s = t.removeEventListener;\n                s && s.call(t, e, i, !1);\n            }\n            function o(i) {\n                let o, r;\n                t.nodeName && (e ? (o = {})[e] = !0 : o = i, k(o, function(t, e) {\n                    if (i[e]) for(r = i[e].length; r--;)s(e, i[e][r].fn);\n                }));\n            }\n            let r = \"function\" == typeof t && t.prototype || t;\n            if (Object.hasOwnProperty.call(r, \"hcEvents\")) {\n                let t = r.hcEvents;\n                if (e) {\n                    let r = t[e] || [];\n                    i ? (t[e] = r.filter(function(t) {\n                        return i !== t.fn;\n                    }), s(e, i)) : (o(t), t[e] = []);\n                } else o(t), delete r.hcEvents;\n            }\n        }\n        function C(e, i, o, r) {\n            let n;\n            if (o = o || {}, s.createEvent && (e.dispatchEvent || e.fireEvent && e !== t)) (n = s.createEvent(\"Events\")).initEvent(i, !0, !0), o = m(n, o), e.dispatchEvent ? e.dispatchEvent(o) : e.fireEvent(i, o);\n            else if (e.hcEvents) {\n                o.target || m(o, {\n                    preventDefault: function() {\n                        o.defaultPrevented = !0;\n                    },\n                    target: e,\n                    type: i\n                });\n                let t = [], s = e, r = !1;\n                for(; s.hcEvents;)Object.hasOwnProperty.call(s, \"hcEvents\") && s.hcEvents[i] && (t.length && (r = !0), t.unshift.apply(t, s.hcEvents[i])), s = Object.getPrototypeOf(s);\n                r && t.sort((t, e)=>t.order - e.order), t.forEach((t)=>{\n                    !1 === t.fn.call(e, o) && o.preventDefault();\n                });\n            }\n            r && !o.defaultPrevented && r.call(e, o);\n        }\n        k({\n            map: \"map\",\n            each: \"forEach\",\n            grep: \"filter\",\n            reduce: \"reduce\",\n            some: \"some\"\n        }, function(e, i) {\n            t[i] = function(t) {\n                return r(32, !1, void 0, {\n                    [\"Highcharts.\".concat(i)]: \"use Array.\".concat(e)\n                }), Array.prototype[e].apply(t, [].slice.call(arguments, 1));\n            };\n        });\n        let w = function() {\n            let t = Math.random().toString(36).substring(2, 9) + \"-\", i = 0;\n            return function() {\n                return \"highcharts-\" + (e ? \"\" : t) + i++;\n            };\n        }();\n        o.jQuery && (o.jQuery.fn.highcharts = function() {\n            let e = [].slice.call(arguments);\n            if (this[0]) return e[0] ? (new t[a(e[0]) ? e.shift() : \"Chart\"](this[0], e[0], e[1]), this) : i[g(this[0], \"data-highcharts-chart\")];\n        });\n        let T = {\n            addEvent: function(e, i, s) {\n                let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                let r = \"function\" == typeof e && e.prototype || e;\n                Object.hasOwnProperty.call(r, \"hcEvents\") || (r.hcEvents = {});\n                let n = r.hcEvents;\n                t.Point && e instanceof t.Point && e.series && e.series.chart && (e.series.chart.runTrackerClick = !0);\n                let a = e.addEventListener;\n                a && a.call(e, i, s, !!t.supportsPassiveEvents && {\n                    passive: void 0 === o.passive ? -1 !== i.indexOf(\"touch\") : o.passive,\n                    capture: !1\n                }), n[i] || (n[i] = []);\n                let h = {\n                    fn: s,\n                    order: \"number\" == typeof o.order ? o.order : 1 / 0\n                };\n                return n[i].push(h), n[i].sort((t, e)=>t.order - e.order), function() {\n                    M(e, i, s);\n                };\n            },\n            arrayMax: function(t) {\n                let e = t.length, i = t[0];\n                for(; e--;)t[e] > i && (i = t[e]);\n                return i;\n            },\n            arrayMin: function(t) {\n                let e = t.length, i = t[0];\n                for(; e--;)t[e] < i && (i = t[e]);\n                return i;\n            },\n            attr: g,\n            clamp: function(t, e, i) {\n                return t > e ? t < i ? t : i : e;\n            },\n            clearTimeout: function(t) {\n                u(t) && clearTimeout(t);\n            },\n            correctFloat: v,\n            createElement: function(t, e, i, o, r) {\n                let n = s.createElement(t);\n                return e && m(n, e), r && y(n, {\n                    padding: \"0\",\n                    border: \"none\",\n                    margin: \"0\"\n                }), i && y(n, i), o && o.appendChild(n), n;\n            },\n            css: y,\n            defined: u,\n            destroyObjectProperties: function(t, e) {\n                k(t, function(i, s) {\n                    i && i !== e && i.destroy && i.destroy(), delete t[s];\n                });\n            },\n            diffObjects: function(t, e, i, s) {\n                let o = {};\n                return function t(e, o, r, n) {\n                    let a = i ? o : e;\n                    k(e, function(i, d) {\n                        if (!n && s && s.indexOf(d) > -1 && o[d]) {\n                            i = f(i), r[d] = [];\n                            for(let e = 0; e < Math.max(i.length, o[d].length); e++)o[d][e] && (void 0 === i[e] ? r[d][e] = o[d][e] : (r[d][e] = {}, t(i[e], o[d][e], r[d][e], n + 1)));\n                        } else l(i, !0) && !i.nodeType ? (r[d] = h(i) ? [] : {}, t(i, o[d] || {}, r[d], n + 1), 0 !== Object.keys(r[d]).length || \"colorAxis\" === d && 0 === n || delete r[d]) : (e[d] !== o[d] || d in e && !(d in o)) && (r[d] = a[d]);\n                    });\n                }(t, e, o, 0), o;\n            },\n            discardElement: function(t) {\n                t && t.parentElement && t.parentElement.removeChild(t);\n            },\n            erase: function(t, e) {\n                let i = t.length;\n                for(; i--;)if (t[i] === e) {\n                    t.splice(i, 1);\n                    break;\n                }\n            },\n            error: r,\n            extend: m,\n            extendClass: function(t, e) {\n                let i = function() {};\n                return i.prototype = new t, m(i.prototype, e), i;\n            },\n            find: S,\n            fireEvent: C,\n            getClosestDistance: function(t, e) {\n                let i, s, o;\n                let r = !e;\n                return t.forEach((t)=>{\n                    if (t.length > 1) for(o = t.length - 1; o > 0; o--)(s = t[o] - t[o - 1]) < 0 && !r ? (e === null || e === void 0 ? void 0 : e(), e = void 0) : s && (void 0 === i || s < i) && (i = s);\n                }), i;\n            },\n            getMagnitude: b,\n            getNestedProperty: function(t, e) {\n                let i = t.split(\".\");\n                for(; i.length && u(e);){\n                    let t = i.shift();\n                    if (void 0 === t || \"__proto__\" === t) return;\n                    if (\"this\" === t) {\n                        let t;\n                        return l(e) && (t = e[\"@this\"]), t !== null && t !== void 0 ? t : e;\n                    }\n                    let s = e[t];\n                    if (!u(s) || \"function\" == typeof s || \"number\" == typeof s.nodeType || s === o) return;\n                    e = s;\n                }\n                return e;\n            },\n            getStyle: function t(e, i, s) {\n                let r;\n                if (\"width\" === i) {\n                    let i = Math.min(e.offsetWidth, e.scrollWidth), s = e.getBoundingClientRect && e.getBoundingClientRect().width;\n                    return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, \"padding-left\", !0) || 0) - (t(e, \"padding-right\", !0) || 0));\n                }\n                if (\"height\" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, \"padding-top\", !0) || 0) - (t(e, \"padding-bottom\", !0) || 0));\n                let a = o.getComputedStyle(e, void 0);\n                return a && (r = a.getPropertyValue(i), x(s, \"opacity\" !== i) && (r = n(r))), r;\n            },\n            inArray: function(t, e, i) {\n                return r(32, !1, void 0, {\n                    \"Highcharts.inArray\": \"use Array.indexOf\"\n                }), e.indexOf(t, i);\n            },\n            insertItem: function(t, e) {\n                let i;\n                let s = t.options.index, o = e.length;\n                for(i = t.options.isInternal ? o : 0; i < o + 1; i++)if (!e[i] || p(s) && s < x(e[i].options.index, e[i]._i) || e[i].options.isInternal) {\n                    e.splice(i, 0, t);\n                    break;\n                }\n                return i;\n            },\n            isArray: h,\n            isClass: c,\n            isDOMElement: d,\n            isFunction: function(t) {\n                return \"function\" == typeof t;\n            },\n            isNumber: p,\n            isObject: l,\n            isString: a,\n            keys: function(t) {\n                return r(32, !1, void 0, {\n                    \"Highcharts.keys\": \"use Object.keys\"\n                }), Object.keys(t);\n            },\n            merge: function() {\n                let t, e = arguments, i = {}, s = function(t, e) {\n                    return \"object\" != typeof t && (t = {}), k(e, function(i, o) {\n                        \"__proto__\" !== o && \"constructor\" !== o && (!l(i, !0) || c(i) || d(i) ? t[o] = e[o] : t[o] = s(t[o] || {}, i));\n                    }), t;\n                };\n                !0 === e[0] && (i = e[1], e = Array.prototype.slice.call(e, 2));\n                let o = e.length;\n                for(t = 0; t < o; t++)i = s(i, e[t]);\n                return i;\n            },\n            normalizeTickInterval: function(t, e, i, s, o) {\n                let r, n = t;\n                i = x(i, b(t));\n                let a = t / i;\n                for(!e && (e = o ? [\n                    1,\n                    1.2,\n                    1.5,\n                    2,\n                    2.5,\n                    3,\n                    4,\n                    5,\n                    6,\n                    8,\n                    10\n                ] : [\n                    1,\n                    2,\n                    2.5,\n                    5,\n                    10\n                ], !1 === s && (1 === i ? e = e.filter(function(t) {\n                    return t % 1 == 0;\n                }) : i <= .1 && (e = [\n                    1 / i\n                ]))), r = 0; r < e.length && (n = e[r], (!o || !(n * i >= t)) && (o || !(a <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);\n                return v(n * i, -Math.round(Math.log(.001) / Math.LN10));\n            },\n            objectEach: k,\n            offset: function(t) {\n                let e = s.documentElement, i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {\n                    top: 0,\n                    left: 0,\n                    width: 0,\n                    height: 0\n                };\n                return {\n                    top: i.top + (o.pageYOffset || e.scrollTop) - (e.clientTop || 0),\n                    left: i.left + (o.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),\n                    width: i.width,\n                    height: i.height\n                };\n            },\n            pad: function(t, e, i) {\n                return Array((e || 2) + 1 - String(t).replace(\"-\", \"\").length).join(i || \"0\") + t;\n            },\n            pick: x,\n            pInt: n,\n            pushUnique: function(t, e) {\n                return 0 > t.indexOf(e) && !!t.push(e);\n            },\n            relativeLength: function(t, e, i) {\n                return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);\n            },\n            removeEvent: M,\n            splat: f,\n            stableSort: function(t, e) {\n                let i, s;\n                let o = t.length;\n                for(s = 0; s < o; s++)t[s].safeI = s;\n                for(t.sort(function(t, s) {\n                    return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;\n                }), s = 0; s < o; s++)delete t[s].safeI;\n            },\n            syncTimeout: function(t, e, i) {\n                return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);\n            },\n            timeUnits: {\n                millisecond: 1,\n                second: 1e3,\n                minute: 6e4,\n                hour: 36e5,\n                day: 864e5,\n                week: 6048e5,\n                month: 24192e5,\n                year: 314496e5\n            },\n            uniqueKey: w,\n            useSerialIds: function(t) {\n                return e = x(t, e);\n            },\n            wrap: function(t, e, i) {\n                let s = t[e];\n                t[e] = function() {\n                    let t = arguments, e = this;\n                    return i.apply(this, [\n                        function() {\n                            return s.apply(e, arguments.length ? arguments : t);\n                        }\n                    ].concat([].slice.call(arguments)));\n                };\n            }\n        };\n        return T;\n    }), i(e, \"Core/Chart/ChartDefaults.js\", [], function() {\n        return {\n            alignThresholds: !1,\n            panning: {\n                enabled: !1,\n                type: \"x\"\n            },\n            styledMode: !1,\n            borderRadius: 0,\n            colorCount: 10,\n            allowMutatingData: !0,\n            ignoreHiddenSeries: !0,\n            spacing: [\n                10,\n                10,\n                15,\n                10\n            ],\n            resetZoomButton: {\n                theme: {},\n                position: {}\n            },\n            reflow: !0,\n            type: \"line\",\n            zooming: {\n                singleTouch: !1,\n                resetButton: {\n                    theme: {\n                        zIndex: 6\n                    },\n                    position: {\n                        align: \"right\",\n                        x: -10,\n                        y: 10\n                    }\n                }\n            },\n            width: null,\n            height: null,\n            borderColor: \"#334eff\",\n            backgroundColor: \"#ffffff\",\n            plotBorderColor: \"#cccccc\"\n        };\n    }), i(e, \"Core/Color/Palettes.js\", [], function() {\n        return {\n            colors: [\n                \"#2caffe\",\n                \"#544fc5\",\n                \"#00e272\",\n                \"#fe6a35\",\n                \"#6b8abc\",\n                \"#d568fb\",\n                \"#2ee0ca\",\n                \"#fa4b42\",\n                \"#feb56a\",\n                \"#91e8e1\"\n            ]\n        };\n    }), i(e, \"Core/Time.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { win: i } = t, { defined: s, error: o, extend: r, isNumber: n, isObject: a, merge: h, objectEach: l, pad: d, pick: c, splat: p, timeUnits: u } = e, g = t.isSafari && i.Intl && i.Intl.DateTimeFormat.prototype.formatRange, f = t.isSafari && i.Intl && !i.Intl.DateTimeFormat.prototype.formatRange;\n        return class {\n            get(t, e) {\n                if (this.variableTimezone || this.timezoneOffset) {\n                    let i = e.getTime(), s = i - this.getTimezoneOffset(e);\n                    e.setTime(s);\n                    let o = e[\"getUTC\" + t]();\n                    return e.setTime(i), o;\n                }\n                return this.useUTC ? e[\"getUTC\" + t]() : e[\"get\" + t]();\n            }\n            set(t, e, i) {\n                if (this.variableTimezone || this.timezoneOffset) {\n                    if (\"Milliseconds\" === t || \"Seconds\" === t || \"Minutes\" === t && this.getTimezoneOffset(e) % 36e5 == 0) return e[\"setUTC\" + t](i);\n                    let s = this.getTimezoneOffset(e), o = e.getTime() - s;\n                    e.setTime(o), e[\"setUTC\" + t](i);\n                    let r = this.getTimezoneOffset(e);\n                    return o = e.getTime() + r, e.setTime(o);\n                }\n                return this.useUTC || g && \"FullYear\" === t ? e[\"setUTC\" + t](i) : e[\"set\" + t](i);\n            }\n            update() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n                let e = c(t.useUTC, !0);\n                this.options = t = h(!0, this.options, t), this.Date = t.Date || i.Date || Date, this.useUTC = e, this.timezoneOffset = e && t.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e && !!(t.getTimezoneOffset || t.timezone);\n            }\n            makeTime(t, e, i, s, o, r) {\n                let n, a, h;\n                return this.useUTC ? (n = this.Date.UTC.apply(0, arguments), a = this.getTimezoneOffset(n), n += a, a !== (h = this.getTimezoneOffset(n)) ? n += h - a : a - 36e5 !== this.getTimezoneOffset(n - 36e5) || f || (n -= 36e5)) : n = new this.Date(t, e, c(i, 1), c(s, 0), c(o, 0), c(r, 0)).getTime(), n;\n            }\n            timezoneOffsetFunction() {\n                let t = this, e = this.options, i = e.getTimezoneOffset;\n                return this.useUTC ? e.timezone ? (t)=>{\n                    try {\n                        let [i, s, o, r, a = 0] = Intl.DateTimeFormat(\"en\", {\n                            timeZone: e.timezone,\n                            timeZoneName: \"shortOffset\"\n                        }).format(t).split(/(GMT|:)/).map(Number), h = -(36e5 * (o + a / 60));\n                        if (n(h)) return h;\n                    } catch (t) {\n                        o(34);\n                    }\n                    return 0;\n                } : this.useUTC && i ? (t)=>6e4 * i(t.valueOf()) : ()=>6e4 * (t.timezoneOffset || 0) : (t)=>6e4 * new Date(t.toString()).getTimezoneOffset();\n            }\n            dateFormat(e, i, o) {\n                if (!s(i) || isNaN(i)) return t.defaultOptions.lang && t.defaultOptions.lang.invalidDate || \"\";\n                e = c(e, \"%Y-%m-%d %H:%M:%S\");\n                let n = this, a = new this.Date(i), h = this.get(\"Hours\", a), p = this.get(\"Day\", a), u = this.get(\"Date\", a), g = this.get(\"Month\", a), f = this.get(\"FullYear\", a), m = t.defaultOptions.lang, x = m && m.weekdays, y = m && m.shortWeekdays, b = r({\n                    a: y ? y[p] : x[p].substr(0, 3),\n                    A: x[p],\n                    d: d(u),\n                    e: d(u, 2, \" \"),\n                    w: p,\n                    b: m.shortMonths[g],\n                    B: m.months[g],\n                    m: d(g + 1),\n                    o: g + 1,\n                    y: f.toString().substr(2, 2),\n                    Y: f,\n                    H: d(h),\n                    k: h,\n                    I: d(h % 12 || 12),\n                    l: h % 12 || 12,\n                    M: d(this.get(\"Minutes\", a)),\n                    p: h < 12 ? \"AM\" : \"PM\",\n                    P: h < 12 ? \"am\" : \"pm\",\n                    S: d(this.get(\"Seconds\", a)),\n                    L: d(Math.floor(i % 1e3), 3)\n                }, t.dateFormats);\n                return l(b, function(t, s) {\n                    for(; -1 !== e.indexOf(\"%\" + s);)e = e.replace(\"%\" + s, \"function\" == typeof t ? t.call(n, i) : t);\n                }), o ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n            }\n            resolveDTLFormat(t) {\n                return a(t, !0) ? t : {\n                    main: (t = p(t))[0],\n                    from: t[1],\n                    to: t[2]\n                };\n            }\n            getTimeTicks(t, e, i, o) {\n                let n, a, h, l;\n                let d = this, p = d.Date, g = [], f = {}, m = new p(e), x = t.unitRange, y = t.count || 1;\n                if (o = c(o, 1), s(e)) {\n                    d.set(\"Milliseconds\", m, x >= u.second ? 0 : y * Math.floor(d.get(\"Milliseconds\", m) / y)), x >= u.second && d.set(\"Seconds\", m, x >= u.minute ? 0 : y * Math.floor(d.get(\"Seconds\", m) / y)), x >= u.minute && d.set(\"Minutes\", m, x >= u.hour ? 0 : y * Math.floor(d.get(\"Minutes\", m) / y)), x >= u.hour && d.set(\"Hours\", m, x >= u.day ? 0 : y * Math.floor(d.get(\"Hours\", m) / y)), x >= u.day && d.set(\"Date\", m, x >= u.month ? 1 : Math.max(1, y * Math.floor(d.get(\"Date\", m) / y))), x >= u.month && (d.set(\"Month\", m, x >= u.year ? 0 : y * Math.floor(d.get(\"Month\", m) / y)), a = d.get(\"FullYear\", m)), x >= u.year && (a -= a % y, d.set(\"FullYear\", m, a)), x === u.week && (l = d.get(\"Day\", m), d.set(\"Date\", m, d.get(\"Date\", m) - l + o + (l < o ? -7 : 0))), a = d.get(\"FullYear\", m);\n                    let t = d.get(\"Month\", m), r = d.get(\"Date\", m), c = d.get(\"Hours\", m);\n                    e = m.getTime(), (d.variableTimezone || !d.useUTC) && s(i) && (h = i - e > 4 * u.month || d.getTimezoneOffset(e) !== d.getTimezoneOffset(i));\n                    let p = m.getTime();\n                    for(n = 1; p < i;)g.push(p), x === u.year ? p = d.makeTime(a + n * y, 0) : x === u.month ? p = d.makeTime(a, t + n * y) : h && (x === u.day || x === u.week) ? p = d.makeTime(a, t, r + n * y * (x === u.day ? 1 : 7)) : h && x === u.hour && y > 1 ? p = d.makeTime(a, t, r, c + n * y) : p += x * y, n++;\n                    g.push(p), x <= u.hour && g.length < 1e4 && g.forEach(function(t) {\n                        t % 18e5 == 0 && \"000000000\" === d.dateFormat(\"%H%M%S%L\", t) && (f[t] = \"day\");\n                    });\n                }\n                return g.info = r(t, {\n                    higherRanks: f,\n                    totalRange: x * y\n                }), g;\n            }\n            getDateFormat(t, e, i, s) {\n                let o = this.dateFormat(\"%m-%d %H:%M:%S.%L\", e), r = \"01-01 00:00:00.000\", n = {\n                    millisecond: 15,\n                    second: 12,\n                    minute: 9,\n                    hour: 6,\n                    day: 3\n                }, a = \"millisecond\", h = a;\n                for(a in u){\n                    if (t === u.week && +this.dateFormat(\"%w\", e) === i && o.substr(6) === r.substr(6)) {\n                        a = \"week\";\n                        break;\n                    }\n                    if (u[a] > t) {\n                        a = h;\n                        break;\n                    }\n                    if (n[a] && o.substr(n[a]) !== r.substr(n[a])) break;\n                    \"week\" !== a && (h = a);\n                }\n                return this.resolveDTLFormat(s[a]).main;\n            }\n            constructor(t){\n                this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = i.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t);\n            }\n        };\n    }), i(e, \"Core/Defaults.js\", [\n        e[\"Core/Chart/ChartDefaults.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Color/Palettes.js\"],\n        e[\"Core/Time.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o) {\n        let { isTouchDevice: r, svg: n } = e, { merge: a } = o, h = {\n            colors: i.colors,\n            symbols: [\n                \"circle\",\n                \"diamond\",\n                \"square\",\n                \"triangle\",\n                \"triangle-down\"\n            ],\n            lang: {\n                loading: \"Loading...\",\n                months: [\n                    \"January\",\n                    \"February\",\n                    \"March\",\n                    \"April\",\n                    \"May\",\n                    \"June\",\n                    \"July\",\n                    \"August\",\n                    \"September\",\n                    \"October\",\n                    \"November\",\n                    \"December\"\n                ],\n                shortMonths: [\n                    \"Jan\",\n                    \"Feb\",\n                    \"Mar\",\n                    \"Apr\",\n                    \"May\",\n                    \"Jun\",\n                    \"Jul\",\n                    \"Aug\",\n                    \"Sep\",\n                    \"Oct\",\n                    \"Nov\",\n                    \"Dec\"\n                ],\n                weekdays: [\n                    \"Sunday\",\n                    \"Monday\",\n                    \"Tuesday\",\n                    \"Wednesday\",\n                    \"Thursday\",\n                    \"Friday\",\n                    \"Saturday\"\n                ],\n                decimalPoint: \".\",\n                numericSymbols: [\n                    \"k\",\n                    \"M\",\n                    \"G\",\n                    \"T\",\n                    \"P\",\n                    \"E\"\n                ],\n                resetZoom: \"Reset zoom\",\n                resetZoomTitle: \"Reset zoom level 1:1\",\n                thousandsSep: \" \"\n            },\n            global: {},\n            time: {\n                Date: void 0,\n                getTimezoneOffset: void 0,\n                timezone: void 0,\n                timezoneOffset: 0,\n                useUTC: !0\n            },\n            chart: t,\n            title: {\n                style: {\n                    color: \"#333333\",\n                    fontWeight: \"bold\"\n                },\n                text: \"Chart title\",\n                align: \"center\",\n                margin: 15,\n                widthAdjust: -44\n            },\n            subtitle: {\n                style: {\n                    color: \"#666666\",\n                    fontSize: \"0.8em\"\n                },\n                text: \"\",\n                align: \"center\",\n                widthAdjust: -44\n            },\n            caption: {\n                margin: 15,\n                style: {\n                    color: \"#666666\",\n                    fontSize: \"0.8em\"\n                },\n                text: \"\",\n                align: \"left\",\n                verticalAlign: \"bottom\"\n            },\n            plotOptions: {},\n            legend: {\n                enabled: !0,\n                align: \"center\",\n                alignColumns: !0,\n                className: \"highcharts-no-tooltip\",\n                layout: \"horizontal\",\n                itemMarginBottom: 2,\n                itemMarginTop: 2,\n                labelFormatter: function() {\n                    return this.name;\n                },\n                borderColor: \"#999999\",\n                borderRadius: 0,\n                navigation: {\n                    style: {\n                        fontSize: \"0.8em\"\n                    },\n                    activeColor: \"#0022ff\",\n                    inactiveColor: \"#cccccc\"\n                },\n                itemStyle: {\n                    color: \"#333333\",\n                    cursor: \"pointer\",\n                    fontSize: \"0.8em\",\n                    textDecoration: \"none\",\n                    textOverflow: \"ellipsis\"\n                },\n                itemHoverStyle: {\n                    color: \"#000000\"\n                },\n                itemHiddenStyle: {\n                    color: \"#666666\",\n                    textDecoration: \"line-through\"\n                },\n                shadow: !1,\n                itemCheckboxStyle: {\n                    position: \"absolute\",\n                    width: \"13px\",\n                    height: \"13px\"\n                },\n                squareSymbol: !0,\n                symbolPadding: 5,\n                verticalAlign: \"bottom\",\n                x: 0,\n                y: 0,\n                title: {\n                    style: {\n                        fontSize: \"0.8em\",\n                        fontWeight: \"bold\"\n                    }\n                }\n            },\n            loading: {\n                labelStyle: {\n                    fontWeight: \"bold\",\n                    position: \"relative\",\n                    top: \"45%\"\n                },\n                style: {\n                    position: \"absolute\",\n                    backgroundColor: \"#ffffff\",\n                    opacity: .5,\n                    textAlign: \"center\"\n                }\n            },\n            tooltip: {\n                enabled: !0,\n                animation: n,\n                borderRadius: 3,\n                dateTimeLabelFormats: {\n                    millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n                    second: \"%A, %e %b, %H:%M:%S\",\n                    minute: \"%A, %e %b, %H:%M\",\n                    hour: \"%A, %e %b, %H:%M\",\n                    day: \"%A, %e %b %Y\",\n                    week: \"Week from %A, %e %b %Y\",\n                    month: \"%B %Y\",\n                    year: \"%Y\"\n                },\n                footerFormat: \"\",\n                headerShape: \"callout\",\n                hideDelay: 500,\n                padding: 8,\n                shape: \"callout\",\n                shared: !1,\n                snap: r ? 25 : 10,\n                headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n                pointFormat: '<span style=\"color:{point.color}\">●</span> {series.name}: <b>{point.y}</b><br/>',\n                backgroundColor: \"#ffffff\",\n                borderWidth: void 0,\n                shadow: !0,\n                stickOnContact: !1,\n                style: {\n                    color: \"#333333\",\n                    cursor: \"default\",\n                    fontSize: \"0.8em\"\n                },\n                useHTML: !1\n            },\n            credits: {\n                enabled: !0,\n                href: \"https://www.highcharts.com?credits\",\n                position: {\n                    align: \"right\",\n                    x: -10,\n                    verticalAlign: \"bottom\",\n                    y: -5\n                },\n                style: {\n                    cursor: \"pointer\",\n                    color: \"#999999\",\n                    fontSize: \"0.6em\"\n                },\n                text: \"Highcharts.com\"\n            }\n        };\n        h.chart.styledMode = !1;\n        let l = new s(h.time);\n        return {\n            defaultOptions: h,\n            defaultTime: l,\n            getOptions: function() {\n                return h;\n            },\n            setOptions: function(t) {\n                return a(!0, h, t), (t.time || t.global) && (e.time ? e.time.update(a(h.global, h.time, t.global, t.time)) : e.time = l), h;\n            }\n        };\n    }), i(e, \"Core/Color/Color.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { isNumber: i, merge: s, pInt: o } = e;\n        class r {\n            static parse(t) {\n                return t ? new r(t) : r.None;\n            }\n            get(t) {\n                let e = this.input, o = this.rgba;\n                if (\"object\" == typeof e && void 0 !== this.stops) {\n                    let i = s(e);\n                    return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s)=>{\n                        i.stops[s] = [\n                            i.stops[s][0],\n                            e.get(t)\n                        ];\n                    }), i;\n                }\n                return o && i(o[0]) ? \"rgb\" !== t && (t || 1 !== o[3]) ? \"a\" === t ? \"\".concat(o[3]) : \"rgba(\" + o.join(\",\") + \")\" : \"rgb(\" + o[0] + \",\" + o[1] + \",\" + o[2] + \")\" : e;\n            }\n            brighten(t) {\n                let e = this.rgba;\n                if (this.stops) this.stops.forEach(function(e) {\n                    e.brighten(t);\n                });\n                else if (i(t) && 0 !== t) for(let i = 0; i < 3; i++)e[i] += o(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);\n                return this;\n            }\n            setOpacity(t) {\n                return this.rgba[3] = t, this;\n            }\n            tweenTo(t, e) {\n                let s = this.rgba, o = t.rgba;\n                if (!i(s[0]) || !i(o[0])) return t.input || \"none\";\n                let r = 1 !== o[3] || 1 !== s[3];\n                return (r ? \"rgba(\" : \"rgb(\") + Math.round(o[0] + (s[0] - o[0]) * (1 - e)) + \",\" + Math.round(o[1] + (s[1] - o[1]) * (1 - e)) + \",\" + Math.round(o[2] + (s[2] - o[2]) * (1 - e)) + (r ? \",\" + (o[3] + (s[3] - o[3]) * (1 - e)) : \"\") + \")\";\n            }\n            constructor(e){\n                let i, s, o, n;\n                this.rgba = [\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN\n                ], this.input = e;\n                let a = t.Color;\n                if (a && a !== r) return new a(e);\n                if (\"object\" == typeof e && void 0 !== e.stops) this.stops = e.stops.map((t)=>new r(t[1]));\n                else if (\"string\" == typeof e) {\n                    if (this.input = e = r.names[e.toLowerCase()] || e, \"#\" === e.charAt(0)) {\n                        let t = e.length, i = parseInt(e.substr(1), 16);\n                        7 === t ? s = [\n                            (16711680 & i) >> 16,\n                            (65280 & i) >> 8,\n                            255 & i,\n                            1\n                        ] : 4 === t && (s = [\n                            (3840 & i) >> 4 | (3840 & i) >> 8,\n                            (240 & i) >> 4 | 240 & i,\n                            (15 & i) << 4 | 15 & i,\n                            1\n                        ]);\n                    }\n                    if (!s) for(o = r.parsers.length; o-- && !s;)(i = (n = r.parsers[o]).regex.exec(e)) && (s = n.parse(i));\n                }\n                s && (this.rgba = s);\n            }\n        }\n        return r.names = {\n            white: \"#ffffff\",\n            black: \"#000000\"\n        }, r.parsers = [\n            {\n                regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n                parse: function(t) {\n                    return [\n                        o(t[1]),\n                        o(t[2]),\n                        o(t[3]),\n                        parseFloat(t[4], 10)\n                    ];\n                }\n            },\n            {\n                regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n                parse: function(t) {\n                    return [\n                        o(t[1]),\n                        o(t[2]),\n                        o(t[3]),\n                        1\n                    ];\n                }\n            }\n        ], r.None = new r(\"\"), r;\n    }), i(e, \"Core/Animation/Fx.js\", [\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { parse: s } = t, { win: o } = e, { isNumber: r, objectEach: n } = i;\n        class a {\n            dSetter() {\n                let t = this.paths, e = t && t[0], i = t && t[1], s = this.now || 0, o = [];\n                if (1 !== s && e && i) {\n                    if (e.length === i.length && s < 1) for(let t = 0; t < i.length; t++){\n                        let n = e[t], a = i[t], h = [];\n                        for(let t = 0; t < a.length; t++){\n                            let e = n[t], i = a[t];\n                            r(e) && r(i) && !(\"A\" === a[0] && (4 === t || 5 === t)) ? h[t] = e + s * (i - e) : h[t] = i;\n                        }\n                        o.push(h);\n                    }\n                    else o = i;\n                } else o = this.toD || [];\n                this.elem.attr(\"d\", o, void 0, !0);\n            }\n            update() {\n                let t = this.elem, e = this.prop, i = this.now, s = this.options.step;\n                this[e + \"Setter\"] ? this[e + \"Setter\"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);\n            }\n            run(t, e, i) {\n                let s = this, r = s.options, n = function(t) {\n                    return !n.stopped && s.step(t);\n                }, h = o.requestAnimationFrame || function(t) {\n                    setTimeout(t, 13);\n                }, l = function() {\n                    for(let t = 0; t < a.timers.length; t++)a.timers[t]() || a.timers.splice(t--, 1);\n                    a.timers.length && h(l);\n                };\n                t !== e || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date, this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, n.elem = this.elem, n.prop = this.prop, n() && 1 === a.timers.push(n) && h(l)) : (delete r.curAnim[this.prop], r.complete && 0 === Object.keys(r.curAnim).length && r.complete.call(this.elem));\n            }\n            step(t) {\n                let e, i;\n                let s = +new Date, o = this.options, r = this.elem, a = o.complete, h = o.duration, l = o.curAnim;\n                return r.attr && !r.element ? e = !1 : t || s >= h + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l[this.prop] = !0, i = !0, n(l, function(t) {\n                    !0 !== t && (i = !1);\n                }), i && a && a.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;\n            }\n            initPath(t, e, i) {\n                let s = t.startX, o = t.endX, n = i.slice(), a = t.isArea, h = a ? 2 : 1, l, d, c, p, u = e && e.slice();\n                if (!u) return [\n                    n,\n                    n\n                ];\n                function g(t, e) {\n                    for(; t.length < d;){\n                        let i = t[0], s = e[d - t.length];\n                        if (s && \"M\" === i[0] && (\"C\" === s[0] ? t[0] = [\n                            \"C\",\n                            i[1],\n                            i[2],\n                            i[1],\n                            i[2],\n                            i[1],\n                            i[2]\n                        ] : t[0] = [\n                            \"L\",\n                            i[1],\n                            i[2]\n                        ]), t.unshift(i), a) {\n                            let e = t.pop();\n                            t.push(t[t.length - 1], e);\n                        }\n                    }\n                }\n                function f(t, e) {\n                    for(; t.length < d;){\n                        let e = t[Math.floor(t.length / h) - 1].slice();\n                        if (\"C\" === e[0] && (e[1] = e[5], e[2] = e[6]), a) {\n                            let i = t[Math.floor(t.length / h)].slice();\n                            t.splice(t.length / 2, 0, e, i);\n                        } else t.push(e);\n                    }\n                }\n                if (s && o && o.length) {\n                    for(c = 0; c < s.length; c++){\n                        if (s[c] === o[0]) {\n                            l = c;\n                            break;\n                        }\n                        if (s[0] === o[o.length - s.length + c]) {\n                            l = c, p = !0;\n                            break;\n                        }\n                        if (s[s.length - 1] === o[o.length - s.length + c]) {\n                            l = s.length - c;\n                            break;\n                        }\n                    }\n                    void 0 === l && (u = []);\n                }\n                return u.length && r(l) && (d = n.length + l * h, p ? (g(u, n), f(n, u)) : (g(n, u), f(u, n))), [\n                    u,\n                    n\n                ];\n            }\n            fillSetter() {\n                a.prototype.strokeSetter.apply(this, arguments);\n            }\n            strokeSetter() {\n                this.elem.attr(this.prop, s(this.start).tweenTo(s(this.end), this.pos), void 0, !0);\n            }\n            constructor(t, e, i){\n                this.pos = NaN, this.options = e, this.elem = t, this.prop = i;\n            }\n        }\n        return a.timers = [], a;\n    }), i(e, \"Core/Animation/AnimationUtilities.js\", [\n        e[\"Core/Animation/Fx.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { defined: i, getStyle: s, isArray: o, isNumber: r, isObject: n, merge: a, objectEach: h, pick: l } = e;\n        function d(t) {\n            return n(t) ? a({\n                duration: 500,\n                defer: 0\n            }, t) : {\n                duration: t ? 500 : 0,\n                defer: 0\n            };\n        }\n        function c(e, i) {\n            let s = t.timers.length;\n            for(; s--;)t.timers[s].elem !== e || i && i !== t.timers[s].prop || (t.timers[s].stopped = !0);\n        }\n        return {\n            animate: function(e, i, l) {\n                let d, p = \"\", u, g, f;\n                n(l) || (f = arguments, l = {\n                    duration: f[2],\n                    easing: f[3],\n                    complete: f[4]\n                }), r(l.duration) || (l.duration = 400), l.easing = \"function\" == typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine, l.curAnim = a(i), h(i, function(r, n) {\n                    c(e, n), g = new t(e, l, n), u = void 0, \"d\" === n && o(i.d) ? (g.paths = g.initPath(e, e.pathArray, i.d), g.toD = i.d, d = 0, u = 1) : e.attr ? d = e.attr(n) : (d = parseFloat(s(e, n)) || 0, \"opacity\" !== n && (p = \"px\")), u || (u = r), \"string\" == typeof u && u.match(\"px\") && (u = u.replace(/px/g, \"\")), g.run(d, u, p);\n                });\n            },\n            animObject: d,\n            getDeferredAnimation: function(t, e, s) {\n                let o = d(e), r = s ? [\n                    s\n                ] : t.series, a = 0, h = 0;\n                r.forEach((t)=>{\n                    let s = d(t.options.animation);\n                    a = n(e) && i(e.defer) ? o.defer : Math.max(a, s.duration + s.defer), h = Math.min(o.duration, s.duration);\n                }), t.renderer.forExport && (a = 0);\n                let l = {\n                    defer: Math.max(0, a - h),\n                    duration: Math.min(a, h)\n                };\n                return l;\n            },\n            setAnimation: function(t, e) {\n                e.renderer.globalAnimation = l(t, e.options.chart.animation, !0);\n            },\n            stop: c\n        };\n    }), i(e, \"Core/Renderer/HTML/AST.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { SVG_NS: i, win: s } = t, { attr: o, createElement: r, css: n, error: a, isFunction: h, isString: l, objectEach: d, splat: c } = e, { trustedTypes: p } = s, u = p && h(p.createPolicy) && p.createPolicy(\"highcharts\", {\n            createHTML: (t)=>t\n        }), g = u ? u.createHTML(\"\") : \"\", f = function() {\n            try {\n                return !!new DOMParser().parseFromString(g, \"text/html\");\n            } catch (t) {\n                return !1;\n            }\n        }();\n        class m {\n            static filterUserAttributes(t) {\n                return d(t, (e, i)=>{\n                    let s = !0;\n                    -1 === m.allowedAttributes.indexOf(i) && (s = !1), -1 !== [\n                        \"background\",\n                        \"dynsrc\",\n                        \"href\",\n                        \"lowsrc\",\n                        \"src\"\n                    ].indexOf(i) && (s = l(e) && m.allowedReferences.some((t)=>0 === e.indexOf(t))), s || (a(33, !1, void 0, {\n                        \"Invalid attribute in config\": \"\".concat(i)\n                    }), delete t[i]), l(e) && t[i] && (t[i] = e.replace(/</g, \"&lt;\"));\n                }), t;\n            }\n            static parseStyle(t) {\n                return t.split(\";\").reduce((t, e)=>{\n                    let i = e.split(\":\").map((t)=>t.trim()), s = i.shift();\n                    return s && i.length && (t[s.replace(/-([a-z])/g, (t)=>t[1].toUpperCase())] = i.join(\":\")), t;\n                }, {});\n            }\n            static setElementHTML(t, e) {\n                if (t.innerHTML = m.emptyHTML, e) {\n                    let i = new m(e);\n                    i.addToDOM(t);\n                }\n            }\n            addToDOM(e) {\n                return function e(s, r) {\n                    let h;\n                    return c(s).forEach(function(s) {\n                        let l;\n                        let c = s.tagName, p = s.textContent ? t.doc.createTextNode(s.textContent) : void 0, u = m.bypassHTMLFiltering;\n                        if (c) {\n                            if (\"#text\" === c) l = p;\n                            else if (-1 !== m.allowedTags.indexOf(c) || u) {\n                                let a = \"svg\" === c ? i : r.namespaceURI || i, h = t.doc.createElementNS(a, c), g = s.attributes || {};\n                                d(s, function(t, e) {\n                                    \"tagName\" !== e && \"attributes\" !== e && \"children\" !== e && \"style\" !== e && \"textContent\" !== e && (g[e] = t);\n                                }), o(h, u ? g : m.filterUserAttributes(g)), s.style && n(h, s.style), p && h.appendChild(p), e(s.children || [], h), l = h;\n                            } else a(33, !1, void 0, {\n                                \"Invalid tagName in config\": c\n                            });\n                        }\n                        l && r.appendChild(l), h = l;\n                    }), h;\n                }(this.nodes, e);\n            }\n            parseMarkup(t) {\n                let e;\n                let i = [];\n                if (t = t.trim().replace(/ style=([\"'])/g, \" data-style=$1\"), f) e = new DOMParser().parseFromString(u ? u.createHTML(t) : t, \"text/html\");\n                else {\n                    let i = r(\"div\");\n                    i.innerHTML = t, e = {\n                        body: i\n                    };\n                }\n                let s = (t, e)=>{\n                    let i = t.nodeName.toLowerCase(), o = {\n                        tagName: i\n                    };\n                    \"#text\" === i && (o.textContent = t.textContent || \"\");\n                    let r = t.attributes;\n                    if (r) {\n                        let t = {};\n                        [].forEach.call(r, (e)=>{\n                            \"data-style\" === e.name ? o.style = m.parseStyle(e.value) : t[e.name] = e.value;\n                        }), o.attributes = t;\n                    }\n                    if (t.childNodes.length) {\n                        let e = [];\n                        [].forEach.call(t.childNodes, (t)=>{\n                            s(t, e);\n                        }), e.length && (o.children = e);\n                    }\n                    e.push(o);\n                };\n                return [].forEach.call(e.body.childNodes, (t)=>s(t, i)), i;\n            }\n            constructor(t){\n                this.nodes = \"string\" == typeof t ? this.parseMarkup(t) : t;\n            }\n        }\n        return m.allowedAttributes = [\n            \"alt\",\n            \"aria-controls\",\n            \"aria-describedby\",\n            \"aria-expanded\",\n            \"aria-haspopup\",\n            \"aria-hidden\",\n            \"aria-label\",\n            \"aria-labelledby\",\n            \"aria-live\",\n            \"aria-pressed\",\n            \"aria-readonly\",\n            \"aria-roledescription\",\n            \"aria-selected\",\n            \"class\",\n            \"clip-path\",\n            \"color\",\n            \"colspan\",\n            \"cx\",\n            \"cy\",\n            \"d\",\n            \"dx\",\n            \"dy\",\n            \"disabled\",\n            \"fill\",\n            \"filterUnits\",\n            \"flood-color\",\n            \"flood-opacity\",\n            \"height\",\n            \"href\",\n            \"id\",\n            \"in\",\n            \"markerHeight\",\n            \"markerWidth\",\n            \"offset\",\n            \"opacity\",\n            \"orient\",\n            \"padding\",\n            \"paddingLeft\",\n            \"paddingRight\",\n            \"patternUnits\",\n            \"r\",\n            \"refX\",\n            \"refY\",\n            \"role\",\n            \"scope\",\n            \"slope\",\n            \"src\",\n            \"startOffset\",\n            \"stdDeviation\",\n            \"stroke\",\n            \"stroke-linecap\",\n            \"stroke-width\",\n            \"style\",\n            \"tableValues\",\n            \"result\",\n            \"rowspan\",\n            \"summary\",\n            \"target\",\n            \"tabindex\",\n            \"text-align\",\n            \"text-anchor\",\n            \"textAnchor\",\n            \"textLength\",\n            \"title\",\n            \"type\",\n            \"valign\",\n            \"width\",\n            \"x\",\n            \"x1\",\n            \"x2\",\n            \"xlink:href\",\n            \"y\",\n            \"y1\",\n            \"y2\",\n            \"zIndex\"\n        ], m.allowedReferences = [\n            \"https://\",\n            \"http://\",\n            \"mailto:\",\n            \"/\",\n            \"../\",\n            \"./\",\n            \"#\"\n        ], m.allowedTags = [\n            \"a\",\n            \"abbr\",\n            \"b\",\n            \"br\",\n            \"button\",\n            \"caption\",\n            \"circle\",\n            \"clipPath\",\n            \"code\",\n            \"dd\",\n            \"defs\",\n            \"div\",\n            \"dl\",\n            \"dt\",\n            \"em\",\n            \"feComponentTransfer\",\n            \"feDropShadow\",\n            \"feFuncA\",\n            \"feFuncB\",\n            \"feFuncG\",\n            \"feFuncR\",\n            \"feGaussianBlur\",\n            \"feOffset\",\n            \"feMerge\",\n            \"feMergeNode\",\n            \"filter\",\n            \"h1\",\n            \"h2\",\n            \"h3\",\n            \"h4\",\n            \"h5\",\n            \"h6\",\n            \"hr\",\n            \"i\",\n            \"img\",\n            \"li\",\n            \"linearGradient\",\n            \"marker\",\n            \"ol\",\n            \"p\",\n            \"path\",\n            \"pattern\",\n            \"pre\",\n            \"rect\",\n            \"small\",\n            \"span\",\n            \"stop\",\n            \"strong\",\n            \"style\",\n            \"sub\",\n            \"sup\",\n            \"svg\",\n            \"table\",\n            \"text\",\n            \"textPath\",\n            \"thead\",\n            \"title\",\n            \"tbody\",\n            \"tspan\",\n            \"td\",\n            \"th\",\n            \"tr\",\n            \"u\",\n            \"ul\",\n            \"#text\"\n        ], m.emptyHTML = g, m.bypassHTMLFiltering = !1, m;\n    }), i(e, \"Core/Templating.js\", [\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { defaultOptions: i, defaultTime: s } = t, { extend: o, getNestedProperty: r, isArray: n, isNumber: a, isObject: h, isString: l, pick: d, pInt: c } = e, p = {\n            add: (t, e)=>t + e,\n            divide: (t, e)=>0 !== e ? t / e : \"\",\n            eq: (t, e)=>t == e,\n            each: function(t) {\n                let e = arguments[arguments.length - 1];\n                return !!n(t) && t.map((i, s)=>u(e.body, o(h(i) ? i : {\n                        \"@this\": i\n                    }, {\n                        \"@index\": s,\n                        \"@first\": 0 === s,\n                        \"@last\": s === t.length - 1\n                    }))).join(\"\");\n            },\n            ge: (t, e)=>t >= e,\n            gt: (t, e)=>t > e,\n            if: (t)=>!!t,\n            le: (t, e)=>t <= e,\n            lt: (t, e)=>t < e,\n            multiply: (t, e)=>t * e,\n            ne: (t, e)=>t != e,\n            subtract: (t, e)=>t - e,\n            unless: (t)=>!t\n        };\n        function u() {\n            let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", e = arguments.length > 1 ? arguments[1] : void 0, o = arguments.length > 2 ? arguments[2] : void 0;\n            let n = /\\{([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= #\\(\\)]+)\\}/g, a = /\\(([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= ]+)\\)/g, h = [], l = /f$/, c = /\\.([0-9])/, f = i.lang, m = o && o.time || s, x = o && o.numberFormatter || g, y = function() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n                let i;\n                return \"true\" === t || \"false\" !== t && ((i = Number(t)).toString() === t ? i : r(t, e));\n            }, b, v, S = 0, k;\n            for(; null !== (b = n.exec(t));){\n                let i = a.exec(b[1]);\n                i && (b = i, k = !0), v && v.isBlock || (v = {\n                    ctx: e,\n                    expression: b[1],\n                    find: b[0],\n                    isBlock: \"#\" === b[1].charAt(0),\n                    start: b.index,\n                    startInner: b.index + b[0].length,\n                    length: b[0].length\n                });\n                let s = b[1].split(\" \")[0].replace(\"#\", \"\");\n                p[s] && (v.isBlock && s === v.fn && S++, v.fn || (v.fn = s));\n                let o = \"else\" === b[1];\n                if (v.isBlock && v.fn && (b[1] === \"/\".concat(v.fn) || o)) {\n                    if (S) !o && S--;\n                    else {\n                        let e = v.startInner, i = t.substr(e, b.index - e);\n                        void 0 === v.body ? (v.body = i, v.startInner = b.index + b[0].length) : v.elseBody = i, v.find += i + b[0], o || (h.push(v), v = void 0);\n                    }\n                } else v.isBlock || h.push(v);\n                if (i && !(v === null || v === void 0 ? void 0 : v.isBlock)) break;\n            }\n            return h.forEach((i)=>{\n                let s, o;\n                let { body: r, elseBody: n, expression: a, fn: h } = i;\n                if (h) {\n                    let t = [\n                        i\n                    ], l = a.split(\" \");\n                    for(o = p[h].length; o--;)t.unshift(y(l[o + 1]));\n                    s = p[h].apply(e, t), i.isBlock && \"boolean\" == typeof s && (s = u(s ? r : n, e));\n                } else {\n                    let t = a.split(\":\");\n                    if (s = y(t.shift() || \"\"), t.length && \"number\" == typeof s) {\n                        let e = t.join(\":\");\n                        if (l.test(e)) {\n                            let t = parseInt((e.match(c) || [\n                                \"\",\n                                \"-1\"\n                            ])[1], 10);\n                            null !== s && (s = x(s, t, f.decimalPoint, e.indexOf(\",\") > -1 ? f.thousandsSep : \"\"));\n                        } else s = m.dateFormat(e, s);\n                    }\n                }\n                t = t.replace(i.find, d(s, \"\"));\n            }), k ? u(t, e, o) : t;\n        }\n        function g(t, e, s, o) {\n            let r, n;\n            t = +t || 0, e = +e;\n            let h = i.lang, l = (t.toString().split(\".\")[1] || \"\").split(\"e\")[0].length, p = t.toString().split(\"e\"), u = e;\n            -1 === e ? e = Math.min(l, 20) : a(e) ? e && p[1] && p[1] < 0 && ((n = e + +p[1]) >= 0 ? (p[0] = (+p[0]).toExponential(n).split(\"e\")[0], e = n) : (p[0] = p[0].split(\".\")[0] || 0, t = e < 20 ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0)) : e = 2;\n            let g = (Math.abs(p[1] ? p[0] : t) + Math.pow(10, -Math.max(e, l) - 1)).toFixed(e), f = String(c(g)), m = f.length > 3 ? f.length % 3 : 0;\n            return s = d(s, h.decimalPoint), o = d(o, h.thousandsSep), r = (t < 0 ? \"-\" : \"\") + (m ? f.substr(0, m) + o : \"\"), 0 > +p[1] && !u ? r = \"0\" : r += f.substr(m).replace(/(\\d{3})(?=\\d)/g, \"$1\" + o), e && (r += s + g.slice(-e)), p[1] && 0 != +r && (r += \"e\" + p[1]), r;\n        }\n        return {\n            dateFormat: function(t, e, i) {\n                return s.dateFormat(t, e, i);\n            },\n            format: u,\n            helpers: p,\n            numberFormat: g\n        };\n    }), i(e, \"Core/Renderer/RendererUtilities.js\", [\n        e[\"Core/Utilities.js\"]\n    ], function(t) {\n        var e;\n        let { clamp: i, pick: s, pushUnique: o, stableSort: r } = t;\n        return (e || (e = {})).distribute = function t(e, n, a) {\n            let h = e, l = h.reducedLen || n, d = (t, e)=>t.target - e.target, c = [], p = e.length, u = [], g = c.push, f, m, x, y = !0, b, v, S = 0, k;\n            for(f = p; f--;)S += e[f].size;\n            if (S > l) {\n                for(r(e, (t, e)=>(e.rank || 0) - (t.rank || 0)), x = (k = e[0].rank === e[e.length - 1].rank) ? p / 2 : -1, m = k ? x : p - 1; x && S > l;)b = e[f = Math.floor(m)], o(u, f) && (S -= b.size), m += x, k && m >= e.length && (x /= 2, m = x);\n                u.sort((t, e)=>e - t).forEach((t)=>g.apply(c, e.splice(t, 1)));\n            }\n            for(r(e, d), e = e.map((t)=>({\n                    size: t.size,\n                    targets: [\n                        t.target\n                    ],\n                    align: s(t.align, .5)\n                })); y;){\n                for(f = e.length; f--;)b = e[f], v = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = i(v - b.size * b.align, 0, n - b.size);\n                for(f = e.length, y = !1; f--;)f > 0 && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > n && (e[f - 1].pos = n - e[f - 1].size), e.splice(f, 1), y = !0);\n            }\n            return g.apply(h, c), f = 0, e.some((e)=>{\n                let i = 0;\n                return (e.targets || []).some(()=>(h[f].pos = e.pos + i, void 0 !== a && Math.abs(h[f].pos - h[f].target) > a) ? (h.slice(0, f + 1).forEach((t)=>delete t.pos), h.reducedLen = (h.reducedLen || n) - .1 * n, h.reducedLen > .1 * n && t(h, n, a), !0) : (i += h[f].size, f++, !1));\n            }), r(h, d), h;\n        }, e;\n    }), i(e, \"Core/Renderer/SVG/SVGElement.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s) {\n        let { animate: o, animObject: r, stop: n } = t, { deg2rad: a, doc: h, noop: l, svg: d, SVG_NS: c, win: p } = i, { addEvent: u, attr: g, createElement: f, css: m, defined: x, erase: y, extend: b, fireEvent: v, isArray: S, isFunction: k, isObject: M, isString: C, merge: w, objectEach: T, pick: A, pInt: P, syncTimeout: L, uniqueKey: O } = s;\n        class D {\n            _defaultGetter(t) {\n                let e = A(this[t + \"Value\"], this[t], this.element ? this.element.getAttribute(t) : null, 0);\n                return /^[\\-0-9\\.]+$/.test(e) && (e = parseFloat(e)), e;\n            }\n            _defaultSetter(t, e, i) {\n                i.setAttribute(e, t);\n            }\n            add(t) {\n                let e;\n                let i = this.renderer, s = this.element;\n                return t && (this.parentGroup = t), void 0 !== this.textStr && \"text\" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;\n            }\n            addClass(t, e) {\n                let i = e ? \"\" : this.attr(\"class\") || \"\";\n                return (t = (t || \"\").split(/ /g).reduce(function(t, e) {\n                    return -1 === i.indexOf(e) && t.push(e), t;\n                }, i ? [\n                    i\n                ] : []).join(\" \")) !== i && this.attr(\"class\", t), this;\n            }\n            afterSetters() {\n                this.doTransform && (this.updateTransform(), this.doTransform = !1);\n            }\n            align(t, e, i) {\n                let s, o, r, n, a;\n                let h = {}, l = this.renderer, d = l.alignedObjects;\n                t ? (this.alignOptions = t, this.alignByTranslate = e, (!i || C(i)) && (this.alignTo = r = i || \"renderer\", y(d, this), d.push(this), i = void 0)) : (t = this.alignOptions, e = this.alignByTranslate, r = this.alignTo), i = A(i, l[r], \"scrollablePlotBox\" === r ? l.plotBox : void 0, l);\n                let c = t.align, p = t.verticalAlign;\n                return s = (i.x || 0) + (t.x || 0), o = (i.y || 0) + (t.y || 0), \"right\" === c ? n = 1 : \"center\" === c && (n = 2), n && (s += (i.width - (t.width || 0)) / n), h[e ? \"translateX\" : \"x\"] = Math.round(s), \"bottom\" === p ? a = 1 : \"middle\" === p && (a = 2), a && (o += (i.height - (t.height || 0)) / a), h[e ? \"translateY\" : \"y\"] = Math.round(o), this[this.placed ? \"animate\" : \"attr\"](h), this.placed = !0, this.alignAttr = h, this;\n            }\n            alignSetter(t) {\n                let e = {\n                    left: \"start\",\n                    center: \"middle\",\n                    right: \"end\"\n                };\n                e[t] && (this.alignValue = t, this.element.setAttribute(\"text-anchor\", e[t]));\n            }\n            animate(t, e, i) {\n                let s = r(A(e, this.renderer.globalAnimation, !0)), n = s.defer;\n                return h.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), L(()=>{\n                    this.element && o(this, t, s);\n                }, n)) : (this.attr(t, void 0, i || s.complete), T(t, function(t, e) {\n                    s.step && s.step.call(this, t, {\n                        prop: e,\n                        pos: 1,\n                        elem: this\n                    });\n                }, this)), this;\n            }\n            applyTextOutline(t) {\n                let e = this.element, s = -1 !== t.indexOf(\"contrast\");\n                s && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));\n                let o = t.split(\" \"), r = o[o.length - 1], n = o[0];\n                if (n && \"none\" !== n && i.svg) {\n                    this.fakeTS = !0, n = n.replace(/(^[\\d\\.]+)(.*?)$/g, function(t, e, i) {\n                        return 2 * Number(e) + i;\n                    }), this.removeTextOutline();\n                    let t = h.createElementNS(c, \"tspan\");\n                    g(t, {\n                        class: \"highcharts-text-outline\",\n                        fill: r,\n                        stroke: r,\n                        \"stroke-width\": n,\n                        \"stroke-linejoin\": \"round\"\n                    });\n                    let i = e.querySelector(\"textPath\") || e;\n                    [].forEach.call(i.childNodes, (e)=>{\n                        let i = e.cloneNode(!0);\n                        i.removeAttribute && [\n                            \"fill\",\n                            \"stroke\",\n                            \"stroke-width\",\n                            \"stroke\"\n                        ].forEach((t)=>i.removeAttribute(t)), t.appendChild(i);\n                    });\n                    let s = 0;\n                    [].forEach.call(i.querySelectorAll(\"text tspan\"), (t)=>{\n                        s += Number(t.getAttribute(\"dy\"));\n                    });\n                    let o = h.createElementNS(c, \"tspan\");\n                    o.textContent = \"​\", g(o, {\n                        x: Number(e.getAttribute(\"x\")),\n                        dy: -s\n                    }), t.appendChild(o), i.insertBefore(t, i.firstChild);\n                }\n            }\n            attr(t, e, i, s) {\n                let o = this.element, r = D.symbolCustomAttribs, a, h, l = this, d;\n                return \"string\" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), \"string\" == typeof t ? l = (this[t + \"Getter\"] || this._defaultGetter).call(this, t, o) : (T(t, function(e, i) {\n                    d = !1, s || n(this, i), this.symbolName && -1 !== r.indexOf(i) && (h || (this.symbolAttr(t), h = !0), d = !0), this.rotation && (\"x\" === i || \"y\" === i) && (this.doTransform = !0), d || (this[i + \"Setter\"] || this._defaultSetter).call(this, e, i, o);\n                }, this), this.afterSetters()), i && i.call(this), l;\n            }\n            clip(t) {\n                if (t && !t.clipPath) {\n                    let e = O() + \"-\", i = this.renderer.createElement(\"clipPath\").attr({\n                        id: e\n                    }).add(this.renderer.defs);\n                    b(t, {\n                        clipPath: i,\n                        id: e,\n                        count: 0\n                    }), t.add(i);\n                }\n                return this.attr(\"clip-path\", t ? \"url(\".concat(this.renderer.url, \"#\").concat(t.id, \")\") : \"none\");\n            }\n            crisp(t, e) {\n                e = e || t.strokeWidth || 0;\n                let i = Math.round(e) % 2 / 2;\n                return t.x = Math.floor(t.x || this.x || 0) + i, t.y = Math.floor(t.y || this.y || 0) + i, t.width = Math.floor((t.width || this.width || 0) - 2 * i), t.height = Math.floor((t.height || this.height || 0) - 2 * i), x(t.strokeWidth) && (t.strokeWidth = e), t;\n            }\n            complexColor(t, i, s) {\n                let o = this.renderer, r, n, a, h, l, d, c, p, u, g, f = [], m;\n                v(this.renderer, \"complexColor\", {\n                    args: arguments\n                }, function() {\n                    if (t.radialGradient ? n = \"radialGradient\" : t.linearGradient && (n = \"linearGradient\"), n) {\n                        if (a = t[n], l = o.gradients, d = t.stops, u = s.radialReference, S(a) && (t[n] = a = {\n                            x1: a[0],\n                            y1: a[1],\n                            x2: a[2],\n                            y2: a[3],\n                            gradientUnits: \"userSpaceOnUse\"\n                        }), \"radialGradient\" === n && u && !x(a.gradientUnits) && (h = a, a = w(a, o.getRadialAttr(u, h), {\n                            gradientUnits: \"userSpaceOnUse\"\n                        })), T(a, function(t, e) {\n                            \"id\" !== e && f.push(e, t);\n                        }), T(d, function(t) {\n                            f.push(t);\n                        }), l[f = f.join(\",\")]) g = l[f].attr(\"id\");\n                        else {\n                            a.id = g = O();\n                            let t = l[f] = o.createElement(n).attr(a).add(o.defs);\n                            t.radAttr = h, t.stops = [], d.forEach(function(i) {\n                                0 === i[1].indexOf(\"rgba\") ? (c = (r = e.parse(i[1])).get(\"rgb\"), p = r.get(\"a\")) : (c = i[1], p = 1);\n                                let s = o.createElement(\"stop\").attr({\n                                    offset: i[0],\n                                    \"stop-color\": c,\n                                    \"stop-opacity\": p\n                                }).add(t);\n                                t.stops.push(s);\n                            });\n                        }\n                        m = \"url(\" + o.url + \"#\" + g + \")\", s.setAttribute(i, m), s.gradient = f, t.toString = function() {\n                            return m;\n                        };\n                    }\n                });\n            }\n            css(t) {\n                let e = this.styles, i = {}, s = this.element, o, r = !e;\n                if (e && T(t, function(t, s) {\n                    e && e[s] !== t && (i[s] = t, r = !0);\n                }), r) {\n                    e && (t = b(e, i)), null === t.width || \"auto\" === t.width ? delete this.textWidth : \"text\" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = P(t.width)), this.styles = t, o && !d && this.renderer.forExport && delete t.width;\n                    let r = w(t);\n                    s.namespaceURI === this.SVG_NS && ([\n                        \"textOutline\",\n                        \"textOverflow\",\n                        \"width\"\n                    ].forEach((t)=>r && delete r[t]), r.color && (r.fill = r.color)), m(s, r);\n                }\n                return this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;\n            }\n            dashstyleSetter(t) {\n                let e, i = this[\"stroke-width\"];\n                if (\"inherit\" === i && (i = 1), t = t && t.toLowerCase()) {\n                    let s = t.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n                    for(e = s.length; e--;)s[e] = \"\" + P(s[e]) * A(i, NaN);\n                    t = s.join(\",\").replace(/NaN/g, \"none\"), this.element.setAttribute(\"stroke-dasharray\", t);\n                }\n            }\n            destroy() {\n                var _t_connector;\n                let t = this, e = t.element || {}, i = t.renderer, s = e.ownerSVGElement, o = \"SPAN\" === e.nodeName && t.parentGroup || void 0, r, a;\n                if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, n(t), t.clipPath && s) {\n                    let e = t.clipPath;\n                    [].forEach.call(s.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function(t) {\n                        t.getAttribute(\"clip-path\").indexOf(e.element.id) > -1 && t.removeAttribute(\"clip-path\");\n                    }), t.clipPath = e.destroy();\n                }\n                if (t.connector = (_t_connector = t.connector) === null || _t_connector === void 0 ? void 0 : _t_connector.destroy(), t.stops) {\n                    for(a = 0; a < t.stops.length; a++)t.stops[a].destroy();\n                    t.stops.length = 0, t.stops = void 0;\n                }\n                for(t.safeRemoveChild(e); o && o.div && 0 === o.div.childNodes.length;)r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r;\n                t.alignTo && y(i.alignedObjects, t), T(t, function(e, i) {\n                    t[i] && t[i].parentGroup === t && t[i].destroy && t[i].destroy(), delete t[i];\n                });\n            }\n            dSetter(t, e, i) {\n                S(t) && (\"string\" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i)=>e && e.join ? (i ? t + \" \" : \"\") + e.join(\" \") : (e || \"\").toString(), \"\")), /(NaN| {2}|^$)/.test(t) && (t = \"M 0 0\"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);\n            }\n            fillSetter(t, e, i) {\n                \"string\" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);\n            }\n            hrefSetter(t, e, i) {\n                i.setAttributeNS(\"http://www.w3.org/1999/xlink\", e, t);\n            }\n            getBBox(t, e) {\n                let i, s, o, r, n;\n                let { alignValue: h, element: l, renderer: d, styles: c, textStr: p } = this, { cache: u, cacheKeys: g } = d, f = l.namespaceURI === this.SVG_NS, y = A(e, this.rotation, 0), v = d.styledMode ? l && D.prototype.getStyle.call(l, \"font-size\") : c && c.fontSize;\n                if (x(p) && (-1 === (n = p.toString()).indexOf(\"<\") && (n = n.replace(/[0-9]/g, \"0\")), n += [\n                    \"\",\n                    d.rootFontSize,\n                    v,\n                    y,\n                    this.textWidth,\n                    h,\n                    c && c.textOverflow,\n                    c && c.fontWeight\n                ].join(\",\")), n && !t && (i = u[n]), !i) {\n                    if (f || d.forExport) {\n                        try {\n                            r = this.fakeTS && function(t) {\n                                let e = l.querySelector(\".highcharts-text-outline\");\n                                e && m(e, {\n                                    display: t\n                                });\n                            }, k(r) && r(\"none\"), i = l.getBBox ? b({}, l.getBBox()) : {\n                                width: l.offsetWidth,\n                                height: l.offsetHeight,\n                                x: 0,\n                                y: 0\n                            }, k(r) && r(\"\");\n                        } catch (t) {}\n                        (!i || i.width < 0) && (i = {\n                            x: 0,\n                            y: 0,\n                            width: 0,\n                            height: 0\n                        });\n                    } else i = this.htmlGetBBox();\n                    if (s = i.width, o = i.height, f && (i.height = o = ({\n                        \"11px,17\": 14,\n                        \"13px,20\": 16\n                    })[\"\".concat(v || \"\", \",\").concat(Math.round(o))] || o), y) {\n                        let t = Number(l.getAttribute(\"y\") || 0) - i.y, e = {\n                            right: 1,\n                            center: .5\n                        }[h || 0] || 0, r = y * a, n = (y - 90) * a, d = s * Math.cos(r), c = s * Math.sin(r), p = Math.cos(n), u = Math.sin(n), g = i.x + e * (s - d), f = i.y + t - e * c, m = g + t * p, x = m + d, b = x - o * p, v = b - d, S = f + t * u, k = S + c, M = k - o * u, C = M - c;\n                        i.x = Math.min(m, x, b, v), i.y = Math.min(S, k, M, C), i.width = Math.max(m, x, b, v) - i.x, i.height = Math.max(S, k, M, C) - i.y;\n                    }\n                }\n                if (n && (\"\" === p || i.height > 0)) {\n                    for(; g.length > 250;)delete u[g.shift()];\n                    u[n] || g.push(n), u[n] = i;\n                }\n                return i;\n            }\n            getStyle(t) {\n                return p.getComputedStyle(this.element || this, \"\").getPropertyValue(t);\n            }\n            hasClass(t) {\n                return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(t);\n            }\n            hide() {\n                return this.attr({\n                    visibility: \"hidden\"\n                });\n            }\n            htmlGetBBox() {\n                return {\n                    height: 0,\n                    width: 0,\n                    x: 0,\n                    y: 0\n                };\n            }\n            on(t, e) {\n                let { onEvents: i } = this;\n                return i[t] && i[t](), i[t] = u(this.element, t, e), this;\n            }\n            opacitySetter(t, e, i) {\n                let s = Number(Number(t).toFixed(3));\n                this.opacity = s, i.setAttribute(e, s);\n            }\n            removeClass(t) {\n                return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(C(t) ? RegExp(\"(^| )\".concat(t, \"( |$)\")) : t, \" \").replace(/ +/g, \" \").trim());\n            }\n            removeTextOutline() {\n                let t = this.element.querySelector(\"tspan.highcharts-text-outline\");\n                t && this.safeRemoveChild(t);\n            }\n            safeRemoveChild(t) {\n                let e = t.parentNode;\n                e && e.removeChild(t);\n            }\n            setRadialReference(t) {\n                let e = this.element.gradient && this.renderer.gradients[this.element.gradient];\n                return this.element.radialReference = t, e && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;\n            }\n            setTextPath(t, e) {\n                e = w(!0, {\n                    enabled: !0,\n                    attributes: {\n                        dy: -5,\n                        startOffset: \"50%\",\n                        textAnchor: \"middle\"\n                    }\n                }, e);\n                let i = this.renderer.url, s = this.text || this, o = s.textPath, { attributes: r, enabled: n } = e;\n                if (t = t || o && o.path, o && o.undo(), t && n) {\n                    let e = u(s, \"afterModifyTree\", (e)=>{\n                        if (t && n) {\n                            let o = t.attr(\"id\");\n                            o || t.attr(\"id\", o = O());\n                            let n = {\n                                x: 0,\n                                y: 0\n                            };\n                            x(r.dx) && (n.dx = r.dx, delete r.dx), x(r.dy) && (n.dy = r.dy, delete r.dy), s.attr(n), this.attr({\n                                transform: \"\"\n                            }), this.box && (this.box = this.box.destroy());\n                            let a = e.nodes.slice(0);\n                            e.nodes.length = 0, e.nodes[0] = {\n                                tagName: \"textPath\",\n                                attributes: b(r, {\n                                    \"text-anchor\": r.textAnchor,\n                                    href: \"\".concat(i, \"#\").concat(o)\n                                }),\n                                children: a\n                            };\n                        }\n                    });\n                    s.textPath = {\n                        path: t,\n                        undo: e\n                    };\n                } else s.attr({\n                    dx: 0,\n                    dy: 0\n                }), delete s.textPath;\n                return this.added && (s.textCache = \"\", this.renderer.buildText(s)), this;\n            }\n            shadow(t) {\n                var _this_parentGroup;\n                let { renderer: e } = this, i = w(((_this_parentGroup = this.parentGroup) === null || _this_parentGroup === void 0 ? void 0 : _this_parentGroup.rotation) === 90 ? {\n                    offsetX: -1,\n                    offsetY: -1\n                } : {}, M(t) ? t : {}), s = e.shadowDefinition(i);\n                return this.attr({\n                    filter: t ? \"url(\".concat(e.url, \"#\").concat(s, \")\") : \"none\"\n                });\n            }\n            show() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n                return this.attr({\n                    visibility: t ? \"inherit\" : \"visible\"\n                });\n            }\n            \"stroke-widthSetter\"(t, e, i) {\n                this[e] = t, i.setAttribute(e, t);\n            }\n            strokeWidth() {\n                if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n                let t = this.getStyle(\"stroke-width\"), e = 0, i;\n                return t.indexOf(\"px\") === t.length - 2 ? e = P(t) : \"\" !== t && (g(i = h.createElementNS(c, \"rect\"), {\n                    width: t,\n                    \"stroke-width\": 0\n                }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;\n            }\n            symbolAttr(t) {\n                let e = this;\n                D.symbolCustomAttribs.forEach(function(i) {\n                    e[i] = A(t[i], e[i]);\n                }), e.attr({\n                    d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n                });\n            }\n            textSetter(t) {\n                t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this));\n            }\n            titleSetter(t) {\n                let e = this.element, i = e.getElementsByTagName(\"title\")[0] || h.createElementNS(this.SVG_NS, \"title\");\n                e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = String(A(t, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n            }\n            toFront() {\n                let t = this.element;\n                return t.parentNode.appendChild(t), this;\n            }\n            translate(t, e) {\n                return this.attr({\n                    translateX: t,\n                    translateY: e\n                });\n            }\n            updateTransform() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"transform\";\n                let { element: e, matrix: i, rotation: s = 0, scaleX: o, scaleY: r, translateX: n = 0, translateY: a = 0 } = this, h = [\n                    \"translate(\" + n + \",\" + a + \")\"\n                ];\n                x(i) && h.push(\"matrix(\" + i.join(\",\") + \")\"), s && h.push(\"rotate(\" + s + \" \" + A(this.rotationOriginX, e.getAttribute(\"x\"), 0) + \" \" + A(this.rotationOriginY, e.getAttribute(\"y\") || 0) + \")\"), (x(o) || x(r)) && h.push(\"scale(\" + A(o, 1) + \" \" + A(r, 1) + \")\"), h.length && !(this.text || this).textPath && e.setAttribute(t, h.join(\" \"));\n            }\n            visibilitySetter(t, e, i) {\n                \"inherit\" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;\n            }\n            xGetter(t) {\n                return \"circle\" === this.element.nodeName && (\"x\" === t ? t = \"cx\" : \"y\" === t && (t = \"cy\")), this._defaultGetter(t);\n            }\n            zIndexSetter(t, e) {\n                let i = this.renderer, s = this.parentGroup, o = s || i, r = o.element || i.box, n = this.element, a = r === i.box, h, l, d, c = !1, p, u = this.added, g;\n                if (x(t) ? (n.setAttribute(\"data-z-index\", t), t = +t, this[e] === t && (u = !1)) : x(this[e]) && n.removeAttribute(\"data-z-index\"), this[e] = t, u) {\n                    for((t = this.zIndex) && s && (s.handleZ = !0), g = (h = r.childNodes).length - 1; g >= 0 && !c; g--)p = !x(d = (l = h[g]).getAttribute(\"data-z-index\")), l !== n && (t < 0 && p && !a && !g ? (r.insertBefore(n, h[g]), c = !0) : (P(d) <= t || p && (!x(t) || t >= 0)) && (r.insertBefore(n, h[g + 1]), c = !0));\n                    c || (r.insertBefore(n, h[a ? 3 : 0]), c = !0);\n                }\n                return c;\n            }\n            constructor(t, e){\n                this.onEvents = {}, this.opacity = 1, this.SVG_NS = c, this.element = \"span\" === e ? f(e) : h.createElementNS(this.SVG_NS, e), this.renderer = t, v(this, \"afterInit\");\n            }\n        }\n        return D.symbolCustomAttribs = [\n            \"anchorX\",\n            \"anchorY\",\n            \"clockwise\",\n            \"end\",\n            \"height\",\n            \"innerR\",\n            \"r\",\n            \"start\",\n            \"width\",\n            \"x\",\n            \"y\"\n        ], D.prototype.strokeSetter = D.prototype.fillSetter, D.prototype.yGetter = D.prototype.xGetter, D.prototype.matrixSetter = D.prototype.rotationOriginXSetter = D.prototype.rotationOriginYSetter = D.prototype.rotationSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.verticalAlignSetter = function(t, e) {\n            this[e] = t, this.doTransform = !0;\n        }, D;\n    }), i(e, \"Core/Renderer/RendererRegistry.js\", [\n        e[\"Core/Globals.js\"]\n    ], function(t) {\n        var e, i;\n        let s;\n        return (i = e || (e = {})).rendererTypes = {}, i.getRendererType = function() {\n            let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s;\n            return i.rendererTypes[t] || i.rendererTypes[s];\n        }, i.registerRendererType = function(e, o, r) {\n            i.rendererTypes[e] = o, (!s || r) && (s = e, t.Renderer = o);\n        }, e;\n    }), i(e, \"Core/Renderer/SVG/SVGLabel.js\", [\n        e[\"Core/Renderer/SVG/SVGElement.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { defined: i, extend: s, isNumber: o, merge: r, pick: n, removeEvent: a } = e;\n        class h extends t {\n            alignSetter(t) {\n                let e = {\n                    left: 0,\n                    center: .5,\n                    right: 1\n                }[t];\n                e !== this.alignFactor && (this.alignFactor = e, this.bBox && o(this.xSetting) && this.attr({\n                    x: this.xSetting\n                }));\n            }\n            anchorXSetter(t, e) {\n                this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);\n            }\n            anchorYSetter(t, e) {\n                this.anchorY = t, this.boxAttr(e, t - this.ySetting);\n            }\n            boxAttr(t, e) {\n                this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;\n            }\n            css(e) {\n                if (e) {\n                    let t = {};\n                    e = r(e), h.textProps.forEach((i)=>{\n                        void 0 !== e[i] && (t[i] = e[i], delete e[i]);\n                    }), this.text.css(t), \"fontSize\" in t || \"fontWeight\" in t ? this.updateTextPadding() : (\"width\" in t || \"textOverflow\" in t) && this.updateBoxSize();\n                }\n                return t.prototype.css.call(this, e);\n            }\n            destroy() {\n                a(this.element, \"mouseenter\"), a(this.element, \"mouseleave\"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t.prototype.destroy.call(this);\n            }\n            fillSetter(t, e) {\n                t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);\n            }\n            getBBox() {\n                this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n                let t = this.padding, e = n(this.paddingLeft, t);\n                return {\n                    width: this.width || 0,\n                    height: this.height || 0,\n                    x: this.bBox.x - e,\n                    y: this.bBox.y - t\n                };\n            }\n            getCrispAdjust() {\n                return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n            }\n            heightSetter(t) {\n                this.heightSetting = t;\n            }\n            onAdd() {\n                this.text.add(this), this.attr({\n                    text: n(this.textStr, \"\"),\n                    x: this.x || 0,\n                    y: this.y || 0\n                }), this.box && i(this.anchorX) && this.attr({\n                    anchorX: this.anchorX,\n                    anchorY: this.anchorY\n                });\n            }\n            paddingSetter(t, e) {\n                o(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;\n            }\n            rSetter(t, e) {\n                this.boxAttr(e, t);\n            }\n            strokeSetter(t, e) {\n                this.stroke = t, this.boxAttr(e, t);\n            }\n            \"stroke-widthSetter\"(t, e) {\n                t && (this.needsBox = !0), this[\"stroke-width\"] = t, this.boxAttr(e, t);\n            }\n            \"text-alignSetter\"(t) {\n                this.textAlign = t;\n            }\n            textSetter(t) {\n                void 0 !== t && this.text.attr({\n                    text: t\n                }), this.updateTextPadding();\n            }\n            updateBoxSize() {\n                let t;\n                let e = this.text, r = {}, n = this.padding, a = this.bBox = (!o(this.widthSetting) || !o(this.heightSetting) || this.textAlign) && i(e.textStr) ? e.getBBox() : h.emptyBBox;\n                this.width = this.getPaddedWidth(), this.height = (this.heightSetting || a.height || 0) + 2 * n;\n                let l = this.renderer.fontMetrics(e);\n                if (this.baselineOffset = n + Math.min((this.text.firstLineMetrics || l).b, a.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2), this.needsBox && !e.textPath) {\n                    if (!this.box) {\n                        let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n                        t.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), t.add(this);\n                    }\n                    t = this.getCrispAdjust(), r.x = t, r.y = (this.baseline ? -this.baselineOffset : 0) + t, r.width = Math.round(this.width), r.height = Math.round(this.height), this.box.attr(s(r, this.deferredAttr)), this.deferredAttr = {};\n                }\n            }\n            updateTextPadding() {\n                let t = this.text;\n                if (!t.textPath) {\n                    this.updateBoxSize();\n                    let e = this.baseline ? 0 : this.baselineOffset, s = n(this.paddingLeft, this.padding);\n                    i(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (s += ({\n                        center: .5,\n                        right: 1\n                    })[this.textAlign] * (this.widthSetting - this.bBox.width)), (s !== t.x || e !== t.y) && (t.attr(\"x\", s), t.hasBoxWidthChanged && (this.bBox = t.getBBox(!0)), void 0 !== e && t.attr(\"y\", e)), t.x = s, t.y = e;\n                }\n            }\n            widthSetter(t) {\n                this.widthSetting = o(t) ? t : void 0;\n            }\n            getPaddedWidth() {\n                let t = this.padding, e = n(this.paddingLeft, t), i = n(this.paddingRight, t);\n                return (this.widthSetting || this.bBox.width || 0) + e + i;\n            }\n            xSetter(t) {\n                this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0), this.xSetting = Math.round(t), this.attr(\"translateX\", this.xSetting);\n            }\n            ySetter(t) {\n                this.ySetting = this.y = Math.round(t), this.attr(\"translateY\", this.ySetting);\n            }\n            constructor(t, e, i, s, o, r, n, a, l, d){\n                let c;\n                super(t, \"g\"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = n, this.baseline = l, this.className = d, this.addClass(\"button\" === d ? \"highcharts-no-tooltip\" : \"highcharts-label\"), d && this.addClass(\"highcharts-\" + d), this.text = t.text(void 0, 0, 0, a).attr({\n                    zIndex: 1\n                }), \"string\" == typeof o && ((c = /^url\\((.*?)\\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = h.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || c, this.deferredAttr = {}, this.alignFactor = 0;\n            }\n        }\n        return h.emptyBBox = {\n            width: 0,\n            height: 0,\n            x: 0,\n            y: 0\n        }, h.textProps = [\n            \"color\",\n            \"direction\",\n            \"fontFamily\",\n            \"fontSize\",\n            \"fontStyle\",\n            \"fontWeight\",\n            \"lineHeight\",\n            \"textAlign\",\n            \"textDecoration\",\n            \"textOutline\",\n            \"textOverflow\",\n            \"whiteSpace\",\n            \"width\"\n        ], h;\n    }), i(e, \"Core/Renderer/SVG/Symbols.js\", [\n        e[\"Core/Utilities.js\"]\n    ], function(t) {\n        let { defined: e, isNumber: i, pick: s } = t;\n        function o(t, i, o, r, n) {\n            let a = [];\n            if (n) {\n                let h = n.start || 0, l = s(n.r, o), d = s(n.r, r || o), c = .001 > Math.abs((n.end || 0) - h - 2 * Math.PI), p = (n.end || 0) - .001, u = n.innerR, g = s(n.open, c), f = Math.cos(h), m = Math.sin(h), x = Math.cos(p), y = Math.sin(p), b = s(n.longArc, p - h - Math.PI < .001 ? 0 : 1), v = [\n                    \"A\",\n                    l,\n                    d,\n                    0,\n                    b,\n                    s(n.clockwise, 1),\n                    t + l * x,\n                    i + d * y\n                ];\n                v.params = {\n                    start: h,\n                    end: p,\n                    cx: t,\n                    cy: i\n                }, a.push([\n                    \"M\",\n                    t + l * f,\n                    i + d * m\n                ], v), e(u) && ((v = [\n                    \"A\",\n                    u,\n                    u,\n                    0,\n                    b,\n                    e(n.clockwise) ? 1 - n.clockwise : 0,\n                    t + u * f,\n                    i + u * m\n                ]).params = {\n                    start: p,\n                    end: h,\n                    cx: t,\n                    cy: i\n                }, a.push(g ? [\n                    \"M\",\n                    t + u * x,\n                    i + u * y\n                ] : [\n                    \"L\",\n                    t + u * x,\n                    i + u * y\n                ], v)), g || a.push([\n                    \"Z\"\n                ]);\n            }\n            return a;\n        }\n        function r(t, e, i, s, o) {\n            return o && o.r ? n(t, e, i, s, o) : [\n                [\n                    \"M\",\n                    t,\n                    e\n                ],\n                [\n                    \"L\",\n                    t + i,\n                    e\n                ],\n                [\n                    \"L\",\n                    t + i,\n                    e + s\n                ],\n                [\n                    \"L\",\n                    t,\n                    e + s\n                ],\n                [\n                    \"Z\"\n                ]\n            ];\n        }\n        function n(t, e, i, s, o) {\n            let r = (o === null || o === void 0 ? void 0 : o.r) || 0;\n            return [\n                [\n                    \"M\",\n                    t + r,\n                    e\n                ],\n                [\n                    \"L\",\n                    t + i - r,\n                    e\n                ],\n                [\n                    \"A\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    t + i,\n                    e + r\n                ],\n                [\n                    \"L\",\n                    t + i,\n                    e + s - r\n                ],\n                [\n                    \"A\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    t + i - r,\n                    e + s\n                ],\n                [\n                    \"L\",\n                    t + r,\n                    e + s\n                ],\n                [\n                    \"A\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    t,\n                    e + s - r\n                ],\n                [\n                    \"L\",\n                    t,\n                    e + r\n                ],\n                [\n                    \"A\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    t + r,\n                    e\n                ],\n                [\n                    \"Z\"\n                ]\n            ];\n        }\n        return {\n            arc: o,\n            callout: function(t, e, s, o, r) {\n                let a = Math.min(r && r.r || 0, s, o), h = a + 6, l = r && r.anchorX, d = r && r.anchorY || 0, c = n(t, e, s, o, {\n                    r: a\n                });\n                if (!i(l) || l < s && l > 0 && d < o && d > 0) return c;\n                if (t + l > s - h) {\n                    if (d > e + h && d < e + o - h) c.splice(3, 1, [\n                        \"L\",\n                        t + s,\n                        d - 6\n                    ], [\n                        \"L\",\n                        t + s + 6,\n                        d\n                    ], [\n                        \"L\",\n                        t + s,\n                        d + 6\n                    ], [\n                        \"L\",\n                        t + s,\n                        e + o - a\n                    ]);\n                    else if (l < s) {\n                        let i = d < e + h, r = i ? e : e + o;\n                        c.splice(i ? 2 : 5, 0, [\n                            \"L\",\n                            l,\n                            d\n                        ], [\n                            \"L\",\n                            t + s - a,\n                            r\n                        ]);\n                    } else c.splice(3, 1, [\n                        \"L\",\n                        t + s,\n                        o / 2\n                    ], [\n                        \"L\",\n                        l,\n                        d\n                    ], [\n                        \"L\",\n                        t + s,\n                        o / 2\n                    ], [\n                        \"L\",\n                        t + s,\n                        e + o - a\n                    ]);\n                } else if (t + l < h) {\n                    if (d > e + h && d < e + o - h) c.splice(7, 1, [\n                        \"L\",\n                        t,\n                        d + 6\n                    ], [\n                        \"L\",\n                        t - 6,\n                        d\n                    ], [\n                        \"L\",\n                        t,\n                        d - 6\n                    ], [\n                        \"L\",\n                        t,\n                        e + a\n                    ]);\n                    else if (l > 0) {\n                        let i = d < e + h, s = i ? e : e + o;\n                        c.splice(i ? 1 : 6, 0, [\n                            \"L\",\n                            l,\n                            d\n                        ], [\n                            \"L\",\n                            t + a,\n                            s\n                        ]);\n                    } else c.splice(7, 1, [\n                        \"L\",\n                        t,\n                        o / 2\n                    ], [\n                        \"L\",\n                        l,\n                        d\n                    ], [\n                        \"L\",\n                        t,\n                        o / 2\n                    ], [\n                        \"L\",\n                        t,\n                        e + a\n                    ]);\n                } else d > o && l < s - h ? c.splice(5, 1, [\n                    \"L\",\n                    l + 6,\n                    e + o\n                ], [\n                    \"L\",\n                    l,\n                    e + o + 6\n                ], [\n                    \"L\",\n                    l - 6,\n                    e + o\n                ], [\n                    \"L\",\n                    t + a,\n                    e + o\n                ]) : d < 0 && l > h && c.splice(1, 1, [\n                    \"L\",\n                    l - 6,\n                    e\n                ], [\n                    \"L\",\n                    l,\n                    e - 6\n                ], [\n                    \"L\",\n                    l + 6,\n                    e\n                ], [\n                    \"L\",\n                    s - a,\n                    e\n                ]);\n                return c;\n            },\n            circle: function(t, e, i, s) {\n                return o(t + i / 2, e + s / 2, i / 2, s / 2, {\n                    start: .5 * Math.PI,\n                    end: 2.5 * Math.PI,\n                    open: !1\n                });\n            },\n            diamond: function(t, e, i, s) {\n                return [\n                    [\n                        \"M\",\n                        t + i / 2,\n                        e\n                    ],\n                    [\n                        \"L\",\n                        t + i,\n                        e + s / 2\n                    ],\n                    [\n                        \"L\",\n                        t + i / 2,\n                        e + s\n                    ],\n                    [\n                        \"L\",\n                        t,\n                        e + s / 2\n                    ],\n                    [\n                        \"Z\"\n                    ]\n                ];\n            },\n            rect: r,\n            roundedRect: n,\n            square: r,\n            triangle: function(t, e, i, s) {\n                return [\n                    [\n                        \"M\",\n                        t + i / 2,\n                        e\n                    ],\n                    [\n                        \"L\",\n                        t + i,\n                        e + s\n                    ],\n                    [\n                        \"L\",\n                        t,\n                        e + s\n                    ],\n                    [\n                        \"Z\"\n                    ]\n                ];\n            },\n            \"triangle-down\": function(t, e, i, s) {\n                return [\n                    [\n                        \"M\",\n                        t,\n                        e\n                    ],\n                    [\n                        \"L\",\n                        t + i,\n                        e\n                    ],\n                    [\n                        \"L\",\n                        t + i / 2,\n                        e + s\n                    ],\n                    [\n                        \"Z\"\n                    ]\n                ];\n            }\n        };\n    }), i(e, \"Core/Renderer/SVG/TextBuilder.js\", [\n        e[\"Core/Renderer/HTML/AST.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { doc: s, SVG_NS: o, win: r } = e, { attr: n, extend: a, fireEvent: h, isString: l, objectEach: d, pick: c } = i;\n        return class {\n            buildSVG() {\n                let e = this.svgElement, i = e.element, o = e.renderer, r = c(e.textStr, \"\").toString(), n = -1 !== r.indexOf(\"<\"), a = i.childNodes, h = !e.added && o.box, d = [\n                    r,\n                    this.ellipsis,\n                    this.noWrap,\n                    this.textLineHeight,\n                    this.textOutline,\n                    e.getStyle(\"font-size\"),\n                    this.width\n                ].join(\",\");\n                if (d !== e.textCache) {\n                    e.textCache = d, delete e.actualWidth;\n                    for(let t = a.length; t--;)i.removeChild(a[t]);\n                    if (n || this.ellipsis || this.width || e.textPath || -1 !== r.indexOf(\" \") && (!this.noWrap || /<br.*?>/g.test(r))) {\n                        if (\"\" !== r) {\n                            h && h.appendChild(i);\n                            let s = new t(r);\n                            this.modifyTree(s.nodes), s.addToDOM(i), this.modifyDOM(), this.ellipsis && -1 !== (i.textContent || \"\").indexOf(\"…\") && e.attr(\"title\", this.unescapeEntities(e.textStr || \"\", [\n                                \"&lt;\",\n                                \"&gt;\"\n                            ])), h && h.removeChild(i);\n                        }\n                    } else i.appendChild(s.createTextNode(this.unescapeEntities(r)));\n                    l(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);\n                }\n            }\n            modifyDOM() {\n                let t;\n                let e = this.svgElement, i = n(e.element, \"x\");\n                for(e.firstLineMetrics = void 0; t = e.element.firstChild;)if (/^[\\s\\u200B]*$/.test(t.textContent || \" \")) e.element.removeChild(t);\n                else break;\n                [].forEach.call(e.element.querySelectorAll(\"tspan.highcharts-br\"), (t, s)=>{\n                    t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), n(t, {\n                        dy: this.getLineHeight(t.nextSibling),\n                        x: i\n                    }));\n                });\n                let a = this.width || 0;\n                if (!a) return;\n                let h = (t, r)=>{\n                    let h = t.textContent || \"\", l = h.replace(/([^\\^])-/g, \"$1- \").split(\" \"), d = !this.noWrap && (l.length > 1 || e.element.childNodes.length > 1), c = this.getLineHeight(r), p = 0, u = e.actualWidth;\n                    if (this.ellipsis) h && this.truncate(t, h, void 0, 0, Math.max(0, a - .8 * c), (t, e)=>t.substring(0, e) + \"…\");\n                    else if (d) {\n                        let h = [], d = [];\n                        for(; r.firstChild && r.firstChild !== t;)d.push(r.firstChild), r.removeChild(r.firstChild);\n                        for(; l.length;)l.length && !this.noWrap && p > 0 && (h.push(t.textContent || \"\"), t.textContent = l.join(\" \").replace(/- /g, \"-\")), this.truncate(t, void 0, l, 0 === p && u || 0, a, (t, e)=>l.slice(0, e).join(\" \").replace(/- /g, \"-\")), u = e.actualWidth, p++;\n                        d.forEach((e)=>{\n                            r.insertBefore(e, t);\n                        }), h.forEach((e)=>{\n                            r.insertBefore(s.createTextNode(e), t);\n                            let a = s.createElementNS(o, \"tspan\");\n                            a.textContent = \"​\", n(a, {\n                                dy: c,\n                                x: i\n                            }), r.insertBefore(a, t);\n                        });\n                    }\n                }, l = (t)=>{\n                    let i = [].slice.call(t.childNodes);\n                    i.forEach((i)=>{\n                        i.nodeType === r.Node.TEXT_NODE ? h(i, t) : (-1 !== i.className.baseVal.indexOf(\"highcharts-br\") && (e.actualWidth = 0), l(i));\n                    });\n                };\n                l(e.element);\n            }\n            getLineHeight(t) {\n                let e = t.nodeType === r.Node.TEXT_NODE ? t.parentElement : t;\n                return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;\n            }\n            modifyTree(t) {\n                let e = (i, s)=>{\n                    let { attributes: o = {}, children: r, style: n = {}, tagName: h } = i, l = this.renderer.styledMode;\n                    if (\"b\" === h || \"strong\" === h ? l ? o.class = \"highcharts-strong\" : n.fontWeight = \"bold\" : (\"i\" === h || \"em\" === h) && (l ? o.class = \"highcharts-emphasized\" : n.fontStyle = \"italic\"), n && n.color && (n.fill = n.color), \"br\" === h) {\n                        o.class = \"highcharts-br\", i.textContent = \"​\";\n                        let e = t[s + 1];\n                        e && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, \"\"));\n                    } else \"a\" === h && r && r.some((t)=>\"#text\" === t.tagName) && (i.children = [\n                        {\n                            children: r,\n                            tagName: \"tspan\"\n                        }\n                    ]);\n                    \"#text\" !== h && \"a\" !== h && (i.tagName = \"tspan\"), a(i, {\n                        attributes: o,\n                        style: n\n                    }), r && r.filter((t)=>\"#text\" !== t.tagName).forEach(e);\n                };\n                t.forEach(e), h(this.svgElement, \"afterModifyTree\", {\n                    nodes: t\n                });\n            }\n            truncate(t, e, i, s, o, r) {\n                let n, a;\n                let h = this.svgElement, { renderer: l, rotation: d } = h, c = [], p = i ? 1 : 0, u = (e || i || \"\").length, g = u, f = function(e, o) {\n                    let r = o || e, n = t.parentNode;\n                    if (n && void 0 === c[r] && n.getSubStringLength) try {\n                        c[r] = s + n.getSubStringLength(0, i ? r + 1 : r);\n                    } catch (t) {}\n                    return c[r];\n                };\n                if (h.rotation = 0, s + (a = f(t.textContent.length)) > o) {\n                    for(; p <= u;)g = Math.ceil((p + u) / 2), i && (n = r(i, g)), a = f(g, n && n.length - 1), p === u ? p = u + 1 : a > o ? u = g - 1 : p = g;\n                    0 === u ? t.textContent = \"\" : e && u === e.length - 1 || (t.textContent = n || r(e || i, g));\n                }\n                i && i.splice(0, g), h.actualWidth = a, h.rotation = d;\n            }\n            unescapeEntities(t, e) {\n                return d(this.renderer.escapes, function(i, s) {\n                    e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, \"g\"), s));\n                }), t;\n            }\n            constructor(t){\n                let e = t.styles;\n                this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e && e.lineHeight, this.textOutline = e && e.textOutline, this.ellipsis = !!(e && \"ellipsis\" === e.textOverflow), this.noWrap = !!(e && \"nowrap\" === e.whiteSpace);\n            }\n        };\n    }), i(e, \"Core/Renderer/SVG/SVGRenderer.js\", [\n        e[\"Core/Renderer/HTML/AST.js\"],\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/RendererRegistry.js\"],\n        e[\"Core/Renderer/SVG/SVGElement.js\"],\n        e[\"Core/Renderer/SVG/SVGLabel.js\"],\n        e[\"Core/Renderer/SVG/Symbols.js\"],\n        e[\"Core/Renderer/SVG/TextBuilder.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r, n, a, h) {\n        let l;\n        let { charts: d, deg2rad: c, doc: p, isFirefox: u, isMS: g, isWebKit: f, noop: m, SVG_NS: x, symbolSizes: y, win: b } = i, { addEvent: v, attr: S, createElement: k, css: M, defined: C, destroyObjectProperties: w, extend: T, isArray: A, isNumber: P, isObject: L, isString: O, merge: D, pick: E, pInt: j, uniqueKey: I } = h;\n        class B {\n            definition(e) {\n                let i = new t([\n                    e\n                ]);\n                return i.addToDOM(this.defs.element);\n            }\n            getReferenceURL() {\n                if ((u || f) && p.getElementsByTagName(\"base\").length) {\n                    if (!C(l)) {\n                        let e = I(), i = new t([\n                            {\n                                tagName: \"svg\",\n                                attributes: {\n                                    width: 8,\n                                    height: 8\n                                },\n                                children: [\n                                    {\n                                        tagName: \"defs\",\n                                        children: [\n                                            {\n                                                tagName: \"clipPath\",\n                                                attributes: {\n                                                    id: e\n                                                },\n                                                children: [\n                                                    {\n                                                        tagName: \"rect\",\n                                                        attributes: {\n                                                            width: 4,\n                                                            height: 4\n                                                        }\n                                                    }\n                                                ]\n                                            }\n                                        ]\n                                    },\n                                    {\n                                        tagName: \"rect\",\n                                        attributes: {\n                                            id: \"hitme\",\n                                            width: 8,\n                                            height: 8,\n                                            \"clip-path\": \"url(#\".concat(e, \")\"),\n                                            fill: \"rgba(0,0,0,0.001)\"\n                                        }\n                                    }\n                                ]\n                            }\n                        ]), s = i.addToDOM(p.body);\n                        M(s, {\n                            position: \"fixed\",\n                            top: 0,\n                            left: 0,\n                            zIndex: 9e5\n                        });\n                        let o = p.elementFromPoint(6, 6);\n                        l = \"hitme\" === (o && o.id), p.body.removeChild(s);\n                    }\n                    if (l) return b.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n                }\n                return \"\";\n            }\n            getStyle(t) {\n                return this.style = T({\n                    fontFamily: \"Helvetica, Arial, sans-serif\",\n                    fontSize: \"1rem\"\n                }, t), this.style;\n            }\n            setStyle(t) {\n                this.boxWrapper.css(this.getStyle(t));\n            }\n            isHidden() {\n                return !this.boxWrapper.getBBox().width;\n            }\n            destroy() {\n                let t = this.defs;\n                return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), w(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;\n            }\n            createElement(t) {\n                return new this.Element(this, t);\n            }\n            getRadialAttr(t, e) {\n                return {\n                    cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],\n                    cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],\n                    r: (e.r || 0) * t[2]\n                };\n            }\n            shadowDefinition(t) {\n                let e = [\n                    \"highcharts-drop-shadow-\".concat(this.chartIndex),\n                    ...Object.keys(t).map((e)=>\"\".concat(e, \"-\").concat(t[e]))\n                ].join(\"-\").toLowerCase().replace(/[^a-z0-9\\-]/g, \"\"), i = D({\n                    color: \"#000000\",\n                    offsetX: 1,\n                    offsetY: 1,\n                    opacity: .15,\n                    width: 5\n                }, t);\n                return this.defs.element.querySelector(\"#\".concat(e)) || this.definition({\n                    tagName: \"filter\",\n                    attributes: {\n                        id: e,\n                        filterUnits: i.filterUnits\n                    },\n                    children: [\n                        {\n                            tagName: \"feDropShadow\",\n                            attributes: {\n                                dx: i.offsetX,\n                                dy: i.offsetY,\n                                \"flood-color\": i.color,\n                                \"flood-opacity\": Math.min(5 * i.opacity, 1),\n                                stdDeviation: i.width / 2\n                            }\n                        }\n                    ]\n                }), e;\n            }\n            buildText(t) {\n                new a(t).buildSVG();\n            }\n            getContrast(t) {\n                let i = e.parse(t).rgba.map((t)=>{\n                    let e = t / 255;\n                    return e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n                }), s = .2126 * i[0] + .7152 * i[1] + .0722 * i[2];\n                return 1.05 / (s + .05) > (s + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n            }\n            button(e, i, s, o) {\n                let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, n = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 ? arguments[6] : void 0, h = arguments.length > 7 ? arguments[7] : void 0, l = arguments.length > 8 ? arguments[8] : void 0, d = arguments.length > 9 ? arguments[9] : void 0;\n                let c, p, u;\n                let f = this.label(e, i, s, l, void 0, void 0, d, void 0, \"button\"), m = this.styledMode, x = r.states || {}, y = 0;\n                r = D(r), delete r.states;\n                let b = D({\n                    color: \"#333333\",\n                    cursor: \"pointer\",\n                    fontSize: \"0.8em\",\n                    fontWeight: \"normal\"\n                }, r.style);\n                delete r.style;\n                let S = t.filterUserAttributes(r);\n                return f.attr(D({\n                    padding: 8,\n                    r: 2\n                }, S)), m || (S = D({\n                    fill: \"#f7f7f7\",\n                    stroke: \"#cccccc\",\n                    \"stroke-width\": 1\n                }, S), c = (n = D(S, {\n                    fill: \"#e6e6e6\"\n                }, t.filterUserAttributes(n || x.hover || {}))).style, delete n.style, p = (a = D(S, {\n                    fill: \"#e6e9ff\",\n                    style: {\n                        color: \"#000000\",\n                        fontWeight: \"bold\"\n                    }\n                }, t.filterUserAttributes(a || x.select || {}))).style, delete a.style, u = (h = D(S, {\n                    style: {\n                        color: \"#cccccc\"\n                    }\n                }, t.filterUserAttributes(h || x.disabled || {}))).style, delete h.style), v(f.element, g ? \"mouseover\" : \"mouseenter\", function() {\n                    3 !== y && f.setState(1);\n                }), v(f.element, g ? \"mouseout\" : \"mouseleave\", function() {\n                    3 !== y && f.setState(y);\n                }), f.setState = function(t) {\n                    if (1 !== t && (f.state = y = t), f.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\n                        \"normal\",\n                        \"hover\",\n                        \"pressed\",\n                        \"disabled\"\n                    ][t || 0]), !m) {\n                        f.attr([\n                            S,\n                            n,\n                            a,\n                            h\n                        ][t || 0]);\n                        let e = [\n                            b,\n                            c,\n                            p,\n                            u\n                        ][t || 0];\n                        L(e) && f.css(e);\n                    }\n                }, !m && (f.attr(S).css(T({\n                    cursor: \"default\"\n                }, b)), d && f.text.css({\n                    pointerEvents: \"none\"\n                })), f.on(\"touchstart\", (t)=>t.stopPropagation()).on(\"click\", function(t) {\n                    3 !== y && o.call(f, t);\n                });\n            }\n            crispLine(t, e) {\n                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"round\";\n                let s = t[0], o = t[1];\n                return C(s[1]) && s[1] === o[1] && (s[1] = o[1] = Math[i](s[1]) - e % 2 / 2), C(s[2]) && s[2] === o[2] && (s[2] = o[2] = Math[i](s[2]) + e % 2 / 2), t;\n            }\n            path(t) {\n                let e = this.styledMode ? {} : {\n                    fill: \"none\"\n                };\n                return A(t) ? e.d = t : L(t) && T(e, t), this.createElement(\"path\").attr(e);\n            }\n            circle(t, e, i) {\n                let s = L(t) ? t : void 0 === t ? {} : {\n                    x: t,\n                    y: e,\n                    r: i\n                }, o = this.createElement(\"circle\");\n                return o.xSetter = o.ySetter = function(t, e, i) {\n                    i.setAttribute(\"c\" + e, t);\n                }, o.attr(s);\n            }\n            arc(t, e, i, s, o, r) {\n                let n;\n                L(t) ? (e = (n = t).y, i = n.r, s = n.innerR, o = n.start, r = n.end, t = n.x) : n = {\n                    innerR: s,\n                    start: o,\n                    end: r\n                };\n                let a = this.symbol(\"arc\", t, e, i, i, n);\n                return a.r = i, a;\n            }\n            rect(t, e, i, s, o, r) {\n                let n = L(t) ? t : void 0 === t ? {} : {\n                    x: t,\n                    y: e,\n                    r: o,\n                    width: Math.max(i || 0, 0),\n                    height: Math.max(s || 0, 0)\n                }, a = this.createElement(\"rect\");\n                return this.styledMode || (void 0 !== r && (n[\"stroke-width\"] = r, T(n, a.crisp(n))), n.fill = \"none\"), a.rSetter = function(t, e, i) {\n                    a.r = t, S(i, {\n                        rx: t,\n                        ry: t\n                    });\n                }, a.rGetter = function() {\n                    return a.r || 0;\n                }, a.attr(n);\n            }\n            roundedRect(t) {\n                return this.symbol(\"roundedRect\").attr(t);\n            }\n            setSize(t, e, i) {\n                this.width = t, this.height = e, this.boxWrapper.animate({\n                    width: t,\n                    height: e\n                }, {\n                    step: function() {\n                        this.attr({\n                            viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n                        });\n                    },\n                    duration: E(i, !0) ? void 0 : 0\n                }), this.alignElements();\n            }\n            g(t) {\n                let e = this.createElement(\"g\");\n                return t ? e.attr({\n                    class: \"highcharts-\" + t\n                }) : e;\n            }\n            image(t, e, i, s, o, r) {\n                let n = {\n                    preserveAspectRatio: \"none\"\n                };\n                P(e) && (n.x = e), P(i) && (n.y = i), P(s) && (n.width = s), P(o) && (n.height = o);\n                let a = this.createElement(\"image\").attr(n), h = function(e) {\n                    a.attr({\n                        href: t\n                    }), r.call(a, e);\n                };\n                if (r) {\n                    a.attr({\n                        href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n                    });\n                    let e = new b.Image;\n                    v(e, \"load\", h), e.src = t, e.complete && h({});\n                } else a.attr({\n                    href: t\n                });\n                return a;\n            }\n            symbol(t, e, i, s, o, r) {\n                let n, a, h, l;\n                let c = this, u = /^url\\((.*?)\\)$/, g = u.test(t), f = !g && (this.symbols[t] ? t : \"circle\"), m = f && this.symbols[f];\n                if (m) \"number\" == typeof e && (a = m.call(this.symbols, Math.round(e || 0), Math.round(i || 0), s || 0, o || 0, r)), n = this.path(a), c.styledMode || n.attr(\"fill\", \"none\"), T(n, {\n                    symbolName: f || void 0,\n                    x: e,\n                    y: i,\n                    width: s,\n                    height: o\n                }), r && T(n, r);\n                else if (g) {\n                    h = t.match(u)[1];\n                    let s = n = this.image(h);\n                    s.imgwidth = E(r && r.width, y[h] && y[h].width), s.imgheight = E(r && r.height, y[h] && y[h].height), l = (t)=>t.attr({\n                            width: t.width,\n                            height: t.height\n                        }), [\n                        \"width\",\n                        \"height\"\n                    ].forEach((t)=>{\n                        s[\"\".concat(t, \"Setter\")] = function(t, e) {\n                            this[e] = t;\n                            let { alignByTranslate: i, element: s, width: o, height: n, imgwidth: a, imgheight: h } = this, l = \"width\" === e ? a : h, d = 1;\n                            r && \"within\" === r.backgroundSize && o && n && a && h ? (d = Math.min(o / a, n / h), S(s, {\n                                width: Math.round(a * d),\n                                height: Math.round(h * d)\n                            })) : s && l && s.setAttribute(e, l), !i && a && h && this.translate(((o || 0) - a * d) / 2, ((n || 0) - h * d) / 2);\n                        };\n                    }), C(e) && s.attr({\n                        x: e,\n                        y: i\n                    }), s.isImg = !0, C(s.imgwidth) && C(s.imgheight) ? l(s) : (s.attr({\n                        width: 0,\n                        height: 0\n                    }), k(\"img\", {\n                        onload: function() {\n                            let t = d[c.chartIndex];\n                            0 === this.width && (M(this, {\n                                position: \"absolute\",\n                                top: \"-999em\"\n                            }), p.body.appendChild(this)), y[h] = {\n                                width: this.width,\n                                height: this.height\n                            }, s.imgwidth = this.width, s.imgheight = this.height, s.element && l(s), this.parentNode && this.parentNode.removeChild(this), c.imgCount--, c.imgCount || !t || t.hasLoaded || t.onload();\n                        },\n                        src: h\n                    }), this.imgCount++);\n                }\n                return n;\n            }\n            clipRect(t, e, i, s) {\n                return this.rect(t, e, i, s, 0);\n            }\n            text(t, e, i, s) {\n                let o = {};\n                if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);\n                o.x = Math.round(e || 0), i && (o.y = Math.round(i)), C(t) && (o.text = t);\n                let r = this.createElement(\"text\").attr(o);\n                return s && (!this.forExport || this.allowHTML) || (r.xSetter = function(t, e, i) {\n                    let s = i.getElementsByTagName(\"tspan\"), o = i.getAttribute(e);\n                    for(let i = 0, r; i < s.length; i++)(r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);\n                    i.setAttribute(e, t);\n                }), r;\n            }\n            fontMetrics(t) {\n                let e = j(o.prototype.getStyle.call(t, \"font-size\") || 0), i = e < 24 ? e + 3 : Math.round(1.2 * e), s = Math.round(.8 * i);\n                return {\n                    h: i,\n                    b: s,\n                    f: e\n                };\n            }\n            rotCorr(t, e, i) {\n                let s = t;\n                return e && i && (s = Math.max(s * Math.cos(e * c), 4)), {\n                    x: -t / 3 * Math.sin(e * c),\n                    y: s\n                };\n            }\n            pathToSegments(t) {\n                let e = [], i = [], s = {\n                    A: 8,\n                    C: 7,\n                    H: 2,\n                    L: 3,\n                    M: 3,\n                    Q: 5,\n                    S: 5,\n                    T: 3,\n                    V: 2\n                };\n                for(let o = 0; o < t.length; o++)O(i[0]) && P(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);\n                return e.push(i.slice(0)), e;\n            }\n            label(t, e, i, s, o, n, a, h, l) {\n                return new r(this, t, e, i, s, o, n, a, h, l);\n            }\n            alignElements() {\n                this.alignedObjects.forEach((t)=>t.align());\n            }\n            constructor(t, e, i, s, o, r, n){\n                let a, h;\n                let l = this.createElement(\"svg\").attr({\n                    version: \"1.1\",\n                    class: \"highcharts-root\"\n                }), d = l.element;\n                n || l.css(this.getStyle(s || {})), t.appendChild(d), S(t, \"dir\", \"ltr\"), -1 === t.innerHTML.indexOf(\"xmlns\") && S(d, \"xmlns\", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL();\n                let c = this.createElement(\"desc\").add();\n                c.element.appendChild(p.createTextNode(\"Created with Highcharts 11.3.0\")), this.defs = this.createElement(\"defs\").add(), this.allowHTML = r, this.forExport = o, this.styledMode = n, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle(\"font-size\"), this.setSize(e, i, !1), u && t.getBoundingClientRect && ((a = function() {\n                    M(t, {\n                        left: 0,\n                        top: 0\n                    }), h = t.getBoundingClientRect(), M(t, {\n                        left: Math.ceil(h.left) - h.left + \"px\",\n                        top: Math.ceil(h.top) - h.top + \"px\"\n                    });\n                })(), this.unSubPixelFix = v(b, \"resize\", a));\n            }\n        }\n        return T(B.prototype, {\n            Element: o,\n            SVG_NS: x,\n            escapes: {\n                \"&\": \"&amp;\",\n                \"<\": \"&lt;\",\n                \">\": \"&gt;\",\n                \"'\": \"&#39;\",\n                '\"': \"&quot;\"\n            },\n            symbols: n,\n            draw: m\n        }), s.registerRendererType(\"svg\", B, !0), B;\n    }), i(e, \"Core/Renderer/HTML/HTMLElement.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/SVG/SVGElement.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { composed: s } = t, { css: o, defined: r, extend: n, pushUnique: a, pInt: h } = i;\n        class l extends e {\n            static compose(t) {\n                if (a(s, this.compose)) {\n                    let e = l.prototype, i = t.prototype;\n                    i.getSpanCorrection = e.getSpanCorrection, i.htmlCss = e.htmlCss, i.htmlGetBBox = e.htmlGetBBox, i.htmlUpdateTransform = e.htmlUpdateTransform, i.setSpanRotation = e.setSpanRotation;\n                }\n                return t;\n            }\n            getSpanCorrection(t, e, i) {\n                this.xCorr = -t * i, this.yCorr = -e;\n            }\n            htmlCss(t) {\n                let e;\n                let { element: i } = this, s = \"SPAN\" === i.tagName && t && \"width\" in t, r = s && t.width;\n                return s && (delete t.width, this.textWidth = h(r) || void 0, e = !0), (t === null || t === void 0 ? void 0 : t.textOverflow) === \"ellipsis\" && (t.whiteSpace = \"nowrap\", t.overflow = \"hidden\"), n(this.styles, t), o(i, t), e && this.htmlUpdateTransform(), this;\n            }\n            htmlGetBBox() {\n                let { element: t } = this;\n                return {\n                    x: t.offsetLeft,\n                    y: t.offsetTop,\n                    width: t.offsetWidth,\n                    height: t.offsetHeight\n                };\n            }\n            htmlUpdateTransform() {\n                if (!this.added) {\n                    this.alignOnAdd = !0;\n                    return;\n                }\n                let { element: t, renderer: e, rotation: i, styles: s, textAlign: n = \"left\", textWidth: a, translateX: h = 0, translateY: l = 0, x: d = 0, y: c = 0 } = this, p = {\n                    left: 0,\n                    center: .5,\n                    right: 1\n                }[n], u = s === null || s === void 0 ? void 0 : s.whiteSpace;\n                if (o(t, {\n                    marginLeft: \"\".concat(h, \"px\"),\n                    marginTop: \"\".concat(l, \"px\")\n                }), \"SPAN\" === t.tagName) {\n                    let s = [\n                        i,\n                        n,\n                        t.innerHTML,\n                        a,\n                        this.textAlign\n                    ].join(\",\"), h, l = !1;\n                    if (a !== this.oldTextWidth) {\n                        let e = this.textPxLength ? this.textPxLength : (o(t, {\n                            width: \"\",\n                            whiteSpace: u || \"nowrap\"\n                        }), t.offsetWidth), s = a || 0;\n                        (s > this.oldTextWidth || e > s) && (/[ \\-]/.test(t.textContent || t.innerText) || \"ellipsis\" === t.style.textOverflow) && (o(t, {\n                            width: e > s || i ? a + \"px\" : \"auto\",\n                            display: \"block\",\n                            whiteSpace: u || \"normal\"\n                        }), this.oldTextWidth = a, l = !0);\n                    }\n                    this.hasBoxWidthChanged = l, s !== this.cTT && (h = e.fontMetrics(t).b, r(i) && (i !== (this.oldRotation || 0) || n !== this.oldAlign) && this.setSpanRotation(i, p, h), this.getSpanCorrection(!r(i) && this.textPxLength || t.offsetWidth, h, p)), o(t, {\n                        left: d + (this.xCorr || 0) + \"px\",\n                        top: c + (this.yCorr || 0) + \"px\"\n                    }), this.cTT = s, this.oldRotation = i, this.oldAlign = n;\n                }\n            }\n            setSpanRotation(t, e, i) {\n                o(this.element, {\n                    transform: \"rotate(\".concat(t, \"deg)\"),\n                    transformOrigin: \"\".concat(100 * e, \"% \").concat(i, \"px\")\n                });\n            }\n        }\n        return l;\n    }), i(e, \"Core/Renderer/HTML/HTMLRenderer.js\", [\n        e[\"Core/Renderer/HTML/AST.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/SVG/SVGElement.js\"],\n        e[\"Core/Renderer/SVG/SVGRenderer.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o) {\n        let { composed: r } = e, { attr: n, createElement: a, extend: h, pick: l, pushUnique: d } = o;\n        class c extends s {\n            static compose(t) {\n                if (d(r, this.compose)) {\n                    let e = c.prototype, i = t.prototype;\n                    i.html = e.html;\n                }\n                return t;\n            }\n            html(e, s, o) {\n                let r = this.createElement(\"span\"), d = r.element, c = r.renderer, p = function(t, e) {\n                    [\n                        \"opacity\",\n                        \"visibility\"\n                    ].forEach(function(s) {\n                        t[s + \"Setter\"] = function(o, r, n) {\n                            let a = t.div ? t.div.style : e;\n                            i.prototype[s + \"Setter\"].call(this, o, r, n), a && (a[r] = o);\n                        };\n                    }), t.addedSetters = !0;\n                };\n                return r.textSetter = function(e) {\n                    e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, t.setElementHTML(this.element, l(e, \"\")), this.textStr = e, r.doTransform = !0);\n                }, p(r, r.element.style), r.xSetter = r.ySetter = r.alignSetter = r.rotationSetter = function(t, e) {\n                    \"align\" === e ? r.alignValue = r.textAlign = t : r[e] = t, r.doTransform = !0;\n                }, r.afterSetters = function() {\n                    this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n                }, r.attr({\n                    text: e,\n                    x: Math.round(s),\n                    y: Math.round(o)\n                }).css({\n                    position: \"absolute\"\n                }), c.styledMode || r.css({\n                    fontFamily: this.style.fontFamily,\n                    fontSize: this.style.fontSize\n                }), d.style.whiteSpace = \"nowrap\", r.css = r.htmlCss, r.add = function(t) {\n                    let e, i;\n                    let s = c.box.parentNode, o = [];\n                    if (this.parentGroup = t, t) {\n                        if (!(e = t.div)) {\n                            for(i = t; i;)o.push(i), i = i.parentGroup;\n                            o.reverse().forEach(function(t) {\n                                var i;\n                                let l = n(t.element, \"class\"), d = t.css;\n                                function c(e, i) {\n                                    t[i] = e, \"translateX\" === i ? g.left = e + \"px\" : g.top = e + \"px\", t.doTransform = !0;\n                                }\n                                let u = t.styles || {};\n                                e = t.div = t.div || a(\"div\", l ? {\n                                    className: l\n                                } : void 0, {\n                                    position: \"absolute\",\n                                    left: (t.translateX || 0) + \"px\",\n                                    top: (t.translateY || 0) + \"px\",\n                                    display: t.display,\n                                    opacity: t.opacity,\n                                    visibility: t.visibility\n                                }, e || s);\n                                let g = e.style;\n                                h(t, {\n                                    classSetter: (i = e, function(t) {\n                                        this.element.setAttribute(\"class\", t), i.className = t;\n                                    }),\n                                    css: function(e) {\n                                        return d.call(t, e), [\n                                            \"cursor\",\n                                            \"pointerEvents\"\n                                        ].forEach((t)=>{\n                                            e[t] && (g[t] = e[t]);\n                                        }), t;\n                                    },\n                                    on: function() {\n                                        return o[0].div && r.on.apply({\n                                            element: o[0].div,\n                                            onEvents: t.onEvents\n                                        }, arguments), t;\n                                    },\n                                    translateXSetter: c,\n                                    translateYSetter: c\n                                }), t.addedSetters || p(t), t.css(u);\n                            });\n                        }\n                    } else e = s;\n                    return e.appendChild(d), r.added = !0, r.alignOnAdd && r.htmlUpdateTransform(), r;\n                }, r;\n            }\n        }\n        return c;\n    }), i(e, \"Core/Axis/AxisDefaults.js\", [], function() {\n        var t, e;\n        return (e = t || (t = {})).xAxis = {\n            alignTicks: !0,\n            allowDecimals: void 0,\n            panningEnabled: !0,\n            zIndex: 2,\n            zoomEnabled: !0,\n            dateTimeLabelFormats: {\n                millisecond: {\n                    main: \"%H:%M:%S.%L\",\n                    range: !1\n                },\n                second: {\n                    main: \"%H:%M:%S\",\n                    range: !1\n                },\n                minute: {\n                    main: \"%H:%M\",\n                    range: !1\n                },\n                hour: {\n                    main: \"%H:%M\",\n                    range: !1\n                },\n                day: {\n                    main: \"%e %b\"\n                },\n                week: {\n                    main: \"%e %b\"\n                },\n                month: {\n                    main: \"%b '%y\"\n                },\n                year: {\n                    main: \"%Y\"\n                }\n            },\n            endOnTick: !1,\n            gridLineDashStyle: \"Solid\",\n            gridZIndex: 1,\n            labels: {\n                autoRotationLimit: 80,\n                distance: 15,\n                enabled: !0,\n                indentation: 10,\n                overflow: \"justify\",\n                padding: 5,\n                reserveSpace: void 0,\n                rotation: void 0,\n                staggerLines: 0,\n                step: 0,\n                useHTML: !1,\n                zIndex: 7,\n                style: {\n                    color: \"#333333\",\n                    cursor: \"default\",\n                    fontSize: \"0.8em\"\n                }\n            },\n            maxPadding: .01,\n            minorGridLineDashStyle: \"Solid\",\n            minorTickLength: 2,\n            minorTickPosition: \"outside\",\n            minorTicksPerMajor: 5,\n            minPadding: .01,\n            offset: void 0,\n            reversed: void 0,\n            reversedStacks: !1,\n            showEmpty: !0,\n            showFirstLabel: !0,\n            showLastLabel: !0,\n            startOfWeek: 1,\n            startOnTick: !1,\n            tickLength: 10,\n            tickPixelInterval: 100,\n            tickmarkPlacement: \"between\",\n            tickPosition: \"outside\",\n            title: {\n                align: \"middle\",\n                useHTML: !1,\n                x: 0,\n                y: 0,\n                style: {\n                    color: \"#666666\",\n                    fontSize: \"0.8em\"\n                }\n            },\n            type: \"linear\",\n            uniqueNames: !0,\n            visible: !0,\n            minorGridLineColor: \"#f2f2f2\",\n            minorGridLineWidth: 1,\n            minorTickColor: \"#999999\",\n            lineColor: \"#333333\",\n            lineWidth: 1,\n            gridLineColor: \"#e6e6e6\",\n            gridLineWidth: void 0,\n            tickColor: \"#333333\"\n        }, e.yAxis = {\n            reversedStacks: !0,\n            endOnTick: !0,\n            maxPadding: .05,\n            minPadding: .05,\n            tickPixelInterval: 72,\n            showLastLabel: !0,\n            labels: {\n                x: void 0\n            },\n            startOnTick: !0,\n            title: {\n                text: \"Values\"\n            },\n            stackLabels: {\n                animation: {},\n                allowOverlap: !1,\n                enabled: !1,\n                crop: !0,\n                overflow: \"justify\",\n                formatter: function() {\n                    let { numberFormatter: t } = this.axis.chart;\n                    return t(this.total || 0, -1);\n                },\n                style: {\n                    color: \"#000000\",\n                    fontSize: \"0.7em\",\n                    fontWeight: \"bold\",\n                    textOutline: \"1px contrast\"\n                }\n            },\n            gridLineWidth: 1,\n            lineWidth: 0\n        }, t;\n    }), i(e, \"Core/Foundation.js\", [\n        e[\"Core/Utilities.js\"]\n    ], function(t) {\n        var e;\n        let { addEvent: i, isFunction: s, objectEach: o, removeEvent: r } = t;\n        return (e || (e = {})).registerEventOptions = function(t, e) {\n            t.eventOptions = t.eventOptions || {}, o(e.events, function(e, o) {\n                t.eventOptions[o] !== e && (t.eventOptions[o] && (r(t, o, t.eventOptions[o]), delete t.eventOptions[o]), s(e) && (t.eventOptions[o] = e, i(t, o, e, {\n                    order: 0\n                })));\n            });\n        }, e;\n    }), i(e, \"Core/Axis/Tick.js\", [\n        e[\"Core/Templating.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { deg2rad: s } = e, { clamp: o, correctFloat: r, defined: n, destroyObjectProperties: a, extend: h, fireEvent: l, isNumber: d, merge: c, objectEach: p, pick: u } = i;\n        return class {\n            addLabel() {\n                let e = this, i = e.axis, s = i.options, o = i.chart, a = i.categories, c = i.logarithmic, p = i.names, g = e.pos, f = u(e.options && e.options.labels, s.labels), m = i.tickPositions, x = g === m[0], y = g === m[m.length - 1], b = (!f.step || 1 === f.step) && 1 === i.tickInterval, v = m.info, S = e.label, k, M, C, w = this.parameters.category || (a ? u(a[g], p[g], g) : g);\n                c && d(w) && (w = r(c.lin2log(w))), i.dateTime && (v ? k = (M = o.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid && v.higherRanks[g] || v.unitName])).main : d(w) && (k = i.dateTime.getXDateFormat(w, s.dateTimeLabelFormats || {}))), e.isFirst = x, e.isLast = y;\n                let T = {\n                    axis: i,\n                    chart: o,\n                    dateTimeLabelFormat: k,\n                    isFirst: x,\n                    isLast: y,\n                    pos: g,\n                    tick: e,\n                    tickPositionInfo: v,\n                    value: w\n                };\n                l(this, \"labelFormat\", T);\n                let A = (e)=>f.formatter ? f.formatter.call(e, e) : f.format ? (e.text = i.defaultLabelFormatter.call(e, e), t.format(f.format, e, o)) : i.defaultLabelFormatter.call(e, e), P = A.call(T, T), L = M && M.list;\n                L ? e.shortenLabel = function() {\n                    for(C = 0; C < L.length; C++)if (h(T, {\n                        dateTimeLabelFormat: L[C]\n                    }), S.attr({\n                        text: A.call(T, T)\n                    }), S.getBBox().width < i.getSlotWidth(e) - 2 * f.padding) return;\n                    S.attr({\n                        text: \"\"\n                    });\n                } : e.shortenLabel = void 0, b && i._addedPlotLB && e.moveLabel(P, f), n(S) || e.movedLabel ? S && S.textStr !== P && !b && (!S.textWidth || f.style.width || S.styles.width || S.css({\n                    width: null\n                }), S.attr({\n                    text: P\n                }), S.textPxLength = S.getBBox().width) : (e.label = S = e.createLabel(P, f), e.rotation = 0);\n            }\n            createLabel(t, e, i) {\n                let s = this.axis, o = s.chart, r = n(t) && e.enabled ? o.renderer.text(t, i === null || i === void 0 ? void 0 : i.x, i === null || i === void 0 ? void 0 : i.y, e.useHTML).add(s.labelGroup) : void 0;\n                return r && (o.styledMode || r.css(c(e.style)), r.textPxLength = r.getBBox().width), r;\n            }\n            destroy() {\n                a(this, this.axis);\n            }\n            getPosition(t, e, i, s) {\n                let n = this.axis, a = n.chart, h = s && a.oldChartHeight || a.chartHeight, d = {\n                    x: t ? r(n.translate(e + i, void 0, void 0, s) + n.transB) : n.left + n.offset + (n.opposite ? (s && a.oldChartWidth || a.chartWidth) - n.right - n.left : 0),\n                    y: t ? h - n.bottom + n.offset - (n.opposite ? n.height : 0) : r(h - n.translate(e + i, void 0, void 0, s) - n.transB)\n                };\n                return d.y = o(d.y, -1e5, 1e5), l(this, \"afterGetPosition\", {\n                    pos: d\n                }), d;\n            }\n            getLabelPosition(t, e, i, o, r, a, h, d) {\n                let c, p;\n                let g = this.axis, f = g.transA, m = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed, x = g.staggerLines, y = g.tickRotCorr || {\n                    x: 0,\n                    y: 0\n                }, b = o || g.reserveSpaceDefault ? 0 : -g.labelOffset * (\"center\" === g.labelAlign ? .5 : 1), v = r.distance, S = {};\n                return c = 0 === g.side ? i.rotation ? -v : -i.getBBox().height : 2 === g.side ? y.y + v : Math.cos(i.rotation * s) * (y.y - i.getBBox(!1, 0).height / 2), n(r.y) && (c = 0 === g.side && g.horiz ? r.y + c : r.y), t = t + u(r.x, [\n                    0,\n                    1,\n                    0,\n                    -1\n                ][g.side] * v) + b + y.x - (a && o ? a * f * (m ? -1 : 1) : 0), e = e + c - (a && !o ? a * f * (m ? 1 : -1) : 0), x && (p = h / (d || 1) % x, g.opposite && (p = x - p - 1), e += p * (g.labelOffset / x)), S.x = t, S.y = Math.round(e), l(this, \"afterGetLabelPosition\", {\n                    pos: S,\n                    tickmarkOffset: a,\n                    index: h\n                }), S;\n            }\n            getLabelSize() {\n                return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n            }\n            getMarkPath(t, e, i, s, o, r) {\n                return r.crispLine([\n                    [\n                        \"M\",\n                        t,\n                        e\n                    ],\n                    [\n                        \"L\",\n                        t + (o ? 0 : -i),\n                        e + (o ? i : 0)\n                    ]\n                ], s);\n            }\n            handleOverflow(t) {\n                let e = this.axis, i = e.options.labels, o = t.x, r = e.chart.chartWidth, n = e.chart.spacing, a = u(e.labelLeft, Math.min(e.pos, n[3])), h = u(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - n[1])), l = this.label, d = this.rotation, c = {\n                    left: 0,\n                    center: .5,\n                    right: 1\n                }[e.labelAlign || l.attr(\"align\")], p = l.getBBox().width, g = e.getSlotWidth(this), f = {}, m = g, x = 1, y;\n                d || \"justify\" !== i.overflow ? d < 0 && o - c * p < a ? y = Math.round(o / Math.cos(d * s) - a) : d > 0 && o + c * p > h && (y = Math.round((r - o) / Math.cos(d * s))) : (o - c * p < a ? m = t.x + m * (1 - c) - a : o + (1 - c) * p > h && (m = h - t.x + m * c, x = -1), (m = Math.min(g, m)) < g && \"center\" === e.labelAlign && (t.x += x * (g - m - c * (g - Math.min(p, m)))), (p > m || e.autoRotation && (l.styles || {}).width) && (y = m)), y && (this.shortenLabel ? this.shortenLabel() : (f.width = Math.floor(y) + \"px\", (i.style || {}).textOverflow || (f.textOverflow = \"ellipsis\"), l.css(f)));\n            }\n            moveLabel(t, e) {\n                let i = this, s = i.label, o = i.axis, r = !1, n;\n                s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : p(o.ticks, function(e) {\n                    r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);\n                }), !r && (i.labelPos || s) && (n = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, n), i.movedLabel && i.movedLabel.attr({\n                    opacity: 0\n                }));\n            }\n            render(t, e, i) {\n                let s = this.axis, o = s.horiz, r = this.pos, n = u(this.tickmarkOffset, s.tickmarkOffset), a = this.getPosition(o, r, n, e), h = a.x, d = a.y, c = o && h === s.pos + s.len || !o && d === s.pos ? -1 : 1, p = u(i, this.label && this.label.newOpacity, 1);\n                i = u(i, 1), this.isActive = !0, this.renderGridLine(e, i, c), this.renderMark(a, i, c), this.renderLabel(a, e, p, t), this.isNew = !1, l(this, \"afterRender\");\n            }\n            renderGridLine(t, e, i) {\n                let s = this.axis, o = s.options, r = {}, n = this.pos, a = this.type, h = u(this.tickmarkOffset, s.tickmarkOffset), l = s.chart.renderer, d = this.gridLine, c, p = o.gridLineWidth, g = o.gridLineColor, f = o.gridLineDashStyle;\n                \"minor\" === this.type && (p = o.minorGridLineWidth, g = o.minorGridLineColor, f = o.minorGridLineDashStyle), d || (s.chart.styledMode || (r.stroke = g, r[\"stroke-width\"] = p || 0, r.dashstyle = f), a || (r.zIndex = 1), t && (e = 0), this.gridLine = d = l.path().attr(r).addClass(\"highcharts-\" + (a ? a + \"-\" : \"\") + \"grid-line\").add(s.gridGroup)), d && (c = s.getPlotLinePath({\n                    value: n + h,\n                    lineWidth: d.strokeWidth() * i,\n                    force: \"pass\",\n                    old: t,\n                    acrossPanes: !1\n                })) && d[t || this.isNew ? \"attr\" : \"animate\"]({\n                    d: c,\n                    opacity: e\n                });\n            }\n            renderMark(t, e, i) {\n                let s = this.axis, o = s.options, r = s.chart.renderer, n = this.type, a = s.tickSize(n ? n + \"Tick\" : \"tick\"), h = t.x, l = t.y, d = u(o[\"minor\" !== n ? \"tickWidth\" : \"minorTickWidth\"], !n && s.isXAxis ? 1 : 0), c = o[\"minor\" !== n ? \"tickColor\" : \"minorTickColor\"], p = this.mark, g = !p;\n                a && (s.opposite && (a[0] = -a[0]), p || (this.mark = p = r.path().addClass(\"highcharts-\" + (n ? n + \"-\" : \"\") + \"tick\").add(s.axisGroup), s.chart.styledMode || p.attr({\n                    stroke: c,\n                    \"stroke-width\": d\n                })), p[g ? \"attr\" : \"animate\"]({\n                    d: this.getMarkPath(h, l, a[0], p.strokeWidth() * i, s.horiz, r),\n                    opacity: e\n                }));\n            }\n            renderLabel(t, e, i, s) {\n                let o = this.axis, r = o.horiz, n = o.options, a = this.label, h = n.labels, l = h.step, c = u(this.tickmarkOffset, o.tickmarkOffset), p = t.x, g = t.y, f = !0;\n                a && d(p) && (a.xy = t = this.getLabelPosition(p, g, a, r, h, c, s, l), (!this.isFirst || this.isLast || n.showFirstLabel) && (!this.isLast || this.isFirst || n.showLastLabel) ? !r || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : f = !1, l && s % l && (f = !1), f && d(t.y) ? (t.opacity = i, a[this.isNewLabel ? \"attr\" : \"animate\"](t).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0));\n            }\n            replaceMovedLabel() {\n                let t = this.label, e = this.axis;\n                t && !this.isNew && (t.animate({\n                    opacity: 0\n                }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;\n            }\n            constructor(t, e, i, s, o){\n                this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || \"\", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, l(this, \"init\"), i || s || this.addLabel();\n            }\n        };\n    }), i(e, \"Core/Axis/Axis.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Axis/AxisDefaults.js\"],\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Foundation.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Axis/Tick.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r, n, a) {\n        let { animObject: h } = t, { xAxis: l, yAxis: d } = e, { defaultOptions: c } = s, { registerEventOptions: p } = o, { deg2rad: u } = r, { arrayMax: g, arrayMin: f, clamp: m, correctFloat: x, defined: y, destroyObjectProperties: b, erase: v, error: S, extend: k, fireEvent: M, getClosestDistance: C, insertItem: w, isArray: T, isNumber: A, isString: P, merge: L, normalizeTickInterval: O, objectEach: D, pick: E, relativeLength: j, removeEvent: I, splat: B, syncTimeout: R } = a, z = (t, e)=>O(e, void 0, void 0, E(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);\n        k(c, {\n            xAxis: l,\n            yAxis: L(l, d)\n        });\n        class N {\n            init(t, e) {\n                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.coll;\n                let s = \"xAxis\" === i, o = this.isZAxis || (t.inverted ? !s : s);\n                this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, M(this, \"init\", {\n                    userOptions: e\n                }), this.opposite = E(e.opposite, this.opposite), this.side = E(e.side, this.side, o ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(e);\n                let r = this.options, n = r.labels, a = r.type;\n                this.userOptions = e, this.minPixelPadding = 0, this.reversed = E(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = \"category\" === a || !0 === r.categories, this.categories = T(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = y(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0;\n                let h = E(r.crosshair, B(t.options.tooltip.crosshairs)[s ? 0 : 1]);\n                this.crosshair = !0 === h ? {} : h, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), w(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !y(this.reversed) && (this.reversed = !0), this.labelRotation = A(n.rotation) ? n.rotation : void 0, p(this, r), M(this, \"afterInit\");\n            }\n            setOptions(t) {\n                let e = this.horiz ? {\n                    labels: {\n                        autoRotation: [\n                            -45\n                        ]\n                    },\n                    margin: 15\n                } : {\n                    title: {\n                        rotation: 90 * this.side\n                    }\n                };\n                this.options = L(e, c[this.coll], t), M(this, \"afterSetOptions\", {\n                    userOptions: t\n                });\n            }\n            defaultLabelFormatter(t) {\n                let e = this.axis, i = this.chart, { numberFormatter: s } = i, o = A(this.value) ? this.value : NaN, r = e.chart.time, n = e.categories, a = this.dateTimeLabelFormat, h = c.lang, l = h.numericSymbols, d = h.numericSymbolMagnitude || 1e3, p = e.logarithmic ? Math.abs(o) : e.tickInterval, u = l && l.length, g, f;\n                if (n) f = \"\".concat(this.value);\n                else if (a) f = r.dateFormat(a, o);\n                else if (u && l && p >= 1e3) for(; u-- && void 0 === f;)p >= (g = Math.pow(d, u + 1)) && 10 * o % g == 0 && null !== l[u] && 0 !== o && (f = s(o / g, -1) + l[u]);\n                return void 0 === f && (f = Math.abs(o) >= 1e4 ? s(o, -1) : s(o, -1, void 0, \"\")), f;\n            }\n            getSeriesExtremes() {\n                let t;\n                let e = this;\n                M(this, \"getSeriesExtremes\", null, function() {\n                    e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach((i)=>{\n                        if (i.reserveSpace()) {\n                            let s = i.options, o, r = s.threshold, n, a;\n                            if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.xData) && o.length && (o = e.logarithmic ? o.filter((t)=>t > 0) : o, n = (t = i.getXExtremes(o)).min, a = t.max, A(n) || n instanceof Date || (o = o.filter(A), n = (t = i.getXExtremes(o)).min, a = t.max), o.length && (e.dataMin = Math.min(E(e.dataMin, n), n), e.dataMax = Math.max(E(e.dataMax, a), a)));\n                            else {\n                                let t = i.applyExtremes();\n                                A(t.dataMin) && (n = t.dataMin, e.dataMin = Math.min(E(e.dataMin, n), n)), A(t.dataMax) && (a = t.dataMax, e.dataMax = Math.max(E(e.dataMax, a), a)), y(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);\n                            }\n                        }\n                    });\n                }), M(this, \"afterGetSeriesExtremes\");\n            }\n            translate(t, e, i, s, o, r) {\n                var _n_brokenAxis;\n                let n = this.linkedParent || this, a = s && n.old ? n.old.min : n.min;\n                if (!A(a)) return NaN;\n                let h = n.minPixelPadding, l = (n.isOrdinal || ((_n_brokenAxis = n.brokenAxis) === null || _n_brokenAxis === void 0 ? void 0 : _n_brokenAxis.hasBreaks) || n.logarithmic && o) && n.lin2val, d = 1, c = 0, p = s && n.old ? n.old.transA : n.transA, u = 0;\n                if (p || (p = n.transA), i && (d *= -1, c = n.len), n.reversed && (d *= -1, c -= d * (n.sector || n.len)), e) u = (t = t * d + c - h) / p + a, l && (u = n.lin2val(u));\n                else {\n                    l && (t = n.val2lin(t));\n                    let e = d * (t - a) * p;\n                    u = (n.isRadial ? e : x(e)) + c + d * h + (A(r) ? p * r : 0);\n                }\n                return u;\n            }\n            toPixels(t, e) {\n                return this.translate(t, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);\n            }\n            toValue(t, e) {\n                return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n            }\n            getPlotLinePath(t) {\n                let e = this, i = e.chart, s = e.left, o = e.top, r = t.old, n = t.value, a = t.lineWidth, h = r && i.oldChartHeight || i.chartHeight, l = r && i.oldChartWidth || i.chartWidth, d = e.transB, c = t.translatedValue, p = t.force, u, g, f, x, y;\n                function b(t, e, i) {\n                    return \"pass\" !== p && (t < e || t > i) && (p ? t = m(t, e, i) : y = !0), t;\n                }\n                let v = {\n                    value: n,\n                    lineWidth: a,\n                    old: r,\n                    force: p,\n                    acrossPanes: t.acrossPanes,\n                    translatedValue: c\n                };\n                return M(this, \"getPlotLinePath\", v, function(t) {\n                    u = f = Math.round((c = m(c = E(c, e.translate(n, void 0, void 0, r)), -1e5, 1e5)) + d), g = x = Math.round(h - c - d), A(c) ? e.horiz ? (g = o, x = h - e.bottom, u = f = b(u, s, s + e.width)) : (u = s, f = l - e.right, g = x = b(g, o, o + e.height)) : (y = !0, p = !1), t.path = y && !p ? void 0 : i.renderer.crispLine([\n                        [\n                            \"M\",\n                            u,\n                            g\n                        ],\n                        [\n                            \"L\",\n                            f,\n                            x\n                        ]\n                    ], a || 1);\n                }), v.path;\n            }\n            getLinearTickPositions(t, e, i) {\n                let s, o, r;\n                let n = x(Math.floor(e / t) * t), a = x(Math.ceil(i / t) * t), h = [];\n                if (x(n + t) === n && (r = 20), this.single) return [\n                    e\n                ];\n                for(s = n; s <= a && (h.push(s), (s = x(s + t, r)) !== o);)o = s;\n                return h;\n            }\n            getMinorTickInterval() {\n                let { minorTicks: t, minorTickInterval: e } = this.options;\n                return !0 === t ? E(e, \"auto\") : !1 !== t ? e : void 0;\n            }\n            getMinorTickPositions() {\n                let t = this.options, e = this.tickPositions, i = this.minorTickInterval, s = this.pointRangePadding || 0, o = (this.min || 0) - s, r = (this.max || 0) + s, n = r - o, a = [], h;\n                if (n && n / i < this.len / 3) {\n                    let s = this.logarithmic;\n                    if (s) this.paddedTicks.forEach(function(t, e, o) {\n                        e && a.push.apply(a, s.getLogTickPositions(i, o[e - 1], o[e], !0));\n                    });\n                    else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) a = a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));\n                    else for(h = o + (e[0] - o) % i; h <= r && h !== a[0]; h += i)a.push(h);\n                }\n                return 0 !== a.length && this.trimTicks(a), a;\n            }\n            adjustForMinRange() {\n                let t = this.options, e = this.logarithmic, { max: i, min: s, minRange: o } = this, r, n, a, h;\n                this.isXAxis && void 0 === o && !e && (o = y(t.min) || y(t.max) || y(t.floor) || y(t.ceiling) ? null : Math.min(5 * (C(this.series.map((t)=>{\n                    var _t_xData;\n                    return (t.xIncrement ? (_t_xData = t.xData) === null || _t_xData === void 0 ? void 0 : _t_xData.slice(0, 2) : t.xData) || [];\n                })) || 0), this.dataMax - this.dataMin)), A(i) && A(s) && A(o) && i - s < o && (n = this.dataMax - this.dataMin >= o, r = (o - i + s) / 2, a = [\n                    s - r,\n                    E(t.min, s - r)\n                ], n && (a[2] = e ? e.log2lin(this.dataMin) : this.dataMin), h = [\n                    (s = g(a)) + o,\n                    E(t.max, s + o)\n                ], n && (h[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (i = f(h)) - s < o && (a[0] = i - o, a[1] = E(t.min, i - o), s = g(a))), this.minRange = o, this.min = s, this.max = i;\n            }\n            getClosest() {\n                let t, e;\n                if (this.categories) e = 1;\n                else {\n                    let i = [];\n                    this.series.forEach(function(t) {\n                        var _t_xData;\n                        let s = t.closestPointRange;\n                        ((_t_xData = t.xData) === null || _t_xData === void 0 ? void 0 : _t_xData.length) === 1 ? i.push(t.xData[0]) : !t.noSharedTooltip && y(s) && t.reserveSpace() && (e = y(e) ? Math.min(e, s) : s);\n                    }), i.length && (i.sort((t, e)=>t - e), t = C([\n                        i\n                    ]));\n                }\n                return t && e ? Math.min(t, e) : t || e;\n            }\n            nameToX(t) {\n                let e = T(this.options.categories), i = e ? this.categories : this.names, s = t.options.x, o;\n                return t.series.requireSorting = !1, y(s) || (s = this.options.uniqueNames && i ? e ? i.indexOf(t.name) : E(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : o = s, void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;\n            }\n            updateNames() {\n                let t = this, e = this.names, i = e.length;\n                i > 0 && (Object.keys(e.keys).forEach(function(t) {\n                    delete e.keys[t];\n                }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e)=>{\n                    e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max, e.xData.length - 1), e.processData(), e.generatePoints()), e.data.forEach(function(i, s) {\n                        let o;\n                        (i === null || i === void 0 ? void 0 : i.options) && void 0 !== i.name && void 0 !== (o = t.nameToX(i)) && o !== i.x && (i.x = o, e.xData[s] = o);\n                    });\n                }));\n            }\n            setAxisTranslation() {\n                let t = this, e = t.max - t.min, i = t.linkedParent, s = !!t.categories, o = t.isXAxis, r = t.axisPointRange || 0, n, a = 0, h = 0, l, d = t.transA;\n                (o || s || r) && (n = t.getClosest(), i ? (a = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function(e) {\n                    let i = s ? 1 : o ? E(e.options.pointRange, n, 0) : t.axisPointRange || 0, l = e.options.pointPlacement;\n                    if (r = Math.max(r, i), !t.single || s) {\n                        let t = e.is(\"xrange\") ? !o : o;\n                        a = Math.max(a, t && P(l) ? 0 : i / 2), h = Math.max(h, t && \"on\" === l ? 0 : i);\n                    }\n                }), l = t.ordinal && t.ordinal.slope && n ? t.ordinal.slope / n : 1, t.minPointOffset = a *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && n && (t.closestPointRange = n)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * a, M(this, \"afterSetAxisTranslation\");\n            }\n            minFromRange() {\n                let { max: t, min: e } = this;\n                return A(t) && A(e) && t - e || void 0;\n            }\n            setTickInterval(t) {\n                var _i_this_coll;\n                let { categories: e, chart: i, dataMax: s, dataMin: o, dateTime: r, isXAxis: n, logarithmic: a, options: h, softThreshold: l } = this, d = A(this.threshold) ? this.threshold : void 0, c = this.minRange || 0, { ceiling: p, floor: u, linkedTo: g, softMax: f, softMin: m } = h, b = A(g) && ((_i_this_coll = i[this.coll]) === null || _i_this_coll === void 0 ? void 0 : _i_this_coll[g]), v = h.tickPixelInterval, k = h.maxPadding, C = h.minPadding, w = 0, T, P = A(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0, L, O, D, j;\n                if (r || e || b || this.getTickAmount(), D = E(this.userMin, h.min), j = E(this.userMax, h.max), b ? (this.linkedParent = b, T = b.getExtremes(), this.min = E(T.min, T.dataMin), this.max = E(T.max, T.dataMax), h.type !== b.options.type && S(11, !0, i)) : (l && y(d) && A(s) && A(o) && (o >= d ? (L = d, C = 0) : s <= d && (O = d, k = 0)), this.min = E(D, L, o), this.max = E(j, O, s)), A(this.max) && A(this.min) && (a && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, E(o, this.min)) && S(10, !0, i), this.min = x(a.log2lin(this.min), 16), this.max = x(a.log2lin(this.max), 16)), this.range && A(o) && (this.userMin = this.min = D = Math.max(o, this.minFromRange() || 0), this.userMax = j = this.max, this.range = void 0)), M(this, \"foundExtremes\"), this.adjustForMinRange(), A(this.min) && A(this.max)) {\n                    var _this_stacking;\n                    if (!A(this.userMin) && A(m) && m < this.min && (this.min = D = m), !A(this.userMax) && A(f) && f > this.max && (this.max = j = f), e || this.axisPointRange || ((_this_stacking = this.stacking) === null || _this_stacking === void 0 ? void 0 : _this_stacking.usePercentage) || b || !(w = this.max - this.min) || (!y(D) && C && (this.min -= w * C), y(j) || !k || (this.max += w * k)), !A(this.userMin) && A(u) && (this.min = Math.max(this.min, u)), !A(this.userMax) && A(p) && (this.max = Math.min(this.max, p)), l && A(o) && A(s)) {\n                        let t = d || 0;\n                        !y(D) && this.min < t && o >= t ? this.min = h.minRange ? Math.min(t, this.max - c) : t : !y(j) && this.max > t && s <= t && (this.max = h.minRange ? Math.max(t, this.min + c) : t);\n                    }\n                    !i.polar && this.min > this.max && (y(h.min) ? this.max = this.min : y(h.max) && (this.min = this.max)), w = this.max - this.min;\n                }\n                if (this.min !== this.max && A(this.min) && A(this.max) ? b && !P && v === b.options.tickPixelInterval ? this.tickInterval = P = b.tickInterval : this.tickInterval = E(P, this.tickAmount ? w / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : w * v / Math.max(this.len, v)) : this.tickInterval = 1, n && !t) {\n                    var _this_old, _this_old1;\n                    let t = this.min !== ((_this_old = this.old) === null || _this_old === void 0 ? void 0 : _this_old.min) || this.max !== ((_this_old1 = this.old) === null || _this_old1 === void 0 ? void 0 : _this_old1.max);\n                    this.series.forEach(function(e) {\n                        var _e_forceCropping;\n                        e.forceCrop = (_e_forceCropping = e.forceCropping) === null || _e_forceCropping === void 0 ? void 0 : _e_forceCropping.call(e), e.processData(t);\n                    }), M(this, \"postProcessData\", {\n                        hasExtremesChanged: t\n                    });\n                }\n                this.setAxisTranslation(), M(this, \"initialAxisTranslation\"), this.pointRange && !P && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n                let I = E(h.minTickInterval, r && !this.series.some((t)=>t.noSharedTooltip) ? this.closestPointRange : 0);\n                !P && this.tickInterval < I && (this.tickInterval = I), r || a || P || (this.tickInterval = z(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();\n            }\n            setTickPositions() {\n                let t = this.options, e = t.tickPositions, i = t.tickPositioner, s = this.getMinorTickInterval(), o = this.hasVerticalPanning(), r = \"colorAxis\" === this.coll, n = (r || !o) && t.startOnTick, a = (r || !o) && t.endOnTick, h = [], l;\n                if (this.tickmarkOffset = this.categories && \"between\" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = \"auto\" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.single = this.min === this.max && y(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) h = e.slice();\n                else if (A(this.min) && A(this.max)) {\n                    var _this_ordinal, _this_ordinal1;\n                    if (!((_this_ordinal = this.ordinal) === null || _this_ordinal === void 0 ? void 0 : _this_ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) h = [\n                        this.min,\n                        this.max\n                    ], S(19, !1, this.chart);\n                    else if (this.dateTime) h = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, (_this_ordinal1 = this.ordinal) === null || _this_ordinal1 === void 0 ? void 0 : _this_ordinal1.positions, this.closestPointRange, !0);\n                    else if (this.logarithmic) h = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);\n                    else {\n                        let t = this.tickInterval, e = t;\n                        for(; e <= 2 * t;)if (h = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && h.length > this.tickAmount) this.tickInterval = z(this, e *= 1.1);\n                        else break;\n                    }\n                    h.length > this.len && (h = [\n                        h[0],\n                        h[h.length - 1]\n                    ])[0] === h[1] && (h.length = 1), i && (this.tickPositions = h, (l = i.apply(this, [\n                        this.min,\n                        this.max\n                    ])) && (h = l));\n                }\n                this.tickPositions = h, this.paddedTicks = h.slice(0), this.trimTicks(h, n, a), !this.isLinked && A(this.min) && A(this.max) && (this.single && h.length < 2 && !this.categories && !this.series.some((t)=>t.is(\"heatmap\") && \"between\" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount()), M(this, \"afterSetTickPositions\");\n            }\n            trimTicks(t, e, i) {\n                let s = t[0], o = t[t.length - 1], r = !this.isOrdinal && this.minPointOffset || 0;\n                if (M(this, \"trimTicks\"), !this.isLinked) {\n                    if (e && s !== -1 / 0) this.min = s;\n                    else for(; this.min - r > t[0];)t.shift();\n                    if (i) this.max = o;\n                    else for(; this.max + r < t[t.length - 1];)t.pop();\n                    0 === t.length && y(s) && !this.options.tickPositions && t.push((o + s) / 2);\n                }\n            }\n            alignToOthers() {\n                let t;\n                let e = this, i = [\n                    this\n                ], s = e.options, o = this.chart.options.chart, r = \"yAxis\" === this.coll && o.alignThresholds, n = [];\n                if (e.thresholdAlignment = void 0, (!1 !== o.alignTicks && s.alignTicks || r) && !1 !== s.startOnTick && !1 !== s.endOnTick && !e.logarithmic) {\n                    let s = (t)=>{\n                        let { horiz: e, options: i } = t;\n                        return [\n                            e ? i.left : i.top,\n                            i.width,\n                            i.height,\n                            i.pane\n                        ].join(\",\");\n                    }, o = s(this);\n                    this.chart[this.coll].forEach(function(r) {\n                        let { series: n } = r;\n                        n.length && n.some((t)=>t.visible) && r !== e && s(r) === o && (t = !0, i.push(r));\n                    });\n                }\n                if (t && r) {\n                    i.forEach((t)=>{\n                        let i = t.getThresholdAlignment(e);\n                        A(i) && n.push(i);\n                    });\n                    let t = n.length > 1 ? n.reduce((t, e)=>t += e, 0) / n.length : void 0;\n                    i.forEach((e)=>{\n                        e.thresholdAlignment = t;\n                    });\n                }\n                return t;\n            }\n            getThresholdAlignment(t) {\n                if ((!A(this.dataMin) || this !== t && this.series.some((t)=>t.isDirty || t.isDirtyData)) && this.getSeriesExtremes(), A(this.threshold)) {\n                    let t = m((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n                    return this.options.reversed && (t = 1 - t), t;\n                }\n            }\n            getTickAmount() {\n                let t = this.options, e = t.tickPixelInterval, i = t.tickAmount;\n                y(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;\n            }\n            adjustTickAmount() {\n                let t = this, { finalTickAmt: e, max: i, min: s, options: o, tickPositions: r, tickAmount: n, thresholdAlignment: a } = t, h = r === null || r === void 0 ? void 0 : r.length, l = E(t.threshold, t.softThreshold ? 0 : null), d, c, p = t.tickInterval, u, g = ()=>r.push(x(r[r.length - 1] + p)), f = ()=>r.unshift(x(r[0] - p));\n                if (A(a) && (u = a < .5 ? Math.ceil(a * (n - 1)) : Math.floor(a * (n - 1)), o.reversed && (u = n - 1 - u)), t.hasData() && A(s) && A(i)) {\n                    let a = ()=>{\n                        t.transA *= (h - 1) / (n - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);\n                    };\n                    if (A(u) && A(t.threshold)) {\n                        for(; r[u] !== l || r.length !== n || r[0] > s || r[r.length - 1] < i;){\n                            for(r.length = 0, r.push(t.threshold); r.length < n;)void 0 === r[u] || r[u] > t.threshold ? f() : g();\n                            if (p > 8 * t.tickInterval) break;\n                            p *= 2;\n                        }\n                        a();\n                    } else if (h < n) {\n                        for(; r.length < n;)r.length % 2 || s === l ? g() : f();\n                        a();\n                    }\n                    if (y(e)) {\n                        for(c = d = r.length; c--;)(3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);\n                        t.finalTickAmt = void 0;\n                    }\n                }\n            }\n            setScale() {\n                var _this_old, _this_old1;\n                let { coll: t, stacking: e } = this, i = !1, s = !1;\n                this.series.forEach((t)=>{\n                    i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis && t.xAxis.isDirty || !1;\n                }), this.setAxisSize();\n                let o = this.len !== (this.old && this.old.len);\n                o || i || s || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (e && \"yAxis\" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && \"xAxis\" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== ((_this_old = this.old) === null || _this_old === void 0 ? void 0 : _this_old.min) || this.max !== ((_this_old1 = this.old) === null || _this_old1 === void 0 ? void 0 : _this_old1.max))) : e && e.cleanStacks(), i && this.panningState && (this.panningState.isDirty = !0), M(this, \"afterSetScale\");\n            }\n            setExtremes(t, e) {\n                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, s = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0;\n                let r = this, n = r.chart;\n                r.series.forEach((t)=>{\n                    delete t.kdTree;\n                }), M(r, \"setExtremes\", o = k(o, {\n                    min: t,\n                    max: e\n                }), ()=>{\n                    r.userMin = t, r.userMax = e, r.eventArgs = o, i && n.redraw(s);\n                });\n            }\n            zoom(t, e) {\n                let i = this, s = this.dataMin, o = this.dataMax, r = this.options, n = Math.min(s, E(r.min, s)), a = Math.max(o, E(r.max, o)), h = {\n                    newMin: t,\n                    newMax: e\n                };\n                return M(this, \"zoom\", h, function(t) {\n                    let e = t.newMin, r = t.newMax;\n                    (e !== i.min || r !== i.max) && (!i.allowZoomOutside && (y(s) && (e < n && (e = n), e > a && (e = a)), y(o) && (r < n && (r = n), r > a && (r = a))), i.displayBtn = void 0 !== e || void 0 !== r, i.setExtremes(e, r, !1, void 0, {\n                        trigger: \"zoom\"\n                    })), t.zoomed = !0;\n                }), h.zoomed;\n            }\n            setAxisSize() {\n                let t = this.chart, e = this.options, i = e.offsets || [\n                    0,\n                    0,\n                    0,\n                    0\n                ], s = this.horiz, o = this.width = Math.round(j(E(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)), r = this.height = Math.round(j(E(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)), n = this.top = Math.round(j(E(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)), a = this.left = Math.round(j(E(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));\n                this.bottom = t.chartHeight - r - n, this.right = t.chartWidth - o - a, this.len = Math.max(s ? o : r, 0), this.pos = s ? a : n;\n            }\n            getExtremes() {\n                let t = this.logarithmic;\n                return {\n                    min: t ? x(t.lin2log(this.min)) : this.min,\n                    max: t ? x(t.lin2log(this.max)) : this.max,\n                    dataMin: this.dataMin,\n                    dataMax: this.dataMax,\n                    userMin: this.userMin,\n                    userMax: this.userMax\n                };\n            }\n            getThreshold(t) {\n                let e = this.logarithmic, i = e ? e.lin2log(this.min) : this.min, s = e ? e.lin2log(this.max) : this.max;\n                return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);\n            }\n            autoLabelAlign(t) {\n                let e = (E(t, 0) - 90 * this.side + 720) % 360, i = {\n                    align: \"center\"\n                };\n                return M(this, \"autoLabelAlign\", i, function(t) {\n                    e > 15 && e < 165 ? t.align = \"right\" : e > 195 && e < 345 && (t.align = \"left\");\n                }), i.align;\n            }\n            tickSize(t) {\n                let e = this.options, i = E(e[\"tick\" === t ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === t && this.isXAxis && !this.categories ? 1 : 0), s = e[\"tick\" === t ? \"tickLength\" : \"minorTickLength\"], o;\n                i && s && (\"inside\" === e[t + \"Position\"] && (s = -s), o = [\n                    s,\n                    i\n                ]);\n                let r = {\n                    tickSize: o\n                };\n                return M(this, \"afterTickSize\", r), r.tickSize;\n            }\n            labelMetrics() {\n                let t = this.chart.renderer, e = this.ticks, i = e[Object.keys(e)[0]] || {};\n                return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);\n            }\n            unsquish() {\n                let t = this.options.labels, e = this.horiz, i = this.tickInterval, s = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / i), o = t.rotation, r = this.labelMetrics().h, n = Math.max(this.max - this.min, 0), a = function(t) {\n                    let e = t / (s || 1);\n                    return (e = e > 1 ? Math.ceil(e) : 1) * i > n && t !== 1 / 0 && s !== 1 / 0 && n && (e = Math.ceil(n / i)), x(e * i);\n                }, h = i, l, d = Number.MAX_VALUE, c;\n                if (e) {\n                    if (!t.staggerLines && (A(o) ? c = [\n                        o\n                    ] : s < t.autoRotationLimit && (c = t.autoRotation)), c) {\n                        let t, e;\n                        for (let i of c)(i === o || i && i >= -90 && i <= 90) && (e = (t = a(Math.abs(r / Math.sin(u * i)))) + Math.abs(i / 360)) < d && (d = e, l = i, h = t);\n                    }\n                } else h = a(.75 * r);\n                return this.autoRotation = c, this.labelRotation = E(l, A(o) ? o : 0), t.step ? i : h;\n            }\n            getSlotWidth(t) {\n                let e = this.chart, i = this.horiz, s = this.options.labels, o = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), r = e.margin[3];\n                if (t && A(t.slotWidth)) return t.slotWidth;\n                if (i && s.step < 2) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;\n                if (!i) {\n                    let t = s.style.width;\n                    if (void 0 !== t) return parseInt(String(t), 10);\n                    if (r) return r - e.spacing[3];\n                }\n                return .33 * e.chartWidth;\n            }\n            renderUnsquish() {\n                let t = this.chart, e = t.renderer, i = this.tickPositions, s = this.ticks, o = this.options.labels, r = o.style, n = this.horiz, a = this.getSlotWidth(), h = Math.max(1, Math.round(a - 2 * o.padding)), l = {}, d = this.labelMetrics(), c = r.textOverflow, p, u, g = 0, f, m;\n                if (P(o.rotation) || (l.rotation = o.rotation || 0), i.forEach(function(t) {\n                    let e = s[t];\n                    e.movedLabel && e.replaceMovedLabel(), e && e.label && e.label.textPxLength > g && (g = e.label.textPxLength);\n                }), this.maxLabelLength = g, this.autoRotation) g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0;\n                else if (a && (p = h, !c)) for(u = \"clip\", m = i.length; !n && m--;)(f = s[i[m]].label) && (f.styles && \"ellipsis\" === f.styles.textOverflow ? f.css({\n                    textOverflow: \"clip\"\n                }) : f.textPxLength > a && f.css({\n                    width: a + \"px\"\n                }), f.getBBox().height > this.len / i.length - (d.h - d.f) && (f.specificTextOverflow = \"ellipsis\"));\n                l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = \"ellipsis\")), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (l.align = this.labelAlign), i.forEach(function(t) {\n                    let e = s[t], i = e && e.label, o = r.width, n = {};\n                    i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !o && \"nowrap\" !== r.whiteSpace && (p < i.textPxLength || \"SPAN\" === i.element.tagName) ? (n.width = p + \"px\", c || (n.textOverflow = i.specificTextOverflow || u), i.css(n)) : i.styles && i.styles.width && !n.width && !o && i.css({\n                        width: null\n                    }), delete i.specificTextOverflow, e.rotation = l.rotation);\n                }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);\n            }\n            hasData() {\n                return this.series.some(function(t) {\n                    return t.hasData();\n                }) || this.options.showEmpty && y(this.min) && y(this.max);\n            }\n            addTitle(t) {\n                let e;\n                let i = this.chart.renderer, s = this.horiz, o = this.opposite, r = this.options, n = r.title, a = this.chart.styledMode;\n                this.axisTitle || ((e = n.textAlign) || (e = (s ? {\n                    low: \"left\",\n                    middle: \"center\",\n                    high: \"right\"\n                } : {\n                    low: o ? \"right\" : \"left\",\n                    middle: \"center\",\n                    high: o ? \"left\" : \"right\"\n                })[n.align]), this.axisTitle = i.text(n.text || \"\", 0, 0, n.useHTML).attr({\n                    zIndex: 7,\n                    rotation: n.rotation || 0,\n                    align: e\n                }).addClass(\"highcharts-axis-title\"), a || this.axisTitle.css(L(n.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || n.style.width || this.isRadial || this.axisTitle.css({\n                    width: this.len + \"px\"\n                }), this.axisTitle[t ? \"show\" : \"hide\"](t);\n            }\n            generateTick(t) {\n                let e = this.ticks;\n                e[t] ? e[t].addLabel() : e[t] = new n(this, t);\n            }\n            createGroups() {\n                let { axisParent: t, chart: e, coll: i, options: s } = this, o = e.renderer, r = (e, r, n)=>o.g(e).attr({\n                        zIndex: n\n                    }).addClass(\"highcharts-\".concat(i.toLowerCase()).concat(r, \" \") + (this.isRadial ? \"highcharts-radial-axis\".concat(r, \" \") : \"\") + (s.className || \"\")).add(t);\n                this.axisGroup || (this.gridGroup = r(\"grid\", \"-grid\", s.gridZIndex), this.axisGroup = r(\"axis\", \"\", s.zIndex), this.labelGroup = r(\"axis-labels\", \"-labels\", s.labels.zIndex));\n            }\n            getOffset() {\n                let t = this, { chart: e, horiz: i, options: s, side: o, ticks: r, tickPositions: n, coll: a } = t, h = e.inverted && !t.isZAxis ? [\n                    1,\n                    0,\n                    3,\n                    2\n                ][o] : o, l = t.hasData(), d = s.title, c = s.labels, p = A(s.crossing), u = e.axisOffset, g = e.clipOffset, f = [\n                    -1,\n                    1,\n                    1,\n                    -1\n                ][o], m, x = 0, b, v = 0, S = 0, k, C;\n                if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (n.forEach(function(e) {\n                    t.generateTick(e);\n                }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || ({\n                    1: \"left\",\n                    3: \"right\"\n                })[o] === t.labelAlign, E(c.reserveSpace, !p && null, \"center\" === t.labelAlign || null, t.reserveSpaceDefault) && n.forEach(function(t) {\n                    S = Math.max(r[t].getLabelSize(), S);\n                }), t.staggerLines && (S *= t.staggerLines), t.labelOffset = S * (t.opposite ? -1 : 1)) : D(r, function(t, e) {\n                    t.destroy(), delete r[e];\n                }), (d === null || d === void 0 ? void 0 : d.text) && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? \"height\" : \"width\"], v = y(b = d.offset) ? 0 : E(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * E(s.offset, u[o] ? u[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {\n                    x: 0,\n                    y: 0\n                }, C = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, k = Math.abs(S) + v, S && (k -= C, k += f * (i ? E(c.y, t.tickRotCorr.y + f * c.distance) : E(c.x, f * c.distance))), t.axisTitleMargin = E(b, k), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, n)), \"colorAxis\" !== a) {\n                    let e = this.tickSize(\"tick\");\n                    u[o] = Math.max(u[o], (t.axisTitleMargin || 0) + x + f * t.offset, k, n && n.length && e ? e[0] + f * t.offset : 0);\n                    let i = !t.axisLine || s.offset ? 0 : 2 * Math.floor(t.axisLine.strokeWidth() / 2);\n                    g[h] = Math.max(g[h], i);\n                }\n                M(this, \"afterGetOffset\");\n            }\n            getLinePath(t) {\n                let e = this.chart, i = this.opposite, s = this.offset, o = this.horiz, r = this.left + (i ? this.width : 0) + s, n = e.chartHeight - this.bottom - (i ? this.height : 0) + s;\n                return i && (t *= -1), e.renderer.crispLine([\n                    [\n                        \"M\",\n                        o ? this.left : r,\n                        o ? n : this.top\n                    ],\n                    [\n                        \"L\",\n                        o ? e.chartWidth - this.right : r,\n                        o ? n : e.chartHeight - this.bottom\n                    ]\n                ], t);\n            }\n            renderLine() {\n                this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n                    stroke: this.options.lineColor,\n                    \"stroke-width\": this.options.lineWidth,\n                    zIndex: 7\n                }));\n            }\n            getTitlePosition(t) {\n                let e = this.horiz, i = this.left, s = this.top, o = this.len, r = this.options.title, n = e ? i : s, a = this.opposite, h = this.offset, l = r.x, d = r.y, c = this.chart.renderer.fontMetrics(t), p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0, u = {\n                    low: n + (e ? 0 : o),\n                    middle: n + o / 2,\n                    high: n + (e ? o : 0)\n                }[r.align], g = (e ? s + this.height : i) + (e ? 1 : -1) * (a ? -1 : 1) * (this.axisTitleMargin || 0) + [\n                    -p,\n                    p,\n                    c.f,\n                    -p\n                ][this.side], f = {\n                    x: e ? u + l : g + (a ? this.width : 0) + h + l,\n                    y: e ? g + d - (a ? this.height : 0) + h : u + d\n                };\n                return M(this, \"afterGetTitlePosition\", {\n                    titlePosition: f\n                }), f;\n            }\n            renderMinorTick(t, e) {\n                let i = this.minorTicks;\n                i[t] || (i[t] = new n(this, t, \"minor\")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);\n            }\n            renderTick(t, e, i) {\n                let s = this.isLinked, o = this.ticks;\n                (!s || t >= this.min && t <= this.max || this.grid && this.grid.isColumn) && (o[t] || (o[t] = new n(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));\n            }\n            render() {\n                let t, e;\n                let i = this, s = i.chart, o = i.logarithmic, a = s.renderer, l = i.options, d = i.isLinked, c = i.tickPositions, p = i.axisTitle, u = i.ticks, g = i.minorTicks, f = i.alternateBands, m = l.stackLabels, x = l.alternateGridColor, y = l.crossing, b = i.tickmarkOffset, v = i.axisLine, S = i.showAxis, k = h(a.globalAnimation);\n                if (i.labelEdge.length = 0, i.overlap = !1, [\n                    u,\n                    g,\n                    f\n                ].forEach(function(t) {\n                    D(t, function(t) {\n                        t.isActive = !1;\n                    });\n                }), A(y)) {\n                    let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0], e = [\n                        1,\n                        -1,\n                        -1,\n                        1\n                    ][this.side];\n                    if (t) {\n                        let s = t.toPixels(y, !0);\n                        i.horiz && (s = t.len - s), i.offset = e * s;\n                    }\n                }\n                if (i.hasData() || d) {\n                    let a = i.chart.hasRendered && i.old && A(i.old.min);\n                    i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function(t) {\n                        i.renderMinorTick(t, a);\n                    }), c.length && (c.forEach(function(t, e) {\n                        i.renderTick(t, e, a);\n                    }), b && (0 === i.min || i.single) && (u[-1] || (u[-1] = new n(i, -1, null, !0)), u[-1].render(-1))), x && c.forEach(function(n, a) {\n                        e = void 0 !== c[a + 1] ? c[a + 1] + b : i.max - b, a % 2 == 0 && n < i.max && e <= i.max + (s.polar ? -b : b) && (f[n] || (f[n] = new r.PlotLineOrBand(i, {})), t = n + b, f[n].options = {\n                            from: o ? o.lin2log(t) : t,\n                            to: o ? o.lin2log(e) : e,\n                            color: x,\n                            className: \"highcharts-alternate-grid\"\n                        }, f[n].render(), f[n].isActive = !0);\n                    }), i._addedPlotLB || (i._addedPlotLB = !0, (l.plotLines || []).concat(l.plotBands || []).forEach(function(t) {\n                        i.addPlotBandOrLine(t);\n                    }));\n                }\n                [\n                    u,\n                    g,\n                    f\n                ].forEach(function(t) {\n                    let e = [], i = k.duration;\n                    D(t, function(t, i) {\n                        t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));\n                    }), R(function() {\n                        let i = e.length;\n                        for(; i--;)t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);\n                    }, t !== f && s.hasRendered && i ? i : 0);\n                }), v && (v[v.isPlaced ? \"animate\" : \"attr\"]({\n                    d: this.getLinePath(v.strokeWidth())\n                }), v.isPlaced = !0, v[S ? \"show\" : \"hide\"](S)), p && S && (p[p.isNew ? \"attr\" : \"animate\"](i.getTitlePosition(p)), p.isNew = !1), m && m.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {\n                    len: i.len,\n                    max: i.max,\n                    min: i.min,\n                    transA: i.transA,\n                    userMax: i.userMax,\n                    userMin: i.userMin\n                }, i.isDirty = !1, M(this, \"afterRender\");\n            }\n            redraw() {\n                this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t) {\n                    t.render();\n                })), this.series.forEach(function(t) {\n                    t.isDirty = !0;\n                });\n            }\n            getKeepProps() {\n                return this.keepProps || N.keepProps;\n            }\n            destroy(t) {\n                let e = this, i = e.plotLinesAndBands, s = this.eventOptions;\n                if (M(this, \"destroy\", {\n                    keepEvents: t\n                }), t || I(e), [\n                    e.ticks,\n                    e.minorTicks,\n                    e.alternateBands\n                ].forEach(function(t) {\n                    b(t);\n                }), i) {\n                    let t = i.length;\n                    for(; t--;)i[t].destroy();\n                }\n                for(let t in [\n                    \"axisLine\",\n                    \"axisTitle\",\n                    \"axisGroup\",\n                    \"gridGroup\",\n                    \"labelGroup\",\n                    \"cross\",\n                    \"scrollbar\"\n                ].forEach(function(t) {\n                    e[t] && (e[t] = e[t].destroy());\n                }), e.plotLinesAndBandsGroups)e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();\n                D(e, function(t, i) {\n                    -1 === e.getKeepProps().indexOf(i) && delete e[i];\n                }), this.eventOptions = s;\n            }\n            drawCrosshair(t, e) {\n                let s = this.crosshair, o = E(s && s.snap, !0), r = this.chart, n, a, h, l = this.cross, d;\n                if (M(this, \"drawCrosshair\", {\n                    e: t,\n                    point: e\n                }), t || (t = this.cross && this.cross.e), s && !1 !== (y(e) || !o)) {\n                    if (o ? y(e) && (a = E(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), y(a) && (d = {\n                        value: e && (this.isXAxis ? e.x : E(e.stackY, e.y)),\n                        translatedValue: a\n                    }, r.polar && k(d, {\n                        isCrosshair: !0,\n                        chartX: t && t.chartX,\n                        chartY: t && t.chartY,\n                        point: e\n                    }), n = this.getPlotLinePath(d) || null), !y(n)) {\n                        this.hideCrosshair();\n                        return;\n                    }\n                    h = this.categories && !this.isRadial, l || (this.cross = l = r.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + (s.className || \"\")).attr({\n                        zIndex: E(s.zIndex, 2)\n                    }).add(), !r.styledMode && (l.attr({\n                        stroke: s.color || (h ? i.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n                        \"stroke-width\": E(s.width, 1)\n                    }).css({\n                        \"pointer-events\": \"none\"\n                    }), s.dashStyle && l.attr({\n                        dashstyle: s.dashStyle\n                    }))), l.show().attr({\n                        d: n\n                    }), h && !s.width && l.attr({\n                        \"stroke-width\": this.transA\n                    }), this.cross.e = t;\n                } else this.hideCrosshair();\n                M(this, \"afterDrawCrosshair\", {\n                    e: t,\n                    point: e\n                });\n            }\n            hideCrosshair() {\n                this.cross && this.cross.hide(), M(this, \"afterHideCrosshair\");\n            }\n            hasVerticalPanning() {\n                let t = this.chart.options.chart.panning;\n                return !!(t && t.enabled && /y/.test(t.type));\n            }\n            update(t, e) {\n                let i = this.chart;\n                t = L(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, E(e, !0) && i.redraw();\n            }\n            remove(t) {\n                let e = this.chart, i = this.coll, s = this.series, o = s.length;\n                for(; o--;)s[o] && s[o].remove(!1);\n                v(e.axes, this), v(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, E(t, !0) && e.redraw();\n            }\n            setTitle(t, e) {\n                this.update({\n                    title: t\n                }, e);\n            }\n            setCategories(t, e) {\n                this.update({\n                    categories: t\n                }, e);\n            }\n            constructor(t, e, i){\n                this.init(t, e, i);\n            }\n        }\n        return N.keepProps = [\n            \"coll\",\n            \"extKey\",\n            \"hcEvents\",\n            \"names\",\n            \"series\",\n            \"userMax\",\n            \"userMin\"\n        ], N;\n    }), i(e, \"Core/Axis/DateTimeAxis.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        var i;\n        let { composed: s } = t, { addEvent: o, getMagnitude: r, normalizeTickInterval: n, pushUnique: a, timeUnits: h } = e;\n        return function(t) {\n            function e() {\n                return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n            }\n            function i() {\n                if (\"datetime\" !== this.options.type) {\n                    this.dateTime = void 0;\n                    return;\n                }\n                this.dateTime || (this.dateTime = new l(this));\n            }\n            t.compose = function t(r) {\n                if (a(s, t)) {\n                    r.keepProps.push(\"dateTime\");\n                    let t = r.prototype;\n                    t.getTimeTicks = e, o(r, \"afterSetOptions\", i);\n                }\n                return r;\n            };\n            class l {\n                normalizeTimeTickInterval(t, e) {\n                    let i = e || [\n                        [\n                            \"millisecond\",\n                            [\n                                1,\n                                2,\n                                5,\n                                10,\n                                20,\n                                25,\n                                50,\n                                100,\n                                200,\n                                500\n                            ]\n                        ],\n                        [\n                            \"second\",\n                            [\n                                1,\n                                2,\n                                5,\n                                10,\n                                15,\n                                30\n                            ]\n                        ],\n                        [\n                            \"minute\",\n                            [\n                                1,\n                                2,\n                                5,\n                                10,\n                                15,\n                                30\n                            ]\n                        ],\n                        [\n                            \"hour\",\n                            [\n                                1,\n                                2,\n                                3,\n                                4,\n                                6,\n                                8,\n                                12\n                            ]\n                        ],\n                        [\n                            \"day\",\n                            [\n                                1,\n                                2\n                            ]\n                        ],\n                        [\n                            \"week\",\n                            [\n                                1,\n                                2\n                            ]\n                        ],\n                        [\n                            \"month\",\n                            [\n                                1,\n                                2,\n                                3,\n                                4,\n                                6\n                            ]\n                        ],\n                        [\n                            \"year\",\n                            null\n                        ]\n                    ], s = i[i.length - 1], o = h[s[0]], a = s[1], l;\n                    for(l = 0; l < i.length; l++)if (o = h[(s = i[l])[0]], a = s[1], i[l + 1]) {\n                        let e = (o * a[a.length - 1] + h[i[l + 1][0]]) / 2;\n                        if (t <= e) break;\n                    }\n                    o === h.year && t < 5 * o && (a = [\n                        1,\n                        2,\n                        5\n                    ]);\n                    let d = n(t / o, a, \"year\" === s[0] ? Math.max(r(t / o), 1) : 1);\n                    return {\n                        unitRange: o,\n                        count: d,\n                        unitName: s[0]\n                    };\n                }\n                getXDateFormat(t, e) {\n                    let { axis: i } = this, s = i.chart.time;\n                    return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;\n                }\n                constructor(t){\n                    this.axis = t;\n                }\n            }\n            t.Additions = l;\n        }(i || (i = {})), i;\n    }), i(e, \"Core/Axis/LogarithmicAxis.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        var i;\n        let { composed: s } = t, { addEvent: o, normalizeTickInterval: r, pick: n, pushUnique: a } = e;\n        return function(t) {\n            function e(t) {\n                let e = t.userOptions, i = this.logarithmic;\n                \"logarithmic\" !== e.type ? this.logarithmic = void 0 : i || (i = this.logarithmic = new h(this));\n            }\n            function i() {\n                let t = this.logarithmic;\n                t && (this.lin2val = function(e) {\n                    return t.lin2log(e);\n                }, this.val2lin = function(e) {\n                    return t.log2lin(e);\n                });\n            }\n            t.compose = function t(r) {\n                return a(s, t) && (r.keepProps.push(\"logarithmic\"), o(r, \"init\", e), o(r, \"afterInit\", i)), r;\n            };\n            class h {\n                getLogTickPositions(t, e, i, s) {\n                    let o = this.axis, a = o.len, h = o.options, l = [];\n                    if (s || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), l = o.getLinearTickPositions(t, e, i);\n                    else if (t >= .08) {\n                        let o, r, n, a, h, d, c;\n                        let p = Math.floor(e);\n                        for(o = t > .3 ? [\n                            1,\n                            2,\n                            4\n                        ] : t > .15 ? [\n                            1,\n                            2,\n                            4,\n                            6,\n                            8\n                        ] : [\n                            1,\n                            2,\n                            3,\n                            4,\n                            5,\n                            6,\n                            7,\n                            8,\n                            9\n                        ], r = p; r < i + 1 && !c; r++)for(n = 0, a = o.length; n < a && !c; n++)(h = this.log2lin(this.lin2log(r) * o[n])) > e && (!s || d <= i) && void 0 !== d && l.push(d), d > i && (c = !0), d = h;\n                    } else {\n                        let d = this.lin2log(e), c = this.lin2log(i), p = s ? o.getMinorTickInterval() : h.tickInterval, u = \"auto\" === p ? null : p, g = h.tickPixelInterval / (s ? 5 : 1), f = s ? a / o.tickPositions.length : a;\n                        t = r(t = n(u, this.minorAutoInterval, (c - d) * g / (f || 1))), l = o.getLinearTickPositions(t, d, c).map(this.log2lin), s || (this.minorAutoInterval = t / 5);\n                    }\n                    return s || (o.tickInterval = t), l;\n                }\n                lin2log(t) {\n                    return Math.pow(10, t);\n                }\n                log2lin(t) {\n                    return Math.log(t) / Math.LN10;\n                }\n                constructor(t){\n                    this.axis = t;\n                }\n            }\n            t.Additions = h;\n        }(i || (i = {})), i;\n    }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        var i;\n        let { composed: s } = t, { erase: o, extend: r, isNumber: n, pushUnique: a } = e;\n        return function(t) {\n            let e;\n            function i(t) {\n                return this.addPlotBandOrLine(t, \"plotBands\");\n            }\n            function h(t, i) {\n                let s = this.userOptions, o = new e(this, t);\n                if (this.visible && (o = o.render()), o) {\n                    if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach((t)=>{\n                        this.addPlotBandOrLine(t);\n                    })), i) {\n                        let e = s[i] || [];\n                        e.push(t), s[i] = e;\n                    }\n                    this.plotLinesAndBands.push(o);\n                }\n                return o;\n            }\n            function l(t) {\n                return this.addPlotBandOrLine(t, \"plotLines\");\n            }\n            function d(t, e, i) {\n                i = i || this.options;\n                let s = this.getPlotLinePath({\n                    value: e,\n                    force: !0,\n                    acrossPanes: i.acrossPanes\n                }), o = [], r = this.horiz, a = !n(this.min) || !n(this.max) || t < this.min && e < this.min || t > this.max && e > this.max, h = this.getPlotLinePath({\n                    value: t,\n                    force: !0,\n                    acrossPanes: i.acrossPanes\n                }), l, d = 1, c;\n                if (h && s) for(a && (c = h.toString() === s.toString(), d = 0), l = 0; l < h.length; l += 2){\n                    let t = h[l], e = h[l + 1], i = s[l], n = s[l + 1];\n                    (\"M\" === t[0] || \"L\" === t[0]) && (\"M\" === e[0] || \"L\" === e[0]) && (\"M\" === i[0] || \"L\" === i[0]) && (\"M\" === n[0] || \"L\" === n[0]) && (r && i[1] === t[1] ? (i[1] += d, n[1] += d) : r || i[2] !== t[2] || (i[2] += d, n[2] += d), o.push([\n                        \"M\",\n                        t[1],\n                        t[2]\n                    ], [\n                        \"L\",\n                        e[1],\n                        e[2]\n                    ], [\n                        \"L\",\n                        n[1],\n                        n[2]\n                    ], [\n                        \"L\",\n                        i[1],\n                        i[2]\n                    ], [\n                        \"Z\"\n                    ])), o.isFlat = c;\n                }\n                return o;\n            }\n            function c(t) {\n                this.removePlotBandOrLine(t);\n            }\n            function p(t) {\n                let e = this.plotLinesAndBands, i = this.options, s = this.userOptions;\n                if (e) {\n                    let r = e.length;\n                    for(; r--;)e[r].id === t && e[r].destroy();\n                    [\n                        i.plotLines || [],\n                        s.plotLines || [],\n                        i.plotBands || [],\n                        s.plotBands || []\n                    ].forEach(function(e) {\n                        for(r = e.length; r--;)(e[r] || {}).id === t && o(e, e[r]);\n                    });\n                }\n            }\n            function u(t) {\n                this.removePlotBandOrLine(t);\n            }\n            t.compose = function t(o, n) {\n                return a(s, t) && (e = o, r(n.prototype, {\n                    addPlotBand: i,\n                    addPlotLine: l,\n                    addPlotBandOrLine: h,\n                    getPlotBandPath: d,\n                    removePlotBand: c,\n                    removePlotLine: u,\n                    removePlotBandOrLine: p\n                })), n;\n            };\n        }(i || (i = {})), i;\n    }), i(e, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [\n        e[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { arrayMax: i, arrayMin: s, defined: o, destroyObjectProperties: r, erase: n, fireEvent: a, merge: h, objectEach: l, pick: d } = e;\n        class c {\n            static compose(e) {\n                return t.compose(c, e);\n            }\n            render() {\n                a(this, \"render\");\n                let { axis: t, options: e } = this, { horiz: i, logarithmic: s } = t, { color: r, events: n, zIndex: c = 0 } = e, p = {}, u = t.chart.renderer, g = e.to, f = e.from, m = e.value, x = e.borderWidth, y = e.label, { label: b, svgElem: v } = this, S = [], k, M = o(f) && o(g), C = o(m), w = !v, T = {\n                    class: \"highcharts-plot-\" + (M ? \"band \" : \"line \") + (e.className || \"\")\n                }, A = M ? \"bands\" : \"lines\";\n                var _s_log2lin;\n                if (!t.chart.styledMode && (C ? (T.stroke = r || \"#999999\", T[\"stroke-width\"] = d(e.width, 1), e.dashStyle && (T.dashstyle = e.dashStyle)) : M && (T.fill = r || \"#e6e9ff\", x && (T.stroke = e.borderColor, T[\"stroke-width\"] = x))), p.zIndex = c, A += \"-\" + c, (k = t.plotLinesAndBandsGroups[A]) || (t.plotLinesAndBandsGroups[A] = k = u.g(\"plot-\" + A).attr(p).add()), v || (this.svgElem = v = u.path().attr(T).add(k)), o(m)) S = t.getPlotLinePath({\n                    value: (_s_log2lin = s === null || s === void 0 ? void 0 : s.log2lin(m)) !== null && _s_log2lin !== void 0 ? _s_log2lin : m,\n                    lineWidth: v.strokeWidth(),\n                    acrossPanes: e.acrossPanes\n                });\n                else {\n                    if (!(o(f) && o(g))) return;\n                    var _s_log2lin1, _s_log2lin2;\n                    S = t.getPlotBandPath((_s_log2lin1 = s === null || s === void 0 ? void 0 : s.log2lin(f)) !== null && _s_log2lin1 !== void 0 ? _s_log2lin1 : f, (_s_log2lin2 = s === null || s === void 0 ? void 0 : s.log2lin(g)) !== null && _s_log2lin2 !== void 0 ? _s_log2lin2 : g, e);\n                }\n                return !this.eventsAdded && n && (l(n, (t, e)=>{\n                    v === null || v === void 0 ? void 0 : v.on(e, function(t) {\n                        n[e].apply(this, [\n                            t\n                        ]);\n                    });\n                }), this.eventsAdded = !0), (w || !v.d) && (S === null || S === void 0 ? void 0 : S.length) ? v.attr({\n                    d: S\n                }) : v && (S ? (v.show(), v.animate({\n                    d: S\n                })) : v.d && (v.hide(), b && (this.label = b = b.destroy()))), y && (o(y.text) || o(y.formatter)) && (S === null || S === void 0 ? void 0 : S.length) && t.width > 0 && t.height > 0 && !S.isFlat ? (y = h({\n                    align: i && M && \"center\",\n                    x: i ? !M && 4 : 10,\n                    verticalAlign: !i && M && \"middle\",\n                    y: i ? M ? 16 : 10 : M ? 6 : -4,\n                    rotation: i && !M && 90\n                }, y), this.renderLabel(y, S, M, c)) : b && b.hide(), this;\n            }\n            renderLabel(t, e, o, r) {\n                let n = this.axis, a = n.chart.renderer, l = this.label;\n                l || (this.label = l = a.text(this.getLabelText(t), 0, 0, t.useHTML).attr({\n                    align: t.textAlign || t.align,\n                    rotation: t.rotation,\n                    class: \"highcharts-plot-\" + (o ? \"band\" : \"line\") + \"-label\" + (t.className || \"\"),\n                    zIndex: r\n                }), n.chart.styledMode || l.css(h({\n                    fontSize: \"0.8em\",\n                    textOverflow: \"ellipsis\"\n                }, t.style)), l.add());\n                let d = e.xBounds || [\n                    e[0][1],\n                    e[1][1],\n                    o ? e[2][1] : e[0][1]\n                ], c = e.yBounds || [\n                    e[0][2],\n                    e[1][2],\n                    o ? e[2][2] : e[0][2]\n                ], p = s(d), u = s(c);\n                if (l.align(t, !1, {\n                    x: p,\n                    y: u,\n                    width: i(d) - p,\n                    height: i(c) - u\n                }), !l.alignValue || \"left\" === l.alignValue) {\n                    let e = t.clip ? n.width : n.chart.chartWidth;\n                    l.css({\n                        width: (90 === l.rotation ? n.height - (l.alignAttr.y - n.top) : e - (l.alignAttr.x - n.left)) + \"px\"\n                    });\n                }\n                l.show(!0);\n            }\n            getLabelText(t) {\n                return o(t.formatter) ? t.formatter.call(this) : t.text;\n            }\n            destroy() {\n                n(this.axis.plotLinesAndBands, this), delete this.axis, r(this);\n            }\n            constructor(t, e){\n                this.axis = t, this.options = e, this.id = e.id;\n            }\n        }\n        return c;\n    }), i(e, \"Core/Tooltip.js\", [\n        e[\"Core/Templating.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/RendererUtilities.js\"],\n        e[\"Core/Renderer/RendererRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o) {\n        var r;\n        let { format: n } = t, { composed: a, doc: h, isSafari: l } = e, { distribute: d } = i, { addEvent: c, clamp: p, css: u, discardElement: g, extend: f, fireEvent: m, isArray: x, isNumber: y, isString: b, merge: v, pick: S, pushUnique: k, splat: M, syncTimeout: C } = o;\n        class w {\n            bodyFormatter(t) {\n                return t.map(function(t) {\n                    let e = t.series.tooltipOptions;\n                    return (e[(t.point.formatPrefix || \"point\") + \"Formatter\"] || t.point.tooltipFormatter).call(t.point, e[(t.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n                });\n            }\n            cleanSplit(t) {\n                this.chart.series.forEach(function(e) {\n                    let i = e && e.tt;\n                    i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);\n                });\n            }\n            defaultFormatter(t) {\n                let e;\n                let i = this.points || M(this);\n                return (e = (e = [\n                    t.tooltipFooterHeaderFormatter(i[0])\n                ]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0], !0)), e;\n            }\n            destroy() {\n                this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), g(this.container)), o.clearTimeout(this.hideTimer), o.clearTimeout(this.tooltipTimeout);\n            }\n            getAnchor(t, e) {\n                let i;\n                let s = this.chart, o = s.pointer, r = s.inverted, n = s.plotTop, a = s.plotLeft;\n                if ((t = M(t))[0].series && t[0].series.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [\n                    e.chartX - a,\n                    e.chartY - n\n                ];\n                else if (t[0].tooltipPos) i = t[0].tooltipPos;\n                else {\n                    let s = 0, o = 0;\n                    t.forEach(function(t) {\n                        let e = t.pos(!0);\n                        e && (s += e[0], o += e[1]);\n                    }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [\n                        s - a,\n                        o - n\n                    ];\n                }\n                return i.map(Math.round);\n            }\n            getClassName(t, e, i) {\n                let s = this.options, o = t.series, r = o.options;\n                return [\n                    s.className,\n                    \"highcharts-label\",\n                    i && \"highcharts-tooltip-header\",\n                    e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\",\n                    !i && \"highcharts-color-\" + S(t.colorIndex, o.colorIndex),\n                    r && r.className\n                ].filter(b).join(\" \");\n            }\n            getLabel() {\n                let t = this, i = this.chart.styledMode, o = this.options, r = this.split && this.allowShared, n = this.container, a = this.chart.renderer;\n                if (this.label) {\n                    let t = !this.label.hasClass(\"highcharts-label\");\n                    (!r && t || r && !t) && this.destroy();\n                }\n                if (!this.label) {\n                    if (this.outside) {\n                        let t = this.chart.options.chart.style, i = s.getRendererType();\n                        this.container = n = e.doc.createElement(\"div\"), n.className = \"highcharts-tooltip-container\", u(n, {\n                            position: \"absolute\",\n                            top: \"1px\",\n                            pointerEvents: \"none\",\n                            zIndex: Math.max(this.options.style.zIndex || 0, (t && t.zIndex || 0) + 3)\n                        }), this.renderer = a = new i(n, 0, 0, t, void 0, void 0, a.styledMode);\n                    }\n                    if (r ? this.label = a.g(\"tooltip\") : (this.label = a.label(\"\", 0, 0, o.shape, void 0, void 0, o.useHTML, void 0, \"tooltip\").attr({\n                        padding: o.padding,\n                        r: o.borderRadius\n                    }), i || this.label.attr({\n                        fill: o.backgroundColor,\n                        \"stroke-width\": o.borderWidth || 0\n                    }).css(o.style).css({\n                        pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\")\n                    })), t.outside) {\n                        let e = this.label, { xSetter: i, ySetter: s } = e;\n                        e.xSetter = function(s) {\n                            i.call(e, t.distance), n && (n.style.left = s + \"px\");\n                        }, e.ySetter = function(i) {\n                            s.call(e, t.distance), n && (n.style.top = i + \"px\");\n                        };\n                    }\n                    this.label.attr({\n                        zIndex: 8\n                    }).shadow(o.shadow).add();\n                }\n                return n && !n.parentElement && e.doc.body.appendChild(n), this.label;\n            }\n            getPlayingField() {\n                let { body: t, documentElement: e } = h, { chart: i, distance: s, outside: o } = this;\n                return {\n                    width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s : i.chartWidth,\n                    height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight\n                };\n            }\n            getPosition(t, e, i) {\n                var _o_hoverSeries_yAxis, _o_hoverSeries;\n                let { distance: s, chart: o, outside: r } = this, { inverted: n, plotLeft: a, plotTop: h, polar: l } = o, { plotX: d = 0, plotY: c = 0 } = i, p = {}, u = n && i.h || 0, { height: g, width: f } = this.getPlayingField(), m = o.pointer.getChartPosition(), x = (t)=>t * m.scaleX, y = (t)=>t * m.scaleY, b = (i)=>{\n                    let n = \"x\" === i;\n                    return [\n                        i,\n                        n ? f : g,\n                        n ? t : e\n                    ].concat(r ? [\n                        n ? x(t) : y(e),\n                        n ? m.left - s + x(d + a) : m.top - s + y(c + h),\n                        0,\n                        n ? f : g\n                    ] : [\n                        n ? t : e,\n                        n ? d + a : c + h,\n                        n ? a : h,\n                        n ? a + o.plotWidth : h + o.plotHeight\n                    ]);\n                }, v = b(\"y\"), k = b(\"x\"), M, C = !!i.negative;\n                !l && ((_o_hoverSeries = o.hoverSeries) === null || _o_hoverSeries === void 0 ? void 0 : (_o_hoverSeries_yAxis = _o_hoverSeries.yAxis) === null || _o_hoverSeries_yAxis === void 0 ? void 0 : _o_hoverSeries_yAxis.reversed) && (C = !C);\n                let w = !this.followPointer && S(i.ttBelow, !l && !n === C), T = function(t, e, i, o, n, a, h) {\n                    let l = r ? \"y\" === t ? y(s) : x(s) : s, d = (i - o) / 2, c = o < n - s, g = n + s + o < e, f = n - l - i + d, m = n + l - d;\n                    if (w && g) p[t] = m;\n                    else if (!w && c) p[t] = f;\n                    else if (c) p[t] = Math.min(h - o, f - u < 0 ? f : f - u);\n                    else {\n                        if (!g) return !1;\n                        p[t] = Math.max(a, m + u + i > e ? m : m + u);\n                    }\n                }, A = function(t, e, i, o, r) {\n                    if (r < s || r > e - s) return !1;\n                    r < i / 2 ? p[t] = 1 : r > e - o / 2 ? p[t] = e - o - 2 : p[t] = r - i / 2;\n                }, P = function(t) {\n                    [v, k] = [\n                        k,\n                        v\n                    ], M = t;\n                }, L = ()=>{\n                    !1 !== T.apply(0, v) ? !1 !== A.apply(0, k) || M || (P(!0), L()) : M ? p.x = p.y = 0 : (P(!0), L());\n                };\n                return (n && !l || this.len > 1) && P(), L(), p;\n            }\n            hide(t) {\n                let e = this;\n                o.clearTimeout(this.hideTimer), t = S(t, this.options.hideDelay), this.isHidden || (this.hideTimer = C(function() {\n                    let i = e.getLabel();\n                    e.getLabel().animate({\n                        opacity: 0\n                    }, {\n                        duration: t ? 150 : t,\n                        complete: ()=>{\n                            i.hide(), e.container && e.container.remove();\n                        }\n                    }), e.isHidden = !0;\n                }, t));\n            }\n            init(t, e) {\n                this.chart = t, this.options = e, this.crosshairs = [], this.now = {\n                    x: 0,\n                    y: 0\n                }, this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = S(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));\n            }\n            shouldStickOnContact(t) {\n                return !!(!this.followPointer && this.options.stickOnContact && (!t || this.chart.pointer.inClass(t.target, \"highcharts-tooltip\")));\n            }\n            move(t, e, i, s) {\n                let r = this, n = r.now, a = !1 !== r.options.animation && !r.isHidden && (Math.abs(t - n.x) > 1 || Math.abs(e - n.y) > 1), h = r.followPointer || r.len > 1;\n                f(n, {\n                    x: a ? (2 * n.x + t) / 3 : t,\n                    y: a ? (n.y + e) / 2 : e,\n                    anchorX: h ? void 0 : a ? (2 * n.anchorX + i) / 3 : i,\n                    anchorY: h ? void 0 : a ? (n.anchorY + s) / 2 : s\n                }), r.getLabel().attr(n), r.drawTracker(), a && (o.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {\n                    r && r.move(t, e, i, s);\n                }, 32));\n            }\n            refresh(t, e) {\n                let i = this.chart, s = this.options, r = i.pointer, a = M(t), h = a[0], l = [], d = s.format, c = s.formatter || this.defaultFormatter, p = this.shared, u = i.styledMode, g = {};\n                if (!s.enabled || !h.series) return;\n                o.clearTimeout(this.hideTimer), this.allowShared = !(!x(t) && t.series && t.series.noSharedTooltip), this.followPointer = !this.split && h.series.tooltipOptions.followPointer;\n                let f = this.getAnchor(t, e), y = f[0], v = f[1];\n                p && this.allowShared ? (r.applyInactiveState(a), a.forEach(function(t) {\n                    t.setState(\"hover\"), l.push(t.getLabelConfig());\n                }), (g = h.getLabelConfig()).points = l) : g = h.getLabelConfig(), this.len = l.length;\n                let k = b(d) ? n(d, g, i) : c.call(g, this), C = h.series;\n                if (this.distance = S(C.tooltipOptions.distance, 16), !1 === k) this.hide();\n                else {\n                    if (this.split && this.allowShared) this.renderSplit(k, a);\n                    else {\n                        let t = y, o = v;\n                        if (e && r.isDirectTouch && (t = e.chartX - i.plotLeft, o = e.chartY - i.plotTop), i.polar || !1 === C.options.clip || a.some((e)=>r.isDirectTouch || e.series.shouldShowTooltip(t, o))) {\n                            let t = this.getLabel();\n                            (!s.style.width || u) && t.css({\n                                width: (this.outside ? this.getPlayingField() : i.spacingBox).width + \"px\"\n                            }), t.attr({\n                                text: k && k.join ? k.join(\"\") : k\n                            }), t.addClass(this.getClassName(h), !0), u || t.attr({\n                                stroke: s.borderColor || h.color || C.color || \"#666666\"\n                            }), this.updatePosition({\n                                plotX: y,\n                                plotY: v,\n                                negative: h.negative,\n                                ttBelow: h.ttBelow,\n                                h: f[2] || 0\n                            });\n                        } else {\n                            this.hide();\n                            return;\n                        }\n                    }\n                    this.isHidden && this.label && this.label.attr({\n                        opacity: 1\n                    }).show(), this.isHidden = !1;\n                }\n                m(this, \"refresh\");\n            }\n            renderSplit(t, e) {\n                let i = this, { chart: s, chart: { chartWidth: o, chartHeight: r, plotHeight: n, plotLeft: a, plotTop: c, pointer: u, scrollablePixelsY: g = 0, scrollablePixelsX: m, scrollingContainer: { scrollLeft: x, scrollTop: y } = {\n                    scrollLeft: 0,\n                    scrollTop: 0\n                }, styledMode: v }, distance: k, options: M, options: { positioner: C } } = i, w = i.outside && \"number\" != typeof m ? h.documentElement.getBoundingClientRect() : {\n                    left: x,\n                    right: x + o,\n                    top: y,\n                    bottom: y + r\n                }, T = i.getLabel(), A = this.renderer || s.renderer, P = !!(s.xAxis[0] && s.xAxis[0].opposite), { left: L, top: O } = u.getChartPosition(), D = c + y, E = 0, j = n - g;\n                function I(t, e, s, o) {\n                    let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;\n                    let n, a;\n                    return s ? (n = P ? 0 : j, a = p(t - o / 2, w.left, w.right - o - (i.outside ? L : 0))) : (n = e - D, a = p(a = r ? t - o - k : t + k, r ? a : w.left, w.right)), {\n                        x: a,\n                        y: n\n                    };\n                }\n                b(t) && (t = [\n                    !1,\n                    t\n                ]);\n                let B = t.slice(0, e.length + 1).reduce(function(t, s, o) {\n                    if (!1 !== s && \"\" !== s) {\n                        let r = e[o - 1] || {\n                            isHeader: !0,\n                            plotX: e[0].plotX,\n                            plotY: n,\n                            series: {}\n                        }, h = r.isHeader, l = h ? i : r.series, d = l.tt = function(t, e, s) {\n                            let o = t, { isHeader: r, series: n } = e;\n                            if (!o) {\n                                let t = {\n                                    padding: M.padding,\n                                    r: M.borderRadius\n                                };\n                                var _M_borderWidth;\n                                v || (t.fill = M.backgroundColor, t[\"stroke-width\"] = (_M_borderWidth = M.borderWidth) !== null && _M_borderWidth !== void 0 ? _M_borderWidth : 1), o = A.label(\"\", 0, 0, M[r ? \"headerShape\" : \"shape\"], void 0, void 0, M.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(T);\n                            }\n                            return o.isActive = !0, o.attr({\n                                text: s\n                            }), v || o.css(M.style).attr({\n                                stroke: M.borderColor || e.color || n.color || \"#333333\"\n                            }), o;\n                        }(l.tt, r, s.toString()), u = d.getBBox(), g = u.width + d.strokeWidth();\n                        h && (E = u.height, j += E, P && (D -= E));\n                        let { anchorX: f, anchorY: m } = function(t) {\n                            let e, i;\n                            let { isHeader: s, plotX: o = 0, plotY: r = 0, series: h } = t;\n                            if (s) e = Math.max(a + o, a), i = c + n / 2;\n                            else {\n                                let { xAxis: t, yAxis: s } = h;\n                                e = t.pos + p(o, -k, t.len + k), h.shouldShowTooltip(0, s.pos - c + r, {\n                                    ignoreX: !0\n                                }) && (i = s.pos + r);\n                            }\n                            return {\n                                anchorX: e = p(e, w.left - k, w.right + k),\n                                anchorY: i\n                            };\n                        }(r);\n                        if (\"number\" == typeof m) {\n                            let e = u.height + 1, s = C ? C.call(i, g, e, r) : I(f, m, h, g);\n                            t.push({\n                                align: C ? 0 : void 0,\n                                anchorX: f,\n                                anchorY: m,\n                                boxWidth: g,\n                                point: r,\n                                rank: S(s.rank, h ? 1 : 0),\n                                size: e,\n                                target: s.y,\n                                tt: d,\n                                x: s.x\n                            });\n                        } else d.isActive = !1;\n                    }\n                    return t;\n                }, []);\n                !C && B.some((t)=>{\n                    let { outside: e } = i, s = (e ? L : 0) + t.anchorX;\n                    return s < w.left && s + t.boxWidth < w.right || s < L - w.left + t.boxWidth && w.right - s > s;\n                }) && (B = B.map((t)=>{\n                    let { x: e, y: i } = I(t.anchorX, t.anchorY, t.point.isHeader, t.boxWidth, !1);\n                    return f(t, {\n                        target: i,\n                        x: e\n                    });\n                })), i.cleanSplit(), d(B, j);\n                let R = {\n                    left: L,\n                    right: L\n                };\n                B.forEach(function(t) {\n                    let { x: e, boxWidth: s, isHeader: o } = t;\n                    !o && (i.outside && L + e < R.left && (R.left = L + e), !o && i.outside && R.left + s > R.right && (R.right = L + e));\n                }), B.forEach(function(t) {\n                    let { x: e, anchorX: s, anchorY: o, pos: r, point: { isHeader: n } } = t, a = {\n                        visibility: void 0 === r ? \"hidden\" : \"inherit\",\n                        x: e,\n                        y: (r || 0) + D,\n                        anchorX: s,\n                        anchorY: o\n                    };\n                    if (i.outside && e < s) {\n                        let t = L - R.left;\n                        t > 0 && (n || (a.x = e + t, a.anchorX = s + t), n && (a.x = (R.right - R.left) / 2, a.anchorX = s + t));\n                    }\n                    t.tt.attr(a);\n                });\n                let { container: z, outside: N, renderer: W } = i;\n                if (N && z && W) {\n                    let { width: t, height: e, x: i, y: s } = T.getBBox();\n                    W.setSize(t + i, e + s, !1), z.style.left = R.left + \"px\", z.style.top = O + \"px\";\n                }\n                l && T.attr({\n                    opacity: 1 === T.opacity ? .999 : 1\n                });\n            }\n            drawTracker() {\n                if (!this.shouldStickOnContact()) {\n                    this.tracker && (this.tracker = this.tracker.destroy());\n                    return;\n                }\n                let t = this.chart, e = this.label, i = this.shared ? t.hoverPoints : t.hoverPoint;\n                if (!e || !i) return;\n                let s = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0\n                }, o = this.getAnchor(i), r = e.getBBox();\n                o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass(\"highcharts-tracker\").add(e), t.styledMode || this.tracker.attr({\n                    fill: \"rgba(0,0,0,0)\"\n                }));\n            }\n            styledModeFormat(t) {\n                return t.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n            }\n            tooltipFooterHeaderFormatter(t, e) {\n                let i = t.series, s = i.tooltipOptions, o = i.xAxis, r = o && o.dateTime, a = {\n                    isFooter: e,\n                    labelConfig: t\n                }, h = s.xDateFormat, l = s[e ? \"footerFormat\" : \"headerFormat\"];\n                return m(this, \"headerFormatter\", a, function(e) {\n                    r && !h && y(t.key) && (h = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && h && (t.point && t.point.tooltipDateKeys || [\n                        \"key\"\n                    ]).forEach(function(t) {\n                        l = l.replace(\"{point.\" + t + \"}\", \"{point.\" + t + \":\" + h + \"}\");\n                    }), i.chart.styledMode && (l = this.styledModeFormat(l)), e.text = n(l, {\n                        point: t,\n                        series: i\n                    }, this.chart);\n                }), a.text;\n            }\n            update(t) {\n                this.destroy(), this.init(this.chart, v(!0, this.options, t));\n            }\n            updatePosition(t) {\n                let { chart: e, container: i, distance: s, options: o, renderer: r } = this, { height: n = 0, width: a = 0 } = this.getLabel(), h = e.pointer, { left: l, top: d, scaleX: c, scaleY: p } = h.getChartPosition(), g = (o.positioner || this.getPosition).call(this, a, n, t), f = (t.plotX || 0) + e.plotLeft, m = (t.plotY || 0) + e.plotTop, x;\n                r && i && (o.positioner && (g.x += l - s, g.y += d - s), x = (o.borderWidth || 0) + 2 * s + 2, r.setSize(a + x, n + x, !1), (1 !== c || 1 !== p) && (u(i, {\n                    transform: \"scale(\".concat(c, \", \").concat(p, \")\")\n                }), f *= c, m *= p), f += l - g.x, m += d - g.y), this.move(Math.round(g.x), Math.round(g.y || 0), f, m);\n            }\n            constructor(t, e){\n                this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e);\n            }\n        }\n        return (r = w || (w = {})).compose = function t(e) {\n            k(a, t) && c(e, \"afterInit\", function() {\n                let t = this.chart;\n                t.options.tooltip && (t.tooltip = new r(t, t.options.tooltip));\n            });\n        }, w;\n    }), i(e, \"Core/Series/Point.js\", [\n        e[\"Core/Renderer/HTML/AST.js\"],\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Templating.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o) {\n        let { animObject: r } = e, { defaultOptions: n } = i, { format: a } = s, { addEvent: h, defined: l, erase: d, extend: c, fireEvent: p, getNestedProperty: u, isArray: g, isFunction: f, isNumber: m, isObject: x, merge: y, objectEach: b, pick: v, syncTimeout: S, removeEvent: k, uniqueKey: M } = o;\n        class C {\n            animateBeforeDestroy() {\n                let t = this, e = {\n                    x: t.startXPos,\n                    opacity: 0\n                }, i = t.getGraphicalProps();\n                i.singular.forEach(function(i) {\n                    t[i] = t[i].animate(\"dataLabel\" === i ? {\n                        x: t[i].startXPos,\n                        y: t[i].startYPos,\n                        opacity: 0\n                    } : e);\n                }), i.plural.forEach(function(e) {\n                    t[e].forEach(function(e) {\n                        e.element && e.animate(c({\n                            x: t.startXPos\n                        }, e.startYPos ? {\n                            x: e.startXPos,\n                            y: e.startYPos\n                        } : {}));\n                    });\n                });\n            }\n            applyOptions(t, e) {\n                let i = this.series, s = i.options.pointValKey || i.pointValKey;\n                return c(this, t = C.prototype.optionsToObject.call(this, t)), this.options = this.options ? c(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = C.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = \"select\"), \"name\" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? void 0 === e ? this.x = i.autoIncrement() : this.x = e : m(t.x) && i.options.relativeXValue && (this.x = i.autoIncrement(t.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? \"null\" : \"point\", this;\n            }\n            destroy() {\n                if (!this.destroyed) {\n                    let t = this, e = t.series, i = e.chart, s = e.options.dataSorting, o = i.hoverPoints, n = t.series.chart.renderer.globalAnimation, a = r(n), h = ()=>{\n                        for(let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (k(t), t.destroyElements()), t)delete t[e];\n                    };\n                    t.legendItem && i.legend.destroyItem(t), o && (t.setState(), d(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), S(h, a.duration)) : h(), i.pointCount--;\n                }\n                this.destroyed = !0;\n            }\n            destroyElements(t) {\n                let e = this, i = e.getGraphicalProps(t);\n                i.singular.forEach(function(t) {\n                    e[t] = e[t].destroy();\n                }), i.plural.forEach(function(t) {\n                    e[t].forEach(function(t) {\n                        t && t.element && t.destroy();\n                    }), delete e[t];\n                });\n            }\n            firePointEvent(t, e, i) {\n                let s = this, o = this.series, r = o.options;\n                (r.point.events[t] || s.options && s.options.events && s.options.events[t]) && s.importEvents(), \"click\" === t && r.allowPointSelect && (i = function(t) {\n                    !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);\n                }), p(s, t, e, i);\n            }\n            getClassName() {\n                return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n            }\n            getGraphicalProps(t) {\n                let e, i;\n                let s = this, o = [], r = {\n                    singular: [],\n                    plural: []\n                };\n                for((t = t || {\n                    graphic: 1,\n                    dataLabel: 1\n                }).graphic && o.push(\"graphic\", \"connector\"), t.dataLabel && o.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\"), i = o.length; i--;)s[e = o[i]] && r.singular.push(e);\n                return [\n                    \"graphic\",\n                    \"dataLabel\"\n                ].forEach(function(e) {\n                    let i = e + \"s\";\n                    t[e] && s[i] && r.plural.push(i);\n                }), r;\n            }\n            getLabelConfig() {\n                return {\n                    x: this.category,\n                    y: this.y,\n                    color: this.color,\n                    colorIndex: this.colorIndex,\n                    key: this.name || this.category,\n                    series: this.series,\n                    point: this,\n                    percentage: this.percentage,\n                    total: this.total || this.stackTotal\n                };\n            }\n            getNestedProperty(t) {\n                return t ? 0 === t.indexOf(\"custom.\") ? u(t, this.options) : this[t] : void 0;\n            }\n            getZone() {\n                let t = this.series, e = t.zones, i = t.zoneAxis || \"y\", s, o = 0;\n                for(s = e[0]; this[i] >= s.value;)s = e[++o];\n                return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;\n            }\n            hasNewShapeType() {\n                let t = this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName);\n                return t !== this.shapeType;\n            }\n            isValid() {\n                return (m(this.x) || this.x instanceof Date) && m(this.y);\n            }\n            optionsToObject(t) {\n                let e = this.series, i = e.options.keys, s = i || e.pointArrayMap || [\n                    \"y\"\n                ], o = s.length, r = {}, n, a = 0, h = 0;\n                if (m(t) || null === t) r[s[0]] = t;\n                else if (g(t)) for(!i && t.length > o && (\"string\" == (n = typeof t[0]) ? r.name = t[0] : \"number\" === n && (r.x = t[0]), a++); h < o;)i && void 0 === t[a] || (s[h].indexOf(\".\") > 0 ? C.prototype.setNestedProperty(r, t[a], s[h]) : r[s[h]] = t[a]), a++, h++;\n                else \"object\" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = ()=>!0), t.marker && (e._hasPointMarkers = !0));\n                return r;\n            }\n            pos(t) {\n                let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.plotY;\n                if (!this.destroyed) {\n                    let { plotX: i, series: s } = this, { chart: o, xAxis: r, yAxis: n } = s, a = 0, h = 0;\n                    if (m(i) && m(e)) return t && (a = r ? r.pos : o.plotLeft, h = n ? n.pos : o.plotTop), o.inverted && r && n ? [\n                        n.len - e + h,\n                        r.len - i + a\n                    ] : [\n                        i + a,\n                        e + h\n                    ];\n                }\n            }\n            resolveColor() {\n                let t = this.series, e = t.chart.options.chart, i = t.chart.styledMode, s, o, r = e.colorCount, n;\n                delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), n = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), n = t.colorIndex), this.colorIndex = v(this.options.colorIndex, n), this.color = v(this.options.color, s);\n            }\n            setNestedProperty(t, e, i) {\n                let s = i.split(\".\");\n                return s.reduce(function(t, i, s, o) {\n                    let r = o.length - 1 === s;\n                    return t[i] = r ? e : x(t[i], !0) ? t[i] : {}, t[i];\n                }, t), t;\n            }\n            shouldDraw() {\n                return !this.isNull;\n            }\n            tooltipFormatter(t) {\n                let e = this.series, i = e.tooltipOptions, s = v(i.valueDecimals, \"\"), o = i.valuePrefix || \"\", r = i.valueSuffix || \"\";\n                return e.chart.styledMode && (t = e.chart.tooltip.styledModeFormat(t)), (e.pointArrayMap || [\n                    \"y\"\n                ]).forEach(function(e) {\n                    e = \"{point.\" + e, (o || r) && (t = t.replace(RegExp(e + \"}\", \"g\"), o + e + \"}\" + r)), t = t.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + s + \"f}\");\n                }), a(t, {\n                    point: this,\n                    series: this.series\n                }, e.chart);\n            }\n            update(t, e, i, s) {\n                let o;\n                let r = this, n = r.series, a = r.graphic, h = n.chart, l = n.options;\n                function d() {\n                    r.applyOptions(t);\n                    let s = a && r.hasMockGraphic, d = null === r.y ? !s : s;\n                    a && d && (r.graphic = a.destroy(), delete r.hasMockGraphic), x(t, !0) && (a && a.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = a.destroy()), (t === null || t === void 0 ? void 0 : t.dataLabels) && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index, n.updateParallelArrays(r, o), l.data[o] = x(l.data[o], !0) || x(t, !0) ? r.options : v(t, l.data[o]), n.isDirty = n.isDirtyData = !0, !n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0), \"point\" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);\n                }\n                e = v(e, !0), !1 === s ? d() : r.firePointEvent(\"update\", {\n                    options: t\n                }, d);\n            }\n            remove(t, e) {\n                this.series.removePoint(this.series.data.indexOf(this), t, e);\n            }\n            select(t, e) {\n                let i = this, s = i.series, o = s.chart;\n                t = v(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? \"select\" : \"unselect\", {\n                    accumulate: e\n                }, function() {\n                    i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && \"select\"), e || o.getSelectedPoints().forEach(function(t) {\n                        let e = t.series;\n                        t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? \"inactive\" : \"\"), t.firePointEvent(\"unselect\"));\n                    });\n                }), delete this.selectedStaging;\n            }\n            onMouseOver(t) {\n                let e = this.series, i = e.chart, s = i.pointer;\n                t = t ? s.normalize(t) : s.getChartCoordinatesFromPoint(this, i.inverted), s.runPointActions(t, this);\n            }\n            onMouseOut() {\n                let t = this.series.chart;\n                this.firePointEvent(\"mouseOut\"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function(t) {\n                    t.setState();\n                }), t.hoverPoints = t.hoverPoint = null;\n            }\n            importEvents() {\n                if (!this.hasImportedEvents) {\n                    let t = this, e = y(t.series.options.point, t.options), i = e.events;\n                    t.events = i, b(i, function(e, i) {\n                        f(e) && h(t, i, e);\n                    }), this.hasImportedEvents = !0;\n                }\n            }\n            setState(e, i) {\n                let s = this.series, o = this.state, r = s.options.states[e || \"normal\"] || {}, a = n.plotOptions[s.type].marker && s.options.marker, h = a && !1 === a.enabled, l = a && a.states && a.states[e || \"normal\"] || {}, d = !1 === l.enabled, u = this.marker || {}, g = s.chart, f = a && s.markerAttribs, x = s.halo, y, b, S, k = s.stateMarkerGraphic, M;\n                if ((e = e || \"\") === this.state && !i || this.selected && \"select\" !== e || !1 === r.enabled || e && (d || h && !1 === l.enabled) || e && u.states && u.states[e] && !1 === u.states[e].enabled) return;\n                if (this.state = e, f && (y = s.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {\n                    if (o && this.graphic.removeClass(\"highcharts-point-\" + o), e && this.graphic.addClass(\"highcharts-point-\" + e), !g.styledMode) {\n                        b = s.pointAttribs(this, e), S = v(g.options.chart.animation, r.animation);\n                        let t = b.opacity;\n                        s.options.inactiveOtherPoints && m(t) && (this.dataLabels || []).forEach(function(e) {\n                            e && !e.hasClass(\"highcharts-data-label-hidden\") && (e.animate({\n                                opacity: t\n                            }, S), e.connector && e.connector.animate({\n                                opacity: t\n                            }, S));\n                        }), this.graphic.animate(b, S);\n                    }\n                    y && this.graphic.animate(y, v(g.options.chart.animation, l.animation, a.animation)), k && k.hide();\n                } else e && l && (M = u.symbol || s.symbol, k && k.currentSymbol !== M && (k = k.destroy()), y && (k ? k[i ? \"animate\" : \"attr\"]({\n                    x: y.x,\n                    y: y.y\n                }) : M && (s.stateMarkerGraphic = k = g.renderer.symbol(M, y.x, y.y, y.width, y.height).add(s.markerGroup), k.currentSymbol = M)), !g.styledMode && k && \"inactive\" !== this.state && k.attr(s.pointAttribs(this, e))), k && (k[e && this.isInside ? \"show\" : \"hide\"](), k.element.point = this, k.addClass(this.getClassName(), !0));\n                let C = r.halo, w = this.graphic || k, T = w && w.visibility || \"inherit\";\n                C && C.size && w && \"hidden\" !== T && !this.isCluster ? (x || (s.halo = x = g.renderer.path().add(w.parentGroup)), x.show()[i ? \"animate\" : \"attr\"]({\n                    d: this.haloPath(C.size)\n                }), x.attr({\n                    class: \"highcharts-halo highcharts-color-\" + v(this.colorIndex, s.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n                    visibility: T,\n                    zIndex: -1\n                }), x.point = this, g.styledMode || x.attr(c({\n                    fill: this.color || s.color,\n                    \"fill-opacity\": C.opacity\n                }, t.filterUserAttributes(C.attributes || {})))) : x && x.point && x.point.haloPath && x.animate({\n                    d: x.point.haloPath(0)\n                }, null, x.hide), p(this, \"afterSetState\", {\n                    state: e\n                });\n            }\n            haloPath(t) {\n                let e = this.pos();\n                return e ? this.series.chart.renderer.symbols.circle(Math.floor(e[0]) - t, e[1] - t, 2 * t, 2 * t) : [];\n            }\n            constructor(t, e, i){\n                var _this_id;\n                this.formatPrefix = \"point\", this.visible = !0, this.series = t, this.applyOptions(e, i), (_this_id = this.id) !== null && _this_id !== void 0 ? _this_id : this.id = M(), this.resolveColor(), t.chart.pointCount++, p(this, \"afterInit\");\n            }\n        }\n        return C;\n    }), i(e, \"Core/Pointer.js\", [\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        var s;\n        let { parse: o } = t, { charts: r, composed: n, noop: a } = e, { addEvent: h, attr: l, css: d, defined: c, extend: p, find: u, fireEvent: g, isNumber: f, isObject: m, objectEach: x, offset: y, pick: b, pushUnique: v, splat: S } = i;\n        class k {\n            applyInactiveState(t) {\n                let e = [], i;\n                (t || []).forEach(function(t) {\n                    i = t.series, e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && (e = e.concat(i.linkedSeries)), i.navigatorSeries && e.push(i.navigatorSeries);\n                }), this.chart.series.forEach(function(t) {\n                    -1 === e.indexOf(t) ? t.setState(\"inactive\", !0) : t.options.inactiveOtherPoints && t.setAllPointsToState(\"inactive\");\n                });\n            }\n            destroy() {\n                let t = this;\n                this.eventsToUnbind.forEach((t)=>t()), this.eventsToUnbind = [], !e.chartCount && (k.unbindDocumentMouseUp && (k.unbindDocumentMouseUp = k.unbindDocumentMouseUp()), k.unbindDocumentTouchEnd && (k.unbindDocumentTouchEnd = k.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), x(t, function(e, i) {\n                    t[i] = void 0;\n                });\n            }\n            getSelectionMarkerAttrs(t, e) {\n                let i = {\n                    args: {\n                        chartX: t,\n                        chartY: e\n                    },\n                    attrs: {},\n                    shapeType: \"rect\"\n                };\n                return g(this, \"getSelectionMarkerAttrs\", i, (i)=>{\n                    let s;\n                    let { chart: o, mouseDownX: r = 0, mouseDownY: n = 0, zoomHor: a, zoomVert: h } = this, l = i.attrs;\n                    l.x = o.plotLeft, l.y = o.plotTop, l.width = a ? 1 : o.plotWidth, l.height = h ? 1 : o.plotHeight, a && (s = t - r, l.width = Math.abs(s), l.x = (s > 0 ? 0 : s) + r), h && (s = e - n, l.height = Math.abs(s), l.y = (s > 0 ? 0 : s) + n);\n                }), i;\n            }\n            drag(t) {\n                let e = this.chart, i = e.options.chart, s = e.plotLeft, r = e.plotTop, n = e.plotWidth, a = e.plotHeight, h = this.mouseDownX || 0, l = this.mouseDownY || 0, d = m(i.panning) ? i.panning && i.panning.enabled : i.panning, c = i.panKey && t[i.panKey + \"Key\"], p = t.chartX, u = t.chartY, g, f = this.selectionMarker;\n                if ((!f || !f.touch) && (p < s ? p = s : p > s + n && (p = s + n), u < r ? u = r : u > r + a && (u = r + a), this.hasDragged = Math.sqrt(Math.pow(h - p, 2) + Math.pow(l - u, 2)), this.hasDragged > 10)) {\n                    g = e.isInsidePlot(h - s, l - r, {\n                        visiblePlotOnly: !0\n                    });\n                    let { shapeType: n, attrs: a } = this.getSelectionMarkerAttrs(p, u);\n                    (e.hasCartesianSeries || e.mapView) && (this.zoomX || this.zoomY) && g && !c && !f && (this.selectionMarker = f = e.renderer[n](), f.attr({\n                        class: \"highcharts-selection-marker\",\n                        zIndex: 7\n                    }).add(), e.styledMode || f.attr({\n                        fill: i.selectionMarkerFill || o(\"#334eff\").setOpacity(.25).get()\n                    })), f && f.attr(a), g && !f && d && e.pan(t, i.panning);\n                }\n            }\n            dragStart(t) {\n                let e = this.chart;\n                e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = this.mouseDownX = t.chartX, e.mouseDownY = this.mouseDownY = t.chartY;\n            }\n            getSelectionBox(t) {\n                let e = {\n                    args: {\n                        marker: t\n                    },\n                    result: {}\n                };\n                return g(this, \"getSelectionBox\", e, (e)=>{\n                    e.result = {\n                        x: t.attr ? +t.attr(\"x\") : t.x,\n                        y: t.attr ? +t.attr(\"y\") : t.y,\n                        width: t.attr ? t.attr(\"width\") : t.width,\n                        height: t.attr ? t.attr(\"height\") : t.height\n                    };\n                }), e.result;\n            }\n            drop(t) {\n                let e = this, i = this.chart, s = this.hasPinched;\n                if (this.selectionMarker) {\n                    let { x: o, y: r, width: n, height: a } = this.getSelectionBox(this.selectionMarker), h = {\n                        originalEvent: t,\n                        xAxis: [],\n                        yAxis: [],\n                        x: o,\n                        y: r,\n                        width: n,\n                        height: a\n                    }, l = !!i.mapView;\n                    (this.hasDragged || s) && (i.axes.forEach(function(i) {\n                        if (i.zoomEnabled && c(i.min) && (s || e[({\n                            xAxis: \"zoomX\",\n                            yAxis: \"zoomY\"\n                        })[i.coll]]) && f(o) && f(r) && f(n) && f(a)) {\n                            let e = i.horiz, s = \"touchend\" === t.type ? i.minPixelPadding : 0, d = i.toValue((e ? o : r) + s), c = i.toValue((e ? o + n : r + a) - s);\n                            h[i.coll].push({\n                                axis: i,\n                                min: Math.min(d, c),\n                                max: Math.max(d, c)\n                            }), l = !0;\n                        }\n                    }), l && g(i, \"selection\", h, function(t) {\n                        i.zoom(p(t, s ? {\n                            animation: !1\n                        } : null));\n                    })), f(i.index) && (this.selectionMarker = this.selectionMarker.destroy()), s && this.scaleGroups();\n                }\n                i && f(i.index) && (d(i.container, {\n                    cursor: i._cursor\n                }), i.cancelClick = +this.hasDragged > 10, i.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n            }\n            findNearestKDPoint(t, e, i) {\n                let s;\n                return t.forEach(function(t) {\n                    let o = t.noSharedTooltip && e, r = !o && 0 > t.options.findNearestPointBy.indexOf(\"y\"), n = t.searchPoint(i, r);\n                    m(n, !0) && n.series && (!m(s, !0) || function(t, i) {\n                        let s = t.distX - i.distX, o = t.dist - i.dist, r = (i.series.group && i.series.group.zIndex) - (t.series.group && t.series.group.zIndex);\n                        return 0 !== s && e ? s : 0 !== o ? o : 0 !== r ? r : t.series.index > i.series.index ? -1 : 1;\n                    }(s, n) > 0) && (s = n);\n                }), s;\n            }\n            getChartCoordinatesFromPoint(t, e) {\n                let i = t.series, s = i.xAxis, o = i.yAxis, r = t.shapeArgs;\n                if (s && o) {\n                    let i = b(t.clientX, t.plotX), n = t.plotY || 0;\n                    return t.isNode && r && f(r.x) && f(r.y) && (i = r.x, n = r.y), e ? {\n                        chartX: o.len + o.pos - n,\n                        chartY: s.len + s.pos - i\n                    } : {\n                        chartX: i + s.pos,\n                        chartY: n + o.pos\n                    };\n                }\n                if (r && r.x && r.y) return {\n                    chartX: r.x,\n                    chartY: r.y\n                };\n            }\n            getChartPosition() {\n                if (this.chartPosition) return this.chartPosition;\n                let { container: t } = this.chart, e = y(t);\n                this.chartPosition = {\n                    left: e.left,\n                    top: e.top,\n                    scaleX: 1,\n                    scaleY: 1\n                };\n                let i = t.offsetWidth, s = t.offsetHeight;\n                return i > 2 && s > 2 && (this.chartPosition.scaleX = e.width / i, this.chartPosition.scaleY = e.height / s), this.chartPosition;\n            }\n            getCoordinates(t) {\n                let e = {\n                    xAxis: [],\n                    yAxis: []\n                };\n                return this.chart.axes.forEach(function(i) {\n                    e[i.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n                        axis: i,\n                        value: i.toValue(t[i.horiz ? \"chartX\" : \"chartY\"])\n                    });\n                }), e;\n            }\n            getHoverData(t, e, i, s, o, r) {\n                let n = [], a = function(t) {\n                    return t.visible && !(!o && t.directTouch) && b(t.options.enableMouseTracking, !0);\n                }, h = e, l, d = {\n                    chartX: r ? r.chartX : void 0,\n                    chartY: r ? r.chartY : void 0,\n                    shared: o\n                };\n                g(this, \"beforeGetHoverData\", d);\n                let c = h && !h.stickyTracking;\n                l = c ? [\n                    h\n                ] : i.filter((t)=>t.stickyTracking && (d.filter || a)(t));\n                let p = s && t || !r ? t : this.findNearestKDPoint(l, o, r);\n                return h = p && p.series, p && (o && !h.noSharedTooltip ? (l = i.filter(function(t) {\n                    return d.filter ? d.filter(t) : a(t) && !t.noSharedTooltip;\n                })).forEach(function(t) {\n                    let e = u(t.points, function(t) {\n                        return t.x === p.x && !t.isNull;\n                    });\n                    m(e) && (t.boosted && t.boost && (e = t.boost.getPoint(e)), n.push(e));\n                }) : n.push(p)), g(this, \"afterGetHoverData\", d = {\n                    hoverPoint: p\n                }), {\n                    hoverPoint: d.hoverPoint,\n                    hoverSeries: h,\n                    hoverPoints: n\n                };\n            }\n            getPointFromEvent(t) {\n                let e = t.target, i;\n                for(; e && !i;)i = e.point, e = e.parentNode;\n                return i;\n            }\n            onTrackerMouseOut(t) {\n                let e = this.chart, i = t.relatedTarget, s = e.hoverSeries;\n                this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, \"highcharts-tooltip\") || this.inClass(i, \"highcharts-series-\" + s.index) && this.inClass(i, \"highcharts-tracker\") || s.onMouseOut();\n            }\n            inClass(t, e) {\n                let i = t, s;\n                for(; i;){\n                    if (s = l(i, \"class\")) {\n                        if (-1 !== s.indexOf(e)) return !0;\n                        if (-1 !== s.indexOf(\"highcharts-container\")) return !1;\n                    }\n                    i = i.parentElement;\n                }\n            }\n            normalize(t, e) {\n                let i = t.touches, s = i ? i.length ? i.item(0) : b(i.changedTouches, t.changedTouches)[0] : t;\n                e || (e = this.getChartPosition());\n                let o = s.pageX - e.left, r = s.pageY - e.top;\n                return p(t, {\n                    chartX: Math.round(o /= e.scaleX),\n                    chartY: Math.round(r /= e.scaleY)\n                });\n            }\n            onContainerClick(t) {\n                let e = this.chart, i = e.hoverPoint, s = this.normalize(t), o = e.plotLeft, r = e.plotTop;\n                !e.cancelClick && (i && this.inClass(s.target, \"highcharts-tracker\") ? (g(i.series, \"click\", p(s, {\n                    point: i\n                })), e.hoverPoint && i.firePointEvent(\"click\", s)) : (p(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {\n                    visiblePlotOnly: !0\n                }) && g(e, \"click\", s)));\n            }\n            onContainerMouseDown(t) {\n                let i = (1 & (t.buttons || t.button)) == 1;\n                t = this.normalize(t), e.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || i) && (this.zoomOption(t), i && t.preventDefault && t.preventDefault(), this.dragStart(t));\n            }\n            onContainerMouseLeave(t) {\n                let e = r[b(k.hoverChartIndex, -1)];\n                t = this.normalize(t), this.onContainerMouseMove(t), e && t.relatedTarget && !this.inClass(t.relatedTarget, \"highcharts-tooltip\") && (e.pointer.reset(), e.pointer.chartPosition = void 0);\n            }\n            onContainerMouseEnter(t) {\n                delete this.chartPosition;\n            }\n            onContainerMouseMove(t) {\n                let e = this.chart, i = e.tooltip, s = this.normalize(t);\n                this.setHoverChartIndex(t), (\"mousedown\" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.openMenu && (this.inClass(s.target, \"highcharts-tracker\") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {\n                    visiblePlotOnly: !0\n                })) && !(i && i.shouldStickOnContact(s)) && (this.inClass(s.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(s));\n            }\n            onDocumentTouchEnd(t) {\n                let e = r[b(k.hoverChartIndex, -1)];\n                e && e.pointer.drop(t);\n            }\n            onContainerTouchMove(t) {\n                this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);\n            }\n            onContainerTouchStart(t) {\n                this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));\n            }\n            onDocumentMouseMove(t) {\n                let e = this.chart, i = e.tooltip, s = this.chartPosition, o = this.normalize(t, s);\n                !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {\n                    visiblePlotOnly: !0\n                }) || i && i.shouldStickOnContact(o) || this.inClass(o.target, \"highcharts-tracker\") || this.reset();\n            }\n            onDocumentMouseUp(t) {\n                let e = r[b(k.hoverChartIndex, -1)];\n                e && e.pointer.drop(t);\n            }\n            pinch(t) {\n                let e = this, i = e.chart, s = e.pinchDown, o = t.touches || [], r = o.length, n = e.lastValidTouch, h = e.hasZoom, l = {}, d = 1 === r && (e.inClass(t.target, \"highcharts-tracker\") && i.runTrackerClick || e.runChartClick), c = {}, u = e.chart.tooltip, f = 1 === r && b(u && u.options.followTouchMove, !0), m = e.selectionMarker;\n                r > 1 ? e.initiated = !0 : f && (e.initiated = !1), h && e.initiated && !d && !1 !== t.cancelable && t.preventDefault(), [].map.call(o, function(t) {\n                    return e.normalize(t);\n                }), \"touchstart\" === t.type ? ([].forEach.call(o, function(t, e) {\n                    s[e] = {\n                        chartX: t.chartX,\n                        chartY: t.chartY\n                    };\n                }), n.x = [\n                    s[0].chartX,\n                    s[1] && s[1].chartX\n                ], n.y = [\n                    s[0].chartY,\n                    s[1] && s[1].chartY\n                ], i.axes.forEach(function(t) {\n                    if (t.zoomEnabled) {\n                        let e = i.bounds[t.horiz ? \"h\" : \"v\"], s = t.minPixelPadding, o = t.toPixels(Math.min(b(t.options.min, t.dataMin), t.dataMin)), r = t.toPixels(Math.max(b(t.options.max, t.dataMax), t.dataMax)), n = Math.min(o, r), a = Math.max(o, r);\n                        e.min = Math.min(t.pos, n - s), e.max = Math.max(t.pos + t.len, a + s);\n                    }\n                }), e.res = !0) : f ? this.runPointActions(e.normalize(t)) : s.length && (g(i, \"touchpan\", {\n                    originalEvent: t\n                }, ()=>{\n                    m || (e.selectionMarker = m = p({\n                        destroy: a,\n                        touch: !0\n                    }, i.plotBox)), e.pinchTranslate(s, o, l, m, c, n), e.hasPinched = h, e.scaleGroups(l, c);\n                }), e.res && (e.res = !1, this.reset(!1, 0)));\n            }\n            pinchTranslate(t, e, i, s, o, r) {\n                this.zoomHor && this.pinchTranslateDirection(!0, t, e, i, s, o, r), this.zoomVert && this.pinchTranslateDirection(!1, t, e, i, s, o, r);\n            }\n            pinchTranslateDirection(t, e, i, s, o, r, n, a) {\n                let h = this.chart, l = t ? \"x\" : \"y\", d = t ? \"X\" : \"Y\", c = \"chart\" + d, p = t ? \"width\" : \"height\", u = h[\"plot\" + (t ? \"Left\" : \"Top\")], g = h.inverted, f = h.bounds[t ? \"h\" : \"v\"], m = 1 === e.length, x = e[0][c], y = !m && e[1][c], b = function() {\n                    \"number\" == typeof w && Math.abs(x - y) > 20 && (M = a || Math.abs(C - w) / Math.abs(x - y)), k = (u - C) / M + x, v = h[\"plot\" + (t ? \"Width\" : \"Height\")] / M;\n                }, v, S, k, M = a || 1, C = i[0][c], w = !m && i[1][c], T;\n                b(), (S = k) < f.min ? (S = f.min, T = !0) : S + v > f.max && (S = f.max - v, T = !0), T ? (C -= .8 * (C - n[l][0]), \"number\" == typeof w && (w -= .8 * (w - n[l][1])), b()) : n[l] = [\n                    C,\n                    w\n                ], g || (r[l] = k - u, r[p] = v);\n                let A = g ? t ? \"scaleY\" : \"scaleX\" : \"scale\" + d, P = g ? 1 / M : M;\n                o[p] = v, o[l] = S, s[A] = M * (g && !t ? -1 : 1), s[\"translate\" + d] = P * u + (C - P * x);\n            }\n            reset(t, e) {\n                let i = this.chart, s = i.hoverSeries, o = i.hoverPoint, r = i.hoverPoints, n = i.tooltip, a = n && n.shared ? r : o;\n                t && a && S(a).forEach(function(e) {\n                    e.series.isCartesian && void 0 === e.plotX && (t = !1);\n                }), t ? n && a && S(a).length && (n.refresh(a), n.shared && r ? r.forEach(function(t) {\n                    t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));\n                }) : o && (o.setState(o.state, !0), i.axes.forEach(function(t) {\n                    t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);\n                }))) : (o && o.onMouseOut(), r && r.forEach(function(t) {\n                    t.setState();\n                }), s && s.onMouseOut(), n && n.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function(t) {\n                    t.hideCrosshair();\n                }), this.hoverX = i.hoverPoints = i.hoverPoint = null);\n            }\n            runPointActions(t, e, i) {\n                let s = this.chart, o = s.series, n = s.tooltip && s.tooltip.options.enabled ? s.tooltip : void 0, a = !!n && n.shared, l = e || s.hoverPoint, d = l && l.series || s.hoverSeries, c = (!t || \"touchmove\" !== t.type) && (!!e || d && d.directTouch && this.isDirectTouch), p = this.getHoverData(l, d, o, c, a, t);\n                l = p.hoverPoint, d = p.hoverSeries;\n                let g = p.hoverPoints, f = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split, m = a && d && !d.noSharedTooltip;\n                if (l && (i || l !== s.hoverPoint || n && n.isHidden)) {\n                    if ((s.hoverPoints || []).forEach(function(t) {\n                        -1 === g.indexOf(t) && t.setState();\n                    }), s.hoverSeries !== d && d.onMouseOver(), this.applyInactiveState(g), (g || []).forEach(function(t) {\n                        t.setState(\"hover\");\n                    }), s.hoverPoint && s.hoverPoint.firePointEvent(\"mouseOut\"), !l.series) return;\n                    s.hoverPoints = g, s.hoverPoint = l, l.firePointEvent(\"mouseOver\", void 0, ()=>{\n                        n && l && n.refresh(m ? g : l, t);\n                    });\n                } else if (f && n && !n.isHidden) {\n                    let e = n.getAnchor([\n                        {}\n                    ], t);\n                    s.isInsidePlot(e[0], e[1], {\n                        visiblePlotOnly: !0\n                    }) && n.updatePosition({\n                        plotX: e[0],\n                        plotY: e[1]\n                    });\n                }\n                this.unDocMouseMove || (this.unDocMouseMove = h(s.container.ownerDocument, \"mousemove\", function(t) {\n                    let e = r[k.hoverChartIndex];\n                    e && e.pointer.onDocumentMouseMove(t);\n                }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function(e) {\n                    let i;\n                    let o = b((e.crosshair || {}).snap, !0);\n                    !o || (i = s.hoverPoint) && i.series[e.coll] === e || (i = u(g, (t)=>t.series && t.series[e.coll] === e)), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();\n                });\n            }\n            scaleGroups(t, e) {\n                let i = this.chart;\n                i.series.forEach(function(s) {\n                    let o = t || s.getPlotBox(\"series\");\n                    s.group && (s.xAxis && s.xAxis.zoomEnabled || i.mapView) && (s.group.attr(o), s.markerGroup && (s.markerGroup.attr(t || s.getPlotBox(\"marker\")), s.markerGroup.clip(e ? i.clipRect : null)), s.dataLabelsGroup && s.dataLabelsGroup.attr(o));\n                }), i.clipRect.attr(e || i.clipBox);\n            }\n            setDOMEvents() {\n                let t = this.chart.container, i = t.ownerDocument;\n                t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(h(t, \"mouseenter\", this.onContainerMouseEnter.bind(this))), this.eventsToUnbind.push(h(t, \"mouseleave\", this.onContainerMouseLeave.bind(this))), k.unbindDocumentMouseUp || (k.unbindDocumentMouseUp = h(i, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n                let s = this.chart.renderTo.parentElement;\n                for(; s && \"BODY\" !== s.tagName;)this.eventsToUnbind.push(h(s, \"scroll\", ()=>{\n                    delete this.chartPosition;\n                })), s = s.parentElement;\n                e.hasTouch && (this.eventsToUnbind.push(h(t, \"touchstart\", this.onContainerTouchStart.bind(this), {\n                    passive: !1\n                })), this.eventsToUnbind.push(h(t, \"touchmove\", this.onContainerTouchMove.bind(this), {\n                    passive: !1\n                })), k.unbindDocumentTouchEnd || (k.unbindDocumentTouchEnd = h(i, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n                    passive: !1\n                })));\n            }\n            setHoverChartIndex(t) {\n                let i = this.chart, s = e.charts[b(k.hoverChartIndex, -1)];\n                s && s !== i && s.pointer.onContainerMouseLeave(t || {\n                    relatedTarget: i.container\n                }), s && s.mouseIsDown || (k.hoverChartIndex = i.index);\n            }\n            touch(t, e) {\n                let i, s;\n                let o = this.chart;\n                this.setHoverChartIndex(), 1 === t.touches.length ? (t = this.normalize(t), o.isInsidePlot(t.chartX - o.plotLeft, t.chartY - o.plotTop, {\n                    visiblePlotOnly: !0\n                }) && !o.openMenu ? (e && this.runPointActions(t), \"touchmove\" === t.type && (i = !!(s = this.pinchDown)[0] && Math.sqrt(Math.pow(s[0].chartX - t.chartX, 2) + Math.pow(s[0].chartY - t.chartY, 2)) >= 4), b(i, !0) && this.pinch(t)) : e && this.reset()) : 2 === t.touches.length && this.pinch(t);\n            }\n            touchSelect(t) {\n                return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);\n            }\n            zoomOption(t) {\n                let e = this.chart, i = (e.options.chart, e.inverted), s = e.zooming.type || \"\", o, r;\n                /touch/.test(t.type) && (s = b(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;\n            }\n            constructor(t, e){\n                var _e_chart_events;\n                this.hasDragged = !1, this.lastValidTouch = {}, this.pinchDown = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!((_e_chart_events = e.chart.events) === null || _e_chart_events === void 0 ? void 0 : _e_chart_events.click), this.pinchDown = [], this.lastValidTouch = {}, this.setDOMEvents(), g(this, \"afterInit\");\n            }\n        }\n        return (s = k || (k = {})).compose = function t(e) {\n            v(n, t) && h(e, \"beforeRender\", function() {\n                this.pointer = new s(this, this.options);\n            });\n        }, k;\n    }), i(e, \"Core/Legend/Legend.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Templating.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Series/Point.js\"],\n        e[\"Core/Renderer/RendererUtilities.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r) {\n        var n;\n        let { animObject: a, setAnimation: h } = t, { format: l } = e, { composed: d, marginNames: c } = i, { distribute: p } = o, { addEvent: u, createElement: g, css: f, defined: m, discardElement: x, find: y, fireEvent: b, isNumber: v, merge: S, pick: k, pushUnique: M, relativeLength: C, stableSort: w, syncTimeout: T } = r;\n        class A {\n            setOptions(t) {\n                let e = k(t.padding, 8);\n                this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = S(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = k(t.symbolWidth, 16), this.pages = [], this.proximate = \"proximate\" === t.layout && !this.chart.inverted, this.baseline = void 0;\n            }\n            update(t, e) {\n                let i = this.chart;\n                this.setOptions(S(!0, this.options, t)), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, k(e, !0) && i.redraw(), b(this, \"afterUpdate\", {\n                    redraw: e\n                });\n            }\n            colorizeItem(t, e) {\n                let { area: i, group: s, label: o, line: r, symbol: n } = t.legendItem || {};\n                if (s === null || s === void 0 ? void 0 : s[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\"), !this.chart.styledMode) {\n                    let { itemHiddenStyle: s = {} } = this, a = s.color, { fillColor: h, fillOpacity: l, lineColor: d, marker: c } = t.options, p = (t)=>(!e && (t.fill && (t.fill = a), t.stroke && (t.stroke = a)), t);\n                    o === null || o === void 0 ? void 0 : o.css(S(e ? this.itemStyle : s)), r === null || r === void 0 ? void 0 : r.attr(p({\n                        stroke: d || t.color\n                    })), n && n.attr(p(c && n.isMarker ? t.pointAttribs() : {\n                        fill: t.color\n                    })), i === null || i === void 0 ? void 0 : i.attr(p({\n                        fill: h || t.color,\n                        \"fill-opacity\": h ? 1 : l !== null && l !== void 0 ? l : .75\n                    }));\n                }\n                b(this, \"afterColorizeItem\", {\n                    item: t,\n                    visible: e\n                });\n            }\n            positionItems() {\n                this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();\n            }\n            positionItem(t) {\n                let { group: e, x: i = 0, y: s = 0 } = t.legendItem || {}, o = this.options, r = o.symbolPadding, n = !o.rtl, a = t.checkbox;\n                if (e && e.element) {\n                    let o = {\n                        translateX: n ? i : this.legendWidth - i - 2 * r - 4,\n                        translateY: s\n                    };\n                    e[m(e.translateY) ? \"animate\" : \"attr\"](o, void 0, ()=>{\n                        b(this, \"afterPositionItem\", {\n                            item: t\n                        });\n                    });\n                }\n                a && (a.x = i, a.y = s);\n            }\n            destroyItem(t) {\n                let e = t.checkbox, i = t.legendItem || {};\n                for (let t of [\n                    \"group\",\n                    \"label\",\n                    \"line\",\n                    \"symbol\"\n                ])i[t] && (i[t] = i[t].destroy());\n                e && x(e), t.legendItem = void 0;\n            }\n            destroy() {\n                for (let t of this.getAllItems())this.destroyItem(t);\n                for (let t of [\n                    \"clipRect\",\n                    \"up\",\n                    \"down\",\n                    \"pager\",\n                    \"nav\",\n                    \"box\",\n                    \"title\",\n                    \"group\"\n                ])this[t] && (this[t] = this[t].destroy());\n                this.display = null;\n            }\n            positionCheckboxes() {\n                let t;\n                let e = this.group && this.group.alignAttr, i = this.clipHeight || this.legendHeight, s = this.titleHeight;\n                e && (t = e.translateY, this.allItems.forEach(function(o) {\n                    let r;\n                    let n = o.checkbox;\n                    n && (r = t + s + n.y + (this.scrollOffset || 0) + 3, f(n, {\n                        left: e.translateX + o.checkboxOffset + n.x - 20 + \"px\",\n                        top: r + \"px\",\n                        display: this.proximate || r > t - 6 && r < t + i - 6 ? \"\" : \"none\"\n                    }));\n                }, this));\n            }\n            renderTitle() {\n                let t = this.options, e = this.padding, i = t.title, s, o = 0;\n                i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, \"legend-title\").attr({\n                    zIndex: 1\n                }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({\n                    width: this.maxLegendWidth + \"px\"\n                }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({\n                    translateY: o\n                })), this.titleHeight = o;\n            }\n            setText(t) {\n                let e = this.options;\n                t.legendItem.label.attr({\n                    text: e.labelFormat ? l(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)\n                });\n            }\n            renderItem(t) {\n                let e = t.legendItem = t.legendItem || {}, i = this.chart, s = i.renderer, o = this.options, r = \"horizontal\" === o.layout, n = this.symbolWidth, a = o.symbolPadding || 0, h = this.itemStyle, l = this.itemHiddenStyle, d = r ? k(o.itemDistance, 20) : 0, c = !o.rtl, p = !t.series, u = !p && t.series.drawLegendSymbol ? t.series : t, g = u.options, f = !!this.createCheckboxForItem && g && g.showCheckbox, m = o.useHTML, x = t.options.className, y = e.label, b = n + a + d + (f ? 20 : 0);\n                !y && (e.group = s.g(\"legend-item\").addClass(\"highcharts-\" + u.type + \"-series highcharts-color-\" + t.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + t.index : \"\")).attr({\n                    zIndex: 1\n                }).add(this.scrollGroup), e.label = y = s.text(\"\", c ? n + a : -a, this.baseline || 0, m), i.styledMode || y.css(S(t.visible ? h : l)), y.attr({\n                    align: c ? \"left\" : \"right\",\n                    zIndex: 2\n                }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr(\"y\", this.baseline), this.symbolHeight = k(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = k(o.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + a + d + (f ? 20 : 0), c && y.attr(\"x\", this.symbolWidth + a))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({\n                    width: (o.itemWidth || this.widthOption || i.spacingBox.width) - b + \"px\"\n                }), this.setText(t);\n                let v = y.getBBox(), M = this.fontMetrics && this.fontMetrics.h || 0;\n                t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * M ? v.height : M));\n            }\n            layoutItem(t) {\n                let e = this.options, i = this.padding, s = \"horizontal\" === e.layout, o = t.itemHeight, r = this.itemMarginBottom, n = this.itemMarginTop, a = s ? k(e.itemDistance, 20) : 0, h = this.maxLegendWidth, l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth, d = t.legendItem || {};\n                s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += n + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = n + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += n + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : a) : l) + i, this.offsetWidth);\n            }\n            getAllItems() {\n                let t = [];\n                return this.chart.series.forEach(function(e) {\n                    let i = e && e.options;\n                    e && k(i.showInLegend, !m(i.linkedTo) && void 0, !0) && (t = t.concat((e.legendItem || {}).labels || (\"point\" === i.legendType ? e.data : e)));\n                }), b(this, \"afterGetAllItems\", {\n                    allItems: t\n                }), t;\n            }\n            getAlignment() {\n                let t = this.options;\n                return this.proximate ? t.align.charAt(0) + \"tv\" : t.floating ? \"\" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);\n            }\n            adjustMargins(t, e) {\n                let i = this.chart, s = this.options, o = this.getAlignment();\n                o && [\n                    /(lth|ct|rth)/,\n                    /(rtv|rm|rbv)/,\n                    /(rbh|cb|lbh)/,\n                    /(lbv|lm|ltv)/\n                ].forEach(function(r, n) {\n                    r.test(o) && !m(t[n]) && (i[c[n]] = Math.max(i[c[n]], i.legend[(n + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [\n                        1,\n                        -1,\n                        -1,\n                        1\n                    ][n] * s[n % 2 ? \"x\" : \"y\"] + k(s.margin, 12) + e[n] + (i.titleOffset[n] || 0)));\n                });\n            }\n            proximatePositions() {\n                let t;\n                let e = this.chart, i = [], s = \"left\" === this.options.align;\n                for (let o of (this.allItems.forEach(function(t) {\n                    let o, r, n = s, a, h;\n                    t.yAxis && (t.xAxis.options.reversed && (n = !n), t.points && (o = y(n ? t.points : t.points.slice(0).reverse(), function(t) {\n                        return v(t.plotY);\n                    })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, a = t.visible ? (o ? o.plotY : t.yAxis.height) + (h - .3 * r) : h + t.yAxis.height, i.push({\n                        target: a,\n                        size: r,\n                        item: t\n                    }));\n                }, this), p(i, e.plotHeight)))t = o.item.legendItem || {}, v(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);\n            }\n            render() {\n                let t = this.chart, e = t.renderer, i = this.options, s = this.padding, o = this.getAllItems(), r, n, a, h = this.group, l, d = this.box;\n                this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = C(i.width, t.spacingBox.width - s), l = t.spacingBox.width - 2 * s - i.x, [\n                    \"rm\",\n                    \"lm\"\n                ].indexOf(this.getAlignment().substring(0, 2)) > -1 && (l /= 2), this.maxLegendWidth = this.widthOption || l, h || (this.group = h = e.g(\"legend\").addClass(i.className || \"\").attr({\n                    zIndex: 7\n                }).add(), this.contentGroup = e.g().attr({\n                    zIndex: 1\n                }).add(h), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), w(o, (t, e)=>(t.options && t.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0)), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), n = (this.widthOption || this.offsetWidth) + s, a = this.lastItemY + this.lastLineHeight + this.titleHeight, a = this.handleOverflow(a) + s, d || (this.box = d = e.rect().addClass(\"highcharts-legend-box\").attr({\n                    r: i.borderRadius\n                }).add(h)), t.styledMode || d.attr({\n                    stroke: i.borderColor,\n                    \"stroke-width\": i.borderWidth || 0,\n                    fill: i.backgroundColor || \"none\"\n                }).shadow(i.shadow), n > 0 && a > 0 && d[d.placed ? \"animate\" : \"attr\"](d.crisp.call({}, {\n                    x: 0,\n                    y: 0,\n                    width: n,\n                    height: a\n                }, d.strokeWidth())), h[r ? \"show\" : \"hide\"](), t.styledMode && \"none\" === h.getStyle(\"display\") && (n = a = 0), this.legendWidth = n, this.legendHeight = a, r && this.align(), this.proximate || this.positionItems(), b(this, \"afterRender\");\n            }\n            align() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.chart.spacingBox;\n                let e = this.chart, i = this.options, s = t.y;\n                /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = S(t, {\n                    y: s\n                })), e.hasRendered || (this.group.placed = !1), this.group.align(S(i, {\n                    width: this.legendWidth,\n                    height: this.legendHeight,\n                    verticalAlign: this.proximate ? \"top\" : i.verticalAlign\n                }), !0, t);\n            }\n            handleOverflow(t) {\n                let e = this, i = this.chart, s = i.renderer, o = this.options, r = o.y, n = \"top\" === o.verticalAlign, a = this.padding, h = o.maxHeight, l = o.navigation, d = k(l.animation, !0), c = l.arrowSize || 12, p = this.pages, u = this.allItems, g = function(t) {\n                    \"number\" == typeof t ? S.attr({\n                        height: t\n                    }) : S && (e.clipRect = S.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? \"rect(\" + a + \"px,9999px,\" + (a + t) + \"px,0)\" : \"auto\");\n                }, f = function(t) {\n                    return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(v), i.styledMode || e[t].attr(\"fill\", \"rgba(0,0,0,0.0001)\"), e[t];\n                }, m, x, y, b = i.spacingBox.height + (n ? -r : r) - a, v = this.nav, S = this.clipRect;\n                return \"horizontal\" !== o.layout || \"middle\" === o.verticalAlign || o.floating || (b /= 2), h && (b = Math.min(b, h)), p.length = 0, t && b > 0 && t > b && !1 !== l.enabled ? (this.clipHeight = m = Math.max(b - 20 - this.titleHeight - a, 0), this.currentPage = k(this.currentPage, 1), this.fullHeight = t, u.forEach((t, e)=>{\n                    y = t.legendItem || {};\n                    let i = y.y || 0, s = Math.round(y.label.getBBox().height), o = p.length;\n                    (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && ((u[e - 1].legendItem || {}).pageIx = o - 1), e === u.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i);\n                }), S || (S = e.clipRect = s.clipRect(0, a - 2, 9999, 0), e.contentGroup.clip(S)), g(m), v || (this.nav = v = s.g().attr({\n                    zIndex: 1\n                }).add(this.group), this.up = s.symbol(\"triangle\", 0, 0, c, c).add(v), f(\"upTracker\").on(\"click\", function() {\n                    e.scroll(-1, d);\n                }), this.pager = s.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(v), this.down = s.symbol(\"triangle-down\", 0, 0, c, c).add(v), f(\"downTracker\").on(\"click\", function() {\n                    e.scroll(1, d);\n                })), e.scroll(0), t = b) : v && (g(), this.nav = v.destroy(), this.scrollGroup.attr({\n                    translateY: 1\n                }), this.clipHeight = 0), t;\n            }\n            scroll(t, e) {\n                let i = this.chart, s = this.pages, o = s.length, r = this.clipHeight, n = this.options.navigation, l = this.pager, d = this.padding, c = this.currentPage + t;\n                if (c > o && (c = o), c > 0) {\n                    void 0 !== e && h(e, i), this.nav.attr({\n                        translateX: d,\n                        translateY: r + this.padding + 7 + this.titleHeight,\n                        visibility: \"inherit\"\n                    }), [\n                        this.up,\n                        this.upTracker\n                    ].forEach(function(t) {\n                        t.attr({\n                            class: 1 === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n                        });\n                    }), l.attr({\n                        text: c + \"/\" + o\n                    }), [\n                        this.down,\n                        this.downTracker\n                    ].forEach(function(t) {\n                        t.attr({\n                            x: 18 + this.pager.getBBox().width,\n                            class: c === o ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n                        });\n                    }, this), i.styledMode || (this.up.attr({\n                        fill: 1 === c ? n.inactiveColor : n.activeColor\n                    }), this.upTracker.css({\n                        cursor: 1 === c ? \"default\" : \"pointer\"\n                    }), this.down.attr({\n                        fill: c === o ? n.inactiveColor : n.activeColor\n                    }), this.downTracker.css({\n                        cursor: c === o ? \"default\" : \"pointer\"\n                    })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({\n                        translateY: this.scrollOffset\n                    }), this.currentPage = c, this.positionCheckboxes();\n                    let t = a(k(e, i.renderer.globalAnimation, !0));\n                    T(()=>{\n                        b(this, \"afterScroll\", {\n                            currentPage: c\n                        });\n                    }, t.duration);\n                }\n            }\n            setItemEvents(t, e, i) {\n                let o = this, r = t.legendItem || {}, n = o.chart.renderer.boxWrapper, a = t instanceof s, h = \"highcharts-legend-\" + (a ? \"point\" : \"series\") + \"-active\", l = o.chart.styledMode, d = i ? [\n                    e,\n                    r.symbol\n                ] : [\n                    r.group\n                ], c = (e)=>{\n                    o.allItems.forEach((i)=>{\n                        t !== i && [\n                            i\n                        ].concat(i.linkedSeries || []).forEach((t)=>{\n                            t.setState(e, !a);\n                        });\n                    });\n                };\n                for (let i of d)i && i.on(\"mouseover\", function() {\n                    t.visible && c(\"inactive\"), t.setState(\"hover\"), t.visible && n.addClass(h), l || e.css(o.options.itemHoverStyle);\n                }).on(\"mouseout\", function() {\n                    o.chart.styledMode || e.css(S(t.visible ? o.itemStyle : o.itemHiddenStyle)), c(\"\"), n.removeClass(h), t.setState();\n                }).on(\"click\", function(e) {\n                    let i = \"legendItemClick\", s = function() {\n                        t.setVisible && t.setVisible(), c(t.visible ? \"inactive\" : \"\");\n                    };\n                    n.removeClass(h), e = {\n                        browserEvent: e\n                    }, t.firePointEvent ? t.firePointEvent(i, e, s) : b(t, i, e, s);\n                });\n            }\n            createCheckboxForItem(t) {\n                t.checkbox = g(\"input\", {\n                    type: \"checkbox\",\n                    className: \"highcharts-legend-checkbox\",\n                    checked: t.selected,\n                    defaultChecked: t.selected\n                }, this.options.itemCheckboxStyle, this.chart.container), u(t.checkbox, \"click\", function(e) {\n                    let i = e.target;\n                    b(t.series || t, \"checkboxClick\", {\n                        checked: i.checked,\n                        item: t\n                    }, function() {\n                        t.select();\n                    });\n                });\n            }\n            constructor(t, e){\n                this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), u(this.chart, \"endResize\", function() {\n                    this.legend.positionCheckboxes();\n                })), u(this.chart, \"render\", ()=>{\n                    this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());\n                });\n            }\n        }\n        return (n = A || (A = {})).compose = function t(e) {\n            M(d, t) && u(e, \"beforeMargins\", function() {\n                this.legend = new n(this, this.options.legend);\n            });\n        }, A;\n    }), i(e, \"Core/Legend/LegendSymbol.js\", [\n        e[\"Core/Utilities.js\"]\n    ], function(t) {\n        var e;\n        let { extend: i, merge: s, pick: o } = t;\n        return function(t) {\n            function e(t, e, r) {\n                let n = this.legendItem = this.legendItem || {}, { chart: a, options: h } = this, { baseline: l = 0, symbolWidth: d, symbolHeight: c } = t, p = this.symbol || \"circle\", u = c / 2, g = a.renderer, f = n.group, m = l - Math.round(c * (r ? .4 : .3)), x = {}, y, b = h.marker, v = 0;\n                if (a.styledMode || (x[\"stroke-width\"] = Math.min(h.lineWidth || 0, 24), h.dashStyle ? x.dashstyle = h.dashStyle : \"square\" === h.linecap || (x[\"stroke-linecap\"] = \"round\")), n.line = g.path().addClass(\"highcharts-graph\").attr(x).add(f), r && (n.area = g.path().addClass(\"highcharts-area\").add(f)), x[\"stroke-linecap\"] && (v = Math.min(n.line.strokeWidth(), d) / 2), d) {\n                    var _n_area;\n                    let t = [\n                        [\n                            \"M\",\n                            v,\n                            m\n                        ],\n                        [\n                            \"L\",\n                            d - v,\n                            m\n                        ]\n                    ];\n                    n.line.attr({\n                        d: t\n                    }), (_n_area = n.area) === null || _n_area === void 0 ? void 0 : _n_area.attr({\n                        d: [\n                            ...t,\n                            [\n                                \"L\",\n                                d - v,\n                                l\n                            ],\n                            [\n                                \"L\",\n                                v,\n                                l\n                            ]\n                        ]\n                    });\n                }\n                if (b && !1 !== b.enabled && d) {\n                    let t = Math.min(o(b.radius, u), u);\n                    0 === p.indexOf(\"url\") && (b = s(b, {\n                        width: c,\n                        height: c\n                    }), t = 0), n.symbol = y = g.symbol(p, d / 2 - t, m - t, 2 * t, 2 * t, i({\n                        context: \"legend\"\n                    }, b)).addClass(\"highcharts-point\").add(f), y.isMarker = !0;\n                }\n            }\n            t.areaMarker = function(t, i) {\n                e.call(this, t, i, !0);\n            }, t.lineMarker = e, t.rectangle = function(t, e) {\n                let i = e.legendItem || {}, s = t.options, r = t.symbolHeight, n = s.squareSymbol, a = n ? r : t.symbolWidth;\n                i.symbol = this.chart.renderer.rect(n ? (t.symbolWidth - r) / 2 : 0, t.baseline - r + 1, a, r, o(t.options.symbolRadius, r / 2)).addClass(\"highcharts-point\").attr({\n                    zIndex: 3\n                }).add(i.group);\n            };\n        }(e || (e = {})), e;\n    }), i(e, \"Core/Series/SeriesDefaults.js\", [], function() {\n        return {\n            lineWidth: 2,\n            allowPointSelect: !1,\n            crisp: !0,\n            showCheckbox: !1,\n            animation: {\n                duration: 1e3\n            },\n            enableMouseTracking: !0,\n            events: {},\n            marker: {\n                enabledThreshold: 2,\n                lineColor: \"#ffffff\",\n                lineWidth: 0,\n                radius: 4,\n                states: {\n                    normal: {\n                        animation: !0\n                    },\n                    hover: {\n                        animation: {\n                            duration: 150\n                        },\n                        enabled: !0,\n                        radiusPlus: 2,\n                        lineWidthPlus: 1\n                    },\n                    select: {\n                        fillColor: \"#cccccc\",\n                        lineColor: \"#000000\",\n                        lineWidth: 2\n                    }\n                }\n            },\n            point: {\n                events: {}\n            },\n            dataLabels: {\n                animation: {},\n                align: \"center\",\n                borderWidth: 0,\n                defer: !0,\n                formatter: function() {\n                    let { numberFormatter: t } = this.series.chart;\n                    return \"number\" != typeof this.y ? \"\" : t(this.y, -1);\n                },\n                padding: 5,\n                style: {\n                    fontSize: \"0.7em\",\n                    fontWeight: \"bold\",\n                    color: \"contrast\",\n                    textOutline: \"1px contrast\"\n                },\n                verticalAlign: \"bottom\",\n                x: 0,\n                y: 0\n            },\n            cropThreshold: 300,\n            opacity: 1,\n            pointRange: 0,\n            softThreshold: !0,\n            states: {\n                normal: {\n                    animation: !0\n                },\n                hover: {\n                    animation: {\n                        duration: 150\n                    },\n                    lineWidthPlus: 1,\n                    marker: {},\n                    halo: {\n                        size: 10,\n                        opacity: .25\n                    }\n                },\n                select: {\n                    animation: {\n                        duration: 0\n                    }\n                },\n                inactive: {\n                    animation: {\n                        duration: 150\n                    },\n                    opacity: .2\n                }\n            },\n            stickyTracking: !0,\n            turboThreshold: 1e3,\n            findNearestPointBy: \"x\"\n        };\n    }), i(e, \"Core/Series/SeriesRegistry.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Series/Point.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s) {\n        var o;\n        let { defaultOptions: r } = e, { extendClass: n, merge: a } = s;\n        return function(e) {\n            function s(t, s) {\n                let o = r.plotOptions || {}, n = s.defaultOptions, a = s.prototype;\n                a.type = t, a.pointClass || (a.pointClass = i), n && (o[t] = n), e.seriesTypes[t] = s;\n            }\n            e.seriesTypes = t.seriesTypes, e.registerSeriesType = s, e.seriesType = function(t, o, h, l, d) {\n                let c = r.plotOptions || {};\n                return o = o || \"\", c[t] = a(c[o], h), s(t, n(e.seriesTypes[o] || function() {}, l)), e.seriesTypes[t].prototype.type = t, d && (e.seriesTypes[t].prototype.pointClass = n(i, d)), e.seriesTypes[t];\n            };\n        }(o || (o = {})), o;\n    }), i(e, \"Core/Series/Series.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Foundation.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Legend/LegendSymbol.js\"],\n        e[\"Core/Series/Point.js\"],\n        e[\"Core/Series/SeriesDefaults.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Renderer/SVG/SVGElement.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r, n, a, h, l) {\n        let { animObject: d, setAnimation: c } = t, { defaultOptions: p } = e, { registerEventOptions: u } = i, { hasTouch: g, svg: f, win: m } = s, { seriesTypes: x } = a, { arrayMax: y, arrayMin: b, clamp: v, correctFloat: S, defined: k, destroyObjectProperties: M, diffObjects: C, erase: w, error: T, extend: A, find: P, fireEvent: L, getClosestDistance: O, getNestedProperty: D, insertItem: E, isArray: j, isNumber: I, isString: B, merge: R, objectEach: z, pick: N, removeEvent: W, splat: G, syncTimeout: H } = l;\n        class X {\n            init(t, e) {\n                let i;\n                L(this, \"init\", {\n                    options: e\n                });\n                let s = this, o = t.series;\n                this.eventsToUnbind = [], s.chart = t, s.options = s.setOptions(e);\n                let r = s.options, n = !1 !== r.visible;\n                s.linkedSeries = [], s.bindAxes(), A(s, {\n                    name: r.name,\n                    state: \"\",\n                    visible: n,\n                    selected: !0 === r.selected\n                }), u(this, r);\n                let a = r.events;\n                (a && a.click || r.point && r.point.events && r.point.events.click || r.allowPointSelect) && (t.runTrackerClick = !0), s.getColor(), s.getSymbol(), s.parallelArrays.forEach(function(t) {\n                    s[t + \"Data\"] || (s[t + \"Data\"] = []);\n                }), s.isCartesian && (t.hasCartesianSeries = !0), o.length && (i = o[o.length - 1]), s._i = N(i && i._i, -1) + 1, s.opacity = s.options.opacity, t.orderItems(\"series\", E(this, o)), r.dataSorting && r.dataSorting.enabled ? s.setDataSortingOptions() : s.points || s.data || s.setData(r.data, !1), L(this, \"afterInit\");\n            }\n            is(t) {\n                return x[t] && this instanceof x[t];\n            }\n            bindAxes() {\n                let t;\n                let e = this, i = e.options, s = e.chart;\n                L(this, \"bindAxes\", null, function() {\n                    (e.axisTypes || []).forEach(function(o) {\n                        s[o].forEach(function(s) {\n                            t = s.options, (N(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (E(e, s.series), e[o] = s, s.isDirty = !0);\n                        }), e[o] || e.optionalAxis === o || T(18, !0, s);\n                    });\n                }), L(this, \"afterBindAxes\");\n            }\n            updateParallelArrays(t, e, i) {\n                let s = t.series, o = I(e) ? function(i) {\n                    let o = \"y\" === i && s.toYData ? s.toYData(t) : t[i];\n                    s[i + \"Data\"][e] = o;\n                } : function(t) {\n                    Array.prototype[e].apply(s[t + \"Data\"], i);\n                };\n                s.parallelArrays.forEach(o);\n            }\n            hasData() {\n                return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;\n            }\n            hasMarkerChanged(t, e) {\n                let i = t.marker, s = e.marker || {};\n                return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);\n            }\n            autoIncrement(t) {\n                let e = this.options, i = e.pointIntervalUnit, s = e.relativeXValue, o = this.chart.time, r = this.xIncrement, n, a;\n                return (r = N(r, e.pointStart, 0), this.pointInterval = a = N(this.pointInterval, e.pointInterval, 1), s && I(t) && (a *= t), i && (n = new o.Date(r), \"day\" === i ? o.set(\"Date\", n, o.get(\"Date\", n) + a) : \"month\" === i ? o.set(\"Month\", n, o.get(\"Month\", n) + a) : \"year\" === i && o.set(\"FullYear\", n, o.get(\"FullYear\", n) + a), a = n.getTime() - r), s && I(t)) ? r + a : (this.xIncrement = r + a, r);\n            }\n            setDataSortingOptions() {\n                let t = this.options;\n                A(this, {\n                    requireSorting: !1,\n                    sorted: !1,\n                    enabledDataSorting: !0,\n                    allowDG: !1\n                }), k(t.pointRange) || (t.pointRange = 1);\n            }\n            setOptions(t) {\n                var _p_plotOptions_series, _d_series;\n                let e;\n                let i = this.chart, s = i.options, o = s.plotOptions, r = i.userOptions || {}, n = R(t), a = i.styledMode, h = {\n                    plotOptions: o,\n                    userOptions: n\n                };\n                L(this, \"setOptions\", h);\n                let l = h.plotOptions[this.type], d = r.plotOptions || {}, c = d.series || {}, u = p.plotOptions[this.type] || {}, g = d[this.type] || {};\n                this.userOptions = h.userOptions;\n                let f = R(l, o.series, g, n);\n                this.tooltipOptions = R(p.tooltip, (_p_plotOptions_series = p.plotOptions.series) === null || _p_plotOptions_series === void 0 ? void 0 : _p_plotOptions_series.tooltip, u === null || u === void 0 ? void 0 : u.tooltip, i.userOptions.tooltip, (_d_series = d.series) === null || _d_series === void 0 ? void 0 : _d_series.tooltip, g.tooltip, n.tooltip), this.stickyTracking = N(n.stickyTracking, g.stickyTracking, c.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || f.stickyTracking), null === l.marker && delete f.marker, this.zoneAxis = f.zoneAxis || \"y\";\n                let m = this.zones = (f.zones || []).slice();\n                return (f.negativeColor || f.negativeFillColor) && !f.zones && (e = {\n                    value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n                    className: \"highcharts-negative\"\n                }, a || (e.color = f.negativeColor, e.fillColor = f.negativeFillColor), m.push(e)), m.length && k(m[m.length - 1].value) && m.push(a ? {} : {\n                    color: this.color,\n                    fillColor: this.fillColor\n                }), L(this, \"afterSetOptions\", {\n                    options: f\n                }), f;\n            }\n            getName() {\n                return N(this.options.name, \"Series \" + (this.index + 1));\n            }\n            getCyclic(t, e, i) {\n                let s, o;\n                let r = this.chart, n = \"\".concat(t, \"Index\"), a = \"\".concat(t, \"Counter\"), h = (i === null || i === void 0 ? void 0 : i.length) || r.options.chart.colorCount;\n                !e && (k(o = N(\"color\" === t ? this.options.colorIndex : void 0, this[n])) ? s = o : (r.series.length || (r[a] = 0), s = r[a] % h, r[a] += 1), i && (e = i[s])), void 0 !== s && (this[n] = s), this[t] = e;\n            }\n            getColor() {\n                this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || p.plotOptions[this.type].color, this.chart.options.colors);\n            }\n            getPointsCollection() {\n                return (this.hasGroupedData ? this.points : this.data) || [];\n            }\n            getSymbol() {\n                let t = this.options.marker;\n                this.getCyclic(\"symbol\", t.symbol, this.chart.options.symbols);\n            }\n            findPointIndex(t, e) {\n                let i, s, o;\n                let n = t.id, a = t.x, h = this.points, l = this.options.dataSorting;\n                if (n) {\n                    let t = this.chart.get(n);\n                    t instanceof r && (i = t);\n                } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n                    let e = (e)=>!e.touched && e.index === t.index;\n                    if (l && l.matchByName ? e = (e)=>!e.touched && e.name === t.name : this.options.relativeXValue && (e = (e)=>!e.touched && e.options.x === t.x), !(i = P(h, e))) return;\n                }\n                return i && void 0 !== (o = i && i.index) && (s = !0), void 0 === o && I(a) && (o = this.xData.indexOf(a, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= this.cropStart ? o - this.cropStart : o), !s && I(o) && h[o] && h[o].touched && (o = void 0), o;\n            }\n            updateData(t, e) {\n                let i = this.options, s = i.dataSorting, o = this.points, r = [], n = this.requireSorting, a = t.length === o.length, h, l, d, c, p = !0;\n                if (this.xIncrement = null, t.forEach(function(t, e) {\n                    let l;\n                    let d = k(t) && this.pointClass.prototype.optionsToObject.call({\n                        series: this\n                    }, t) || {}, p = d.x, u = d.id;\n                    u || I(p) ? (-1 === (l = this.findPointIndex(d, c)) || void 0 === l ? r.push(t) : o[l] && t !== i.data[l] ? (o[l].update(t, !1, null, !1), o[l].touched = !0, n && (c = l + 1)) : o[l] && (o[l].touched = !0), (!a || e !== l || s && s.enabled || this.hasDerivedData) && (h = !0)) : r.push(t);\n                }, this), h) for(l = o.length; l--;)(d = o[l]) && !d.touched && d.remove && d.remove(!1, e);\n                else !a || s && s.enabled ? p = !1 : (t.forEach(function(t, e) {\n                    t === o[e].y || o[e].destroyed || o[e].update(t, !1, null, !1);\n                }), r.length = 0);\n                return o.forEach(function(t) {\n                    t && (t.touched = !1);\n                }), !!p && (r.forEach(function(t) {\n                    this.addPoint(t, !1, null, null, !1);\n                }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = y(this.xData), this.autoIncrement()), !0);\n            }\n            setData(t) {\n                let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, i = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n                let o = this, r = o.points, n = r && r.length || 0, a = o.options, h = o.chart, l = a.dataSorting, d = o.xAxis, c = a.turboThreshold, p = this.xData, u = this.yData, g = o.pointArrayMap, f = g && g.length, m = a.keys, x, y, b, v = 0, S = 1, k = null, M;\n                h.options.chart.allowMutatingData || (a.data && delete o.options.data, o.userOptions.data && delete o.userOptions.data, M = R(!0, t)), t = M || t || [];\n                let C = t.length;\n                if (l && l.enabled && (t = this.sortData(t)), h.options.chart.allowMutatingData && !1 !== s && C && n && !o.cropped && !o.hasGroupedData && o.visible && !o.boosted && (b = this.updateData(t, i)), !b) {\n                    var _r_x;\n                    if (o.xIncrement = null, o.colorCounter = 0, this.parallelArrays.forEach(function(t) {\n                        o[t + \"Data\"].length = 0;\n                    }), c && C > c) {\n                        if (I(k = o.getFirstValidPoint(t))) for(x = 0; x < C; x++)p[x] = this.autoIncrement(), u[x] = t[x];\n                        else if (j(k)) {\n                            if (f) {\n                                if (k.length === f) for(x = 0; x < C; x++)p[x] = this.autoIncrement(), u[x] = t[x];\n                                else for(x = 0; x < C; x++)y = t[x], p[x] = y[0], u[x] = y.slice(1, f + 1);\n                            } else if (m && (v = m.indexOf(\"x\"), S = m.indexOf(\"y\"), v = v >= 0 ? v : 0, S = S >= 0 ? S : 1), 1 === k.length && (S = 0), v === S) for(x = 0; x < C; x++)p[x] = this.autoIncrement(), u[x] = t[x][S];\n                            else for(x = 0; x < C; x++)y = t[x], p[x] = y[v], u[x] = y[S];\n                        } else T(12, !1, h);\n                    } else for(x = 0; x < C; x++)y = {\n                        series: o\n                    }, o.pointClass.prototype.applyOptions.apply(y, [\n                        t[x]\n                    ]), o.updateParallelArrays(y, x);\n                    for(u && B(u[0]) && T(14, !0, h), o.data = [], o.options.data = o.userOptions.data = t, x = n; x--;)(_r_x = r[x]) === null || _r_x === void 0 ? void 0 : _r_x.destroy();\n                    d && (d.minRange = d.userMinRange), o.isDirty = h.isDirtyBox = !0, o.isDirtyData = !!r, i = !1;\n                }\n                \"point\" === a.legendType && (this.processData(), this.generatePoints()), e && h.redraw(i);\n            }\n            sortData(t) {\n                let e = this, i = e.options, s = i.dataSorting, o = s.sortKey || \"y\", r = function(t, e) {\n                    return k(e) && t.pointClass.prototype.optionsToObject.call({\n                        series: t\n                    }, e) || {};\n                };\n                t.forEach(function(i, s) {\n                    t[s] = r(e, i), t[s].index = s;\n                }, this);\n                let n = t.concat().sort((t, e)=>{\n                    let i = D(o, t), s = D(o, e);\n                    return s < i ? -1 : s > i ? 1 : 0;\n                });\n                return n.forEach(function(t, e) {\n                    t.x = e;\n                }, this), e.linkedSeries && e.linkedSeries.forEach(function(e) {\n                    let i = e.options, s = i.data;\n                    i.dataSorting && i.dataSorting.enabled || !s || (s.forEach(function(i, o) {\n                        s[o] = r(e, i), t[o] && (s[o].x = t[o].x, s[o].index = o);\n                    }), e.setData(s, !1));\n                }), t;\n            }\n            getProcessedData(t) {\n                let e = this, i = e.xAxis, s = e.options, o = s.cropThreshold, r = t || e.getExtremesFromAll || s.getExtremesFromAll, n = i === null || i === void 0 ? void 0 : i.logarithmic, a = e.isCartesian, h, l, d = 0, c, p, u, g = e.xData, f = e.yData, m = !1, x = g.length;\n                i && (p = (c = i.getExtremes()).min, u = c.max, m = !!(i.categories && !i.names.length)), a && e.sorted && !r && (!o || x > o || e.forceCrop) && (g[x - 1] < p || g[0] > u ? (g = [], f = []) : e.yData && (g[0] < p || g[x - 1] > u) && (g = (h = this.cropData(e.xData, e.yData, p, u)).xData, f = h.yData, d = h.start, l = !0));\n                let y = O([\n                    n ? g.map(n.log2lin) : g\n                ], ()=>e.requireSorting && !m && T(15, !1, e.chart));\n                return {\n                    xData: g,\n                    yData: f,\n                    cropped: l,\n                    cropStart: d,\n                    closestPointRange: y\n                };\n            }\n            processData(t) {\n                let e = this.xAxis;\n                if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;\n                let i = this.getProcessedData();\n                this.cropped = i.cropped, this.cropStart = i.cropStart, this.processedXData = i.xData, this.processedYData = i.yData, this.closestPointRange = this.basePointRange = i.closestPointRange, L(this, \"afterProcessData\");\n            }\n            cropData(t, e, i, s) {\n                let o = t.length, r, n, a = 0, h = o;\n                for(r = 0; r < o; r++)if (t[r] >= i) {\n                    a = Math.max(0, r - 1);\n                    break;\n                }\n                for(n = r; n < o; n++)if (t[n] > s) {\n                    h = n + 1;\n                    break;\n                }\n                return {\n                    xData: t.slice(a, h),\n                    yData: e.slice(a, h),\n                    start: a,\n                    end: h\n                };\n            }\n            generatePoints() {\n                let t = this.options, e = this.processedData || t.data, i = this.processedXData, s = this.processedYData, o = this.pointClass, r = i.length, n = this.cropStart || 0, a = this.hasGroupedData, h = t.keys, l = [], d = t.dataGrouping && t.dataGrouping.groupAll ? n : 0, c, p, u, g, f = this.data;\n                if (!f && !a) {\n                    let t = [];\n                    t.length = e.length, f = this.data = t;\n                }\n                for(h && a && (this.options.keys = !1), g = 0; g < r; g++)p = n + g, a ? ((u = new o(this, [\n                    i[g]\n                ].concat(G(s[g])))).dataGroup = this.groupMap[d + g], u.dataGroup.options && (u.options = u.dataGroup.options, A(u, u.dataGroup.options), delete u.dataLabels)) : (u = f[p]) || void 0 === e[p] || (f[p] = u = new o(this, e[p], i[g])), u && (u.index = a ? d + g : p, l[g] = u);\n                if (this.options.keys = h, f && (r !== (c = f.length) || a)) for(g = 0; g < c; g++)g !== n || a || (g += r), f[g] && (f[g].destroyElements(), f[g].plotX = void 0);\n                this.data = f, this.points = l, L(this, \"afterGeneratePoints\");\n            }\n            getXExtremes(t) {\n                return {\n                    min: b(t),\n                    max: y(t)\n                };\n            }\n            getExtremes(t, e) {\n                let i = this.xAxis, s = this.yAxis, o = this.processedXData || this.xData, r = [], n = this.requireSorting && !this.is(\"column\") ? 1 : 0, a = !!s && s.positiveValuesOnly, h, l, d, c, p, u, g, f = 0, m = 0, x = 0;\n                t = t || this.stackedYData || this.processedYData || [];\n                let v = t.length;\n                for(i && (f = (h = i.getExtremes()).min, m = h.max), u = 0; u < v; u++)if (c = o[u], l = (I(p = t[u]) || j(p)) && ((I(p) ? p > 0 : p.length) || !a), d = e || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i || (o[u + n] || c) >= f && (o[u - n] || c) <= m, l && d) {\n                    if (g = p.length) for(; g--;)I(p[g]) && (r[x++] = p[g]);\n                    else r[x++] = p;\n                }\n                let S = {\n                    activeYData: r,\n                    dataMin: b(r),\n                    dataMax: y(r)\n                };\n                return L(this, \"afterGetExtremes\", {\n                    dataExtremes: S\n                }), S;\n            }\n            applyExtremes() {\n                let t = this.getExtremes();\n                return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;\n            }\n            getFirstValidPoint(t) {\n                let e = t.length, i = 0, s = null;\n                for(; null === s && i < e;)s = t[i], i++;\n                return s;\n            }\n            translate() {\n                this.processedXData || this.processData(), this.generatePoints();\n                let t = this.options, e = t.stacking, i = this.xAxis, s = i.categories, o = this.enabledDataSorting, r = this.yAxis, n = this.points, a = n.length, h = this.pointPlacementToXValue(), l = !!h, d = t.threshold, c = t.startFromThreshold ? d : 0, p, u, g, f, m = Number.MAX_VALUE;\n                function x(t) {\n                    return v(t, -1e5, 1e5);\n                }\n                for(p = 0; p < a; p++){\n                    var _r_stacking;\n                    let t;\n                    let a = n[p], y = a.x, b, v, M = a.y, C = a.low, w = e && ((_r_stacking = r.stacking) === null || _r_stacking === void 0 ? void 0 : _r_stacking.stacks[(this.negStacks && M < (c ? 0 : d) ? \"-\" : \"\") + this.stackKey]);\n                    u = i.translate(y, !1, !1, !1, !0, h), a.plotX = I(u) ? S(x(u)) : void 0, e && this.visible && w && w[y] && (f = this.getStackIndicator(f, y, this.index), !a.isNull && f.key && (v = (b = w[y]).points[f.key]), b && j(v) && (C = v[0], M = v[1], C === c && f.key === w[y].base && (C = N(I(d) ? d : r.min)), r.positiveValuesOnly && k(C) && C <= 0 && (C = void 0), a.total = a.stackTotal = N(b.total), a.percentage = k(a.y) && b.total ? a.y / b.total * 100 : void 0, a.stackY = M, this.irregularWidths || b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a.yBottom = k(C) ? x(r.translate(C, !1, !0, !1, !0)) : void 0, this.dataModify && (M = this.dataModify.modifyValue(M, p)), I(M) && void 0 !== a.plotX && (t = I(t = r.translate(M, !1, !0, !1, !0)) ? x(t) : void 0), a.plotY = t, a.isInside = this.isPointInside(a), a.clientX = l ? S(i.translate(y, !1, !1, !1, !0, h)) : u, a.negative = (a.y || 0) < (d || 0), a.category = N(s && s[a.x], a.x), a.isNull || !1 === a.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), a.zone = this.zones.length ? a.getZone() : void 0, !a.graphic && this.group && o && (a.isNew = !0);\n                }\n                this.closestPointRangePx = m, L(this, \"afterTranslate\");\n            }\n            getValidPoints(t, e, i) {\n                let s = this.chart;\n                return (t || this.points || []).filter(function(t) {\n                    let { plotX: o, plotY: r } = t, n = !i && (t.isNull || !I(r));\n                    return !n && (!e || !!s.isInsidePlot(o, r, {\n                        inverted: s.inverted\n                    })) && !1 !== t.visible;\n                });\n            }\n            getClipBox() {\n                let { chart: t, xAxis: e, yAxis: i } = this, s = R(t.clipBox);\n                return e && e.len !== t.plotSizeX && (s.width = e.len), i && i.len !== t.plotSizeY && (s.height = i.len), s;\n            }\n            getSharedClipKey() {\n                return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0), this.sharedClipKey;\n            }\n            setClip() {\n                let { chart: t, group: e, markerGroup: i } = this, s = t.sharedClips, o = t.renderer, r = this.getClipBox(), n = this.getSharedClipKey(), a = s[n];\n                a ? a.animate(r) : s[n] = a = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : a), i && i.clip();\n            }\n            animate(t) {\n                let { chart: e, group: i, markerGroup: s } = this, o = e.inverted, r = d(this.options.animation), n = [\n                    this.getSharedClipKey(),\n                    r.duration,\n                    r.easing,\n                    r.defer\n                ].join(\",\"), a = e.sharedClips[n], h = e.sharedClips[n + \"m\"];\n                if (t && i) {\n                    let t = this.getClipBox();\n                    if (a) a.attr(\"height\", t.height);\n                    else {\n                        t.width = 0, o && (t.x = e.plotHeight), a = e.renderer.clipRect(t), e.sharedClips[n] = a;\n                        let i = {\n                            x: -99,\n                            y: -99,\n                            width: o ? e.plotWidth + 199 : 99,\n                            height: o ? 99 : e.plotHeight + 199\n                        };\n                        h = e.renderer.clipRect(i), e.sharedClips[n + \"m\"] = h;\n                    }\n                    i.clip(a), s && s.clip(h);\n                } else if (a && !a.hasClass(\"highcharts-animating\")) {\n                    let t = this.getClipBox(), e = r.step;\n                    s && s.element.childNodes.length && (r.step = function(t, i) {\n                        e && e.apply(i, arguments), \"width\" === i.prop && h && h.element && h.attr(o ? \"height\" : \"width\", t + 99);\n                    }), a.addClass(\"highcharts-animating\").animate(t, r);\n                }\n            }\n            afterAnimate() {\n                this.setClip(), z(this.chart.sharedClips, (t, e, i)=>{\n                    t && !this.chart.container.querySelector('[clip-path=\"url(#'.concat(t.id, ')\"]')) && (t.destroy(), delete i[e]);\n                }), this.finishedAnimating = !0, L(this, \"afterAnimate\");\n            }\n            drawPoints() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.points;\n                let e, i, s, o, r, n, a;\n                let h = this.chart, l = h.styledMode, { colorAxis: d, options: c } = this, p = c.marker, u = this[this.specialGroup || \"markerGroup\"], g = this.xAxis, f = N(p.enabled, !g || !!g.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);\n                if (!1 !== p.enabled || this._hasPointMarkers) for(e = 0; e < t.length; e++){\n                    o = (s = (i = t[e]).graphic) ? \"animate\" : \"attr\", r = i.marker || {}, n = !!i.marker;\n                    let c = (f && void 0 === r.enabled || r.enabled) && !i.isNull && !1 !== i.visible;\n                    if (c) {\n                        let t = N(r.symbol, this.symbol, \"rect\");\n                        a = this.markerAttribs(i, i.selected && \"select\"), this.enabledDataSorting && (i.startXPos = g.reversed ? -(a.width || 0) : g.width);\n                        let e = !1 !== i.isInside;\n                        if (!s && e && ((a.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(t, a.x, a.y, a.width, a.height, n ? r : p).add(u), this.enabledDataSorting && h.hasRendered && (s.attr({\n                            x: i.startXPos\n                        }), o = \"animate\")), s && \"animate\" === o && s[e ? \"show\" : \"hide\"](e).animate(a), s) {\n                            let t = this.pointAttribs(i, l || !i.selected ? void 0 : \"select\");\n                            l ? d && s.css({\n                                fill: t.fill\n                            }) : s[o](t);\n                        }\n                        s && s.addClass(i.getClassName(), !0);\n                    } else s && (i.graphic = s.destroy());\n                }\n            }\n            markerAttribs(t, e) {\n                let i = this.options, s = i.marker, o = t.marker || {}, r = o.symbol || s.symbol, n = {}, a, h, l = N(o.radius, s && s.radius);\n                e && (a = s.states[e], l = N((h = o.states && o.states[e]) && h.radius, a && a.radius, l && l + (a && a.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf(\"url\"), t.hasImage && (l = 0);\n                let d = t.pos();\n                return I(l) && d && (n.x = d[0] - l, n.y = d[1] - l, i.crisp && (n.x = Math.floor(n.x))), l && (n.width = n.height = 2 * l), n;\n            }\n            pointAttribs(t, e) {\n                let i = this.options.marker, s = t && t.options, o = s && s.marker || {}, r = s && s.color, n = t && t.color, a = t && t.zone && t.zone.color, h, l, d = this.color, c, p, u = N(o.lineWidth, i.lineWidth), g = 1;\n                return d = r || a || n || d, c = o.fillColor || i.fillColor || d, p = o.lineColor || i.lineColor || d, e = e || \"normal\", h = i.states[e] || {}, u = N((l = o.states && o.states[e] || {}).lineWidth, h.lineWidth, u + N(l.lineWidthPlus, h.lineWidthPlus, 0)), c = l.fillColor || h.fillColor || c, {\n                    stroke: p = l.lineColor || h.lineColor || p,\n                    \"stroke-width\": u,\n                    fill: c,\n                    opacity: g = N(l.opacity, h.opacity, g)\n                };\n            }\n            destroy(t) {\n                let e, i, s;\n                let o = this, r = o.chart, n = /AppleWebKit\\/533/.test(m.navigator.userAgent), a = o.data || [];\n                for(L(o, \"destroy\", {\n                    keepEventsForUpdate: t\n                }), this.removeEvents(t), (o.axisTypes || []).forEach(function(t) {\n                    (s = o[t]) && s.series && (w(s.series, o), s.isDirty = s.forceRedraw = !0);\n                }), o.legendItem && o.chart.legend.destroyItem(o), e = a.length; e--;)(i = a[e]) && i.destroy && i.destroy();\n                o.zones.forEach(M), l.clearTimeout(o.animationTimeout), z(o, function(t, e) {\n                    t instanceof h && !t.survive && t[n && \"group\" === e ? \"hide\" : \"destroy\"]();\n                }), r.hoverSeries === o && (r.hoverSeries = void 0), w(r.series, o), r.orderItems(\"series\"), z(o, function(e, i) {\n                    t && \"hcEvents\" === i || delete o[i];\n                });\n            }\n            applyZones() {\n                let { area: t, chart: e, graph: i, zones: s, points: o, xAxis: r, yAxis: n, zoneAxis: a } = this, { inverted: h, renderer: l } = e, d = this[\"\".concat(a, \"Axis\")], { isXAxis: c, len: p = 0 } = d || {}, u = ((i === null || i === void 0 ? void 0 : i.strokeWidth()) || 0) / 2 + 1, g = function(t) {\n                    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n                    h && (i = p - i);\n                    let { translated: s = 0, lineClip: o } = t, r = i - s;\n                    o === null || o === void 0 ? void 0 : o.push([\n                        \"L\",\n                        e,\n                        Math.abs(r) < u ? i - u * (r <= 0 ? -1 : 1) : s\n                    ]);\n                };\n                if (s.length && (i || t) && d && I(d.min)) {\n                    let e = d.getExtremes().max, u = (t)=>{\n                        t.forEach((e, i)=>{\n                            (\"M\" === e[0] || \"L\" === e[0]) && (t[i] = [\n                                e[0],\n                                c ? p - e[1] : e[1],\n                                c ? e[2] : p - e[2]\n                            ]);\n                        });\n                    };\n                    if (s.forEach((t, i)=>{\n                        t.lineClip = [], t.translated = v(d.toPixels(N(t.value, e), !0) || 0, 0, p);\n                    }), i && !this.showLine && i.hide(), t && t.hide(), \"y\" === a && o.length < r.len) for (let t of o){\n                        let { plotX: e, plotY: i, zone: o } = t, r = o && s[s.indexOf(o) - 1];\n                        o && g(o, e, i), r && g(r, e, i);\n                    }\n                    let f = [], m = d.toPixels(d.getExtremes().min, !0);\n                    s.forEach((e)=>{\n                        var _e_graph, _e_area;\n                        let s = e.lineClip || [], o = Math.round(e.translated || 0);\n                        r.reversed && s.reverse();\n                        let { clip: a, simpleClip: d } = e, p = 0, g = 0, x = r.len, y = n.len;\n                        c ? (p = o, x = m) : (g = o, y = m);\n                        let b = [\n                            [\n                                \"M\",\n                                p,\n                                g\n                            ],\n                            [\n                                \"L\",\n                                x,\n                                g\n                            ],\n                            [\n                                \"L\",\n                                x,\n                                y\n                            ],\n                            [\n                                \"L\",\n                                p,\n                                y\n                            ],\n                            [\n                                \"Z\"\n                            ]\n                        ], v = [\n                            b[0],\n                            ...s,\n                            b[1],\n                            b[2],\n                            ...f,\n                            b[3],\n                            b[4]\n                        ];\n                        f = s.reverse(), m = o, h && (u(v), t && u(b)), a ? (a.animate({\n                            d: v\n                        }), d === null || d === void 0 ? void 0 : d.animate({\n                            d: b\n                        })) : (a = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && ((_e_graph = e.graph) === null || _e_graph === void 0 ? void 0 : _e_graph.clip(a)), t && ((_e_area = e.area) === null || _e_area === void 0 ? void 0 : _e_area.clip(d));\n                    });\n                } else this.visible && (i && i.show(), t && t.show());\n            }\n            plotGroup(t, e, i, s, o) {\n                let r = this[t], n = !r, a = {\n                    visibility: i,\n                    zIndex: s || .1\n                };\n                return k(this.opacity) && !this.chart.styledMode && \"inactive\" !== this.state && (a.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass(\"highcharts-\" + e + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (k(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (r.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0), r.attr(a)[n ? \"attr\" : \"animate\"](this.getPlotBox(e)), r;\n            }\n            getPlotBox(t) {\n                let e = this.xAxis, i = this.yAxis, s = this.chart, o = s.inverted && !s.polar && e && !1 !== this.invertible && \"series\" === t;\n                return s.inverted && (e = i, i = this.xAxis), {\n                    translateX: e ? e.left : s.plotLeft,\n                    translateY: i ? i.top : s.plotTop,\n                    rotation: o ? 90 : 0,\n                    rotationOriginX: o ? (e.len - i.len) / 2 : 0,\n                    rotationOriginY: o ? (e.len + i.len) / 2 : 0,\n                    scaleX: o ? -1 : 1,\n                    scaleY: 1\n                };\n            }\n            removeEvents(t) {\n                let { eventsToUnbind: e } = this;\n                t || W(this), e.length && (e.forEach((t)=>{\n                    t();\n                }), e.length = 0);\n            }\n            render() {\n                var _t_animate, _t_drawDataLabels, _t_redrawPoints, _t_drawTracker, _t_animate1;\n                let t = this, { chart: e, options: i, hasRendered: s } = t, o = d(i.animation), r = t.visible ? \"inherit\" : \"hidden\", n = i.zIndex, a = e.seriesGroup, h = t.finishedAnimating ? 0 : o.duration;\n                L(this, \"render\"), t.plotGroup(\"group\", \"series\", r, n, a), t.markerGroup = t.plotGroup(\"markerGroup\", \"markers\", r, n, a), !1 !== i.clip && t.setClip(), h && ((_t_animate = t.animate) === null || _t_animate === void 0 ? void 0 : _t_animate.call(t, !0)), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), (_t_drawDataLabels = t.drawDataLabels) === null || _t_drawDataLabels === void 0 ? void 0 : _t_drawDataLabels.call(t), (_t_redrawPoints = t.redrawPoints) === null || _t_redrawPoints === void 0 ? void 0 : _t_redrawPoints.call(t), i.enableMouseTracking && ((_t_drawTracker = t.drawTracker) === null || _t_drawTracker === void 0 ? void 0 : _t_drawTracker.call(t)), h && ((_t_animate1 = t.animate) === null || _t_animate1 === void 0 ? void 0 : _t_animate1.call(t)), s || (h && o.defer && (h += o.defer), t.animationTimeout = H(()=>{\n                    t.afterAnimate();\n                }, h || 0)), t.isDirty = !1, t.hasRendered = !0, L(t, \"afterRender\");\n            }\n            redraw() {\n                let t = this.isDirty || this.isDirtyData;\n                this.translate(), this.render(), t && delete this.kdTree;\n            }\n            reserveSpace() {\n                return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n            }\n            searchPoint(t, e) {\n                let { xAxis: i, yAxis: s } = this, o = this.chart.inverted;\n                return this.searchKDTree({\n                    clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,\n                    plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos\n                }, e, t);\n            }\n            buildKDTree(t) {\n                this.buildingKdTree = !0;\n                let e = this, i = e.options.findNearestPointBy.indexOf(\"y\") > -1 ? 2 : 1;\n                delete e.kdTree, H(function() {\n                    e.kdTree = function t(i, s, o) {\n                        let r, n;\n                        let a = i === null || i === void 0 ? void 0 : i.length;\n                        if (a) return r = e.kdAxisArray[s % o], i.sort((t, e)=>(t[r] || 0) - (e[r] || 0)), {\n                            point: i[n = Math.floor(a / 2)],\n                            left: t(i.slice(0, n), s + 1, o),\n                            right: t(i.slice(n + 1), s + 1, o)\n                        };\n                    }(e.getValidPoints(void 0, !e.directTouch), i, i), e.buildingKdTree = !1;\n                }, e.options.kdNow || (t === null || t === void 0 ? void 0 : t.type) === \"touchstart\" ? 0 : 1);\n            }\n            searchKDTree(t, e, i) {\n                let s = this, [o, r] = this.kdAxisArray, n = e ? \"distX\" : \"dist\", a = (s.options.findNearestPointBy || \"\").indexOf(\"y\") > -1 ? 2 : 1, h = !!s.isBubble;\n                if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, a, l) {\n                    var _d_marker;\n                    let d = i.point, c = s.kdAxisArray[a % l], p, u, g = d;\n                    !function(t, e) {\n                        var _e_marker;\n                        let i = t[o], s = e[o], n = k(i) && k(s) ? i - s : null, a = t[r], l = e[r], d = k(a) && k(l) ? a - l : 0, c = h && ((_e_marker = e.marker) === null || _e_marker === void 0 ? void 0 : _e_marker.radius) || 0;\n                        e.dist = Math.sqrt((n && n * n || 0) + d * d) - c, e.distX = k(n) ? Math.abs(n) - c : Number.MAX_VALUE;\n                    }(e, d);\n                    let f = (e[c] || 0) - (d[c] || 0) + (h && ((_d_marker = d.marker) === null || _d_marker === void 0 ? void 0 : _d_marker.radius) || 0), m = f < 0 ? \"left\" : \"right\", x = f < 0 ? \"right\" : \"left\";\n                    return i[m] && (g = (p = t(e, i[m], a + 1, l))[n] < g[n] ? p : d), i[x] && Math.sqrt(f * f) < g[n] && (g = (u = t(e, i[x], a + 1, l))[n] < g[n] ? u : g), g;\n                }(t, this.kdTree, a, a);\n            }\n            pointPlacementToXValue() {\n                let { options: t, xAxis: e } = this, i = t.pointPlacement;\n                return \"between\" === i && (i = e.reversed ? -.5 : .5), I(i) ? i * (t.pointRange || e.pointRange) : 0;\n            }\n            isPointInside(t) {\n                let { chart: e, xAxis: i, yAxis: s } = this, { plotX: o = -1, plotY: r = -1 } = t, n = r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth);\n                return n;\n            }\n            drawTracker() {\n                var _o_options_tooltip;\n                let t = this, e = t.options, i = e.trackByArea, s = [].concat((i ? t.areaPath : t.graphPath) || []), o = t.chart, r = o.pointer, n = o.renderer, a = ((_o_options_tooltip = o.options.tooltip) === null || _o_options_tooltip === void 0 ? void 0 : _o_options_tooltip.snap) || 0, h = ()=>{\n                    e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();\n                }, l = \"rgba(192,192,192,\" + (f ? 1e-4 : .002) + \")\", d = t.tracker;\n                d ? d.attr({\n                    d: s\n                }) : t.graph && (t.tracker = d = n.path(s).attr({\n                    visibility: t.visible ? \"inherit\" : \"hidden\",\n                    zIndex: 2\n                }).addClass(i ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(t.group), o.styledMode || d.attr({\n                    \"stroke-linecap\": \"round\",\n                    \"stroke-linejoin\": \"round\",\n                    stroke: l,\n                    fill: i ? l : \"none\",\n                    \"stroke-width\": t.graph.strokeWidth() + (i ? 0 : 2 * a)\n                }), [\n                    t.tracker,\n                    t.markerGroup,\n                    t.dataLabelsGroup\n                ].forEach((t)=>{\n                    t && (t.addClass(\"highcharts-tracker\").on(\"mouseover\", h).on(\"mouseout\", (t)=>{\n                        r.onTrackerMouseOut(t);\n                    }), e.cursor && !o.styledMode && t.css({\n                        cursor: e.cursor\n                    }), g && t.on(\"touchstart\", h));\n                })), L(this, \"afterDrawTracker\");\n            }\n            addPoint(t, e, i, s, o) {\n                let r, n;\n                let a = this.options, h = this.data, l = this.chart, d = this.xAxis, c = d && d.hasNames && d.names, p = a.data, u = this.xData;\n                e = N(e, !0);\n                let g = {\n                    series: this\n                };\n                this.pointClass.prototype.applyOptions.apply(g, [\n                    t\n                ]);\n                let f = g.x;\n                if (n = u.length, this.requireSorting && f < u[n - 1]) for(r = !0; n && u[n - 1] > f;)n--;\n                this.updateParallelArrays(g, \"splice\", [\n                    n,\n                    0,\n                    0\n                ]), this.updateParallelArrays(g, n), c && g.name && (c[f] = g.name), p.splice(n, 0, t), (r || this.processedData) && (this.data.splice(n, 0, null), this.processData()), \"point\" === a.legendType && this.generatePoints(), i && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(g, \"shift\"), p.shift())), !1 !== o && L(this, \"addPoint\", {\n                    point: g\n                }), this.isDirty = !0, this.isDirtyData = !0, e && l.redraw(s);\n            }\n            removePoint(t, e, i) {\n                let s = this, o = s.data, r = o[t], n = s.points, a = s.chart, h = function() {\n                    n && n.length === o.length && n.splice(t, 1), o.splice(t, 1), s.options.data.splice(t, 1), s.updateParallelArrays(r || {\n                        series: s\n                    }, \"splice\", [\n                        t,\n                        1\n                    ]), r && r.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && a.redraw();\n                };\n                c(i, a), e = N(e, !0), r ? r.firePointEvent(\"remove\", null, h) : h();\n            }\n            remove(t, e, i, s) {\n                let o = this, r = o.chart;\n                function n() {\n                    o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), N(t, !0) && r.redraw(e);\n                }\n                !1 !== i ? L(o, \"remove\", null, n) : n();\n            }\n            update(t, e) {\n                var _n_series, _i_xData, _i_hasDataLabels;\n                L(this, \"update\", {\n                    options: t = C(t, this.userOptions)\n                });\n                let i = this, s = i.chart, o = i.userOptions, r = i.initialType || i.type, n = s.options.plotOptions, a = x[r].prototype, h = i.finishedAnimating && {\n                    animation: !1\n                }, l = {}, d, c, p = [\n                    \"colorIndex\",\n                    \"eventOptions\",\n                    \"navigatorSeries\",\n                    \"symbolIndex\",\n                    \"baseSeries\"\n                ], u = t.type || o.type || s.options.chart.type, g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [\n                    \"dataGrouping\",\n                    \"pointStart\",\n                    \"pointInterval\",\n                    \"pointIntervalUnit\",\n                    \"keys\"\n                ].some((t)=>i.hasOptionChanged(t)));\n                var _n_series_pointStart, _ref;\n                u = u || r, g && (p.push(\"data\", \"isDirtyData\", \"isDirtyCanvas\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"hasDataLabels\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== t.visible && p.push(\"area\", \"graph\"), i.parallelArrays.forEach(function(t) {\n                    p.push(t + \"Data\");\n                }), t.data && (t.dataSorting && A(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))), t = R(o, {\n                    index: void 0 === o.index ? i.index : o.index,\n                    pointStart: (_ref = (_n_series_pointStart = n === null || n === void 0 ? void 0 : (_n_series = n.series) === null || _n_series === void 0 ? void 0 : _n_series.pointStart) !== null && _n_series_pointStart !== void 0 ? _n_series_pointStart : o.pointStart) !== null && _ref !== void 0 ? _ref : (_i_xData = i.xData) === null || _i_xData === void 0 ? void 0 : _i_xData[0]\n                }, !g && {\n                    data: i.options.data\n                }, t, h), g && t.data && (t.data = i.options.data), (p = [\n                    \"group\",\n                    \"markerGroup\",\n                    \"dataLabelsGroup\",\n                    \"transformGroup\"\n                ].concat(p)).forEach(function(t) {\n                    p[t] = i[t], delete i[t];\n                });\n                let f = !1;\n                if (x[u]) {\n                    if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) {\n                        if (Object.setPrototypeOf) Object.setPrototypeOf(i, x[u].prototype);\n                        else {\n                            let t = Object.hasOwnProperty.call(i, \"hcEvents\") && i.hcEvents;\n                            for(c in a)i[c] = void 0;\n                            A(i, x[u].prototype), t ? i.hcEvents = t : delete i.hcEvents;\n                        }\n                    }\n                } else T(17, !0, s, {\n                    missingModuleFor: u\n                });\n                if (p.forEach(function(t) {\n                    i[t] = p[t];\n                }), i.init(s, t), g && this.points) for (let t of (!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (l.graphic = 1), ((_i_hasDataLabels = i.hasDataLabels) === null || _i_hasDataLabels === void 0 ? void 0 : _i_hasDataLabels.call(i)) || (l.dataLabel = 1)), this.points))t && t.series && (t.resolveColor(), Object.keys(l).length && t.destroyElements(l), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));\n                i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), L(this, \"afterUpdate\"), N(e, !0) && s.redraw(!!g && void 0);\n            }\n            setName(t) {\n                this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;\n            }\n            hasOptionChanged(t) {\n                var _s_this_type, _s_series;\n                let e = this.chart, i = this.options[t], s = e.options.plotOptions, o = this.userOptions[t], r = N(s === null || s === void 0 ? void 0 : (_s_this_type = s[this.type]) === null || _s_this_type === void 0 ? void 0 : _s_this_type[t], s === null || s === void 0 ? void 0 : (_s_series = s.series) === null || _s_series === void 0 ? void 0 : _s_series[t]);\n                return o && !k(r) ? i !== o : i !== N(r, i);\n            }\n            onMouseOver() {\n                let t = this.chart, e = t.hoverSeries, i = t.pointer;\n                i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && L(this, \"mouseOver\"), this.setState(\"hover\"), t.hoverSeries = this;\n            }\n            onMouseOut() {\n                let t = this.options, e = this.chart, i = e.tooltip, s = e.hoverPoint;\n                e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && L(this, \"mouseOut\"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function(t) {\n                    t.setState(\"\", !0);\n                });\n            }\n            setState(t, e) {\n                let i = this, s = i.options, o = i.graph, r = s.inactiveOtherPoints, n = s.states, a = N(n[t || \"normal\"] && n[t || \"normal\"].animation, i.chart.options.chart.animation), h = s.lineWidth, l = s.opacity;\n                if (t = t || \"\", i.state !== t && ([\n                    i.group,\n                    i.markerGroup,\n                    i.dataLabelsGroup\n                ].forEach(function(e) {\n                    e && (i.state && e.removeClass(\"highcharts-series-\" + i.state), t && e.addClass(\"highcharts-series-\" + t));\n                }), i.state = t, !i.chart.styledMode)) {\n                    if (n[t] && !1 === n[t].enabled) return;\n                    if (t && (h = n[t].lineWidth || h + (n[t].lineWidthPlus || 0), l = N(n[t].opacity, l)), o && !o.dashstyle && I(h)) for (let t of [\n                        o,\n                        ...this.zones.map((t)=>t.graph)\n                    ])t === null || t === void 0 ? void 0 : t.animate({\n                        \"stroke-width\": h\n                    }, a);\n                    r || [\n                        i.group,\n                        i.markerGroup,\n                        i.dataLabelsGroup,\n                        i.labelBySeries\n                    ].forEach(function(t) {\n                        t && t.animate({\n                            opacity: l\n                        }, a);\n                    });\n                }\n                e && r && i.points && i.setAllPointsToState(t || void 0);\n            }\n            setAllPointsToState(t) {\n                this.points.forEach(function(e) {\n                    e.setState && e.setState(t);\n                });\n            }\n            setVisible(t, e) {\n                var _s_hoverPoint;\n                let i = this, s = i.chart, o = s.options.chart.ignoreHiddenSeries, r = i.visible;\n                i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;\n                let n = t ? \"show\" : \"hide\";\n                [\n                    \"group\",\n                    \"dataLabelsGroup\",\n                    \"markerGroup\",\n                    \"tracker\",\n                    \"tt\"\n                ].forEach((t)=>{\n                    var _i_t;\n                    (_i_t = i[t]) === null || _i_t === void 0 ? void 0 : _i_t[n]();\n                }), (s.hoverSeries === i || ((_s_hoverPoint = s.hoverPoint) === null || _s_hoverPoint === void 0 ? void 0 : _s_hoverPoint.series) === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach((t)=>{\n                    t.options.stacking && t.visible && (t.isDirty = !0);\n                }), i.linkedSeries.forEach((e)=>{\n                    e.setVisible(t, !1);\n                }), o && (s.isDirtyBox = !0), L(i, n), !1 !== e && s.redraw();\n            }\n            show() {\n                this.setVisible(!0);\n            }\n            hide() {\n                this.setVisible(!1);\n            }\n            select(t) {\n                this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), L(this, t ? \"select\" : \"unselect\");\n            }\n            shouldShowTooltip(t, e) {\n                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);\n            }\n            drawLegendSymbol(t, e) {\n                var _o_;\n                (_o_ = o[this.options.legendSymbol || \"rectangle\"]) === null || _o_ === void 0 ? void 0 : _o_.call(this, t, e);\n            }\n            constructor(){\n                this.zoneAxis = \"y\";\n            }\n        }\n        return X.defaultOptions = n, X.types = a.seriesTypes, X.registerType = a.registerSeriesType, A(X.prototype, {\n            axisTypes: [\n                \"xAxis\",\n                \"yAxis\"\n            ],\n            coll: \"series\",\n            colorCounter: 0,\n            directTouch: !1,\n            isCartesian: !0,\n            kdAxisArray: [\n                \"clientX\",\n                \"plotY\"\n            ],\n            parallelArrays: [\n                \"x\",\n                \"y\"\n            ],\n            pointClass: r,\n            requireSorting: !0,\n            sorted: !0\n        }), a.series = X, X;\n    }), i(e, \"Core/Chart/Chart.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Axis/Axis.js\"],\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Templating.js\"],\n        e[\"Core/Foundation.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/RendererRegistry.js\"],\n        e[\"Core/Series/Series.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Renderer/SVG/SVGRenderer.js\"],\n        e[\"Core/Time.js\"],\n        e[\"Core/Utilities.js\"],\n        e[\"Core/Renderer/HTML/AST.js\"],\n        e[\"Core/Axis/Tick.js\"]\n    ], function(t, e, i, s, o, r, n, a, h, l, d, c, p, u) {\n        let { animate: g, animObject: f, setAnimation: m } = t, { defaultOptions: x, defaultTime: y } = i, { numberFormat: b } = s, { registerEventOptions: v } = o, { charts: S, doc: k, marginNames: M, svg: C, win: w } = r, { seriesTypes: T } = h, { addEvent: A, attr: P, createElement: L, clamp: O, css: D, defined: E, diffObjects: j, discardElement: I, erase: B, error: R, extend: z, find: N, fireEvent: W, getStyle: G, isArray: H, isNumber: X, isObject: F, isString: Y, merge: U, objectEach: V, pick: $, pInt: Z, relativeLength: _, removeEvent: q, splat: K, syncTimeout: J, uniqueKey: Q } = c;\n        class tt {\n            static chart(t, e, i) {\n                return new tt(t, e, i);\n            }\n            setZoomOptions() {\n                let t = this.options.chart, e = t.zooming;\n                this.zooming = {\n                    ...e,\n                    type: $(t.zoomType, e.type),\n                    key: $(t.zoomKey, e.key),\n                    pinchType: $(t.pinchType, e.pinchType),\n                    singleTouch: $(t.zoomBySingleTouch, e.singleTouch, !1),\n                    resetButton: U(e.resetButton, t.resetZoomButton)\n                };\n            }\n            init(t, e) {\n                W(this, \"init\", {\n                    args: arguments\n                }, function() {\n                    let i = U(x, t), s = i.chart;\n                    this.userOptions = z({}, t), this.margin = [], this.spacing = [], this.bounds = {\n                        h: {},\n                        v: {}\n                    }, this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.time = t.time && Object.keys(t.time).length ? new d(t.time) : r.time, this.numberFormatter = s.numberFormatter || b, this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = S.length, S.push(this), r.chartCount++, v(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), W(this, \"afterInit\"), this.firstRender();\n                });\n            }\n            initSeries(t) {\n                let e = this.options.chart, i = t.type || e.type, s = T[i];\n                s || R(17, !0, this, {\n                    missingModuleFor: i\n                });\n                let o = new s;\n                return \"function\" == typeof o.init && o.init(this, t), o;\n            }\n            setSortedData() {\n                this.getSeriesOrderByLinks().forEach(function(t) {\n                    t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);\n                });\n            }\n            getSeriesOrderByLinks() {\n                return this.series.concat().sort(function(t, e) {\n                    return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;\n                });\n            }\n            orderItems(t) {\n                let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n                let i = this[t], s = this.options[t] = K(this.options[t]).slice(), o = this.userOptions[t] = this.userOptions[t] ? K(this.userOptions[t]).slice() : [];\n                if (this.hasRendered && (s.splice(e), o.splice(e)), i) for(let t = e, r = i.length; t < r; ++t){\n                    let e = i[t];\n                    e && (e.index = t, e instanceof a && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));\n                }\n            }\n            isInsidePlot(t, e) {\n                let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                let { inverted: s, plotBox: o, plotLeft: r, plotTop: n, scrollablePlotBox: a } = this, h = 0, l = 0;\n                i.visiblePlotOnly && this.scrollingContainer && ({ scrollLeft: h, scrollTop: l } = this.scrollingContainer);\n                let d = i.series, c = i.visiblePlotOnly && a || o, p = i.inverted ? e : t, u = i.inverted ? t : e, g = {\n                    x: p,\n                    y: u,\n                    isInsidePlot: !0,\n                    options: i\n                };\n                if (!i.ignoreX) {\n                    let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {\n                        pos: r,\n                        len: 1 / 0\n                    }, e = i.paneCoordinates ? t.pos + p : r + p;\n                    e >= Math.max(h + r, t.pos) && e <= Math.min(h + r + c.width, t.pos + t.len) || (g.isInsidePlot = !1);\n                }\n                if (!i.ignoreY && g.isInsidePlot) {\n                    let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {\n                        pos: n,\n                        len: 1 / 0\n                    }, e = i.paneCoordinates ? t.pos + u : n + u;\n                    e >= Math.max(l + n, t.pos) && e <= Math.min(l + n + c.height, t.pos + t.len) || (g.isInsidePlot = !1);\n                }\n                return W(this, \"afterIsInsidePlot\", g), g.isInsidePlot;\n            }\n            redraw(t) {\n                W(this, \"beforeRedraw\");\n                let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i = this.series, s = this.pointer, o = this.legend, r = this.userOptions.legend, n = this.renderer, a = n.isHidden(), h = [], l, d, c, p = this.isDirtyBox, u = this.isDirtyLegend, g;\n                for(n.rootFontSize = n.boxWrapper.getStyle(\"font-size\"), this.setResponsive && this.setResponsive(!1), m(!!this.hasRendered && t, this), a && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;)if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {\n                    l = !0;\n                    break;\n                }\n                if (l) for(c = i.length; c--;)(g = i[c]).options.stacking && (g.isDirty = !0);\n                i.forEach(function(t) {\n                    t.isDirty && (\"point\" === t.options.legendType ? (\"function\" == typeof t.updateTotals && t.updateTotals(), u = !0) : r && (r.labelFormatter || r.labelFormat) && (u = !0)), t.isDirtyData && W(t, \"updatedData\");\n                }), u && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function(t) {\n                    t.updateNames(), t.setScale();\n                }), this.getMargins(), e.forEach(function(t) {\n                    t.isDirty && (p = !0);\n                }), e.forEach(function(t) {\n                    let e = t.min + \",\" + t.max;\n                    t.extKey !== e && (t.extKey = e, h.push(function() {\n                        W(t, \"afterSetExtremes\", z(t.eventArgs, t.getExtremes())), delete t.eventArgs;\n                    })), (p || d) && t.redraw();\n                }), p && this.drawChartBox(), W(this, \"predraw\"), i.forEach(function(t) {\n                    (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;\n                }), s && s.reset(!0), n.draw(), W(this, \"redraw\"), W(this, \"render\"), a && this.temporaryDisplay(!0), h.forEach(function(t) {\n                    t.call();\n                });\n            }\n            get(t) {\n                let e = this.series;\n                function i(e) {\n                    return e.id === t || e.options && e.options.id === t;\n                }\n                let s = N(this.axes, i) || N(this.series, i);\n                for(let t = 0; !s && t < e.length; t++)s = N(e[t].points || [], i);\n                return s;\n            }\n            getAxes() {\n                let t = this.userOptions;\n                for (let i of (W(this, \"getAxes\"), [\n                    \"xAxis\",\n                    \"yAxis\"\n                ])){\n                    let s = t[i] = K(t[i] || {});\n                    for (let t of s)new e(this, t, i);\n                }\n                W(this, \"afterGetAxes\");\n            }\n            getSelectedPoints() {\n                return this.series.reduce((t, e)=>(e.getPointsCollection().forEach((e)=>{\n                        $(e.selectedStaging, e.selected) && t.push(e);\n                    }), t), []);\n            }\n            getSelectedSeries() {\n                return this.series.filter(function(t) {\n                    return t.selected;\n                });\n            }\n            setTitle(t, e, i) {\n                this.applyDescription(\"title\", t), this.applyDescription(\"subtitle\", e), this.applyDescription(\"caption\", void 0), this.layOutTitles(i);\n            }\n            applyDescription(t, e) {\n                let i = this, s = this.options[t] = U(this.options[t], e), o = this[t];\n                o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({\n                    align: s.align,\n                    class: \"highcharts-\" + t,\n                    zIndex: s.zIndex || 4\n                }).add()).update = function(e, s) {\n                    i.applyDescription(t, e), i.layOutTitles(s);\n                }, this.styledMode || o.css(z(\"title\" === t ? {\n                    fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n                } : {}, s.style)), this[t] = o);\n            }\n            layOutTitles() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n                let e = [\n                    0,\n                    0,\n                    0\n                ], i = this.renderer, s = this.spacingBox;\n                [\n                    \"title\",\n                    \"subtitle\",\n                    \"caption\"\n                ].forEach(function(t) {\n                    let o = this[t], r = this.options[t], n = r.verticalAlign || \"top\", a = \"title\" === t ? \"top\" === n ? -3 : 0 : \"top\" === n ? e[0] + 2 : 0;\n                    if (o) {\n                        o.css({\n                            width: (r.width || s.width + (r.widthAdjust || 0)) + \"px\"\n                        });\n                        let t = i.fontMetrics(o).b, h = Math.round(o.getBBox(r.useHTML).height);\n                        o.align(z({\n                            y: \"bottom\" === n ? t : a + t,\n                            height: h\n                        }, r), !1, \"spacingBox\"), r.floating || (\"top\" === n ? e[0] = Math.ceil(e[0] + h) : \"bottom\" === n && (e[2] = Math.ceil(e[2] + h)));\n                    }\n                }, this), e[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (e[0] += this.options.title.margin), e[2] && \"bottom\" === this.options.caption.verticalAlign && (e[2] += this.options.caption.margin);\n                let o = !this.titleOffset || this.titleOffset.join(\",\") !== e.join(\",\");\n                this.titleOffset = e, W(this, \"afterLayOutTitles\"), !this.isDirtyBox && o && (this.isDirtyBox = this.isDirtyLegend = o, this.hasRendered && t && this.isDirtyBox && this.redraw());\n            }\n            getContainerBox() {\n                return {\n                    width: G(this.renderTo, \"width\", !0) || 0,\n                    height: G(this.renderTo, \"height\", !0) || 0\n                };\n            }\n            getChartSize() {\n                let t = this.options.chart, e = t.width, i = t.height, s = this.getContainerBox();\n                this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, _(i, this.chartWidth) || (s.height > 1 ? s.height : 400)), this.containerBox = s;\n            }\n            temporaryDisplay(t) {\n                let e = this.renderTo, i;\n                if (t) for(; e && e.style;)e.hcOrigStyle && (D(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (k.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;\n                else for(; e && e.style && (k.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, k.body.appendChild(e)), (\"none\" === G(e, \"display\", !1) || e.hcOricDetached) && (e.hcOrigStyle = {\n                    display: e.style.display,\n                    height: e.style.height,\n                    overflow: e.style.overflow\n                }, i = {\n                    display: \"block\",\n                    overflow: \"hidden\"\n                }, e !== this.renderTo && (i.height = 0), D(e, i), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\")), (e = e.parentNode) !== k.body););\n            }\n            setClassName(t) {\n                this.container.className = \"highcharts-container \" + (t || \"\");\n            }\n            getContainer() {\n                let t = this.options, e = t.chart, i = \"data-highcharts-chart\", s = Q(), o, r = this.renderTo;\n                r || (this.renderTo = r = e.renderTo), Y(r) && (this.renderTo = r = k.getElementById(r)), r || R(13, !0, this);\n                let a = Z(P(r, i));\n                X(a) && S[a] && S[a].hasRendered && S[a].destroy(), P(r, i, this.index), r.innerHTML = p.emptyHTML, e.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();\n                let h = this.chartWidth, d = this.chartHeight;\n                D(r, {\n                    overflow: \"hidden\"\n                }), this.styledMode || (o = z({\n                    position: \"relative\",\n                    overflow: \"hidden\",\n                    width: h + \"px\",\n                    height: d + \"px\",\n                    textAlign: \"left\",\n                    lineHeight: \"normal\",\n                    zIndex: 0,\n                    \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n                    userSelect: \"none\",\n                    \"touch-action\": \"manipulation\",\n                    outline: \"none\"\n                }, e.style || {}));\n                let c = L(\"div\", {\n                    id: s\n                }, o, r);\n                this.container = c, this._cursor = c.style.cursor;\n                let u = e.renderer || !C ? n.getRendererType(e.renderer) : l;\n                if (this.renderer = new u(c, h, d, void 0, e.forExport, t.exporting && t.exporting.allowHTML, this.styledMode), this.containerBox = this.getContainerBox(), m(void 0, this), this.setClassName(e.className), this.styledMode) for(let e in t.defs)this.renderer.definition(t.defs[e]);\n                else this.renderer.setStyle(e.style);\n                this.renderer.chartIndex = this.index, W(this, \"afterGetContainer\");\n            }\n            getMargins(t) {\n                let { spacing: e, margin: i, titleOffset: s } = this;\n                this.resetMargins(), s[0] && !E(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !E(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend && this.legend.display && this.legend.adjustMargins(i, e), W(this, \"getMargins\"), t || this.getAxisMargins();\n            }\n            getAxisMargins() {\n                let t = this, e = t.axisOffset = [\n                    0,\n                    0,\n                    0,\n                    0\n                ], i = t.colorAxis, s = t.margin, o = function(t) {\n                    t.forEach(function(t) {\n                        t.visible && t.getOffset();\n                    });\n                };\n                t.hasCartesianSeries ? o(t.axes) : i && i.length && o(i), M.forEach(function(i, o) {\n                    E(s[o]) || (t[i] += e[o]);\n                }), t.setChartSize();\n            }\n            getOptions() {\n                return j(this.userOptions, x);\n            }\n            reflow(t) {\n                let e = this, i = e.containerBox, s = e.getContainerBox();\n                delete e.pointer.chartPosition, !e.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (c.clearTimeout(e.reflowTimeout), e.reflowTimeout = J(function() {\n                    e.container && e.setSize(void 0, void 0, !1);\n                }, t ? 100 : 0)), e.containerBox = s);\n            }\n            setReflow() {\n                let t = this, e = (e)=>{\n                    var _t_options;\n                    ((_t_options = t.options) === null || _t_options === void 0 ? void 0 : _t_options.chart.reflow) && t.hasLoaded && t.reflow(e);\n                };\n                if (\"function\" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);\n                else {\n                    let t = A(w, \"resize\", e);\n                    A(this, \"destroy\", t);\n                }\n            }\n            setSize(t, e, i) {\n                let s = this, o = s.renderer;\n                s.isResizing += 1, m(i, s);\n                let r = o.globalAnimation;\n                s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();\n                let { chartWidth: n, chartHeight: a, scrollablePixelsX: h = 0, scrollablePixelsY: l = 0 } = s;\n                (s.isDirtyBox || n !== s.oldChartWidth || a !== s.oldChartHeight) && (s.styledMode || (r ? g : D)(s.container, {\n                    width: \"\".concat(n + h, \"px\"),\n                    height: \"\".concat(a + l, \"px\")\n                }, r), s.setChartSize(!0), o.setSize(n, a, r), s.axes.forEach(function(t) {\n                    t.isDirty = !0, t.setScale();\n                }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, W(s, \"resize\"), setTimeout(()=>{\n                    s && W(s, \"endResize\", void 0, ()=>{\n                        s.isResizing -= 1;\n                    });\n                }, f(r).duration));\n            }\n            setChartSize(t) {\n                let e, i, s, o;\n                let r = this.inverted, n = this.renderer, a = this.chartWidth, h = this.chartHeight, l = this.options.chart, d = this.spacing, c = this.clipOffset;\n                this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(a - e - this.marginRight)), this.plotHeight = o = Math.max(0, Math.round(h - i - this.marginBottom)), this.plotSizeX = r ? o : s, this.plotSizeY = r ? s : o, this.plotBorderWidth = l.plotBorderWidth || 0, this.spacingBox = n.spacingBox = {\n                    x: d[3],\n                    y: d[0],\n                    width: a - d[3] - d[1],\n                    height: h - d[0] - d[2]\n                }, this.plotBox = n.plotBox = {\n                    x: e,\n                    y: i,\n                    width: s,\n                    height: o\n                };\n                let p = 2 * Math.floor(this.plotBorderWidth / 2), u = Math.ceil(Math.max(p, c[3]) / 2), g = Math.ceil(Math.max(p, c[0]) / 2);\n                this.clipBox = {\n                    x: u,\n                    y: g,\n                    width: Math.floor(this.plotSizeX - Math.max(p, c[1]) / 2 - u),\n                    height: Math.max(0, Math.floor(this.plotSizeY - Math.max(p, c[2]) / 2 - g))\n                }, t || (this.axes.forEach(function(t) {\n                    t.setAxisSize(), t.setAxisTranslation();\n                }), n.alignElements()), W(this, \"afterSetChartSize\", {\n                    skipAxes: t\n                });\n            }\n            resetMargins() {\n                W(this, \"resetMargins\");\n                let t = this, e = t.options.chart;\n                [\n                    \"margin\",\n                    \"spacing\"\n                ].forEach(function(i) {\n                    let s = e[i], o = F(s) ? s : [\n                        s,\n                        s,\n                        s,\n                        s\n                    ];\n                    [\n                        \"Top\",\n                        \"Right\",\n                        \"Bottom\",\n                        \"Left\"\n                    ].forEach(function(s, r) {\n                        t[i][r] = $(e[i + s], o[r]);\n                    });\n                }), M.forEach(function(e, i) {\n                    t[e] = $(t.margin[i], t.spacing[i]);\n                }), t.axisOffset = [\n                    0,\n                    0,\n                    0,\n                    0\n                ], t.clipOffset = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            drawChartBox() {\n                let t = this.options.chart, e = this.renderer, i = this.chartWidth, s = this.chartHeight, o = this.styledMode, r = this.plotBGImage, n = t.backgroundColor, a = t.plotBackgroundColor, h = t.plotBackgroundImage, l = this.plotLeft, d = this.plotTop, c = this.plotWidth, p = this.plotHeight, u = this.plotBox, g = this.clipRect, f = this.clipBox, m = this.chartBackground, x = this.plotBackground, y = this.plotBorder, b, v, S, k = \"animate\";\n                m || (this.chartBackground = m = e.rect().addClass(\"highcharts-background\").add(), k = \"attr\"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + (t.shadow ? 8 : 0), S = {\n                    fill: n || \"none\"\n                }, (b || m[\"stroke-width\"]) && (S.stroke = t.borderColor, S[\"stroke-width\"] = b), m.attr(S).shadow(t.shadow)), m[k]({\n                    x: v / 2,\n                    y: v / 2,\n                    width: i - v - b % 2,\n                    height: s - v - b % 2,\n                    r: t.borderRadius\n                }), k = \"animate\", x || (k = \"attr\", this.plotBackground = x = e.rect().addClass(\"highcharts-plot-background\").add()), x[k](u), !o && (x.attr({\n                    fill: a || \"none\"\n                }).shadow(t.plotShadow), h && (r ? (h !== r.attr(\"href\") && r.attr(\"href\", h), r.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({\n                    width: f.width,\n                    height: f.height\n                }) : this.clipRect = e.clipRect(f), k = \"animate\", y || (k = \"attr\", this.plotBorder = y = e.rect().addClass(\"highcharts-plot-border\").attr({\n                    zIndex: 1\n                }).add()), o || y.attr({\n                    stroke: t.plotBorderColor,\n                    \"stroke-width\": t.plotBorderWidth || 0,\n                    fill: \"none\"\n                }), y[k](y.crisp({\n                    x: l,\n                    y: d,\n                    width: c,\n                    height: p\n                }, -y.strokeWidth())), this.isDirtyBox = !1, W(this, \"afterDrawChartBox\");\n            }\n            propFromSeries() {\n                let t, e, i;\n                let s = this, o = s.options.chart, r = s.options.series;\n                [\n                    \"inverted\",\n                    \"angular\",\n                    \"polar\"\n                ].forEach(function(n) {\n                    for(e = T[o.type], i = o[n] || e && e.prototype[n], t = r && r.length; !i && t--;)(e = T[r[t].type]) && e.prototype[n] && (i = !0);\n                    s[n] = i;\n                });\n            }\n            linkSeries(t) {\n                let e = this, i = e.series;\n                i.forEach(function(t) {\n                    t.linkedSeries.length = 0;\n                }), i.forEach(function(t) {\n                    let { linkedTo: i } = t.options;\n                    if (Y(i)) {\n                        let s;\n                        (s = \":previous\" === i ? e.series[t.index - 1] : e.get(i)) && s.linkedParent !== t && (s.linkedSeries.push(t), t.linkedParent = s, s.enabledDataSorting && t.setDataSortingOptions(), t.visible = $(t.options.visible, s.options.visible, t.visible));\n                    }\n                }), W(this, \"afterLinkSeries\", {\n                    isUpdating: t\n                });\n            }\n            renderSeries() {\n                this.series.forEach(function(t) {\n                    t.translate(), t.render();\n                });\n            }\n            render() {\n                var _this_getStacks, _this;\n                let t = this.axes, e = this.colorAxis, i = this.renderer, s = this.options.chart.axisLayoutRuns || 2, o = (t)=>{\n                    t.forEach((t)=>{\n                        t.visible && t.render();\n                    });\n                }, r = 0, n = !0, a, h = 0;\n                for (let e of (this.setTitle(), W(this, \"beforeMargins\"), (_this_getStacks = (_this = this).getStacks) === null || _this_getStacks === void 0 ? void 0 : _this_getStacks.call(_this), this.getMargins(!0), this.setChartSize(), t)){\n                    let { options: t } = e, { labels: i } = t;\n                    if (e.horiz && e.visible && i.enabled && e.series.length && \"colorAxis\" !== e.coll && !this.polar) {\n                        r = t.tickLength, e.createGroups();\n                        let s = new u(e, 0, \"\", !0), o = s.createLabel(\"x\", i);\n                        if (s.destroy(), o && $(i.reserveSpace, !X(t.crossing)) && (r = o.getBBox().height + i.distance + Math.max(t.offset || 0, 0)), r) {\n                            o === null || o === void 0 ? void 0 : o.destroy();\n                            break;\n                        }\n                    }\n                }\n                for(this.plotHeight = Math.max(this.plotHeight - r, 0); (n || a || s > 1) && h < s;){\n                    let e = this.plotWidth, i = this.plotHeight;\n                    for (let e of t)0 === h ? e.setScale() : (e.horiz && n || !e.horiz && a) && e.setTickInterval(!0);\n                    0 === h ? this.getAxisMargins() : this.getMargins(), n = e / this.plotWidth > (h ? 1 : 1.1), a = i / this.plotHeight > (h ? 1 : 1.05), h++;\n                }\n                this.drawChartBox(), this.hasCartesianSeries ? o(t) : e && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g(\"series-group\").attr({\n                    zIndex: 3\n                }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;\n            }\n            addCredits(t) {\n                let e = this, i = U(!0, this.options.credits, t);\n                i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function() {\n                    i.href && (w.location.href = i.href);\n                }).attr({\n                    align: i.position.align,\n                    zIndex: 8\n                }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function(t) {\n                    e.credits = e.credits.destroy(), e.addCredits(t);\n                });\n            }\n            destroy() {\n                let t;\n                let e = this, i = e.axes, s = e.series, o = e.container, n = o && o.parentNode;\n                for(W(e, \"destroy\"), e.renderer.forExport ? B(S, e) : S[e.index] = void 0, r.chartCount--, e.renderTo.removeAttribute(\"data-highcharts-chart\"), q(e), t = i.length; t--;)i[t] = i[t].destroy();\n                for(this.scroller && this.scroller.destroy && this.scroller.destroy(), t = s.length; t--;)s[t] = s[t].destroy();\n                [\n                    \"title\",\n                    \"subtitle\",\n                    \"chartBackground\",\n                    \"plotBackground\",\n                    \"plotBGImage\",\n                    \"plotBorder\",\n                    \"seriesGroup\",\n                    \"clipRect\",\n                    \"credits\",\n                    \"pointer\",\n                    \"rangeSelector\",\n                    \"legend\",\n                    \"resetZoomButton\",\n                    \"tooltip\",\n                    \"renderer\"\n                ].forEach(function(t) {\n                    let i = e[t];\n                    i && i.destroy && (e[t] = i.destroy());\n                }), o && (o.innerHTML = p.emptyHTML, q(o), n && I(o)), V(e, function(t, i) {\n                    delete e[i];\n                });\n            }\n            firstRender() {\n                let t = this, e = t.options;\n                t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.getAxes();\n                let i = H(e.series) ? e.series : [];\n                e.series = [], i.forEach(function(e) {\n                    t.initSeries(e);\n                }), t.linkSeries(), t.setSortedData(), W(t, \"beforeRender\"), t.render(), t.pointer.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);\n            }\n            onload() {\n                this.callbacks.concat([\n                    this.callback\n                ]).forEach(function(t) {\n                    t && void 0 !== this.index && t.apply(this, [\n                        this\n                    ]);\n                }, this), W(this, \"load\"), W(this, \"render\"), E(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;\n            }\n            warnIfA11yModuleNotLoaded() {\n                let { options: t, title: e } = this;\n                !t || this.accessibility || (this.renderer.boxWrapper.attr({\n                    role: \"img\",\n                    \"aria-label\": (e && e.element.textContent || \"\").replace(/</g, \"&lt;\")\n                }), t.accessibility && !1 === t.accessibility.enabled || R('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n            }\n            addSeries(t, e, i) {\n                let s;\n                let o = this;\n                return t && (e = $(e, !0), W(o, \"addSeries\", {\n                    options: t\n                }, function() {\n                    s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), W(o, \"afterAddSeries\", {\n                        series: s\n                    }), e && o.redraw(i);\n                })), s;\n            }\n            addAxis(t, e, i, s) {\n                return this.createAxis(e ? \"xAxis\" : \"yAxis\", {\n                    axis: t,\n                    redraw: i,\n                    animation: s\n                });\n            }\n            addColorAxis(t, e, i) {\n                return this.createAxis(\"colorAxis\", {\n                    axis: t,\n                    redraw: e,\n                    animation: i\n                });\n            }\n            createAxis(t, i) {\n                let s = new e(this, i.axis, t);\n                return $(i.redraw, !0) && this.redraw(i.animation), s;\n            }\n            showLoading(t) {\n                let e = this, i = e.options, s = i.loading, o = function() {\n                    r && D(r, {\n                        left: e.plotLeft + \"px\",\n                        top: e.plotTop + \"px\",\n                        width: e.plotWidth + \"px\",\n                        height: e.plotHeight + \"px\"\n                    });\n                }, r = e.loadingDiv, n = e.loadingSpan;\n                r || (e.loadingDiv = r = L(\"div\", {\n                    className: \"highcharts-loading highcharts-loading-hidden\"\n                }, null, e.container)), n || (e.loadingSpan = n = L(\"span\", {\n                    className: \"highcharts-loading-inner\"\n                }, null, r), A(e, \"redraw\", o)), r.className = \"highcharts-loading\", p.setElementHTML(n, $(t, i.lang.loading, \"\")), e.styledMode || (D(r, z(s.style, {\n                    zIndex: 10\n                })), D(n, s.labelStyle), e.loadingShown || (D(r, {\n                    opacity: 0,\n                    display: \"\"\n                }), g(r, {\n                    opacity: s.style.opacity || .5\n                }, {\n                    duration: s.showDuration || 0\n                }))), e.loadingShown = !0, o();\n            }\n            hideLoading() {\n                let t = this.options, e = this.loadingDiv;\n                e && (e.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || g(e, {\n                    opacity: 0\n                }, {\n                    duration: t.loading.hideDuration || 100,\n                    complete: function() {\n                        D(e, {\n                            display: \"none\"\n                        });\n                    }\n                })), this.loadingShown = !1;\n            }\n            update(t, e, i, s) {\n                let o, r, n;\n                let a = this, h = {\n                    credits: \"addCredits\",\n                    title: \"setTitle\",\n                    subtitle: \"setSubtitle\",\n                    caption: \"setCaption\"\n                }, l = t.isResponsiveOptions, c = [];\n                W(a, \"update\", {\n                    options: t\n                }), l || a.setResponsive(!1, !0), t = j(t, a.options), a.userOptions = U(a.userOptions, t);\n                let p = t.chart;\n                p && (U(!0, a.options.chart, p), this.setZoomOptions(), \"className\" in p && a.setClassName(p.className), (\"inverted\" in p || \"polar\" in p || \"type\" in p) && (a.propFromSeries(), o = !0), \"alignTicks\" in p && (o = !0), \"events\" in p && v(this, p), V(p, function(t, e) {\n                    -1 !== a.propsRequireUpdateSeries.indexOf(\"chart.\" + e) && (r = !0), -1 !== a.propsRequireDirtyBox.indexOf(e) && (a.isDirtyBox = !0), -1 === a.propsRequireReflow.indexOf(e) || (a.isDirtyBox = !0, l || (n = !0));\n                }), !a.styledMode && p.style && a.renderer.setStyle(a.options.chart.style || {})), !a.styledMode && t.colors && (this.options.colors = t.colors), t.time && (this.time === y && (this.time = new d(t.time)), U(!0, a.options.time, t.time)), V(t, function(e, i) {\n                    a[i] && \"function\" == typeof a[i].update ? a[i].update(e, !1) : \"function\" == typeof a[h[i]] ? a[h[i]](e) : \"colors\" !== i && -1 === a.collectionsWithUpdate.indexOf(i) && U(!0, a.options[i], t[i]), \"chart\" !== i && -1 !== a.propsRequireUpdateSeries.indexOf(i) && (r = !0);\n                }), this.collectionsWithUpdate.forEach(function(e) {\n                    t[e] && (K(t[e]).forEach(function(t, s) {\n                        let o;\n                        let r = E(t.id);\n                        r && (o = a.get(t.id)), !o && a[e] && (o = a[e][$(t.index, s)]) && (r && E(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && a.collectionsWithInit[e] && (a.collectionsWithInit[e][0].apply(a, [\n                            t\n                        ].concat(a.collectionsWithInit[e][1] || []).concat([\n                            !1\n                        ])).touched = !0);\n                    }), i && a[e].forEach(function(t) {\n                        t.touched || t.options.isInternal ? delete t.touched : c.push(t);\n                    }));\n                }), c.forEach(function(t) {\n                    t.chart && t.remove && t.remove(!1);\n                }), o && a.axes.forEach(function(t) {\n                    t.update({}, !1);\n                }), r && a.getSeriesOrderByLinks().forEach(function(t) {\n                    t.chart && t.update({}, !1);\n                }, this);\n                let u = p && p.width, g = p && (Y(p.height) ? _(p.height, u || a.chartWidth) : p.height);\n                n || X(u) && u !== a.chartWidth || X(g) && g !== a.chartHeight ? a.setSize(u, g, s) : $(e, !0) && a.redraw(s), W(a, \"afterUpdate\", {\n                    options: t,\n                    redraw: e,\n                    animation: s\n                });\n            }\n            setSubtitle(t, e) {\n                this.applyDescription(\"subtitle\", t), this.layOutTitles(e);\n            }\n            setCaption(t, e) {\n                this.applyDescription(\"caption\", t), this.layOutTitles(e);\n            }\n            showResetZoom() {\n                let t = this, e = x.lang, i = t.zooming.resetButton, s = i.theme, o = \"chart\" === i.relativeTo || \"spacingBox\" === i.relativeTo ? null : \"scrollablePlotBox\";\n                function r() {\n                    t.zoomOut();\n                }\n                W(this, \"beforeShowResetZoom\", null, function() {\n                    t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({\n                        align: i.position.align,\n                        title: e.resetZoomTitle\n                    }).addClass(\"highcharts-reset-zoom\").add().align(i.position, !1, o);\n                }), W(this, \"afterShowResetZoom\");\n            }\n            zoomOut() {\n                W(this, \"selection\", {\n                    resetSelection: !0\n                }, this.zoom);\n            }\n            zoom(t) {\n                let e = this, i = e.pointer, s = !1, o;\n                !t || t.resetSelection ? (e.axes.forEach(function(t) {\n                    o = t.zoom();\n                }), i.initiated = !1) : t.xAxis.concat(t.yAxis).forEach(function(t) {\n                    let r = t.axis, n = r.isXAxis, { hasPinched: a, mouseDownX: h, mouseDownY: l } = i;\n                    (i[n ? \"zoomX\" : \"zoomY\"] && E(h) && E(l) && e.isInsidePlot(h - e.plotLeft, l - e.plotTop, {\n                        axis: r,\n                        ignoreX: a,\n                        ignoreY: a\n                    }) || !E(e.inverted ? h : l)) && (o = r.zoom(t.min, t.max), r.displayBtn && (s = !0));\n                });\n                let r = e.resetZoomButton;\n                s && !r ? e.showResetZoom() : !s && F(r) && (e.resetZoomButton = r.destroy()), o && e.redraw($(e.options.chart.animation, t && t.animation, e.pointCount < 100));\n            }\n            pan(t, e) {\n                let i;\n                let s = this, o = s.hoverPoints, r = \"object\" == typeof e ? e : {\n                    enabled: e,\n                    type: \"x\"\n                }, n = s.options.chart;\n                n && n.panning && (n.panning = r);\n                let a = r.type;\n                W(this, \"pan\", {\n                    originalEvent: t\n                }, function() {\n                    o && o.forEach(function(t) {\n                        t.setState();\n                    });\n                    let e = s.xAxis;\n                    \"xy\" === a ? e = e.concat(s.yAxis) : \"y\" === a && (e = s.yAxis);\n                    let r = {};\n                    e.forEach(function(e) {\n                        if (!e.options.panningEnabled || e.options.isInternal) return;\n                        let o = e.horiz, n = t[o ? \"chartX\" : \"chartY\"], h = o ? \"mouseDownX\" : \"mouseDownY\", l = s[h], d = e.minPointOffset || 0, c = e.reversed && !s.inverted || !e.reversed && s.inverted ? -1 : 1, p = e.getExtremes(), u = e.toValue(l - n, !0) + d * c, g = e.toValue(l + e.len - n, !0) - (d * c || e.isXAxis && e.pointRangePadding || 0), f = g < u, m = e.hasVerticalPanning(), x = f ? g : u, y = f ? u : g, b = e.panningState, v;\n                        m && !e.isXAxis && (!b || b.isDirty) && e.series.forEach(function(t) {\n                            let e = t.getProcessedData(!0), i = t.getExtremes(e.yData, !0);\n                            b || (b = {\n                                startMin: Number.MAX_VALUE,\n                                startMax: -Number.MAX_VALUE\n                            }), X(i.dataMin) && X(i.dataMax) && (b.startMin = Math.min($(t.options.threshold, 1 / 0), i.dataMin, b.startMin), b.startMax = Math.max($(t.options.threshold, -1 / 0), i.dataMax, b.startMax));\n                        });\n                        let S = Math.min($(b && b.startMin, p.dataMin), d ? p.min : e.toValue(e.toPixels(p.min) - e.minPixelPadding)), k = Math.max($(b && b.startMax, p.dataMax), d ? p.max : e.toValue(e.toPixels(p.max) + e.minPixelPadding));\n                        e.panningState = b, e.isOrdinal || ((v = S - x) > 0 && (y += v, x = S), (v = y - k) > 0 && (y = k, x -= v), e.series.length && x !== p.min && y !== p.max && x >= S && y <= k && (e.setExtremes(x, y, !1, !1, {\n                            trigger: \"pan\"\n                        }), !s.resetZoomButton && x !== S && y !== k && a.match(\"y\") && (s.showResetZoom(), e.displayBtn = !1), i = !0), r[h] = n);\n                    }), V(r, (t, e)=>{\n                        s[e] = t;\n                    }), i && s.redraw(!1), D(s.container, {\n                        cursor: \"move\"\n                    });\n                });\n            }\n            constructor(t, e, i){\n                this.sharedClips = {};\n                let s = [\n                    ...arguments\n                ];\n                (Y(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);\n            }\n        }\n        return z(tt.prototype, {\n            callbacks: [],\n            collectionsWithInit: {\n                xAxis: [\n                    tt.prototype.addAxis,\n                    [\n                        !0\n                    ]\n                ],\n                yAxis: [\n                    tt.prototype.addAxis,\n                    [\n                        !1\n                    ]\n                ],\n                series: [\n                    tt.prototype.addSeries\n                ]\n            },\n            collectionsWithUpdate: [\n                \"xAxis\",\n                \"yAxis\",\n                \"series\"\n            ],\n            propsRequireDirtyBox: [\n                \"backgroundColor\",\n                \"borderColor\",\n                \"borderWidth\",\n                \"borderRadius\",\n                \"plotBackgroundColor\",\n                \"plotBackgroundImage\",\n                \"plotBorderColor\",\n                \"plotBorderWidth\",\n                \"plotShadow\",\n                \"shadow\"\n            ],\n            propsRequireReflow: [\n                \"margin\",\n                \"marginTop\",\n                \"marginRight\",\n                \"marginBottom\",\n                \"marginLeft\",\n                \"spacing\",\n                \"spacingTop\",\n                \"spacingRight\",\n                \"spacingBottom\",\n                \"spacingLeft\"\n            ],\n            propsRequireUpdateSeries: [\n                \"chart.inverted\",\n                \"chart.polar\",\n                \"chart.ignoreHiddenSeries\",\n                \"chart.type\",\n                \"colors\",\n                \"plotOptions\",\n                \"time\",\n                \"tooltip\"\n            ]\n        }), tt;\n    }), i(e, \"Extensions/ScrollablePlotArea.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/RendererRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s) {\n        let { stop: o } = t, { composed: r } = e, { addEvent: n, createElement: a, css: h, defined: l, extend: d, merge: c, pick: p, pushUnique: u } = s;\n        function g() {\n            var _b_style, _this_chartBackground, _this_scrollableMask;\n            let t;\n            let { axisOffset: e, chartWidth: s, chartHeight: r, container: l, plotHeight: d, plotLeft: c, plotTop: u, plotWidth: g, scrollablePixelsX: f = 0, scrollablePixelsY: m = 0, scrollingContainer: x } = this, y = !this.fixedDiv, b = this.options.chart, v = b.scrollablePlotArea, { scrollPositionX: S, scrollPositionY: k } = v, M = i.getRendererType(), { fixedRenderer: C } = this;\n            C ? C.setSize(s, r) : (this.fixedDiv = a(\"div\", {\n                className: \"highcharts-fixed\"\n            }, {\n                position: \"absolute\",\n                overflow: \"hidden\",\n                pointerEvents: \"none\",\n                zIndex: (((_b_style = b.style) === null || _b_style === void 0 ? void 0 : _b_style.zIndex) || 0) + 2,\n                top: 0\n            }, void 0, !0), x === null || x === void 0 ? void 0 : x.parentNode.insertBefore(this.fixedDiv, x), h(this.renderTo, {\n                overflow: \"visible\"\n            }), this.fixedRenderer = C = new M(this.fixedDiv, s, r, b.style), this.scrollableMask = C.path().attr({\n                fill: b.backgroundColor || \"#fff\",\n                \"fill-opacity\": p(v.opacity, .85),\n                zIndex: -1\n            }).addClass(\"highcharts-scrollable-mask\").add(), n(this, \"afterShowResetZoom\", this.moveFixedElements), n(this, \"afterApplyDrilldown\", this.moveFixedElements), n(this, \"afterLayOutTitles\", this.moveFixedElements)), (this.scrollableDirty || y) && (this.scrollableDirty = !1, this.moveFixedElements());\n            let w = s + f, T = r + m;\n            o(this.container), h(l, {\n                width: \"\".concat(w, \"px\"),\n                height: \"\".concat(T, \"px\")\n            }), this.renderer.boxWrapper.attr({\n                width: w,\n                height: T,\n                viewBox: [\n                    0,\n                    0,\n                    w,\n                    T\n                ].join(\" \")\n            }), (_this_chartBackground = this.chartBackground) === null || _this_chartBackground === void 0 ? void 0 : _this_chartBackground.attr({\n                width: w,\n                height: T\n            }), x && (h(x, {\n                width: \"\".concat(this.chartWidth, \"px\"),\n                height: \"\".concat(this.chartHeight, \"px\")\n            }), y && (S && (x.scrollLeft = f * S), k && (x.scrollTop = m * k)));\n            let A = u - e[0] - 1, P = c - e[3] - 1, L = u + d + e[2] + 1, O = c + g + e[1] + 1, D = c + g - f, E = u + d - m;\n            t = f ? [\n                [\n                    \"M\",\n                    0,\n                    A\n                ],\n                [\n                    \"L\",\n                    c - 1,\n                    A\n                ],\n                [\n                    \"L\",\n                    c - 1,\n                    L\n                ],\n                [\n                    \"L\",\n                    0,\n                    L\n                ],\n                [\n                    \"Z\"\n                ],\n                [\n                    \"M\",\n                    D,\n                    A\n                ],\n                [\n                    \"L\",\n                    s,\n                    A\n                ],\n                [\n                    \"L\",\n                    s,\n                    L\n                ],\n                [\n                    \"L\",\n                    D,\n                    L\n                ],\n                [\n                    \"Z\"\n                ]\n            ] : m ? [\n                [\n                    \"M\",\n                    P,\n                    0\n                ],\n                [\n                    \"L\",\n                    P,\n                    u - 1\n                ],\n                [\n                    \"L\",\n                    O,\n                    u - 1\n                ],\n                [\n                    \"L\",\n                    O,\n                    0\n                ],\n                [\n                    \"Z\"\n                ],\n                [\n                    \"M\",\n                    P,\n                    E\n                ],\n                [\n                    \"L\",\n                    P,\n                    r\n                ],\n                [\n                    \"L\",\n                    O,\n                    r\n                ],\n                [\n                    \"L\",\n                    O,\n                    E\n                ],\n                [\n                    \"Z\"\n                ]\n            ] : [\n                [\n                    \"M\",\n                    0,\n                    0\n                ]\n            ], \"adjustHeight\" !== this.redrawTrigger && ((_this_scrollableMask = this.scrollableMask) === null || _this_scrollableMask === void 0 ? void 0 : _this_scrollableMask.attr({\n                d: t\n            }));\n        }\n        function f() {\n            let t;\n            let e = this.container, i = this.fixedRenderer, s = [\n                \".highcharts-breadcrumbs-group\",\n                \".highcharts-contextbutton\",\n                \".highcharts-caption\",\n                \".highcharts-credits\",\n                \".highcharts-legend\",\n                \".highcharts-legend-checkbox\",\n                \".highcharts-navigator-series\",\n                \".highcharts-navigator-xaxis\",\n                \".highcharts-navigator-yaxis\",\n                \".highcharts-navigator\",\n                \".highcharts-reset-zoom\",\n                \".highcharts-drillup-button\",\n                \".highcharts-scrollbar\",\n                \".highcharts-subtitle\",\n                \".highcharts-title\"\n            ];\n            for (let o of (this.scrollablePixelsX && !this.inverted ? t = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? t = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? t = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (t = \".highcharts-yaxis\"), t && s.push(\"\".concat(t, \":not(.highcharts-radial-axis)\"), \"\".concat(t, \"-labels:not(.highcharts-radial-axis-labels)\")), s))[].forEach.call(e.querySelectorAll(o), (t)=>{\n                (t.namespaceURI === i.SVG_NS ? i.box : i.box.parentNode).appendChild(t), t.style.pointerEvents = \"auto\";\n            });\n        }\n        function m() {\n            let t;\n            let e = {\n                WebkitOverflowScrolling: \"touch\",\n                overflowX: \"hidden\",\n                overflowY: \"hidden\"\n            };\n            this.scrollablePixelsX && (e.overflowX = \"auto\"), this.scrollablePixelsY && (e.overflowY = \"auto\"), this.scrollingParent = a(\"div\", {\n                className: \"highcharts-scrolling-parent\"\n            }, {\n                position: \"relative\"\n            }, this.renderTo), this.scrollingContainer = a(\"div\", {\n                className: \"highcharts-scrolling\"\n            }, e, this.scrollingParent), n(this.scrollingContainer, \"scroll\", ()=>{\n                this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (t = this.hoverPoint), this.pointer.runPointActions(void 0, t, !0));\n            }), this.innerContainer = a(\"div\", {\n                className: \"highcharts-inner-container\"\n            }, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null;\n        }\n        function x() {\n            this.chart.scrollableDirty = !0;\n        }\n        function y(t) {\n            let e, i, s;\n            let o = this.options.chart.scrollablePlotArea, r = o && o.minWidth, n = o && o.minHeight;\n            if (!this.renderer.forExport && (r ? (this.scrollablePixelsX = e = Math.max(0, r - this.chartWidth), e && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.width = this.plotWidth += e, this.inverted ? this.clipBox.height += e : this.clipBox.width += e, s = {\n                1: {\n                    name: \"right\",\n                    value: e\n                }\n            })) : n && (this.scrollablePixelsY = i = Math.max(0, n - this.chartHeight), l(i) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.height = this.plotHeight += i, this.inverted ? this.clipBox.width += i : this.clipBox.height += i, s = {\n                2: {\n                    name: \"bottom\",\n                    value: i\n                }\n            })), s && !t.skipAxes)) for (let t of this.axes)if (s[t.side]) {\n                let e = t.getPlotLinePath;\n                t.getPlotLinePath = function() {\n                    let i = s[t.side].name, o = s[t.side].value, r = this[i];\n                    this[i] = r - o;\n                    let n = e.apply(this, arguments);\n                    return this[i] = r, n;\n                };\n            } else t.setAxisSize(), t.setAxisTranslation();\n        }\n        function b() {\n            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n        }\n        function v() {\n            this.chart.scrollableDirty = !0;\n        }\n        return {\n            compose: function t(e, i, s) {\n                u(r, t) && (n(e, \"afterInit\", x), d(i.prototype, {\n                    applyFixed: g,\n                    moveFixedElements: f,\n                    setUpScrolling: m\n                }), n(i, \"afterSetChartSize\", y), n(i, \"render\", b), n(s, \"show\", v));\n            }\n        };\n    }), i(e, \"Core/Axis/Stacking/StackItem.js\", [\n        e[\"Core/Templating.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { format: s } = t, { series: o } = e, { destroyObjectProperties: r, fireEvent: n, isNumber: a, pick: h } = i;\n        return class {\n            destroy() {\n                r(this, this.axis);\n            }\n            render(t) {\n                let e = this.axis.chart, i = this.options, o = i.format, r = o ? s(o, this, e) : i.formatter.call(this);\n                if (this.label) this.label.attr({\n                    text: r,\n                    visibility: \"hidden\"\n                });\n                else {\n                    this.label = e.renderer.label(r, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, \"stack-labels\");\n                    let s = {\n                        r: i.borderRadius || 0,\n                        text: r,\n                        padding: h(i.padding, 5),\n                        visibility: \"hidden\"\n                    };\n                    e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s[\"stroke-width\"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);\n                }\n                this.label.labelrank = e.plotSizeY, n(this, \"afterRender\");\n            }\n            setOffset(t, e, i, s, r, l) {\n                let { alignOptions: d, axis: c, label: p, options: u, textAlign: g } = this, f = c.chart, m = this.getStackBox({\n                    xOffset: t,\n                    width: e,\n                    boxBottom: i,\n                    boxTop: s,\n                    defaultX: r,\n                    xAxis: l\n                }), { verticalAlign: x } = d;\n                if (p && m) {\n                    let t = p.getBBox(), e = p.padding, i = \"justify\" === h(u.overflow, \"justify\"), s;\n                    d.x = u.x || 0, d.y = u.y || 0;\n                    let { x: r, y: n } = this.adjustStackPosition({\n                        labelBox: t,\n                        verticalAlign: x,\n                        textAlign: g\n                    });\n                    m.x -= r, m.y -= n, p.align(d, !1, m), (s = f.isInsidePlot(p.alignAttr.x + d.x + r, p.alignAttr.y + d.y + n)) || (i = !1), i && o.prototype.justifyDataLabel.call(c, p, d, p.alignAttr, t, m), p.attr({\n                        x: p.alignAttr.x,\n                        y: p.alignAttr.y,\n                        rotation: u.rotation,\n                        rotationOriginX: t.width / 2,\n                        rotationOriginY: t.height / 2\n                    }), h(!i && u.crop, !0) && (s = a(p.x) && a(p.y) && f.isInsidePlot(p.x - e + (p.width || 0), p.y) && f.isInsidePlot(p.x + e, p.y)), p[s ? \"show\" : \"hide\"]();\n                }\n                n(this, \"afterSetOffset\", {\n                    xOffset: t,\n                    width: e\n                });\n            }\n            adjustStackPosition(param) {\n                let { labelBox: t, verticalAlign: e, textAlign: i } = param;\n                let s = {\n                    bottom: 0,\n                    middle: 1,\n                    top: 2,\n                    right: 1,\n                    center: 0,\n                    left: -1\n                }, o = s[e], r = s[i];\n                return {\n                    x: t.width / 2 + t.width / 2 * r,\n                    y: t.height / 2 * o\n                };\n            }\n            getStackBox(t) {\n                let e = this.axis, i = e.chart, { boxTop: s, defaultX: o, xOffset: r, width: n, boxBottom: l } = t, d = e.stacking.usePercentage ? 100 : h(s, this.total, 0), c = e.toPixels(d), p = t.xAxis || i.xAxis[0], u = h(o, p.translate(this.x)) + r, g = e.toPixels(l || a(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0), f = Math.abs(c - g), m = i.inverted, x = this.isNegative;\n                return m ? {\n                    x: (x ? c : c - f) - i.plotLeft,\n                    y: p.height - u - n,\n                    width: f,\n                    height: n\n                } : {\n                    x: u + p.transB - i.plotLeft,\n                    y: (x ? c - f : c) - i.plotTop,\n                    width: n,\n                    height: f\n                };\n            }\n            constructor(t, e, i, s, o){\n                let r = t.chart.inverted, n = t.reversed;\n                this.axis = t;\n                let a = this.isNegative = !!i != !!n;\n                this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {\n                    align: e.align || (r ? a ? \"left\" : \"right\" : \"center\"),\n                    verticalAlign: e.verticalAlign || (r ? \"middle\" : a ? \"bottom\" : \"top\"),\n                    y: e.y,\n                    x: e.x\n                }, this.textAlign = e.textAlign || (r ? a ? \"right\" : \"left\" : \"center\");\n            }\n        };\n    }), i(e, \"Core/Axis/Stacking/StackingAxis.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Axis/Axis.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Axis/Stacking/StackItem.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r) {\n        var n;\n        let { getDeferredAnimation: a } = t, { composed: h } = i, { series: { prototype: l } } = s, { addEvent: d, correctFloat: c, defined: p, destroyObjectProperties: u, fireEvent: g, isArray: f, isNumber: m, objectEach: x, pick: y, pushUnique: b } = r;\n        function v() {\n            let t = this.inverted;\n            this.axes.forEach((t)=>{\n                t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);\n            }), this.series.forEach((e)=>{\n                let i = e.xAxis && e.xAxis.options || {};\n                e.options.stacking && e.reserveSpace() && (e.stackKey = [\n                    e.type,\n                    y(e.options.stack, \"\"),\n                    t ? i.top : i.left,\n                    t ? i.height : i.width\n                ].join(\",\"));\n            });\n        }\n        function S() {\n            let t = this.stacking;\n            if (t) {\n                var _t_stackTotalGroup;\n                let e = t.stacks;\n                x(e, (t, i)=>{\n                    u(t), delete e[i];\n                }), (_t_stackTotalGroup = t.stackTotalGroup) === null || _t_stackTotalGroup === void 0 ? void 0 : _t_stackTotalGroup.destroy();\n            }\n        }\n        function k() {\n            this.stacking || (this.stacking = new P(this));\n        }\n        function M(t, e, i, s) {\n            return !p(t) || t.x !== e || s && t.stackKey !== s ? t = {\n                x: e,\n                index: 0,\n                key: s,\n                stackKey: s\n            } : t.index++, t.key = [\n                i,\n                e,\n                t.index\n            ].join(\",\"), t;\n        }\n        function C() {\n            let t;\n            let e = this, i = e.yAxis, s = e.stackKey || \"\", o = i.stacking.stacks, r = e.processedXData, n = e.options.stacking, a = e[n + \"Stacker\"];\n            a && [\n                s,\n                \"-\" + s\n            ].forEach((i)=>{\n                var _o_i;\n                let s = r.length, n, h, l;\n                for(; s--;)n = r[s], t = e.getStackIndicator(t, n, e.index, i), h = (_o_i = o[i]) === null || _o_i === void 0 ? void 0 : _o_i[n], (l = h === null || h === void 0 ? void 0 : h.points[t.key || \"\"]) && a.call(e, l, h, s);\n            });\n        }\n        function w(t, e, i) {\n            let s = e.total ? 100 / e.total : 0;\n            t[0] = c(t[0] * s), t[1] = c(t[1] * s), this.stackedYData[i] = t[1];\n        }\n        function T(t) {\n            (this.is(\"column\") || this.is(\"columnrange\")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? l.setStackedPoints.call(this, t, \"group\") : t.stacking.resetStacks());\n        }\n        function A(t, e) {\n            let i, s, r, n, a, h, l, d, u;\n            let g = e || this.options.stacking;\n            if (!g || !this.reserveSpace() || (({\n                group: \"xAxis\"\n            })[g] || \"yAxis\") !== t.coll) return;\n            let m = this.processedXData, x = this.processedYData, b = [], v = x.length, S = this.options, k = S.threshold || 0, M = S.startFromThreshold ? k : 0, C = S.stack, w = e ? \"\".concat(this.type, \",\").concat(g) : this.stackKey || \"\", T = \"-\" + w, A = this.negStacks, P = t.stacking, L = P.stacks, O = P.oldStacks;\n            for(P.stacksTouched += 1, l = 0; l < v; l++){\n                var _O_a, _L_n;\n                d = m[l], u = x[l], h = (i = this.getStackIndicator(i, d, this.index)).key || \"\", L[a = (s = A && u < (M ? 0 : k)) ? T : w] || (L[a] = {}), L[a][d] || (((_O_a = O[a]) === null || _O_a === void 0 ? void 0 : _O_a[d]) ? (L[a][d] = O[a][d], L[a][d].total = null) : L[a][d] = new o(t, t.options.stackLabels, !!s, d, C)), r = L[a][d], null !== u ? (r.points[h] = r.points[this.index] = [\n                    y(r.cumulative, M)\n                ], p(r.cumulative) || (r.base = h), r.touched = P.stacksTouched, i.index > 0 && !1 === this.singleStacks && (r.points[h][0] = r.points[this.index + \",\" + d + \",0\"][0])) : (delete r.points[h], delete r.points[this.index]);\n                let e = r.total || 0;\n                \"percent\" === g ? (n = s ? w : T, e = A && ((_L_n = L[n]) === null || _L_n === void 0 ? void 0 : _L_n[d]) ? (n = L[n][d]).total = Math.max(n.total || 0, e) + Math.abs(u) || 0 : c(e + (Math.abs(u) || 0))) : \"group\" === g ? (f(u) && (u = u[0]), null !== u && e++) : e = c(e + (u || 0)), \"group\" === g ? r.cumulative = (e || 1) - 1 : r.cumulative = c(y(r.cumulative, M) + (u || 0)), r.total = e, null !== u && (r.points[h].push(r.cumulative), b[l] = r.cumulative, r.hasValidPoints = !0);\n            }\n            \"percent\" === g && (P.usePercentage = !0), \"group\" !== g && (this.stackedYData = b), P.oldStacks = {};\n        }\n        class P {\n            buildStacks() {\n                let t, e;\n                let i = this.axis, s = i.series, o = \"xAxis\" === i.coll, r = i.options.reversedStacks, n = s.length;\n                for(this.resetStacks(), this.usePercentage = !1, e = n; e--;)t = s[r ? e : n - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);\n                if (!o) for(e = 0; e < n; e++)s[e].modifyStacks();\n                g(i, \"afterBuildStacks\");\n            }\n            cleanStacks() {\n                this.oldStacks && (this.stacks = this.oldStacks, x(this.stacks, (t)=>{\n                    x(t, (t)=>{\n                        t.cumulative = t.total;\n                    });\n                }));\n            }\n            resetStacks() {\n                x(this.stacks, (t)=>{\n                    x(t, (e, i)=>{\n                        m(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);\n                    });\n                });\n            }\n            renderStackTotals() {\n                var _t_options_stackLabels;\n                let t = this.axis, e = t.chart, i = e.renderer, s = this.stacks, o = (_t_options_stackLabels = t.options.stackLabels) === null || _t_options_stackLabels === void 0 ? void 0 : _t_options_stackLabels.animation, r = a(e, o || !1), n = this.stackTotalGroup = this.stackTotalGroup || i.g(\"stack-labels\").attr({\n                    zIndex: 6,\n                    opacity: 0\n                }).add();\n                n.translate(e.plotLeft, e.plotTop), x(s, (t)=>{\n                    x(t, (t)=>{\n                        t.render(n);\n                    });\n                }), n.animate({\n                    opacity: 1\n                }, r);\n            }\n            constructor(t){\n                this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;\n            }\n        }\n        return (n || (n = {})).compose = function t(e, i, s) {\n            if (b(h, t)) {\n                let t = i.prototype, o = s.prototype;\n                d(e, \"init\", k), d(e, \"destroy\", S), t.getStacks = v, o.getStackIndicator = M, o.modifyStacks = C, o.percentStacker = w, o.setGroupedPoints = T, o.setStackedPoints = A;\n            }\n        }, n;\n    }), i(e, \"Series/Line/LineSeries.js\", [\n        e[\"Core/Series/Series.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { defined: s, merge: o, isObject: r } = i;\n        class n extends t {\n            drawGraph() {\n                let t = this.options, e = (this.gappedPath || this.getGraphPath).call(this), i = this.chart.styledMode;\n                [\n                    this,\n                    ...this.zones\n                ].forEach((s, n)=>{\n                    let a, h = s.graph, l = h ? \"animate\" : \"attr\", d = s.dashStyle || t.dashStyle;\n                    h ? (h.endX = this.preventGraphAnimation ? null : e.xMap, h.animate({\n                        d: e\n                    })) : e.length && (s.graph = h = this.chart.renderer.path(e).addClass(\"highcharts-graph\" + (n ? \" highcharts-zone-graph-\".concat(n - 1, \" \") : \" \") + (n && s.className || \"\")).attr({\n                        zIndex: 1\n                    }).add(this.group)), h && !i && (a = {\n                        stroke: !n && t.lineColor || s.color || this.color || \"#cccccc\",\n                        \"stroke-width\": t.lineWidth || 0,\n                        fill: this.fillGraph && this.color || \"none\"\n                    }, d ? a.dashstyle = d : \"square\" !== t.linecap && (a[\"stroke-linecap\"] = a[\"stroke-linejoin\"] = \"round\"), h[l](a).shadow(n < 2 && t.shadow && o({\n                        filterUnits: \"userSpaceOnUse\"\n                    }, r(t.shadow) ? t.shadow : {}))), h && (h.startX = e.xMap, h.isArea = e.isArea);\n                });\n            }\n            getGraphPath(t, e, i) {\n                let o = this, r = o.options, n = [], a = [], h, l = r.step;\n                t = t || o.points;\n                let d = t.reversed;\n                return d && t.reverse(), (l = ({\n                    right: 1,\n                    center: 2\n                })[l] || l && 3) && d && (l = 4 - l), (t = this.getValidPoints(t, !1, !(r.connectNulls && !e && !i))).forEach(function(d, c) {\n                    let p;\n                    let u = d.plotX, g = d.plotY, f = t[c - 1], m = d.isNull || \"number\" != typeof g;\n                    (d.leftCliff || f && f.rightCliff) && !i && (h = !0), m && !s(e) && c > 0 ? h = !r.connectNulls : m && !e ? h = !0 : (0 === c || h ? p = [\n                        [\n                            \"M\",\n                            d.plotX,\n                            d.plotY\n                        ]\n                    ] : o.getPointSpline ? p = [\n                        o.getPointSpline(t, d, c)\n                    ] : l ? (p = 1 === l ? [\n                        [\n                            \"L\",\n                            f.plotX,\n                            g\n                        ]\n                    ] : 2 === l ? [\n                        [\n                            \"L\",\n                            (f.plotX + u) / 2,\n                            f.plotY\n                        ],\n                        [\n                            \"L\",\n                            (f.plotX + u) / 2,\n                            g\n                        ]\n                    ] : [\n                        [\n                            \"L\",\n                            u,\n                            f.plotY\n                        ]\n                    ]).push([\n                        \"L\",\n                        u,\n                        g\n                    ]) : p = [\n                        [\n                            \"L\",\n                            u,\n                            g\n                        ]\n                    ], a.push(d.x), l && (a.push(d.x), 2 === l && a.push(d.x)), n.push.apply(n, p), h = !1);\n                }), n.xMap = a, o.graphPath = n, n;\n            }\n        }\n        return n.defaultOptions = o(t.defaultOptions, {\n            legendSymbol: \"lineMarker\"\n        }), e.registerSeriesType(\"line\", n), n;\n    }), i(e, \"Series/Area/AreaSeries.js\", [\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { parse: s } = t, { seriesTypes: { line: o } } = e, { extend: r, merge: n, objectEach: a, pick: h } = i;\n        class l extends o {\n            drawGraph() {\n                this.areaPath = [], super.drawGraph.apply(this);\n                let { areaPath: t, options: e } = this;\n                [\n                    this,\n                    ...this.zones\n                ].forEach((i, s)=>{\n                    let o = {}, r = i.fillColor || e.fillColor, n = i.area, a = n ? \"animate\" : \"attr\";\n                    var _e_fillOpacity;\n                    n ? (n.endX = this.preventGraphAnimation ? null : t.xMap, n.animate({\n                        d: t\n                    })) : (o.zIndex = 0, (n = i.area = this.chart.renderer.path(t).addClass(\"highcharts-area\" + (s ? \" highcharts-zone-area-\".concat(s - 1, \" \") : \" \") + (s && i.className || \"\")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o[\"fill-opacity\"] = r ? 1 : (_e_fillOpacity = e.fillOpacity) !== null && _e_fillOpacity !== void 0 ? _e_fillOpacity : .75, n.css({\n                        pointerEvents: this.stickyTracking ? \"none\" : \"auto\"\n                    })), n[a](o), n.startX = t.xMap, n.shiftUnit = e.step ? 2 : 1;\n                });\n            }\n            getGraphPath(t) {\n                let e, i, s;\n                let r = o.prototype.getGraphPath, n = this.options, a = n.stacking, l = this.yAxis, d = [], c = [], p = this.index, u = l.stacking.stacks[this.stackKey], g = n.threshold, f = Math.round(l.getThreshold(n.threshold)), m = h(n.connectNulls, \"percent\" === a), x = function(i, s, o) {\n                    let r = t[i], n = a && u[r.x].points[p], h = r[o + \"Null\"] || 0, m = r[o + \"Cliff\"] || 0, x, y, b = !0;\n                    m || h ? (x = (h ? n[0] : n[1]) + m, y = n[0] + m, b = !!h) : !a && t[s] && t[s].isNull && (x = y = g), void 0 !== x && (c.push({\n                        plotX: e,\n                        plotY: null === x ? f : l.getThreshold(x),\n                        isNull: b,\n                        isCliff: !0\n                    }), d.push({\n                        plotX: e,\n                        plotY: null === y ? f : l.getThreshold(y),\n                        doCurve: !1\n                    }));\n                };\n                t = t || this.points, a && (t = this.getStackPoints(t));\n                for(let o = 0, r = t.length; o < r; ++o)a || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = h(t[o].rectPlotX, t[o].plotX), s = a ? h(t[o].yBottom, f) : f, i && !m || (m || x(o, o - 1, \"left\"), i && !a && m || (c.push(t[o]), d.push({\n                    x: o,\n                    plotX: e,\n                    plotY: s\n                })), m || x(o, o + 1, \"right\"));\n                let y = r.call(this, c, !0, !0);\n                d.reversed = !0;\n                let b = r.call(this, d, !0, !0), v = b[0];\n                v && \"M\" === v[0] && (b[0] = [\n                    \"L\",\n                    v[1],\n                    v[2]\n                ]);\n                let S = y.concat(b);\n                S.length && S.push([\n                    \"Z\"\n                ]);\n                let k = r.call(this, c, !1, m);\n                return S.xMap = y.xMap, this.areaPath = S, k;\n            }\n            getStackPoints(t) {\n                let e = this, i = [], s = [], o = this.xAxis, r = this.yAxis, n = r.stacking.stacks[this.stackKey], l = {}, d = r.series, c = d.length, p = r.options.reversedStacks ? 1 : -1, u = d.indexOf(e);\n                if (t = t || this.points, this.options.stacking) {\n                    for(let e = 0; e < t.length; e++)t[e].leftNull = t[e].rightNull = void 0, l[t[e].x] = t[e];\n                    a(n, function(t, e) {\n                        null !== t.total && s.push(e);\n                    }), s.sort(function(t, e) {\n                        return t - e;\n                    });\n                    let g = d.map((t)=>t.visible);\n                    s.forEach(function(t, a) {\n                        let f = 0, m, x;\n                        if (l[t] && !l[t].isNull) i.push(l[t]), [\n                            -1,\n                            1\n                        ].forEach(function(i) {\n                            let o = 1 === i ? \"rightNull\" : \"leftNull\", r = n[s[a + i]], h = 0;\n                            if (r) {\n                                let i = u;\n                                for(; i >= 0 && i < c;){\n                                    let s = d[i].index;\n                                    !(m = r.points[s]) && (s === e.index ? l[t][o] = !0 : g[i] && (x = n[t].points[s]) && (h -= x[1] - x[0])), i += p;\n                                }\n                            }\n                            l[t][1 === i ? \"rightCliff\" : \"leftCliff\"] = h;\n                        });\n                        else {\n                            let e = u;\n                            for(; e >= 0 && e < c;){\n                                let i = d[e].index;\n                                if (m = n[t].points[i]) {\n                                    f = m[1];\n                                    break;\n                                }\n                                e += p;\n                            }\n                            f = h(f, 0), f = r.translate(f, 0, 1, 0, 1), i.push({\n                                isNull: !0,\n                                plotX: o.translate(t, 0, 0, 0, 1),\n                                x: t,\n                                plotY: f,\n                                yBottom: f\n                            });\n                        }\n                    });\n                }\n                return i;\n            }\n        }\n        return l.defaultOptions = n(o.defaultOptions, {\n            threshold: 0,\n            legendSymbol: \"areaMarker\"\n        }), r(l.prototype, {\n            singleStacks: !1\n        }), e.registerSeriesType(\"area\", l), l;\n    }), i(e, \"Series/Spline/SplineSeries.js\", [\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { line: i } = t.seriesTypes, { merge: s, pick: o } = e;\n        class r extends i {\n            getPointSpline(t, e, i) {\n                let s, r, n, a;\n                let h = e.plotX || 0, l = e.plotY || 0, d = t[i - 1], c = t[i + 1];\n                function p(t) {\n                    return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;\n                }\n                if (p(d) && p(c)) {\n                    let t = d.plotX || 0, i = d.plotY || 0, o = c.plotX || 0, p = c.plotY || 0, u = 0;\n                    s = (1.5 * h + t) / 2.5, r = (1.5 * l + i) / 2.5, n = (1.5 * h + o) / 2.5, a = (1.5 * l + p) / 2.5, n !== s && (u = (a - r) * (n - h) / (n - s) + l - a), r += u, a += u, r > i && r > l ? (r = Math.max(i, l), a = 2 * l - r) : r < i && r < l && (r = Math.min(i, l), a = 2 * l - r), a > p && a > l ? (a = Math.max(p, l), r = 2 * l - a) : a < p && a < l && (a = Math.min(p, l), r = 2 * l - a), e.rightContX = n, e.rightContY = a, e.controlPoints = {\n                        low: [\n                            s,\n                            r\n                        ],\n                        high: [\n                            n,\n                            a\n                        ]\n                    };\n                }\n                let u = [\n                    \"C\",\n                    o(d.rightContX, d.plotX, 0),\n                    o(d.rightContY, d.plotY, 0),\n                    o(s, h, 0),\n                    o(r, l, 0),\n                    h,\n                    l\n                ];\n                return d.rightContX = d.rightContY = void 0, u;\n            }\n        }\n        return r.defaultOptions = s(i.defaultOptions), t.registerSeriesType(\"spline\", r), r;\n    }), i(e, \"Series/AreaSpline/AreaSplineSeries.js\", [\n        e[\"Series/Spline/SplineSeries.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { area: s, area: { prototype: o } } = e.seriesTypes, { extend: r, merge: n } = i;\n        class a extends t {\n        }\n        return a.defaultOptions = n(t.defaultOptions, s.defaultOptions), r(a.prototype, {\n            getGraphPath: o.getGraphPath,\n            getStackPoints: o.getStackPoints,\n            drawGraph: o.drawGraph\n        }), e.registerSeriesType(\"areaspline\", a), a;\n    }), i(e, \"Series/Column/ColumnSeriesDefaults.js\", [], function() {\n        return {\n            borderRadius: 3,\n            centerInCategory: !1,\n            groupPadding: .2,\n            marker: null,\n            pointPadding: .1,\n            minPointLength: 0,\n            cropThreshold: 50,\n            pointRange: null,\n            states: {\n                hover: {\n                    halo: !1,\n                    brightness: .1\n                },\n                select: {\n                    color: \"#cccccc\",\n                    borderColor: \"#000000\"\n                }\n            },\n            dataLabels: {\n                align: void 0,\n                verticalAlign: void 0,\n                y: void 0\n            },\n            startFromThreshold: !0,\n            stickyTracking: !1,\n            tooltip: {\n                distance: 6\n            },\n            threshold: 0,\n            borderColor: \"#ffffff\"\n        };\n    }), i(e, \"Series/Column/ColumnSeries.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Color/Color.js\"],\n        e[\"Series/Column/ColumnSeriesDefaults.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Series/Series.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r, n) {\n        let { animObject: a } = t, { parse: h } = e, { hasTouch: l, noop: d } = s, { clamp: c, defined: p, extend: u, fireEvent: g, isArray: f, isNumber: m, merge: x, pick: y, objectEach: b, relativeLength: v } = n;\n        class S extends o {\n            animate(t) {\n                let e, i;\n                let s = this, o = this.yAxis, r = o.pos, n = s.options, h = this.chart.inverted, l = {}, d = h ? \"translateX\" : \"translateY\";\n                t ? (l.scaleY = .001, i = c(o.toPixels(n.threshold), r, r + o.len), h ? l.translateX = i - o.len : l.translateY = i, s.clipBox && s.setClip(), s.group.attr(l)) : (e = Number(s.group.attr(d)), s.group.animate({\n                    scaleY: 1\n                }, u(a(s.options.animation), {\n                    step: function(t, i) {\n                        s.group && (l[d] = e + i.pos * (r - e), s.group.attr(l));\n                    }\n                })));\n            }\n            init(t, e) {\n                super.init.apply(this, arguments);\n                let i = this;\n                (t = i.chart).hasRendered && t.series.forEach(function(t) {\n                    t.type === i.type && (t.isDirty = !0);\n                });\n            }\n            getColumnMetrics() {\n                var _i_brokenAxis, _i_ordinal;\n                let t = this, e = t.options, i = t.xAxis, s = t.yAxis, o = i.options.reversedStacks, r = i.reversed && !o || !i.reversed && o, n = {}, a, h = 0;\n                !1 === e.grouping ? h = 1 : t.chart.series.forEach(function(e) {\n                    let i;\n                    let o = e.yAxis, r = e.options;\n                    e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && \"group\" !== r.stacking ? (void 0 === n[a = e.stackKey] && (n[a] = h++), i = n[a]) : !1 !== r.grouping && (i = h++), e.columnIndex = i);\n                });\n                let l = Math.min(Math.abs(i.transA) * (!((_i_brokenAxis = i.brokenAxis) === null || _i_brokenAxis === void 0 ? void 0 : _i_brokenAxis.hasBreaks) && ((_i_ordinal = i.ordinal) === null || _i_ordinal === void 0 ? void 0 : _i_ordinal.slope) || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len), d = l * e.groupPadding, c = (l - 2 * d) / (h || 1), p = Math.min(e.maxPointWidth || i.len, y(e.pointWidth, c * (1 - 2 * e.pointPadding))), u = (c - p) / 2, g = (t.columnIndex || 0) + (r ? 1 : 0), f = u + (d + g * c - l / 2) * (r ? -1 : 1);\n                return t.columnMetrics = {\n                    width: p,\n                    offset: f,\n                    paddedWidth: c,\n                    columnCount: h\n                }, t.columnMetrics;\n            }\n            crispCol(t, e, i, s) {\n                this.chart;\n                let o = this.borderWidth, r = -(o % 2 ? .5 : 0), n = o % 2 ? .5 : 1;\n                this.options.crisp && (i = Math.round(t + i) + r - (t = Math.round(t) + r));\n                let a = Math.round(e + s) + n, h = .5 >= Math.abs(e) && a > .5;\n                return s = a - (e = Math.round(e) + n), h && s && (e -= 1, s += 1), {\n                    x: t,\n                    y: e,\n                    width: i,\n                    height: s\n                };\n            }\n            adjustForMissingColumns(t, e, i, s) {\n                if (!i.isNull && s.columnCount > 1) {\n                    var _this_xAxis_stacking;\n                    let o = this.xAxis.series.filter((t)=>t.visible).map((t)=>t.index), r = 0, n = 0;\n                    b((_this_xAxis_stacking = this.xAxis.stacking) === null || _this_xAxis_stacking === void 0 ? void 0 : _this_xAxis_stacking.stacks, (t)=>{\n                        if (\"number\" == typeof i.x) {\n                            let e = t[i.x.toString()];\n                            if (e) {\n                                let t = e.points[this.index];\n                                if (f(t)) {\n                                    let t = Object.keys(e.points).filter((t)=>!t.match(\",\") && e.points[t] && e.points[t].length > 1).map(parseFloat).filter((t)=>-1 !== o.indexOf(t)).sort((t, e)=>e - t);\n                                    r = t.indexOf(this.index), n = t.length;\n                                }\n                            }\n                        }\n                    });\n                    let a = (n - 1) * s.paddedWidth + e;\n                    t = (i.plotX || 0) + a / 2 - e - r * s.paddedWidth;\n                }\n                return t;\n            }\n            translate() {\n                let t = this, e = t.chart, i = t.options, s = t.dense = t.closestPointRange * t.xAxis.transA < 2, r = t.borderWidth = y(i.borderWidth, s ? 0 : 1), n = t.xAxis, a = t.yAxis, h = i.threshold, l = y(i.minPointLength, 5), d = t.getColumnMetrics(), u = d.width, f = t.pointXOffset = d.offset, x = t.dataMin, b = t.dataMax, v = t.barW = Math.max(u, 1 + 2 * r), S = t.translatedThreshold = a.getThreshold(h);\n                e.inverted && (S -= .5), i.pointPadding && (v = Math.ceil(v)), o.prototype.translate.apply(t), t.points.forEach(function(s) {\n                    let o = y(s.yBottom, S), r = 999 + Math.abs(o), g = s.plotX || 0, k = c(s.plotY, -r, a.len + r);\n                    s.stackBox;\n                    let M, C = Math.min(k, o), w = Math.max(k, o) - C, T = u, A = g + f, P = v;\n                    l && Math.abs(w) < l && (w = l, M = !a.reversed && !s.negative || a.reversed && s.negative, m(h) && m(b) && s.y === h && b <= h && (a.min || 0) < h && (x !== b || (a.max || 0) <= h) && (M = !M, s.negative = !s.negative), C = Math.abs(C - S) > l ? o - l : S - (M ? l : 0)), p(s.options.pointWidth) && (A -= Math.round(((T = P = Math.ceil(s.options.pointWidth)) - u) / 2)), i.centerInCategory && !i.stacking && (A = t.adjustForMissingColumns(A, T, s, d)), s.barX = A, s.pointWidth = T, s.tooltipPos = e.inverted ? [\n                        c(a.len + a.pos - e.plotLeft - k, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft),\n                        n.len + n.pos - e.plotTop - A - P / 2,\n                        w\n                    ] : [\n                        n.left - e.plotLeft + A + P / 2,\n                        c(k + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop),\n                        w\n                    ], s.shapeType = t.pointClass.prototype.shapeType || \"roundedRect\", s.shapeArgs = t.crispCol(A, s.isNull ? S : C, P, s.isNull ? 0 : w);\n                }), g(this, \"afterColumnTranslate\");\n            }\n            drawGraph() {\n                this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n            }\n            pointAttribs(t, e) {\n                let i = this.options, s = this.pointAttrToOptions || {}, o = s.stroke || \"borderColor\", r = s[\"stroke-width\"] || \"borderWidth\", n, a, l, d = t && t.color || this.color, c = t && t[o] || i[o] || d, p = t && t.options.dashStyle || i.dashStyle, u = t && t[r] || i[r] || this[r] || 0, g = y(t && t.opacity, i.opacity, 1);\n                t && this.zones.length && (a = t.getZone(), d = t.options.color || a && (a.color || t.nonZonedColor) || this.color, a && (c = a.borderColor || c, p = a.dashStyle || p, u = a.borderWidth || u)), e && t && (l = (n = x(i.states[e], t.options.states && t.options.states[e] || {})).brightness, d = n.color || void 0 !== l && h(d).brighten(n.brightness).get() || d, c = n[o] || c, u = n[r] || u, p = n.dashStyle || p, g = y(n.opacity, g));\n                let f = {\n                    fill: d,\n                    stroke: c,\n                    \"stroke-width\": u,\n                    opacity: g\n                };\n                return p && (f.dashstyle = p), f;\n            }\n            drawPoints() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.points;\n                let e;\n                let i = this, s = this.chart, o = i.options, r = s.renderer, n = o.animationLimit || 250;\n                t.forEach(function(t) {\n                    let a = t.plotY, h = t.graphic, l = !!h, d = h && s.pointCount < n ? \"animate\" : \"attr\";\n                    m(a) && null !== t.y ? (e = t.shapeArgs, h && t.hasNewShapeType() && (h = h.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !h && (t.graphic = h = r[t.shapeType](e).add(t.group || i.group), h && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (h.attr({\n                        x: t.startXPos\n                    }), l = !0, d = \"animate\")), h && l && h[d](x(e)), s.styledMode || h[d](i.pointAttribs(t, t.selected && \"select\")).shadow(!1 !== t.allowShadow && o.shadow), h && (h.addClass(t.getClassName(), !0), h.attr({\n                        visibility: t.visible ? \"inherit\" : \"hidden\"\n                    }))) : h && (t.graphic = h.destroy());\n                });\n            }\n            drawTracker() {\n                let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.points;\n                let e;\n                let i = this, s = i.chart, o = s.pointer, r = function(t) {\n                    let e = o.getPointFromEvent(t);\n                    void 0 !== e && i.options.enableMouseTracking && (o.isDirectTouch = !0, e.onMouseOver(t));\n                };\n                t.forEach(function(t) {\n                    e = f(t.dataLabels) ? t.dataLabels : t.dataLabel ? [\n                        t.dataLabel\n                    ] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function(e) {\n                        e.div ? e.div.point = t : e.element.point = t;\n                    });\n                }), i._hasTracking || (i.trackerGroups.forEach(function(t) {\n                    i[t] && (i[t].addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\", function(t) {\n                        o.onTrackerMouseOut(t);\n                    }), l && i[t].on(\"touchstart\", r), !s.styledMode && i.options.cursor && i[t].css({\n                        cursor: i.options.cursor\n                    }));\n                }), i._hasTracking = !0), g(this, \"afterDrawTracker\");\n            }\n            remove() {\n                let t = this, e = t.chart;\n                e.hasRendered && e.series.forEach(function(e) {\n                    e.type === t.type && (e.isDirty = !0);\n                }), o.prototype.remove.apply(t, arguments);\n            }\n        }\n        return S.defaultOptions = x(o.defaultOptions, i), u(S.prototype, {\n            directTouch: !0,\n            getSymbol: d,\n            negStacks: !0,\n            trackerGroups: [\n                \"group\",\n                \"dataLabelsGroup\"\n            ]\n        }), r.registerSeriesType(\"column\", S), S;\n    }), i(e, \"Core/Series/DataLabel.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Templating.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s) {\n        var o;\n        let { getDeferredAnimation: r } = t, { format: n } = e, { composed: a } = i, { defined: h, extend: l, fireEvent: d, isArray: c, isString: p, merge: u, objectEach: g, pick: f, pInt: m, pushUnique: x, splat: y } = s;\n        return function(t) {\n            function e() {\n                return k(this).some((t)=>t === null || t === void 0 ? void 0 : t.enabled);\n            }\n            function i(t, e, i, s, o) {\n                let r = this, n = this.chart, a = this.isCartesian && n.inverted, d = this.enabledDataSorting, c = t.plotX, p = t.plotY, u = i.rotation, g = i.align, m = h(c) && h(p) && n.isInsidePlot(c, Math.round(p), {\n                    inverted: a,\n                    paneCoordinates: !0,\n                    series: r\n                }), x = (i)=>{\n                    d && r.xAxis && !S && r.setDataLabelStartPos(t, e, o, m, i);\n                }, y, b, v, S = \"justify\" === f(i.overflow, d ? \"none\" : \"justify\"), k = this.visible && !1 !== t.visible && h(c) && (t.series.forceDL || d && !S || m || f(i.inside, !!this.options.stacking) && s && n.isInsidePlot(c, a ? s.x + 1 : s.y + s.height - 1, {\n                    inverted: a,\n                    paneCoordinates: !0,\n                    series: r\n                })), M = t.pos();\n                if (k && M) {\n                    u && e.attr({\n                        align: g\n                    });\n                    let t = e.getBBox(!0), a = [\n                        0,\n                        0\n                    ];\n                    if (y = n.renderer.fontMetrics(e).b, s = l({\n                        x: M[0],\n                        y: Math.round(M[1]),\n                        width: 0,\n                        height: 0\n                    }, s), l(i, {\n                        width: t.width,\n                        height: t.height\n                    }), u ? (S = !1, b = n.renderer.rotCorr(y, u), v = {\n                        x: s.x + (i.x || 0) + s.width / 2 + b.x,\n                        y: s.y + (i.y || 0) + ({\n                            top: 0,\n                            middle: .5,\n                            bottom: 1\n                        })[i.verticalAlign] * s.height\n                    }, a = [\n                        t.x - Number(e.attr(\"x\")),\n                        t.y - Number(e.attr(\"y\"))\n                    ], x(v), e[o ? \"attr\" : \"animate\"](v)) : (x(s), e.align(i, void 0, s), v = e.alignAttr), S && s.height >= 0) this.justifyDataLabel(e, i, v, t, s, o);\n                    else if (f(i.crop, !0)) {\n                        let { x: e, y: i } = v;\n                        e += a[0], i += a[1], k = n.isInsidePlot(e, i, {\n                            paneCoordinates: !0,\n                            series: r\n                        }) && n.isInsidePlot(e + t.width, i + t.height, {\n                            paneCoordinates: !0,\n                            series: r\n                        });\n                    }\n                    i.shape && !u && e[o ? \"attr\" : \"animate\"]({\n                        anchorX: M[0],\n                        anchorY: M[1]\n                    });\n                }\n                o && d && (e.placed = !1), k || d && !S ? e.show() : (e.hide(), e.placed = !1);\n            }\n            function s() {\n                return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n            }\n            function o(t) {\n                let e = this.hasRendered || 0, i = this.initDataLabelsGroup().attr({\n                    opacity: +e\n                });\n                return !e && i && (this.visible && i.show(), this.options.animation ? i.animate({\n                    opacity: 1\n                }, t) : i.attr({\n                    opacity: 1\n                })), i;\n            }\n            function b(t) {\n                var _i_hasDataLabels;\n                let e;\n                t = t || this.points;\n                let i = this, s = i.chart, o = i.options, a = s.renderer, { backgroundColor: l, plotBackgroundColor: c } = s.options.chart, u = a.getContrast(p(c) && c || p(l) && l || \"#000000\"), x = k(i), { animation: b, defer: v } = x[0], M = v ? r(s, b, i) : {\n                    defer: 0,\n                    duration: 0\n                };\n                d(this, \"drawDataLabels\"), ((_i_hasDataLabels = i.hasDataLabels) === null || _i_hasDataLabels === void 0 ? void 0 : _i_hasDataLabels.call(i)) && (e = this.initDataLabels(M), t.forEach((t)=>{\n                    var _t_options, _r_l;\n                    let r = t.dataLabels || [];\n                    y(S(x, t.dlOptions || ((_t_options = t.options) === null || _t_options === void 0 ? void 0 : _t_options.dataLabels))).forEach((l, d)=>{\n                        let c = l.enabled && t.visible && (!t.isNull || t.dataLabelOnNull) && function(t, e) {\n                            let i = e.filter;\n                            if (i) {\n                                let e = i.operator, s = t[i.property], o = i.value;\n                                return \">\" === e && s > o || \"<\" === e && s < o || \">=\" === e && s >= o || \"<=\" === e && s <= o || \"==\" === e && s == o || \"===\" === e && s === o || \"!=\" === e && s != o || \"!==\" === e && s !== o;\n                            }\n                            return !0;\n                        }(t, l), { backgroundColor: x, borderColor: y, distance: b, style: v = {} } = l, S, k, M, C, w = {}, T = r[d], A = !T, P;\n                        if (c && (k = f(l[t.formatPrefix + \"Format\"], l.format), S = t.getLabelConfig(), M = h(k) ? n(k, S, s) : (l[t.formatPrefix + \"Formatter\"] || l.formatter).call(S, l), C = l.rotation, !s.styledMode && (v.color = f(l.color, v.color, p(i.color) ? i.color : void 0, \"#000000\"), \"contrast\" === v.color ? (\"none\" !== x && (P = x), t.contrastColor = a.getContrast(\"auto\" !== P && P || t.color || i.color), v.color = P || !h(b) && l.inside || 0 > m(b || 0) || o.stacking ? t.contrastColor : u) : delete t.contrastColor, o.cursor && (v.cursor = o.cursor)), w = {\n                            r: l.borderRadius || 0,\n                            rotation: C,\n                            padding: l.padding,\n                            zIndex: 1\n                        }, s.styledMode || (w.fill = \"auto\" === x ? t.color : x, w.stroke = \"auto\" === y ? t.color : y, w[\"stroke-width\"] = l.borderWidth), g(w, (t, e)=>{\n                            void 0 === t && delete w[e];\n                        })), !T || c && h(M) && !!T.div == !!l.useHTML && (T.rotation && l.rotation || T.rotation === l.rotation) || (T = void 0, A = !0), c && h(M) && (T ? w.text = M : (T = C ? a.text(M, 0, 0, l.useHTML).addClass(\"highcharts-data-label\") : a.label(M, 0, 0, l.shape, void 0, void 0, l.useHTML, void 0, \"data-label\")) && T.addClass(\" highcharts-data-label-color-\" + t.colorIndex + \" \" + (l.className || \"\") + (l.useHTML ? \" highcharts-tracker\" : \"\")), T)) {\n                            var _t_getDataLabelPath;\n                            T.options = l, T.attr(w), s.styledMode || T.css(v).shadow(l.shadow);\n                            let o = l[t.formatPrefix + \"TextPath\"] || l.textPath;\n                            o && !l.useHTML && (T.setTextPath(((_t_getDataLabelPath = t.getDataLabelPath) === null || _t_getDataLabelPath === void 0 ? void 0 : _t_getDataLabelPath.call(t, T)) || t.graphic, o), t.dataLabelPath && !o.enabled && (t.dataLabelPath = t.dataLabelPath.destroy())), T.added || T.add(e), i.alignDataLabel(t, T, l, void 0, A), T.isActive = !0, r[d] && r[d] !== T && r[d].destroy(), r[d] = T;\n                        }\n                    });\n                    let l = r.length;\n                    for(; l--;)r[l] && r[l].isActive ? r[l].isActive = !1 : ((_r_l = r[l]) === null || _r_l === void 0 ? void 0 : _r_l.destroy(), r.splice(l, 1));\n                    t.dataLabel = r[0], t.dataLabels = r;\n                })), d(this, \"afterDrawDataLabels\");\n            }\n            function v(t, e, i, s, o, r) {\n                let n = this.chart, a = e.align, h = e.verticalAlign, l = t.box ? 0 : t.padding || 0, { x: d = 0, y: c = 0 } = e, p, u;\n                return (p = (i.x || 0) + l) < 0 && (\"right\" === a && d >= 0 ? (e.align = \"left\", e.inside = !0) : d -= p, u = !0), (p = (i.x || 0) + s.width - l) > n.plotWidth && (\"left\" === a && d <= 0 ? (e.align = \"right\", e.inside = !0) : d += n.plotWidth - p, u = !0), (p = i.y + l) < 0 && (\"bottom\" === h && c >= 0 ? (e.verticalAlign = \"top\", e.inside = !0) : c -= p, u = !0), (p = (i.y || 0) + s.height - l) > n.plotHeight && (\"top\" === h && c <= 0 ? (e.verticalAlign = \"bottom\", e.inside = !0) : c += n.plotHeight - p, u = !0), u && (e.x = d, e.y = c, t.placed = !r, t.align(e, void 0, o)), u;\n            }\n            function S(t, e) {\n                let i = [], s;\n                if (c(t) && !c(e)) i = t.map(function(t) {\n                    return u(t, e);\n                });\n                else if (c(e) && !c(t)) i = e.map(function(e) {\n                    return u(t, e);\n                });\n                else if (c(t) || c(e)) {\n                    if (c(t) && c(e)) for(s = Math.max(t.length, e.length); s--;)i[s] = u(t[s], e[s]);\n                } else i = u(t, e);\n                return i;\n            }\n            function k(t) {\n                var _e_series, _e_t_type;\n                let e = t.chart.options.plotOptions;\n                return y(S(S(e === null || e === void 0 ? void 0 : (_e_series = e.series) === null || _e_series === void 0 ? void 0 : _e_series.dataLabels, e === null || e === void 0 ? void 0 : (_e_t_type = e[t.type]) === null || _e_t_type === void 0 ? void 0 : _e_t_type.dataLabels), t.options.dataLabels));\n            }\n            function M(t, e, i, s, o) {\n                let r = this.chart, n = r.inverted, a = this.xAxis, h = a.reversed, l = ((n ? e.height : e.width) || 0) / 2, d = t.pointWidth, c = d ? d / 2 : 0;\n                e.startXPos = n ? o.x : h ? -l - c : a.width - l + c, e.startYPos = n ? h ? this.yAxis.height - l + c : -l - c : o.y, s ? \"hidden\" === e.visibility && (e.show(), e.attr({\n                    opacity: 0\n                }).animate({\n                    opacity: 1\n                })) : e.attr({\n                    opacity: 1\n                }).animate({\n                    opacity: 0\n                }, void 0, e.hide), r.hasRendered && (i && e.attr({\n                    x: e.startXPos,\n                    y: e.startYPos\n                }), e.placed = !0);\n            }\n            t.compose = function t(r) {\n                if (x(a, t)) {\n                    let t = r.prototype;\n                    t.initDataLabelsGroup = s, t.initDataLabels = o, t.alignDataLabel = i, t.drawDataLabels = b, t.justifyDataLabel = v, t.setDataLabelStartPos = M, t.hasDataLabels = e;\n                }\n            };\n        }(o || (o = {})), o;\n    }), i(e, \"Series/Column/ColumnDataLabel.js\", [\n        e[\"Core/Series/DataLabel.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s) {\n        var o;\n        let { composed: r } = e, { series: n } = i, { merge: a, pick: h, pushUnique: l } = s;\n        return function(e) {\n            function i(t, e, i, s, o) {\n                let r = this.chart.inverted, l = t.series, d = (l.xAxis ? l.xAxis.len : this.chart.plotSizeX) || 0, c = (l.yAxis ? l.yAxis.len : this.chart.plotSizeY) || 0, p = t.dlBox || t.shapeArgs, u = h(t.below, t.plotY > h(this.translatedThreshold, c)), g = h(i.inside, !!this.options.stacking);\n                if (p) {\n                    if (s = a(p), !(\"allow\" === i.overflow && !1 === i.crop)) {\n                        s.y < 0 && (s.height += s.y, s.y = 0);\n                        let t = s.y + s.height - c;\n                        t > 0 && t < s.height && (s.height -= t);\n                    }\n                    r && (s = {\n                        x: c - s.y - s.height,\n                        y: d - s.x - s.width,\n                        width: s.height,\n                        height: s.width\n                    }), g || (r ? (s.x += u ? 0 : s.width, s.width = 0) : (s.y += u ? s.height : 0, s.height = 0));\n                }\n                i.align = h(i.align, !r || g ? \"center\" : u ? \"right\" : \"left\"), i.verticalAlign = h(i.verticalAlign, r || g ? \"middle\" : u ? \"top\" : \"bottom\"), n.prototype.alignDataLabel.call(this, t, e, i, s, o), i.inside && t.contrastColor && e.css({\n                    color: t.contrastColor\n                });\n            }\n            e.compose = function e(s) {\n                t.compose(n), l(r, e) && (s.prototype.alignDataLabel = i);\n            };\n        }(o || (o = {})), o;\n    }), i(e, \"Series/Bar/BarSeries.js\", [\n        e[\"Series/Column/ColumnSeries.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { extend: s, merge: o } = i;\n        class r extends t {\n        }\n        return r.defaultOptions = o(t.defaultOptions, {}), s(r.prototype, {\n            inverted: !0\n        }), e.registerSeriesType(\"bar\", r), r;\n    }), i(e, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function() {\n        return {\n            lineWidth: 0,\n            findNearestPointBy: \"xy\",\n            jitter: {\n                x: 0,\n                y: 0\n            },\n            marker: {\n                enabled: !0\n            },\n            tooltip: {\n                headerFormat: '<span style=\"color:{point.color}\">●</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n                pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n            }\n        };\n    }), i(e, \"Series/Scatter/ScatterSeries.js\", [\n        e[\"Series/Scatter/ScatterSeriesDefaults.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { column: s, line: o } = e.seriesTypes, { addEvent: r, extend: n, merge: a } = i;\n        class h extends o {\n            applyJitter() {\n                let t = this, e = this.options.jitter, i = this.points.length;\n                e && this.points.forEach(function(s, o) {\n                    [\n                        \"x\",\n                        \"y\"\n                    ].forEach(function(r, n) {\n                        let a, h = \"plot\" + r.toUpperCase(), l, d, c;\n                        e[r] && !s.isNull && (a = t[r + \"Axis\"], c = e[r] * a.transA, a && !a.isLog && (l = Math.max(0, s[h] - c), d = Math.min(a.len, s[h] + c), s[h] = l + (d - l) * function(t) {\n                            let e = 1e4 * Math.sin(t);\n                            return e - Math.floor(e);\n                        }(o + n * i), \"x\" === r && (s.clientX = s.plotX)));\n                    });\n                });\n            }\n            drawGraph() {\n                this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n            }\n        }\n        return h.defaultOptions = a(o.defaultOptions, t), n(h.prototype, {\n            drawTracker: s.prototype.drawTracker,\n            sorted: !1,\n            requireSorting: !1,\n            noSharedTooltip: !0,\n            trackerGroups: [\n                \"group\",\n                \"markerGroup\",\n                \"dataLabelsGroup\"\n            ]\n        }), r(h, \"afterTranslate\", function() {\n            this.applyJitter();\n        }), e.registerSeriesType(\"scatter\", h), h;\n    }), i(e, \"Series/CenteredUtilities.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Series/Series.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        var s, o;\n        let { deg2rad: r } = t, { fireEvent: n, isNumber: a, pick: h, relativeLength: l } = i;\n        return (o = s || (s = {})).getCenter = function() {\n            let t = this.options, i = this.chart, s = 2 * (t.slicedOffset || 0), o = i.plotWidth - 2 * s, r = i.plotHeight - 2 * s, d = t.center, c = Math.min(o, r), p = t.thickness, u, g = t.size, f = t.innerSize || 0, m, x;\n            \"string\" == typeof g && (g = parseFloat(g)), \"string\" == typeof f && (f = parseFloat(f));\n            let y = [\n                h(d[0], \"50%\"),\n                h(d[1], \"50%\"),\n                h(g && g < 0 ? void 0 : t.size, \"100%\"),\n                h(f && f < 0 ? void 0 : t.innerSize || 0, \"0%\")\n            ];\n            for(!i.angular || this instanceof e || (y[3] = 0), m = 0; m < 4; ++m)x = y[m], u = m < 2 || 2 === m && /%$/.test(x), y[m] = l(x, [\n                o,\n                r,\n                c,\n                y[2]\n            ][m]) + (u ? s : 0);\n            return y[3] > y[2] && (y[3] = y[2]), a(p) && 2 * p < y[2] && p > 0 && (y[3] = y[2] - 2 * p), n(this, \"afterGetCenter\", {\n                positions: y\n            }), y;\n        }, o.getStartAndEndRadians = function(t, e) {\n            let i = a(t) ? t : 0, s = a(e) && e > i && e - i < 360 ? e : i + 360;\n            return {\n                start: r * (i + -90),\n                end: r * (s + -90)\n            };\n        }, s;\n    }), i(e, \"Series/Pie/PiePoint.js\", [\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Series/Point.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { setAnimation: s } = t, { addEvent: o, defined: r, extend: n, isNumber: a, isString: h, pick: l, relativeLength: d } = i;\n        class c extends e {\n            getConnectorPath(t) {\n                let e = t.dataLabelPosition, i = t.options || {}, s = i.connectorShape, o = this.connectorShapes[s] || s;\n                return e && o.call(this, {\n                    ...e.computed,\n                    alignment: e.alignment\n                }, e.connectorPosition, i) || [];\n            }\n            getTranslate() {\n                return this.sliced && this.slicedTranslation || {\n                    translateX: 0,\n                    translateY: 0\n                };\n            }\n            haloPath(t) {\n                let e = this.shapeArgs;\n                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {\n                    innerR: e.r - 1,\n                    start: e.start,\n                    end: e.end,\n                    borderRadius: e.borderRadius\n                });\n            }\n            isValid() {\n                return a(this.y) && this.y >= 0;\n            }\n            setVisible(t) {\n                let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n                t !== this.visible && this.update({\n                    visible: t !== null && t !== void 0 ? t : !this.visible\n                }, e, void 0, !1);\n            }\n            slice(t, e, i) {\n                let o = this.series, n = o.chart;\n                s(i, n), e = l(e, !0), this.sliced = this.options.sliced = t = r(t) ? t : !this.sliced, o.options.data[o.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());\n            }\n            constructor(t, e, i){\n                var _this_name;\n                super(t, e, i), this.half = 0, (_this_name = this.name) !== null && _this_name !== void 0 ? _this_name : this.name = \"Slice\";\n                let s = (t)=>{\n                    this.slice(\"select\" === t.type);\n                };\n                o(this, \"select\", s), o(this, \"unselect\", s);\n            }\n        }\n        return n(c.prototype, {\n            connectorShapes: {\n                fixedOffset: function(t, e, i) {\n                    let s = e.breakAt, o = e.touchingSliceAt, r = i.softConnector ? [\n                        \"C\",\n                        t.x + (\"left\" === t.alignment ? -5 : 5),\n                        t.y,\n                        2 * s.x - o.x,\n                        2 * s.y - o.y,\n                        s.x,\n                        s.y\n                    ] : [\n                        \"L\",\n                        s.x,\n                        s.y\n                    ];\n                    return [\n                        [\n                            \"M\",\n                            t.x,\n                            t.y\n                        ],\n                        r,\n                        [\n                            \"L\",\n                            o.x,\n                            o.y\n                        ]\n                    ];\n                },\n                straight: function(t, e) {\n                    let i = e.touchingSliceAt;\n                    return [\n                        [\n                            \"M\",\n                            t.x,\n                            t.y\n                        ],\n                        [\n                            \"L\",\n                            i.x,\n                            i.y\n                        ]\n                    ];\n                },\n                crookedLine: function(t, e, i) {\n                    let { breakAt: s, touchingSliceAt: o } = e, { series: r } = this, [n, a, h] = r.center, l = h / 2, { plotLeft: c, plotWidth: p } = r.chart, u = \"left\" === t.alignment, { x: g, y: f } = t, m = s.x;\n                    if (i.crookDistance) {\n                        let t = d(i.crookDistance, 1);\n                        m = u ? n + l + (p + c - n - l) * (1 - t) : c + (n - l) * t;\n                    } else m = n + (a - f) * Math.tan((this.angle || 0) - Math.PI / 2);\n                    let x = [\n                        [\n                            \"M\",\n                            g,\n                            f\n                        ]\n                    ];\n                    return (u ? m <= g && m >= s.x : m >= g && m <= s.x) && x.push([\n                        \"L\",\n                        m,\n                        f\n                    ]), x.push([\n                        \"L\",\n                        s.x,\n                        s.y\n                    ], [\n                        \"L\",\n                        o.x,\n                        o.y\n                    ]), x;\n                }\n            }\n        }), c;\n    }), i(e, \"Series/Pie/PieSeriesDefaults.js\", [], function() {\n        return {\n            borderRadius: 3,\n            center: [\n                null,\n                null\n            ],\n            clip: !1,\n            colorByPoint: !0,\n            dataLabels: {\n                connectorPadding: 5,\n                connectorShape: \"crookedLine\",\n                crookDistance: void 0,\n                distance: 30,\n                enabled: !0,\n                formatter: function() {\n                    return this.point.isNull ? void 0 : this.point.name;\n                },\n                softConnector: !0,\n                x: 0\n            },\n            fillColor: void 0,\n            ignoreHiddenPoint: !0,\n            inactiveOtherPoints: !0,\n            legendType: \"point\",\n            marker: null,\n            size: null,\n            showInLegend: !1,\n            slicedOffset: 10,\n            stickyTracking: !1,\n            tooltip: {\n                followPointer: !0\n            },\n            borderColor: \"#ffffff\",\n            borderWidth: 1,\n            lineWidth: void 0,\n            states: {\n                hover: {\n                    brightness: .1\n                }\n            }\n        };\n    }), i(e, \"Series/Pie/PieSeries.js\", [\n        e[\"Series/CenteredUtilities.js\"],\n        e[\"Series/Column/ColumnSeries.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Series/Pie/PiePoint.js\"],\n        e[\"Series/Pie/PieSeriesDefaults.js\"],\n        e[\"Core/Series/Series.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Renderer/SVG/Symbols.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o, r, n, a, h) {\n        let { getStartAndEndRadians: l } = t, { noop: d } = i, { clamp: c, extend: p, fireEvent: u, merge: g, pick: f, relativeLength: m, splat: x } = h;\n        class y extends r {\n            animate(t) {\n                let e = this, i = e.points, s = e.startAngleRad;\n                t || i.forEach(function(t) {\n                    let i = t.graphic, o = t.shapeArgs;\n                    i && o && (i.attr({\n                        r: f(t.startR, e.center && e.center[3] / 2),\n                        start: s,\n                        end: s\n                    }), i.animate({\n                        r: o.r,\n                        start: o.start,\n                        end: o.end\n                    }, e.options.animation));\n                });\n            }\n            drawEmpty() {\n                let t, e;\n                let i = this.startAngleRad, s = this.endAngleRad, o = this.options;\n                0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n                    d: a.arc(t, e, this.center[2] / 2, 0, {\n                        start: i,\n                        end: s,\n                        innerR: this.center[3] / 2\n                    })\n                }), this.chart.styledMode || this.graph.attr({\n                    \"stroke-width\": o.borderWidth,\n                    fill: o.fillColor || \"none\",\n                    stroke: o.color || \"#cccccc\"\n                })) : this.graph && (this.graph = this.graph.destroy());\n            }\n            drawPoints() {\n                let t = this.chart.renderer;\n                this.points.forEach(function(e) {\n                    e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n                });\n            }\n            generatePoints() {\n                super.generatePoints(), this.updateTotals();\n            }\n            getX(t, e, i, s) {\n                let o = this.center, r = this.radii ? this.radii[i.index] || 0 : o[2] / 2, n = s.dataLabelPosition, a = (n === null || n === void 0 ? void 0 : n.distance) || 0, h = Math.asin(c((t - o[1]) / (r + a), -1, 1)), l = o[0] + (e ? -1 : 1) * (Math.cos(h) * (r + a)) + (a > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);\n                return l;\n            }\n            hasData() {\n                return !!this.processedXData.length;\n            }\n            redrawPoints() {\n                let t, e, i, s;\n                let o = this, r = o.chart;\n                this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function(n) {\n                    let a = {};\n                    e = n.graphic, !n.isNull && e ? (s = n.shapeArgs, t = n.getTranslate(), r.styledMode || (i = o.pointAttribs(n, n.selected && \"select\")), n.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({\n                        \"stroke-linejoin\": \"round\"\n                    }), n.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || g(!0, a, i), g(!0, a, s, t), e.animate(a)), e.attr({\n                        visibility: n.visible ? \"inherit\" : \"hidden\"\n                    }), e.addClass(n.getClassName(), !0)) : e && (n.graphic = e.destroy());\n                });\n            }\n            sortByAngle(t, e) {\n                t.sort(function(t, i) {\n                    return void 0 !== t.angle && (i.angle - t.angle) * e;\n                });\n            }\n            translate(t) {\n                u(this, \"translate\"), this.generatePoints();\n                let e = this.options, i = e.slicedOffset, s = l(e.startAngle, e.endAngle), o = this.startAngleRad = s.start, r = this.endAngleRad = s.end, n = r - o, a = this.points, h = e.ignoreHiddenPoint, d = a.length, c, p, g, f, m, x, y, b = 0;\n                for(t || (this.center = t = this.getCenter()), x = 0; x < d; x++){\n                    y = a[x], c = o + b * n, y.isValid() && (!h || y.visible) && (b += y.percentage / 100), p = o + b * n;\n                    let e = {\n                        x: t[0],\n                        y: t[1],\n                        r: t[2] / 2,\n                        innerR: t[3] / 2,\n                        start: Math.round(1e3 * c) / 1e3,\n                        end: Math.round(1e3 * p) / 1e3\n                    };\n                    y.shapeType = \"arc\", y.shapeArgs = e, (g = (p + c) / 2) > 1.5 * Math.PI ? g -= 2 * Math.PI : g < -Math.PI / 2 && (g += 2 * Math.PI), y.slicedTranslation = {\n                        translateX: Math.round(Math.cos(g) * i),\n                        translateY: Math.round(Math.sin(g) * i)\n                    }, f = Math.cos(g) * t[2] / 2, m = Math.sin(g) * t[2] / 2, y.tooltipPos = [\n                        t[0] + .7 * f,\n                        t[1] + .7 * m\n                    ], y.half = g < -Math.PI / 2 || g > Math.PI / 2 ? 1 : 0, y.angle = g;\n                }\n                u(this, \"afterTranslate\");\n            }\n            updateTotals() {\n                let t = this.points, e = t.length, i = this.options.ignoreHiddenPoint, s, o, r = 0;\n                for(s = 0; s < e; s++)(o = t[s]).isValid() && (!i || o.visible) && (r += o.y);\n                for(s = 0, this.total = r; s < e; s++)(o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;\n            }\n        }\n        return y.defaultOptions = g(r.defaultOptions, o), p(y.prototype, {\n            axisTypes: [],\n            directTouch: !0,\n            drawGraph: void 0,\n            drawTracker: e.prototype.drawTracker,\n            getCenter: t.getCenter,\n            getSymbol: d,\n            isCartesian: !1,\n            noSharedTooltip: !0,\n            pointAttribs: e.prototype.pointAttribs,\n            pointClass: s,\n            requireSorting: !1,\n            searchPoint: d,\n            trackerGroups: [\n                \"group\",\n                \"dataLabelsGroup\"\n            ]\n        }), n.registerSeriesType(\"pie\", y), y;\n    }), i(e, \"Series/Pie/PieDataLabel.js\", [\n        e[\"Core/Series/DataLabel.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Renderer/RendererUtilities.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i, s, o) {\n        var r;\n        let { composed: n, noop: a } = e, { distribute: h } = i, { series: l } = s, { arrayMax: d, clamp: c, defined: p, pick: u, pushUnique: g, relativeLength: f } = o;\n        return function(e) {\n            let i = {\n                radialDistributionY: function(t, e) {\n                    var _e_dataLabelPosition;\n                    return (((_e_dataLabelPosition = e.dataLabelPosition) === null || _e_dataLabelPosition === void 0 ? void 0 : _e_dataLabelPosition.top) || 0) + t.distributeBox.pos;\n                },\n                radialDistributionX: function(t, e, i, s, o) {\n                    let r = o.dataLabelPosition;\n                    return t.getX(i < ((r === null || r === void 0 ? void 0 : r.top) || 0) + 2 || i > ((r === null || r === void 0 ? void 0 : r.bottom) || 0) - 2 ? s : i, e.half, e, o);\n                },\n                justify: function(t, e, i, s) {\n                    var _e_dataLabelPosition;\n                    return s[0] + (t.half ? -1 : 1) * (i + (((_e_dataLabelPosition = e.dataLabelPosition) === null || _e_dataLabelPosition === void 0 ? void 0 : _e_dataLabelPosition.distance) || 0));\n                },\n                alignToPlotEdges: function(t, e, i, s) {\n                    let o = t.getBBox().width;\n                    return e ? o + s : i - o - s;\n                },\n                alignToConnectors: function(t, e, i, s) {\n                    let o = 0, r;\n                    return t.forEach(function(t) {\n                        (r = t.dataLabel.getBBox().width) > o && (o = r);\n                    }), e ? o + s : i - o - s;\n                }\n            };\n            function s(t, e) {\n                let { center: i, options: s } = this, o = i[2] / 2, r = t.angle || 0, n = Math.cos(r), a = Math.sin(r), h = i[0] + n * o, l = i[1] + a * o, d = Math.min((s.slicedOffset || 0) + (s.borderWidth || 0), e / 5);\n                return {\n                    natural: {\n                        x: h + n * e,\n                        y: l + a * e\n                    },\n                    computed: {},\n                    alignment: e < 0 ? \"center\" : t.half ? \"right\" : \"left\",\n                    connectorPosition: {\n                        breakAt: {\n                            x: h + n * d,\n                            y: l + a * d\n                        },\n                        touchingSliceAt: {\n                            x: h,\n                            y: l\n                        }\n                    },\n                    distance: e\n                };\n            }\n            function o() {\n                var _t_hasDataLabels;\n                let t = this, e = t.points, i = t.chart, s = i.plotWidth, o = i.plotHeight, r = i.plotLeft, n = Math.round(i.chartWidth / 3), a = t.center, c = a[2] / 2, g = a[1], m = [\n                    [],\n                    []\n                ], x = [\n                    0,\n                    0,\n                    0,\n                    0\n                ], y = t.dataLabelPositioners, b, v, S, k = 0;\n                t.visible && ((_t_hasDataLabels = t.hasDataLabels) === null || _t_hasDataLabels === void 0 ? void 0 : _t_hasDataLabels.call(t)) && (e.forEach((t)=>{\n                    (t.dataLabels || []).forEach((t)=>{\n                        t.shortened && (t.attr({\n                            width: \"auto\"\n                        }).css({\n                            width: \"auto\",\n                            textOverflow: \"clip\"\n                        }), t.shortened = !1);\n                    });\n                }), l.prototype.drawDataLabels.apply(t), e.forEach((t)=>{\n                    (t.dataLabels || []).forEach((e, i)=>{\n                        var _o_style;\n                        let s = a[2] / 2, o = e.options, r = f((o === null || o === void 0 ? void 0 : o.distance) || 0, s);\n                        0 === i && m[t.half].push(t), !p(o === null || o === void 0 ? void 0 : (_o_style = o.style) === null || _o_style === void 0 ? void 0 : _o_style.width) && e.getBBox().width > n && (e.css({\n                            width: Math.round(.7 * n) + \"px\"\n                        }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), k = Math.max(k, r);\n                    });\n                }), m.forEach((e, n)=>{\n                    let l = e.length, d = [], f, m, b = 0, M;\n                    l && (t.sortByAngle(e, n - .5), k > 0 && (f = Math.max(0, g - c - k), m = Math.min(g + c + k, i.plotHeight), e.forEach((t)=>{\n                        (t.dataLabels || []).forEach((e, s)=>{\n                            var _e_dataLabelPosition;\n                            let o = e.dataLabelPosition;\n                            o && o.distance > 0 && (o.top = Math.max(0, g - c - o.distance), o.bottom = Math.min(g + c + o.distance, i.plotHeight), b = e.getBBox().height || 21, t.distributeBox = {\n                                target: (((_e_dataLabelPosition = e.dataLabelPosition) === null || _e_dataLabelPosition === void 0 ? void 0 : _e_dataLabelPosition.natural.y) || 0) - o.top + b / 2,\n                                size: b,\n                                rank: t.y\n                            }, d.push(t.distributeBox));\n                        });\n                    }), h(d, M = m + b - f, M / 5)), e.forEach((i)=>{\n                        (i.dataLabels || []).forEach((h)=>{\n                            let l = h.options || {}, g = i.distributeBox, f = h.dataLabelPosition, m = (f === null || f === void 0 ? void 0 : f.natural.y) || 0, b = l.connectorPadding || 0, k = 0, M = m, C = \"inherit\";\n                            if (f) {\n                                if (d && p(g) && f.distance > 0 && (void 0 === g.pos ? C = \"hidden\" : (S = g.size, M = y.radialDistributionY(i, h))), l.justify) k = y.justify(i, h, c, a);\n                                else switch(l.alignTo){\n                                    case \"connectors\":\n                                        k = y.alignToConnectors(e, n, s, r);\n                                        break;\n                                    case \"plotEdges\":\n                                        k = y.alignToPlotEdges(h, n, s, r);\n                                        break;\n                                    default:\n                                        k = y.radialDistributionX(t, i, M, m, h);\n                                }\n                                if (f.attribs = {\n                                    visibility: C,\n                                    align: f.alignment\n                                }, f.posAttribs = {\n                                    x: k + (l.x || 0) + (({\n                                        left: b,\n                                        right: -b\n                                    })[f.alignment] || 0),\n                                    y: M + (l.y || 0) - h.getBBox().height / 2\n                                }, f.computed.x = k, f.computed.y = M, u(l.crop, !0)) {\n                                    let t;\n                                    k - (v = h.getBBox().width) < b && 1 === n ? (t = Math.round(v - k + b), x[3] = Math.max(t, x[3])) : k + v > s - b && 0 === n && (t = Math.round(k + v - s + b), x[1] = Math.max(t, x[1])), M - S / 2 < 0 ? x[0] = Math.max(Math.round(-M + S / 2), x[0]) : M + S / 2 > o && (x[2] = Math.max(Math.round(M + S / 2 - o), x[2])), f.sideOverflow = t;\n                                }\n                            }\n                        });\n                    }));\n                }), (0 === d(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach((e)=>{\n                    (e.dataLabels || []).forEach((s)=>{\n                        let { connectorColor: o, connectorWidth: r = 1 } = s.options || {}, n = s.dataLabelPosition;\n                        if (r) {\n                            var _n_attribs;\n                            let a;\n                            b = s.connector, n && n.distance > 0 ? (a = !b, b || (s.connector = b = i.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + e.colorIndex + (e.className ? \" \" + e.className : \"\")).add(t.dataLabelsGroup)), i.styledMode || b.attr({\n                                \"stroke-width\": r,\n                                stroke: o || e.color || \"#666666\"\n                            }), b[a ? \"attr\" : \"animate\"]({\n                                d: e.getConnectorPath(s)\n                            }), b.attr({\n                                visibility: (_n_attribs = n.attribs) === null || _n_attribs === void 0 ? void 0 : _n_attribs.visibility\n                            })) : b && (s.connector = b.destroy());\n                        }\n                    });\n                })));\n            }\n            function r() {\n                this.points.forEach((t)=>{\n                    (t.dataLabels || []).forEach((t)=>{\n                        var _t_options;\n                        let e = t.dataLabelPosition;\n                        e ? (e.sideOverflow && (t.css({\n                            width: Math.max(t.getBBox().width - e.sideOverflow, 0) + \"px\",\n                            textOverflow: (((_t_options = t.options) === null || _t_options === void 0 ? void 0 : _t_options.style) || {}).textOverflow || \"ellipsis\"\n                        }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? \"animate\" : \"attr\"](e.posAttribs), t.moved = !0) : t && t.attr({\n                            y: -9999\n                        });\n                    }), delete t.distributeBox;\n                }, this);\n            }\n            function m(t) {\n                let e = this.center, i = this.options, s = i.center, o = i.minSize || 80, r = o, n = null !== i.size;\n                return !n && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = c(r, o, e[2] - Math.max(t[0], t[2])) : (r = c(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, f(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : n = !0), n;\n            }\n            e.compose = function e(h) {\n                if (t.compose(l), g(n, e)) {\n                    let t = h.prototype;\n                    t.dataLabelPositioners = i, t.alignDataLabel = a, t.drawDataLabels = o, t.getDataLabelPosition = s, t.placeDataLabels = r, t.verifyDataLabelOverflow = m;\n                }\n            };\n        }(r || (r = {})), r;\n    }), i(e, \"Extensions/OverlappingDataLabels.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        let { composed: i } = t, { addEvent: s, fireEvent: o, isNumber: r, objectEach: n, pick: a, pushUnique: h } = e;\n        function l(t) {\n            let e = t.length, i = this.renderer, s = (t, e)=>!(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y), n = (t)=>{\n                let e = t.box ? 0 : t.padding || 0, s, o, n, a = 0, h = 0, l, d;\n                if (t && (!t.alignAttr || t.placed)) return s = t.alignAttr || {\n                    x: t.attr(\"x\"),\n                    y: t.attr(\"y\")\n                }, o = t.parentGroup, t.width || (n = t.getBBox(), t.width = n.width, t.height = n.height, a = i.fontMetrics(t.element).h), l = t.width - 2 * e, (d = ({\n                    left: \"0\",\n                    center: \"0.5\",\n                    right: \"1\"\n                })[t.alignValue]) ? h = +d * l : r(t.x) && Math.round(t.x) !== t.translateX && (h = t.x - (t.translateX || 0)), {\n                    x: s.x + (o.translateX || 0) + e - (h || 0),\n                    y: s.y + (o.translateY || 0) + e - a,\n                    width: t.width - 2 * e,\n                    height: (t.height || 0) - 2 * e\n                };\n            }, a, h, l, c, p, u = !1;\n            for(let i = 0; i < e; i++)(a = t[i]) && (a.oldOpacity = a.opacity, a.newOpacity = 1, a.absoluteBox = n(a));\n            t.sort((t, e)=>(e.labelrank || 0) - (t.labelrank || 0));\n            for(let i = 0; i < e; ++i){\n                c = (h = t[i]) && h.absoluteBox;\n                for(let o = i + 1; o < e; ++o)p = (l = t[o]) && l.absoluteBox, c && p && h !== l && 0 !== h.newOpacity && 0 !== l.newOpacity && \"hidden\" !== h.visibility && \"hidden\" !== l.visibility && s(c, p) && ((h.labelrank < l.labelrank ? h : l).newOpacity = 0);\n            }\n            for (let e of t)d(e, this) && (u = !0);\n            u && o(this, \"afterHideAllOverlappingLabels\");\n        }\n        function d(t, e) {\n            let i, s = !1;\n            return t && (i = t.newOpacity, t.oldOpacity !== i && (t.hasClass(\"highcharts-data-label\") ? (t[i ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), s = !0, t[t.isOld ? \"animate\" : \"attr\"]({\n                opacity: i\n            }, void 0, function() {\n                e.styledMode || t.css({\n                    pointerEvents: i ? \"auto\" : \"none\"\n                });\n            }), o(e, \"afterHideOverlappingLabel\")) : t.attr({\n                opacity: i\n            })), t.isOld = !0), s;\n        }\n        function c() {\n            var _i_hasDataLabels;\n            let t = this, e = [];\n            for (let i of t.labelCollectors || [])e = e.concat(i());\n            for (let i of t.yAxis || [])i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && n(i.stacking.stacks, (t)=>{\n                n(t, (t)=>{\n                    t.label && e.push(t.label);\n                });\n            });\n            for (let i of t.series || [])if (i.visible && ((_i_hasDataLabels = i.hasDataLabels) === null || _i_hasDataLabels === void 0 ? void 0 : _i_hasDataLabels.call(i))) {\n                let s = (i)=>{\n                    for (let s of i)s.visible && (s.dataLabels || []).forEach((i)=>{\n                        var _s_shapeArgs;\n                        let o = i.options || {};\n                        var _o_allowOverlap;\n                        i.labelrank = a(o.labelrank, s.labelrank, (_s_shapeArgs = s.shapeArgs) === null || _s_shapeArgs === void 0 ? void 0 : _s_shapeArgs.height), ((_o_allowOverlap = o.allowOverlap) !== null && _o_allowOverlap !== void 0 ? _o_allowOverlap : Number(o.distance) > 0) ? (i.oldOpacity = i.opacity, i.newOpacity = 1, d(i, t)) : e.push(i);\n                    });\n                };\n                s(i.nodes || []), s(i.points);\n            }\n            this.hideOverlappingLabels(e);\n        }\n        return {\n            compose: function t(e) {\n                if (h(i, t)) {\n                    let t = e.prototype;\n                    t.hideOverlappingLabels = l, s(e, \"render\", c);\n                }\n            }\n        };\n    }), i(e, \"Extensions/BorderRadius.js\", [\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e, i) {\n        let { defaultOptions: s } = t, { composed: o, noop: r } = e, { addEvent: n, extend: a, isObject: h, merge: l, pushUnique: d, relativeLength: c } = i, p = {\n            radius: 0,\n            scope: \"stack\",\n            where: void 0\n        }, u = r, g = r;\n        function f(t, e, i, s) {\n            let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};\n            let r = u(t, e, i, s, o), { innerR: n = 0, r: a = i, start: h = 0, end: l = 0 } = o;\n            if (o.open || !o.borderRadius) return r;\n            let d = l - h, p = Math.sin(d / 2), g = Math.max(Math.min(c(o.borderRadius || 0, a - n), (a - n) / 2, a * p / (1 + p)), 0), f = Math.min(g, 2 * (d / Math.PI) * n), m = r.length - 1;\n            for(; m--;)!function(t, e, i) {\n                let s, o, r;\n                let n = t[e], a = t[e + 1];\n                if (\"Z\" === a[0] && (a = t[0]), (\"M\" === n[0] || \"L\" === n[0]) && \"A\" === a[0] ? (s = n, o = a, r = !0) : \"A\" === n[0] && (\"M\" === a[0] || \"L\" === a[0]) && (s = a, o = n), s && o && o.params) {\n                    let n = o[1], a = o[5], h = o.params, { start: l, end: d, cx: c, cy: p } = h, u = a ? n - i : n + i, g = u ? Math.asin(i / u) : 0, f = a ? g : -g, m = Math.cos(g) * u;\n                    r ? (h.start = l + f, s[1] = c + m * Math.cos(l), s[2] = p + m * Math.sin(l), t.splice(e + 1, 0, [\n                        \"A\",\n                        i,\n                        i,\n                        0,\n                        0,\n                        1,\n                        c + n * Math.cos(h.start),\n                        p + n * Math.sin(h.start)\n                    ])) : (h.end = d - f, o[6] = c + n * Math.cos(h.end), o[7] = p + n * Math.sin(h.end), t.splice(e + 1, 0, [\n                        \"A\",\n                        i,\n                        i,\n                        0,\n                        0,\n                        1,\n                        c + m * Math.cos(d),\n                        p + m * Math.sin(d)\n                    ])), o[4] = Math.abs(h.end - h.start) < Math.PI ? 0 : 1;\n                }\n            }(r, m, m > 1 ? f : g);\n            return r;\n        }\n        function m() {\n            if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n                var _s_plotOptions_this_type, _s_plotOptions;\n                let { options: t, yAxis: e } = this, i = \"percent\" === t.stacking, o = (_s_plotOptions = s.plotOptions) === null || _s_plotOptions === void 0 ? void 0 : (_s_plotOptions_this_type = _s_plotOptions[this.type]) === null || _s_plotOptions_this_type === void 0 ? void 0 : _s_plotOptions_this_type.borderRadius, r = x(t.borderRadius, h(o) ? o : {}), n = e.options.reversed;\n                for (let s of this.points){\n                    let { shapeArgs: o } = s;\n                    if (\"roundedRect\" === s.shapeType && o) {\n                        let { width: h = 0, height: l = 0, y: d = 0 } = o, p = d, u = l;\n                        if (\"stack\" === r.scope && s.stackTotal) {\n                            let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0), r = e.translate(t.threshold || 0, !1, !0, !1, !0), n = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));\n                            p = n.y, u = n.height;\n                        }\n                        let g = (s.negative ? -1 : 1) * (n ? -1 : 1) == -1, f = r.where;\n                        !f && this.is(\"waterfall\") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (f = \"all\"), f || (f = \"end\");\n                        let m = Math.min(c(r.radius, h), h / 2, \"all\" === f ? l / 2 : 1 / 0) || 0;\n                        \"end\" === f && (g && (p -= m), u += m), a(o, {\n                            brBoxHeight: u,\n                            brBoxY: p,\n                            r: m\n                        });\n                    }\n                }\n            }\n        }\n        function x(t, e) {\n            return h(t) || (t = {\n                radius: t || 0\n            }), l(p, e, t);\n        }\n        function y() {\n            let t = x(this.options.borderRadius);\n            for (let e of this.points){\n                let i = e.shapeArgs;\n                i && (i.borderRadius = c(t.radius, (i.r || 0) - (i.innerR || 0)));\n            }\n        }\n        function b(t, e, i, s) {\n            let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};\n            let r = g(t, e, i, s, o), { r: n = 0, brBoxHeight: a = s, brBoxY: h = e } = o, l = e - h, d = h + a - (e + s), c = l - n > -.1 ? 0 : n, p = d - n > -.1 ? 0 : n, u = Math.max(c && l, 0), f = Math.max(p && d, 0), m = [\n                t + c,\n                e\n            ], x = [\n                t + i - c,\n                e\n            ], y = [\n                t + i,\n                e + c\n            ], b = [\n                t + i,\n                e + s - p\n            ], v = [\n                t + i - p,\n                e + s\n            ], S = [\n                t + p,\n                e + s\n            ], k = [\n                t,\n                e + s - p\n            ], M = [\n                t,\n                e + c\n            ], C = (t, e)=>Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));\n            if (u) {\n                let t = C(c, c - u);\n                m[0] -= t, x[0] += t, y[1] = M[1] = e + c - u;\n            }\n            if (s < c - u) {\n                let o = C(c, c - u - s);\n                y[0] = b[0] = t + i - c + o, v[0] = Math.min(y[0], v[0]), S[0] = Math.max(b[0], S[0]), k[0] = M[0] = t + c - o, y[1] = M[1] = e + s;\n            }\n            if (f) {\n                let t = C(p, p - f);\n                v[0] += t, S[0] -= t, b[1] = k[1] = e + s - p + f;\n            }\n            if (s < p - f) {\n                let o = C(p, p - f - s);\n                y[0] = b[0] = t + i - p + o, x[0] = Math.min(y[0], x[0]), m[0] = Math.max(b[0], m[0]), k[0] = M[0] = t + p - o, b[1] = k[1] = e;\n            }\n            return r.length = 0, r.push([\n                \"M\",\n                ...m\n            ], [\n                \"L\",\n                ...x\n            ], [\n                \"A\",\n                c,\n                c,\n                0,\n                0,\n                1,\n                ...y\n            ], [\n                \"L\",\n                ...b\n            ], [\n                \"A\",\n                p,\n                p,\n                0,\n                0,\n                1,\n                ...v\n            ], [\n                \"L\",\n                ...S\n            ], [\n                \"A\",\n                p,\n                p,\n                0,\n                0,\n                1,\n                ...k\n            ], [\n                \"L\",\n                ...M\n            ], [\n                \"A\",\n                c,\n                c,\n                0,\n                0,\n                1,\n                ...m\n            ], [\n                \"Z\"\n            ]), r;\n        }\n        return {\n            compose: function t(e, i, s, r) {\n                if (d(o, t)) {\n                    let t = r.prototype.symbols;\n                    n(e, \"afterColumnTranslate\", m, {\n                        order: 9\n                    }), n(i, \"afterTranslate\", y), s.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\"), u = t.arc, g = t.roundedRect, t.arc = f, t.roundedRect = b;\n                }\n            },\n            optionsToObject: x\n        };\n    }), i(e, \"Core/Responsive.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"]\n    ], function(t, e) {\n        var i;\n        let { composed: s } = t, { diffObjects: o, extend: r, find: n, merge: a, pick: h, pushUnique: l, uniqueKey: d } = e;\n        return function(t) {\n            function e(t, e) {\n                let i = t.condition, s = i.callback || function() {\n                    return this.chartWidth <= h(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= h(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= h(i.minWidth, 0) && this.chartHeight >= h(i.minHeight, 0);\n                };\n                s.call(this) && e.push(t._id);\n            }\n            function i(t, e) {\n                let i = this.options.responsive, s = this.currentResponsive, r = [], h;\n                !e && i && i.rules && i.rules.forEach((t)=>{\n                    void 0 === t._id && (t._id = d()), this.matchResponsiveRule(t, r);\n                }, this);\n                let l = a(...r.map((t)=>n((i || {}).rules || [], (e)=>e._id === t)).map((t)=>t && t.chartOptions));\n                l.isResponsiveOptions = !0, r = r.toString() || void 0;\n                let c = s && s.ruleIds;\n                r !== c && (s && this.update(s.undoOptions, t, !0), r ? ((h = o(l, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {\n                    ruleIds: r,\n                    mergedOptions: l,\n                    undoOptions: h\n                }, this.update(l, t, !0)) : this.currentResponsive = void 0);\n            }\n            t.compose = function t(o) {\n                return l(s, t) && r(o.prototype, {\n                    matchResponsiveRule: e,\n                    setResponsive: i\n                }), o;\n            };\n        }(i || (i = {})), i;\n    }), i(e, \"masters/highcharts.src.js\", [\n        e[\"Core/Globals.js\"],\n        e[\"Core/Utilities.js\"],\n        e[\"Core/Defaults.js\"],\n        e[\"Core/Animation/Fx.js\"],\n        e[\"Core/Animation/AnimationUtilities.js\"],\n        e[\"Core/Renderer/HTML/AST.js\"],\n        e[\"Core/Templating.js\"],\n        e[\"Core/Renderer/RendererUtilities.js\"],\n        e[\"Core/Renderer/SVG/SVGElement.js\"],\n        e[\"Core/Renderer/SVG/SVGRenderer.js\"],\n        e[\"Core/Renderer/HTML/HTMLElement.js\"],\n        e[\"Core/Renderer/HTML/HTMLRenderer.js\"],\n        e[\"Core/Axis/Axis.js\"],\n        e[\"Core/Axis/DateTimeAxis.js\"],\n        e[\"Core/Axis/LogarithmicAxis.js\"],\n        e[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"],\n        e[\"Core/Axis/Tick.js\"],\n        e[\"Core/Tooltip.js\"],\n        e[\"Core/Series/Point.js\"],\n        e[\"Core/Pointer.js\"],\n        e[\"Core/Legend/Legend.js\"],\n        e[\"Core/Chart/Chart.js\"],\n        e[\"Extensions/ScrollablePlotArea.js\"],\n        e[\"Core/Axis/Stacking/StackingAxis.js\"],\n        e[\"Core/Axis/Stacking/StackItem.js\"],\n        e[\"Core/Series/Series.js\"],\n        e[\"Core/Series/SeriesRegistry.js\"],\n        e[\"Series/Column/ColumnSeries.js\"],\n        e[\"Series/Column/ColumnDataLabel.js\"],\n        e[\"Series/Pie/PieSeries.js\"],\n        e[\"Series/Pie/PieDataLabel.js\"],\n        e[\"Core/Series/DataLabel.js\"],\n        e[\"Extensions/OverlappingDataLabels.js\"],\n        e[\"Extensions/BorderRadius.js\"],\n        e[\"Core/Responsive.js\"],\n        e[\"Core/Color/Color.js\"],\n        e[\"Core/Time.js\"]\n    ], function(t, e, i, s, o, r, n, a, h, l, d, c, p, u, g, f, m, x, y, b, v, S, k, M, C, w, T, A, P, L, O, D, E, j, I, B, R) {\n        return t.animate = o.animate, t.animObject = o.animObject, t.getDeferredAnimation = o.getDeferredAnimation, t.setAnimation = o.setAnimation, t.stop = o.stop, t.timers = s.timers, t.AST = r, t.Axis = p, t.Chart = S, t.chart = S.chart, t.Fx = s, t.Legend = v, t.PlotLineOrBand = f, t.Point = y, t.Pointer = b, t.Series = w, t.StackItem = C, t.SVGElement = h, t.SVGRenderer = l, t.Templating = n, t.Tick = m, t.Time = R, t.Tooltip = x, t.Color = B, t.color = B.parse, c.compose(l), d.compose(h), b.compose(S), v.compose(S), t.defaultOptions = i.defaultOptions, t.getOptions = i.getOptions, t.time = i.defaultTime, t.setOptions = i.setOptions, t.dateFormat = n.dateFormat, t.format = n.format, t.numberFormat = n.numberFormat, e.extend(t, e), t.distribute = a.distribute, t.seriesType = T.seriesType, P.compose(A), j.compose(w, L, h, l), D.compose(w), u.compose(p), g.compose(p), E.compose(S), O.compose(L), f.compose(p), I.compose(S), k.compose(p, S, w), M.compose(p, S, w), x.compose(b), t;\n    }), e[\"masters/highcharts.src.js\"]._modules = e, e[\"masters/highcharts.src.js\"];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oaWdoY2hhcnRzL2hpZ2hjaGFydHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DO0FBQUUsQ0FBQyxTQUFTQSxDQUFDLEVBQUNDLENBQUM7SUFBRSxLQUF1QkMsSUFBRUEsT0FBT0MsT0FBTyxHQUFFRixDQUFBQSxFQUFFRyxPQUFPLEdBQUNILEdBQUVDLE9BQU9DLE9BQU8sR0FBQ0gsS0FBR0EsRUFBRUssUUFBUSxHQUFDSixFQUFFRCxLQUFHQyxDQUFBQSxJQUFHLEtBQXFDLEdBQUNLLG1DQUErQjtRQUFXLE9BQU9MLEVBQUVEO0lBQUUsQ0FBQztBQUFBLGtHQUFDLEdBQUVBLENBQUFBLENBQXdEO0FBQUUsRUFBRSxLQUFhLEdBQWNVLFNBQU8sR0FBSyxTQUFTVixDQUFDO0lBQUU7SUFBYSxJQUFJQyxJQUFFLENBQUM7SUFBRSxTQUFTVSxFQUFFVixDQUFDLEVBQUNVLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUVaLEVBQUVhLGNBQWMsQ0FBQ0gsTUFBS1YsQ0FBQUEsQ0FBQyxDQUFDVSxFQUFFLEdBQUNFLEVBQUVFLEtBQUssQ0FBQyxNQUFLSCxJQUFHLGNBQVksT0FBT0ksZUFBYWhCLEVBQUVpQixhQUFhLENBQUMsSUFBSUQsWUFBWSwwQkFBeUI7WUFBQ0UsUUFBTztnQkFBQ0MsTUFBS1I7Z0JBQUVULFFBQU9ELENBQUMsQ0FBQ1UsRUFBRTtZQUFBO1FBQUMsR0FBRTtJQUFFO0lBQUMsT0FBT0EsRUFBRVYsR0FBRSxtQkFBa0IsRUFBRSxFQUFDO1FBQVcsSUFBSUEsR0FBRVU7UUFBRSxPQUFNLENBQUNBLElBQUVWLEtBQUlBLENBQUFBLElBQUUsQ0FBQyxFQUFDLEVBQUdtQixNQUFNLEdBQUMsOEJBQTZCVCxFQUFFVSxPQUFPLEdBQUMsY0FBYVYsRUFBRVcsT0FBTyxHQUFDLFVBQVNYLEVBQUVZLEdBQUcsR0FBQyxLQUFLLE1BQUl2QixJQUFFQSxJQUFFLENBQUMsR0FBRVcs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QixHQUFFcUssR0FBRTlPLEdBQUVFLElBQUdzYSxFQUFFb1EsT0FBTyxDQUFDbm1CLElBQUdqRCxFQUFFb3BCLE9BQU8sQ0FBQzNxQixJQUFHd0IsRUFBRW1wQixPQUFPLENBQUMzcUIsSUFBR3luQixFQUFFa0QsT0FBTyxDQUFDNW5CLElBQUd1WCxFQUFFcVEsT0FBTyxDQUFDOWIsSUFBR2pOLEVBQUUrb0IsT0FBTyxDQUFDM3FCLElBQUcyTyxFQUFFZ2MsT0FBTyxDQUFDNW5CLElBQUc1QyxFQUFFd3FCLE9BQU8sQ0FBQzNxQixHQUFFK0MsR0FBRXlCLElBQUd0QixFQUFFeW5CLE9BQU8sQ0FBQzNxQixHQUFFK0MsR0FBRXlCLElBQUcxQyxFQUFFNm9CLE9BQU8sQ0FBQ3RvQixJQUFHdEc7SUFBQyxJQUFHQyxDQUFDLENBQUMsNEJBQTRCLENBQUN1ekQsUUFBUSxHQUFDdnpELEdBQUVBLENBQUMsQ0FBQyw0QkFBNEI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9oaWdoY2hhcnRzLmpzPzE0MzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIaWdoY2hhcnRzIEpTIHYxMS4zLjAgKDIwMjQtMDEtMTApXG4gKlxuICogKGMpIDIwMDktMjAyNCBUb3JzdGVpbiBIb25zaVxuICpcbiAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4gKi8hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz8oZS5kZWZhdWx0PWUsbW9kdWxlLmV4cG9ydHM9dCYmdC5kb2N1bWVudD9lKHQpOmUpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJoaWdoY2hhcnRzL2hpZ2hjaGFydHNcIixmdW5jdGlvbigpe3JldHVybiBlKHQpfSk6KHQuSGlnaGNoYXJ0cyYmdC5IaWdoY2hhcnRzLmVycm9yKDE2LCEwKSx0LkhpZ2hjaGFydHM9ZSh0KSl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e307ZnVuY3Rpb24gaShlLGkscyxvKXtlLmhhc093blByb3BlcnR5KGkpfHwoZVtpXT1vLmFwcGx5KG51bGwscyksXCJmdW5jdGlvblwiPT10eXBlb2YgQ3VzdG9tRXZlbnQmJnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJIaWdoY2hhcnRzTW9kdWxlTG9hZGVkXCIse2RldGFpbDp7cGF0aDppLG1vZHVsZTplW2ldfX0pKSl9cmV0dXJuIGkoZSxcIkNvcmUvR2xvYmFscy5qc1wiLFtdLGZ1bmN0aW9uKCl7dmFyIGUsaTtyZXR1cm4oaT1lfHwoZT17fSkpLlNWR19OUz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsaS5wcm9kdWN0PVwiSGlnaGNoYXJ0c1wiLGkudmVyc2lvbj1cIjExLjMuMFwiLGkud2luPXZvaWQgMCE9PXQ/dDp7fSxpLmRvYz1pLndpbi5kb2N1bWVudCxpLnN2Zz1pLmRvYyYmaS5kb2MuY3JlYXRlRWxlbWVudE5TJiYhIWkuZG9jLmNyZWF0ZUVsZW1lbnROUyhpLlNWR19OUyxcInN2Z1wiKS5jcmVhdGVTVkdSZWN0LGkudXNlckFnZW50PWkud2luLm5hdmlnYXRvciYmaS53aW4ubmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJcIixpLmlzQ2hyb21lPS0xIT09aS51c2VyQWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSxpLmlzRmlyZWZveD0tMSE9PWkudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpLGkuaXNNUz0vKGVkZ2V8bXNpZXx0cmlkZW50KS9pLnRlc3QoaS51c2VyQWdlbnQpJiYhaS53aW4ub3BlcmEsaS5pc1NhZmFyaT0haS5pc0Nocm9tZSYmLTEhPT1pLnVzZXJBZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpLGkuaXNUb3VjaERldmljZT0vKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KGkudXNlckFnZW50KSxpLmlzV2ViS2l0PS0xIT09aS51c2VyQWdlbnQuaW5kZXhPZihcIkFwcGxlV2ViS2l0XCIpLGkuZGVnMnJhZD0yKk1hdGguUEkvMzYwLGkuaGFzQmlkaUJ1Zz1pLmlzRmlyZWZveCYmND5wYXJzZUludChpLnVzZXJBZ2VudC5zcGxpdChcIkZpcmVmb3gvXCIpWzFdLDEwKSxpLmhhc1RvdWNoPSEhaS53aW4uVG91Y2hFdmVudCxpLm1hcmdpbk5hbWVzPVtcInBsb3RUb3BcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcInBsb3RMZWZ0XCJdLGkubm9vcD1mdW5jdGlvbigpe30saS5zdXBwb3J0c1Bhc3NpdmVFdmVudHM9ZnVuY3Rpb24oKXtsZXQgdD0hMTtpZighaS5pc01TKXtsZXQgZT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe3Q9ITB9fSk7aS53aW4uYWRkRXZlbnRMaXN0ZW5lciYmaS53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lciYmKGkud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZVwiLGkubm9vcCxlKSxpLndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIixpLm5vb3AsZSkpfXJldHVybiB0fSgpLGkuY2hhcnRzPVtdLGkuY29tcG9zZWQ9W10saS5kYXRlRm9ybWF0cz17fSxpLnNlcmllc1R5cGVzPXt9LGkuc3ltYm9sU2l6ZXM9e30saS5jaGFydENvdW50PTAsZX0pLGkoZSxcIkNvcmUvVXRpbGl0aWVzLmpzXCIsW2VbXCJDb3JlL0dsb2JhbHMuanNcIl1dLGZ1bmN0aW9uKHQpe2xldCBlO2xldHtjaGFydHM6aSxkb2M6cyx3aW46b309dDtmdW5jdGlvbiByKGUsaSxzLG4pe2xldCBhPWk/XCJIaWdoY2hhcnRzIGVycm9yXCI6XCJIaWdoY2hhcnRzIHdhcm5pbmdcIjszMj09PWUmJihlPWAke2F9OiBEZXByZWNhdGVkIG1lbWJlcmApO2xldCBoPXAoZSksbD1oP2Ake2F9ICMke2V9OiB3d3cuaGlnaGNoYXJ0cy5jb20vZXJyb3JzLyR7ZX0vYDplLnRvU3RyaW5nKCk7aWYodm9pZCAwIT09bil7bGV0IHQ9XCJcIjtoJiYobCs9XCI/XCIpLGsobixmdW5jdGlvbihlLGkpe3QrPWBcbiAtICR7aX06ICR7ZX1gLGgmJihsKz1lbmNvZGVVUkkoaSkrXCI9XCIrZW5jb2RlVVJJKGUpKX0pLGwrPXR9Qyh0LFwiZGlzcGxheUVycm9yXCIse2NoYXJ0OnMsY29kZTplLG1lc3NhZ2U6bCxwYXJhbXM6bn0sZnVuY3Rpb24oKXtpZihpKXRocm93IEVycm9yKGwpO28uY29uc29sZSYmLTE9PT1yLm1lc3NhZ2VzLmluZGV4T2YobCkmJmNvbnNvbGUud2FybihsKX0pLHIubWVzc2FnZXMucHVzaChsKX1mdW5jdGlvbiBuKHQsZSl7cmV0dXJuIHBhcnNlSW50KHQsZXx8MTApfWZ1bmN0aW9uIGEodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR9ZnVuY3Rpb24gaCh0KXtsZXQgZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCk7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09ZXx8XCJbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXVwiPT09ZX1mdW5jdGlvbiBsKHQsZSl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmKCFlfHwhaCh0KSl9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbCh0KSYmXCJudW1iZXJcIj09dHlwZW9mIHQubm9kZVR5cGV9ZnVuY3Rpb24gYyh0KXtsZXQgZT10JiZ0LmNvbnN0cnVjdG9yO3JldHVybiEhKGwodCwhMCkmJiFkKHQpJiZlJiZlLm5hbWUmJlwiT2JqZWN0XCIhPT1lLm5hbWUpfWZ1bmN0aW9uIHAodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJiFpc05hTih0KSYmdDwxLzAmJnQ+LTEvMH1mdW5jdGlvbiB1KHQpe3JldHVybiBudWxsIT10fWZ1bmN0aW9uIGcodCxlLGkpe2xldCBzO2xldCBvPWEoZSkmJiF1KGkpLHI9KGUsaSk9Pnt1KGUpP3Quc2V0QXR0cmlidXRlKGksZSk6bz8ocz10LmdldEF0dHJpYnV0ZShpKSl8fFwiY2xhc3NcIiE9PWl8fChzPXQuZ2V0QXR0cmlidXRlKGkrXCJOYW1lXCIpKTp0LnJlbW92ZUF0dHJpYnV0ZShpKX07cmV0dXJuIGEoZSk/cihpLGUpOmsoZSxyKSxzfWZ1bmN0aW9uIGYodCl7cmV0dXJuIGgodCk/dDpbdF19ZnVuY3Rpb24gbSh0LGUpe2xldCBpO2ZvcihpIGluIHR8fCh0PXt9KSxlKXRbaV09ZVtpXTtyZXR1cm4gdH1mdW5jdGlvbiB4KCl7bGV0IHQ9YXJndW1lbnRzLGU9dC5sZW5ndGg7Zm9yKGxldCBpPTA7aTxlO2krKyl7bGV0IGU9dFtpXTtpZihudWxsIT1lKXJldHVybiBlfX1mdW5jdGlvbiB5KGUsaSl7dC5pc01TJiYhdC5zdmcmJmkmJnUoaS5vcGFjaXR5KSYmKGkuZmlsdGVyPWBhbHBoYShvcGFjaXR5PSR7MTAwKmkub3BhY2l0eX0pYCksbShlLnN0eWxlLGkpfWZ1bmN0aW9uIGIodCl7cmV0dXJuIE1hdGgucG93KDEwLE1hdGguZmxvb3IoTWF0aC5sb2codCkvTWF0aC5MTjEwKSl9ZnVuY3Rpb24gdih0LGUpe3JldHVybiB0PjFlMTQ/dDpwYXJzZUZsb2F0KHQudG9QcmVjaXNpb24oZXx8MTQpKX0ocnx8KHI9e30pKS5tZXNzYWdlcz1bXSxNYXRoLmVhc2VJbk91dFNpbmU9ZnVuY3Rpb24odCl7cmV0dXJuIC0uNSooTWF0aC5jb3MoTWF0aC5QSSp0KS0xKX07bGV0IFM9QXJyYXkucHJvdG90eXBlLmZpbmQ/ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5maW5kKGUpfTpmdW5jdGlvbih0LGUpe2xldCBpO2xldCBzPXQubGVuZ3RoO2ZvcihpPTA7aTxzO2krKylpZihlKHRbaV0saSkpcmV0dXJuIHRbaV19O2Z1bmN0aW9uIGsodCxlLGkpe2ZvcihsZXQgcyBpbiB0KU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscykmJmUuY2FsbChpfHx0W3NdLHRbc10scyx0KX1mdW5jdGlvbiBNKHQsZSxpKXtmdW5jdGlvbiBzKGUsaSl7bGV0IHM9dC5yZW1vdmVFdmVudExpc3RlbmVyO3MmJnMuY2FsbCh0LGUsaSwhMSl9ZnVuY3Rpb24gbyhpKXtsZXQgbyxyO3Qubm9kZU5hbWUmJihlPyhvPXt9KVtlXT0hMDpvPWksayhvLGZ1bmN0aW9uKHQsZSl7aWYoaVtlXSlmb3Iocj1pW2VdLmxlbmd0aDtyLS07KXMoZSxpW2VdW3JdLmZuKX0pKX1sZXQgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZ0LnByb3RvdHlwZXx8dDtpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLFwiaGNFdmVudHNcIikpe2xldCB0PXIuaGNFdmVudHM7aWYoZSl7bGV0IHI9dFtlXXx8W107aT8odFtlXT1yLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gaSE9PXQuZm59KSxzKGUsaSkpOihvKHQpLHRbZV09W10pfWVsc2Ugbyh0KSxkZWxldGUgci5oY0V2ZW50c319ZnVuY3Rpb24gQyhlLGksbyxyKXtsZXQgbjtpZihvPW98fHt9LHMuY3JlYXRlRXZlbnQmJihlLmRpc3BhdGNoRXZlbnR8fGUuZmlyZUV2ZW50JiZlIT09dCkpKG49cy5jcmVhdGVFdmVudChcIkV2ZW50c1wiKSkuaW5pdEV2ZW50KGksITAsITApLG89bShuLG8pLGUuZGlzcGF0Y2hFdmVudD9lLmRpc3BhdGNoRXZlbnQobyk6ZS5maXJlRXZlbnQoaSxvKTtlbHNlIGlmKGUuaGNFdmVudHMpe28udGFyZ2V0fHxtKG8se3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7by5kZWZhdWx0UHJldmVudGVkPSEwfSx0YXJnZXQ6ZSx0eXBlOml9KTtsZXQgdD1bXSxzPWUscj0hMTtmb3IoO3MuaGNFdmVudHM7KU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsXCJoY0V2ZW50c1wiKSYmcy5oY0V2ZW50c1tpXSYmKHQubGVuZ3RoJiYocj0hMCksdC51bnNoaWZ0LmFwcGx5KHQscy5oY0V2ZW50c1tpXSkpLHM9T2JqZWN0LmdldFByb3RvdHlwZU9mKHMpO3ImJnQuc29ydCgodCxlKT0+dC5vcmRlci1lLm9yZGVyKSx0LmZvckVhY2godD0+eyExPT09dC5mbi5jYWxsKGUsbykmJm8ucHJldmVudERlZmF1bHQoKX0pfXImJiFvLmRlZmF1bHRQcmV2ZW50ZWQmJnIuY2FsbChlLG8pfWsoe21hcDpcIm1hcFwiLGVhY2g6XCJmb3JFYWNoXCIsZ3JlcDpcImZpbHRlclwiLHJlZHVjZTpcInJlZHVjZVwiLHNvbWU6XCJzb21lXCJ9LGZ1bmN0aW9uKGUsaSl7dFtpXT1mdW5jdGlvbih0KXtyZXR1cm4gcigzMiwhMSx2b2lkIDAse1tgSGlnaGNoYXJ0cy4ke2l9YF06YHVzZSBBcnJheS4ke2V9YH0pLEFycmF5LnByb3RvdHlwZVtlXS5hcHBseSh0LFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX19KTtsZXQgdz1mdW5jdGlvbigpe2xldCB0PU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLDkpK1wiLVwiLGk9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm5cImhpZ2hjaGFydHMtXCIrKGU/XCJcIjp0KStpKyt9fSgpO28ualF1ZXJ5JiYoby5qUXVlcnkuZm4uaGlnaGNoYXJ0cz1mdW5jdGlvbigpe2xldCBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZih0aGlzWzBdKXJldHVybiBlWzBdPyhuZXcgdFthKGVbMF0pP2Uuc2hpZnQoKTpcIkNoYXJ0XCJdKHRoaXNbMF0sZVswXSxlWzFdKSx0aGlzKTppW2codGhpc1swXSxcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiKV19KTtsZXQgVD17YWRkRXZlbnQ6ZnVuY3Rpb24oZSxpLHMsbz17fSl7bGV0IHI9XCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZS5wcm90b3R5cGV8fGU7T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixcImhjRXZlbnRzXCIpfHwoci5oY0V2ZW50cz17fSk7bGV0IG49ci5oY0V2ZW50czt0LlBvaW50JiZlIGluc3RhbmNlb2YgdC5Qb2ludCYmZS5zZXJpZXMmJmUuc2VyaWVzLmNoYXJ0JiYoZS5zZXJpZXMuY2hhcnQucnVuVHJhY2tlckNsaWNrPSEwKTtsZXQgYT1lLmFkZEV2ZW50TGlzdGVuZXI7YSYmYS5jYWxsKGUsaSxzLCEhdC5zdXBwb3J0c1Bhc3NpdmVFdmVudHMmJntwYXNzaXZlOnZvaWQgMD09PW8ucGFzc2l2ZT8tMSE9PWkuaW5kZXhPZihcInRvdWNoXCIpOm8ucGFzc2l2ZSxjYXB0dXJlOiExfSksbltpXXx8KG5baV09W10pO2xldCBoPXtmbjpzLG9yZGVyOlwibnVtYmVyXCI9PXR5cGVvZiBvLm9yZGVyP28ub3JkZXI6MS8wfTtyZXR1cm4gbltpXS5wdXNoKGgpLG5baV0uc29ydCgodCxlKT0+dC5vcmRlci1lLm9yZGVyKSxmdW5jdGlvbigpe00oZSxpLHMpfX0sYXJyYXlNYXg6ZnVuY3Rpb24odCl7bGV0IGU9dC5sZW5ndGgsaT10WzBdO2Zvcig7ZS0tOyl0W2VdPmkmJihpPXRbZV0pO3JldHVybiBpfSxhcnJheU1pbjpmdW5jdGlvbih0KXtsZXQgZT10Lmxlbmd0aCxpPXRbMF07Zm9yKDtlLS07KXRbZV08aSYmKGk9dFtlXSk7cmV0dXJuIGl9LGF0dHI6ZyxjbGFtcDpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHQ+ZT90PGk/dDppOmV9LGNsZWFyVGltZW91dDpmdW5jdGlvbih0KXt1KHQpJiZjbGVhclRpbWVvdXQodCl9LGNvcnJlY3RGbG9hdDp2LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24odCxlLGksbyxyKXtsZXQgbj1zLmNyZWF0ZUVsZW1lbnQodCk7cmV0dXJuIGUmJm0obixlKSxyJiZ5KG4se3BhZGRpbmc6XCIwXCIsYm9yZGVyOlwibm9uZVwiLG1hcmdpbjpcIjBcIn0pLGkmJnkobixpKSxvJiZvLmFwcGVuZENoaWxkKG4pLG59LGNzczp5LGRlZmluZWQ6dSxkZXN0cm95T2JqZWN0UHJvcGVydGllczpmdW5jdGlvbih0LGUpe2sodCxmdW5jdGlvbihpLHMpe2kmJmkhPT1lJiZpLmRlc3Ryb3kmJmkuZGVzdHJveSgpLGRlbGV0ZSB0W3NdfSl9LGRpZmZPYmplY3RzOmZ1bmN0aW9uKHQsZSxpLHMpe2xldCBvPXt9O3JldHVybiBmdW5jdGlvbiB0KGUsbyxyLG4pe2xldCBhPWk/bzplO2soZSxmdW5jdGlvbihpLGQpe2lmKCFuJiZzJiZzLmluZGV4T2YoZCk+LTEmJm9bZF0pe2k9ZihpKSxyW2RdPVtdO2ZvcihsZXQgZT0wO2U8TWF0aC5tYXgoaS5sZW5ndGgsb1tkXS5sZW5ndGgpO2UrKylvW2RdW2VdJiYodm9pZCAwPT09aVtlXT9yW2RdW2VdPW9bZF1bZV06KHJbZF1bZV09e30sdChpW2VdLG9bZF1bZV0scltkXVtlXSxuKzEpKSl9ZWxzZSBsKGksITApJiYhaS5ub2RlVHlwZT8ocltkXT1oKGkpP1tdOnt9LHQoaSxvW2RdfHx7fSxyW2RdLG4rMSksMCE9PU9iamVjdC5rZXlzKHJbZF0pLmxlbmd0aHx8XCJjb2xvckF4aXNcIj09PWQmJjA9PT1ufHxkZWxldGUgcltkXSk6KGVbZF0hPT1vW2RdfHxkIGluIGUmJiEoZCBpbiBvKSkmJihyW2RdPWFbZF0pfSl9KHQsZSxvLDApLG99LGRpc2NhcmRFbGVtZW50OmZ1bmN0aW9uKHQpe3QmJnQucGFyZW50RWxlbWVudCYmdC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHQpfSxlcmFzZTpmdW5jdGlvbih0LGUpe2xldCBpPXQubGVuZ3RoO2Zvcig7aS0tOylpZih0W2ldPT09ZSl7dC5zcGxpY2UoaSwxKTticmVha319LGVycm9yOnIsZXh0ZW5kOm0sZXh0ZW5kQ2xhc3M6ZnVuY3Rpb24odCxlKXtsZXQgaT1mdW5jdGlvbigpe307cmV0dXJuIGkucHJvdG90eXBlPW5ldyB0LG0oaS5wcm90b3R5cGUsZSksaX0sZmluZDpTLGZpcmVFdmVudDpDLGdldENsb3Nlc3REaXN0YW5jZTpmdW5jdGlvbih0LGUpe2xldCBpLHMsbztsZXQgcj0hZTtyZXR1cm4gdC5mb3JFYWNoKHQ9PntpZih0Lmxlbmd0aD4xKWZvcihvPXQubGVuZ3RoLTE7bz4wO28tLSkocz10W29dLXRbby0xXSk8MCYmIXI/KGU/LigpLGU9dm9pZCAwKTpzJiYodm9pZCAwPT09aXx8czxpKSYmKGk9cyl9KSxpfSxnZXRNYWduaXR1ZGU6YixnZXROZXN0ZWRQcm9wZXJ0eTpmdW5jdGlvbih0LGUpe2xldCBpPXQuc3BsaXQoXCIuXCIpO2Zvcig7aS5sZW5ndGgmJnUoZSk7KXtsZXQgdD1pLnNoaWZ0KCk7aWYodm9pZCAwPT09dHx8XCJfX3Byb3RvX19cIj09PXQpcmV0dXJuO2lmKFwidGhpc1wiPT09dCl7bGV0IHQ7cmV0dXJuIGwoZSkmJih0PWVbXCJAdGhpc1wiXSksdD8/ZX1sZXQgcz1lW3RdO2lmKCF1KHMpfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBzfHxcIm51bWJlclwiPT10eXBlb2Ygcy5ub2RlVHlwZXx8cz09PW8pcmV0dXJuO2U9c31yZXR1cm4gZX0sZ2V0U3R5bGU6ZnVuY3Rpb24gdChlLGkscyl7bGV0IHI7aWYoXCJ3aWR0aFwiPT09aSl7bGV0IGk9TWF0aC5taW4oZS5vZmZzZXRXaWR0aCxlLnNjcm9sbFdpZHRoKSxzPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0JiZlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO3JldHVybiBzPGkmJnM+PWktMSYmKGk9TWF0aC5mbG9vcihzKSksTWF0aC5tYXgoMCxpLSh0KGUsXCJwYWRkaW5nLWxlZnRcIiwhMCl8fDApLSh0KGUsXCJwYWRkaW5nLXJpZ2h0XCIsITApfHwwKSl9aWYoXCJoZWlnaHRcIj09PWkpcmV0dXJuIE1hdGgubWF4KDAsTWF0aC5taW4oZS5vZmZzZXRIZWlnaHQsZS5zY3JvbGxIZWlnaHQpLSh0KGUsXCJwYWRkaW5nLXRvcFwiLCEwKXx8MCktKHQoZSxcInBhZGRpbmctYm90dG9tXCIsITApfHwwKSk7bGV0IGE9by5nZXRDb21wdXRlZFN0eWxlKGUsdm9pZCAwKTtyZXR1cm4gYSYmKHI9YS5nZXRQcm9wZXJ0eVZhbHVlKGkpLHgocyxcIm9wYWNpdHlcIiE9PWkpJiYocj1uKHIpKSkscn0saW5BcnJheTpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHIoMzIsITEsdm9pZCAwLHtcIkhpZ2hjaGFydHMuaW5BcnJheVwiOlwidXNlIEFycmF5LmluZGV4T2ZcIn0pLGUuaW5kZXhPZih0LGkpfSxpbnNlcnRJdGVtOmZ1bmN0aW9uKHQsZSl7bGV0IGk7bGV0IHM9dC5vcHRpb25zLmluZGV4LG89ZS5sZW5ndGg7Zm9yKGk9dC5vcHRpb25zLmlzSW50ZXJuYWw/bzowO2k8bysxO2krKylpZighZVtpXXx8cChzKSYmczx4KGVbaV0ub3B0aW9ucy5pbmRleCxlW2ldLl9pKXx8ZVtpXS5vcHRpb25zLmlzSW50ZXJuYWwpe2Uuc3BsaWNlKGksMCx0KTticmVha31yZXR1cm4gaX0saXNBcnJheTpoLGlzQ2xhc3M6Yyxpc0RPTUVsZW1lbnQ6ZCxpc0Z1bmN0aW9uOmZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LGlzTnVtYmVyOnAsaXNPYmplY3Q6bCxpc1N0cmluZzphLGtleXM6ZnVuY3Rpb24odCl7cmV0dXJuIHIoMzIsITEsdm9pZCAwLHtcIkhpZ2hjaGFydHMua2V5c1wiOlwidXNlIE9iamVjdC5rZXlzXCJ9KSxPYmplY3Qua2V5cyh0KX0sbWVyZ2U6ZnVuY3Rpb24oKXtsZXQgdCxlPWFyZ3VtZW50cyxpPXt9LHM9ZnVuY3Rpb24odCxlKXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdCYmKHQ9e30pLGsoZSxmdW5jdGlvbihpLG8pe1wiX19wcm90b19fXCIhPT1vJiZcImNvbnN0cnVjdG9yXCIhPT1vJiYoIWwoaSwhMCl8fGMoaSl8fGQoaSk/dFtvXT1lW29dOnRbb109cyh0W29dfHx7fSxpKSl9KSx0fTshMD09PWVbMF0mJihpPWVbMV0sZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLDIpKTtsZXQgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspaT1zKGksZVt0XSk7cmV0dXJuIGl9LG5vcm1hbGl6ZVRpY2tJbnRlcnZhbDpmdW5jdGlvbih0LGUsaSxzLG8pe2xldCByLG49dDtpPXgoaSxiKHQpKTtsZXQgYT10L2k7Zm9yKCFlJiYoZT1vP1sxLDEuMiwxLjUsMiwyLjUsMyw0LDUsNiw4LDEwXTpbMSwyLDIuNSw1LDEwXSwhMT09PXMmJigxPT09aT9lPWUuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0JTE9PTB9KTppPD0uMSYmKGU9WzEvaV0pKSkscj0wO3I8ZS5sZW5ndGgmJihuPWVbcl0sKCFvfHwhKG4qaT49dCkpJiYob3x8IShhPD0oZVtyXSsoZVtyKzFdfHxlW3JdKSkvMikpKTtyKyspO3JldHVybiB2KG4qaSwtTWF0aC5yb3VuZChNYXRoLmxvZyguMDAxKS9NYXRoLkxOMTApKX0sb2JqZWN0RWFjaDprLG9mZnNldDpmdW5jdGlvbih0KXtsZXQgZT1zLmRvY3VtZW50RWxlbWVudCxpPXQucGFyZW50RWxlbWVudHx8dC5wYXJlbnROb2RlP3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6e3RvcDowLGxlZnQ6MCx3aWR0aDowLGhlaWdodDowfTtyZXR1cm57dG9wOmkudG9wKyhvLnBhZ2VZT2Zmc2V0fHxlLnNjcm9sbFRvcCktKGUuY2xpZW50VG9wfHwwKSxsZWZ0OmkubGVmdCsoby5wYWdlWE9mZnNldHx8ZS5zY3JvbGxMZWZ0KS0oZS5jbGllbnRMZWZ0fHwwKSx3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodH19LHBhZDpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIEFycmF5KChlfHwyKSsxLVN0cmluZyh0KS5yZXBsYWNlKFwiLVwiLFwiXCIpLmxlbmd0aCkuam9pbihpfHxcIjBcIikrdH0scGljazp4LHBJbnQ6bixwdXNoVW5pcXVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA+dC5pbmRleE9mKGUpJiYhIXQucHVzaChlKX0scmVsYXRpdmVMZW5ndGg6ZnVuY3Rpb24odCxlLGkpe3JldHVybi8lJC8udGVzdCh0KT9lKnBhcnNlRmxvYXQodCkvMTAwKyhpfHwwKTpwYXJzZUZsb2F0KHQpfSxyZW1vdmVFdmVudDpNLHNwbGF0OmYsc3RhYmxlU29ydDpmdW5jdGlvbih0LGUpe2xldCBpLHM7bGV0IG89dC5sZW5ndGg7Zm9yKHM9MDtzPG87cysrKXRbc10uc2FmZUk9cztmb3IodC5zb3J0KGZ1bmN0aW9uKHQscyl7cmV0dXJuIDA9PT0oaT1lKHQscykpP3Quc2FmZUktcy5zYWZlSTppfSkscz0wO3M8bztzKyspZGVsZXRlIHRbc10uc2FmZUl9LHN5bmNUaW1lb3V0OmZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gZT4wP3NldFRpbWVvdXQodCxlLGkpOih0LmNhbGwoMCxpKSwtMSl9LHRpbWVVbml0czp7bWlsbGlzZWNvbmQ6MSxzZWNvbmQ6MWUzLG1pbnV0ZTo2ZTQsaG91cjozNmU1LGRheTo4NjRlNSx3ZWVrOjYwNDhlNSxtb250aDoyNDE5MmU1LHllYXI6MzE0NDk2ZTV9LHVuaXF1ZUtleTp3LHVzZVNlcmlhbElkczpmdW5jdGlvbih0KXtyZXR1cm4gZT14KHQsZSl9LHdyYXA6ZnVuY3Rpb24odCxlLGkpe2xldCBzPXRbZV07dFtlXT1mdW5jdGlvbigpe2xldCB0PWFyZ3VtZW50cyxlPXRoaXM7cmV0dXJuIGkuYXBwbHkodGhpcyxbZnVuY3Rpb24oKXtyZXR1cm4gcy5hcHBseShlLGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzOnQpfV0uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpfX19O3JldHVybiBUfSksaShlLFwiQ29yZS9DaGFydC9DaGFydERlZmF1bHRzLmpzXCIsW10sZnVuY3Rpb24oKXtyZXR1cm57YWxpZ25UaHJlc2hvbGRzOiExLHBhbm5pbmc6e2VuYWJsZWQ6ITEsdHlwZTpcInhcIn0sc3R5bGVkTW9kZTohMSxib3JkZXJSYWRpdXM6MCxjb2xvckNvdW50OjEwLGFsbG93TXV0YXRpbmdEYXRhOiEwLGlnbm9yZUhpZGRlblNlcmllczohMCxzcGFjaW5nOlsxMCwxMCwxNSwxMF0scmVzZXRab29tQnV0dG9uOnt0aGVtZTp7fSxwb3NpdGlvbjp7fX0scmVmbG93OiEwLHR5cGU6XCJsaW5lXCIsem9vbWluZzp7c2luZ2xlVG91Y2g6ITEscmVzZXRCdXR0b246e3RoZW1lOnt6SW5kZXg6Nn0scG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx5OjEwfX19LHdpZHRoOm51bGwsaGVpZ2h0Om51bGwsYm9yZGVyQ29sb3I6XCIjMzM0ZWZmXCIsYmFja2dyb3VuZENvbG9yOlwiI2ZmZmZmZlwiLHBsb3RCb3JkZXJDb2xvcjpcIiNjY2NjY2NcIn19KSxpKGUsXCJDb3JlL0NvbG9yL1BhbGV0dGVzLmpzXCIsW10sZnVuY3Rpb24oKXtyZXR1cm57Y29sb3JzOltcIiMyY2FmZmVcIixcIiM1NDRmYzVcIixcIiMwMGUyNzJcIixcIiNmZTZhMzVcIixcIiM2YjhhYmNcIixcIiNkNTY4ZmJcIixcIiMyZWUwY2FcIixcIiNmYTRiNDJcIixcIiNmZWI1NmFcIixcIiM5MWU4ZTFcIl19fSksaShlLFwiQ29yZS9UaW1lLmpzXCIsW2VbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUpe2xldHt3aW46aX09dCx7ZGVmaW5lZDpzLGVycm9yOm8sZXh0ZW5kOnIsaXNOdW1iZXI6bixpc09iamVjdDphLG1lcmdlOmgsb2JqZWN0RWFjaDpsLHBhZDpkLHBpY2s6YyxzcGxhdDpwLHRpbWVVbml0czp1fT1lLGc9dC5pc1NhZmFyaSYmaS5JbnRsJiZpLkludGwuRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLmZvcm1hdFJhbmdlLGY9dC5pc1NhZmFyaSYmaS5JbnRsJiYhaS5JbnRsLkRhdGVUaW1lRm9ybWF0LnByb3RvdHlwZS5mb3JtYXRSYW5nZTtyZXR1cm4gY2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5vcHRpb25zPXt9LHRoaXMudXNlVVRDPSExLHRoaXMudmFyaWFibGVUaW1lem9uZT0hMSx0aGlzLkRhdGU9aS5EYXRlLHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQ9dGhpcy50aW1lem9uZU9mZnNldEZ1bmN0aW9uKCksdGhpcy51cGRhdGUodCl9Z2V0KHQsZSl7aWYodGhpcy52YXJpYWJsZVRpbWV6b25lfHx0aGlzLnRpbWV6b25lT2Zmc2V0KXtsZXQgaT1lLmdldFRpbWUoKSxzPWktdGhpcy5nZXRUaW1lem9uZU9mZnNldChlKTtlLnNldFRpbWUocyk7bGV0IG89ZVtcImdldFVUQ1wiK3RdKCk7cmV0dXJuIGUuc2V0VGltZShpKSxvfXJldHVybiB0aGlzLnVzZVVUQz9lW1wiZ2V0VVRDXCIrdF0oKTplW1wiZ2V0XCIrdF0oKX1zZXQodCxlLGkpe2lmKHRoaXMudmFyaWFibGVUaW1lem9uZXx8dGhpcy50aW1lem9uZU9mZnNldCl7aWYoXCJNaWxsaXNlY29uZHNcIj09PXR8fFwiU2Vjb25kc1wiPT09dHx8XCJNaW51dGVzXCI9PT10JiZ0aGlzLmdldFRpbWV6b25lT2Zmc2V0KGUpJTM2ZTU9PTApcmV0dXJuIGVbXCJzZXRVVENcIit0XShpKTtsZXQgcz10aGlzLmdldFRpbWV6b25lT2Zmc2V0KGUpLG89ZS5nZXRUaW1lKCktcztlLnNldFRpbWUobyksZVtcInNldFVUQ1wiK3RdKGkpO2xldCByPXRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoZSk7cmV0dXJuIG89ZS5nZXRUaW1lKCkrcixlLnNldFRpbWUobyl9cmV0dXJuIHRoaXMudXNlVVRDfHxnJiZcIkZ1bGxZZWFyXCI9PT10P2VbXCJzZXRVVENcIit0XShpKTplW1wic2V0XCIrdF0oaSl9dXBkYXRlKHQ9e30pe2xldCBlPWModC51c2VVVEMsITApO3RoaXMub3B0aW9ucz10PWgoITAsdGhpcy5vcHRpb25zLHQpLHRoaXMuRGF0ZT10LkRhdGV8fGkuRGF0ZXx8RGF0ZSx0aGlzLnVzZVVUQz1lLHRoaXMudGltZXpvbmVPZmZzZXQ9ZSYmdC50aW1lem9uZU9mZnNldHx8dm9pZCAwLHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQ9dGhpcy50aW1lem9uZU9mZnNldEZ1bmN0aW9uKCksdGhpcy52YXJpYWJsZVRpbWV6b25lPWUmJiEhKHQuZ2V0VGltZXpvbmVPZmZzZXR8fHQudGltZXpvbmUpfW1ha2VUaW1lKHQsZSxpLHMsbyxyKXtsZXQgbixhLGg7cmV0dXJuIHRoaXMudXNlVVRDPyhuPXRoaXMuRGF0ZS5VVEMuYXBwbHkoMCxhcmd1bWVudHMpLGE9dGhpcy5nZXRUaW1lem9uZU9mZnNldChuKSxuKz1hLGEhPT0oaD10aGlzLmdldFRpbWV6b25lT2Zmc2V0KG4pKT9uKz1oLWE6YS0zNmU1IT09dGhpcy5nZXRUaW1lem9uZU9mZnNldChuLTM2ZTUpfHxmfHwobi09MzZlNSkpOm49bmV3IHRoaXMuRGF0ZSh0LGUsYyhpLDEpLGMocywwKSxjKG8sMCksYyhyLDApKS5nZXRUaW1lKCksbn10aW1lem9uZU9mZnNldEZ1bmN0aW9uKCl7bGV0IHQ9dGhpcyxlPXRoaXMub3B0aW9ucyxpPWUuZ2V0VGltZXpvbmVPZmZzZXQ7cmV0dXJuIHRoaXMudXNlVVRDP2UudGltZXpvbmU/dD0+e3RyeXtsZXRbaSxzLG8scixhPTBdPUludGwuRGF0ZVRpbWVGb3JtYXQoXCJlblwiLHt0aW1lWm9uZTplLnRpbWV6b25lLHRpbWVab25lTmFtZTpcInNob3J0T2Zmc2V0XCJ9KS5mb3JtYXQodCkuc3BsaXQoLyhHTVR8OikvKS5tYXAoTnVtYmVyKSxoPS0oMzZlNSoobythLzYwKSk7aWYobihoKSlyZXR1cm4gaH1jYXRjaCh0KXtvKDM0KX1yZXR1cm4gMH06dGhpcy51c2VVVEMmJmk/dD0+NmU0KmkodC52YWx1ZU9mKCkpOigpPT42ZTQqKHQudGltZXpvbmVPZmZzZXR8fDApOnQ9PjZlNCpuZXcgRGF0ZSh0LnRvU3RyaW5nKCkpLmdldFRpbWV6b25lT2Zmc2V0KCl9ZGF0ZUZvcm1hdChlLGksbyl7aWYoIXMoaSl8fGlzTmFOKGkpKXJldHVybiB0LmRlZmF1bHRPcHRpb25zLmxhbmcmJnQuZGVmYXVsdE9wdGlvbnMubGFuZy5pbnZhbGlkRGF0ZXx8XCJcIjtlPWMoZSxcIiVZLSVtLSVkICVIOiVNOiVTXCIpO2xldCBuPXRoaXMsYT1uZXcgdGhpcy5EYXRlKGkpLGg9dGhpcy5nZXQoXCJIb3Vyc1wiLGEpLHA9dGhpcy5nZXQoXCJEYXlcIixhKSx1PXRoaXMuZ2V0KFwiRGF0ZVwiLGEpLGc9dGhpcy5nZXQoXCJNb250aFwiLGEpLGY9dGhpcy5nZXQoXCJGdWxsWWVhclwiLGEpLG09dC5kZWZhdWx0T3B0aW9ucy5sYW5nLHg9bSYmbS53ZWVrZGF5cyx5PW0mJm0uc2hvcnRXZWVrZGF5cyxiPXIoe2E6eT95W3BdOnhbcF0uc3Vic3RyKDAsMyksQTp4W3BdLGQ6ZCh1KSxlOmQodSwyLFwiIFwiKSx3OnAsYjptLnNob3J0TW9udGhzW2ddLEI6bS5tb250aHNbZ10sbTpkKGcrMSksbzpnKzEseTpmLnRvU3RyaW5nKCkuc3Vic3RyKDIsMiksWTpmLEg6ZChoKSxrOmgsSTpkKGglMTJ8fDEyKSxsOmglMTJ8fDEyLE06ZCh0aGlzLmdldChcIk1pbnV0ZXNcIixhKSkscDpoPDEyP1wiQU1cIjpcIlBNXCIsUDpoPDEyP1wiYW1cIjpcInBtXCIsUzpkKHRoaXMuZ2V0KFwiU2Vjb25kc1wiLGEpKSxMOmQoTWF0aC5mbG9vcihpJTFlMyksMyl9LHQuZGF0ZUZvcm1hdHMpO3JldHVybiBsKGIsZnVuY3Rpb24odCxzKXtmb3IoOy0xIT09ZS5pbmRleE9mKFwiJVwiK3MpOyllPWUucmVwbGFjZShcIiVcIitzLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dC5jYWxsKG4saSk6dCl9KSxvP2Uuc3Vic3RyKDAsMSkudG9VcHBlckNhc2UoKStlLnN1YnN0cigxKTplfXJlc29sdmVEVExGb3JtYXQodCl7cmV0dXJuIGEodCwhMCk/dDp7bWFpbjoodD1wKHQpKVswXSxmcm9tOnRbMV0sdG86dFsyXX19Z2V0VGltZVRpY2tzKHQsZSxpLG8pe2xldCBuLGEsaCxsO2xldCBkPXRoaXMscD1kLkRhdGUsZz1bXSxmPXt9LG09bmV3IHAoZSkseD10LnVuaXRSYW5nZSx5PXQuY291bnR8fDE7aWYobz1jKG8sMSkscyhlKSl7ZC5zZXQoXCJNaWxsaXNlY29uZHNcIixtLHg+PXUuc2Vjb25kPzA6eSpNYXRoLmZsb29yKGQuZ2V0KFwiTWlsbGlzZWNvbmRzXCIsbSkveSkpLHg+PXUuc2Vjb25kJiZkLnNldChcIlNlY29uZHNcIixtLHg+PXUubWludXRlPzA6eSpNYXRoLmZsb29yKGQuZ2V0KFwiU2Vjb25kc1wiLG0pL3kpKSx4Pj11Lm1pbnV0ZSYmZC5zZXQoXCJNaW51dGVzXCIsbSx4Pj11LmhvdXI/MDp5Kk1hdGguZmxvb3IoZC5nZXQoXCJNaW51dGVzXCIsbSkveSkpLHg+PXUuaG91ciYmZC5zZXQoXCJIb3Vyc1wiLG0seD49dS5kYXk/MDp5Kk1hdGguZmxvb3IoZC5nZXQoXCJIb3Vyc1wiLG0pL3kpKSx4Pj11LmRheSYmZC5zZXQoXCJEYXRlXCIsbSx4Pj11Lm1vbnRoPzE6TWF0aC5tYXgoMSx5Kk1hdGguZmxvb3IoZC5nZXQoXCJEYXRlXCIsbSkveSkpKSx4Pj11Lm1vbnRoJiYoZC5zZXQoXCJNb250aFwiLG0seD49dS55ZWFyPzA6eSpNYXRoLmZsb29yKGQuZ2V0KFwiTW9udGhcIixtKS95KSksYT1kLmdldChcIkZ1bGxZZWFyXCIsbSkpLHg+PXUueWVhciYmKGEtPWEleSxkLnNldChcIkZ1bGxZZWFyXCIsbSxhKSkseD09PXUud2VlayYmKGw9ZC5nZXQoXCJEYXlcIixtKSxkLnNldChcIkRhdGVcIixtLGQuZ2V0KFwiRGF0ZVwiLG0pLWwrbysobDxvPy03OjApKSksYT1kLmdldChcIkZ1bGxZZWFyXCIsbSk7bGV0IHQ9ZC5nZXQoXCJNb250aFwiLG0pLHI9ZC5nZXQoXCJEYXRlXCIsbSksYz1kLmdldChcIkhvdXJzXCIsbSk7ZT1tLmdldFRpbWUoKSwoZC52YXJpYWJsZVRpbWV6b25lfHwhZC51c2VVVEMpJiZzKGkpJiYoaD1pLWU+NCp1Lm1vbnRofHxkLmdldFRpbWV6b25lT2Zmc2V0KGUpIT09ZC5nZXRUaW1lem9uZU9mZnNldChpKSk7bGV0IHA9bS5nZXRUaW1lKCk7Zm9yKG49MTtwPGk7KWcucHVzaChwKSx4PT09dS55ZWFyP3A9ZC5tYWtlVGltZShhK24qeSwwKTp4PT09dS5tb250aD9wPWQubWFrZVRpbWUoYSx0K24qeSk6aCYmKHg9PT11LmRheXx8eD09PXUud2Vlayk/cD1kLm1ha2VUaW1lKGEsdCxyK24qeSooeD09PXUuZGF5PzE6NykpOmgmJng9PT11LmhvdXImJnk+MT9wPWQubWFrZVRpbWUoYSx0LHIsYytuKnkpOnArPXgqeSxuKys7Zy5wdXNoKHApLHg8PXUuaG91ciYmZy5sZW5ndGg8MWU0JiZnLmZvckVhY2goZnVuY3Rpb24odCl7dCUxOGU1PT0wJiZcIjAwMDAwMDAwMFwiPT09ZC5kYXRlRm9ybWF0KFwiJUglTSVTJUxcIix0KSYmKGZbdF09XCJkYXlcIil9KX1yZXR1cm4gZy5pbmZvPXIodCx7aGlnaGVyUmFua3M6Zix0b3RhbFJhbmdlOngqeX0pLGd9Z2V0RGF0ZUZvcm1hdCh0LGUsaSxzKXtsZXQgbz10aGlzLmRhdGVGb3JtYXQoXCIlbS0lZCAlSDolTTolUy4lTFwiLGUpLHI9XCIwMS0wMSAwMDowMDowMC4wMDBcIixuPXttaWxsaXNlY29uZDoxNSxzZWNvbmQ6MTIsbWludXRlOjksaG91cjo2LGRheTozfSxhPVwibWlsbGlzZWNvbmRcIixoPWE7Zm9yKGEgaW4gdSl7aWYodD09PXUud2VlayYmK3RoaXMuZGF0ZUZvcm1hdChcIiV3XCIsZSk9PT1pJiZvLnN1YnN0cig2KT09PXIuc3Vic3RyKDYpKXthPVwid2Vla1wiO2JyZWFrfWlmKHVbYV0+dCl7YT1oO2JyZWFrfWlmKG5bYV0mJm8uc3Vic3RyKG5bYV0pIT09ci5zdWJzdHIoblthXSkpYnJlYWs7XCJ3ZWVrXCIhPT1hJiYoaD1hKX1yZXR1cm4gdGhpcy5yZXNvbHZlRFRMRm9ybWF0KHNbYV0pLm1haW59fX0pLGkoZSxcIkNvcmUvRGVmYXVsdHMuanNcIixbZVtcIkNvcmUvQ2hhcnQvQ2hhcnREZWZhdWx0cy5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL0NvbG9yL1BhbGV0dGVzLmpzXCJdLGVbXCJDb3JlL1RpbWUuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSxzLG8pe2xldHtpc1RvdWNoRGV2aWNlOnIsc3ZnOm59PWUse21lcmdlOmF9PW8saD17Y29sb3JzOmkuY29sb3JzLHN5bWJvbHM6W1wiY2lyY2xlXCIsXCJkaWFtb25kXCIsXCJzcXVhcmVcIixcInRyaWFuZ2xlXCIsXCJ0cmlhbmdsZS1kb3duXCJdLGxhbmc6e2xvYWRpbmc6XCJMb2FkaW5nLi4uXCIsbW9udGhzOltcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFwiSnVseVwiLFwiQXVndXN0XCIsXCJTZXB0ZW1iZXJcIixcIk9jdG9iZXJcIixcIk5vdmVtYmVyXCIsXCJEZWNlbWJlclwiXSxzaG9ydE1vbnRoczpbXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdLHdlZWtkYXlzOltcIlN1bmRheVwiLFwiTW9uZGF5XCIsXCJUdWVzZGF5XCIsXCJXZWRuZXNkYXlcIixcIlRodXJzZGF5XCIsXCJGcmlkYXlcIixcIlNhdHVyZGF5XCJdLGRlY2ltYWxQb2ludDpcIi5cIixudW1lcmljU3ltYm9sczpbXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCJdLHJlc2V0Wm9vbTpcIlJlc2V0IHpvb21cIixyZXNldFpvb21UaXRsZTpcIlJlc2V0IHpvb20gbGV2ZWwgMToxXCIsdGhvdXNhbmRzU2VwOlwiIFwifSxnbG9iYWw6e30sdGltZTp7RGF0ZTp2b2lkIDAsZ2V0VGltZXpvbmVPZmZzZXQ6dm9pZCAwLHRpbWV6b25lOnZvaWQgMCx0aW1lem9uZU9mZnNldDowLHVzZVVUQzohMH0sY2hhcnQ6dCx0aXRsZTp7c3R5bGU6e2NvbG9yOlwiIzMzMzMzM1wiLGZvbnRXZWlnaHQ6XCJib2xkXCJ9LHRleHQ6XCJDaGFydCB0aXRsZVwiLGFsaWduOlwiY2VudGVyXCIsbWFyZ2luOjE1LHdpZHRoQWRqdXN0Oi00NH0sc3VidGl0bGU6e3N0eWxlOntjb2xvcjpcIiM2NjY2NjZcIixmb250U2l6ZTpcIjAuOGVtXCJ9LHRleHQ6XCJcIixhbGlnbjpcImNlbnRlclwiLHdpZHRoQWRqdXN0Oi00NH0sY2FwdGlvbjp7bWFyZ2luOjE1LHN0eWxlOntjb2xvcjpcIiM2NjY2NjZcIixmb250U2l6ZTpcIjAuOGVtXCJ9LHRleHQ6XCJcIixhbGlnbjpcImxlZnRcIix2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCJ9LHBsb3RPcHRpb25zOnt9LGxlZ2VuZDp7ZW5hYmxlZDohMCxhbGlnbjpcImNlbnRlclwiLGFsaWduQ29sdW1uczohMCxjbGFzc05hbWU6XCJoaWdoY2hhcnRzLW5vLXRvb2x0aXBcIixsYXlvdXQ6XCJob3Jpem9udGFsXCIsaXRlbU1hcmdpbkJvdHRvbToyLGl0ZW1NYXJnaW5Ub3A6MixsYWJlbEZvcm1hdHRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9LGJvcmRlckNvbG9yOlwiIzk5OTk5OVwiLGJvcmRlclJhZGl1czowLG5hdmlnYXRpb246e3N0eWxlOntmb250U2l6ZTpcIjAuOGVtXCJ9LGFjdGl2ZUNvbG9yOlwiIzAwMjJmZlwiLGluYWN0aXZlQ29sb3I6XCIjY2NjY2NjXCJ9LGl0ZW1TdHlsZTp7Y29sb3I6XCIjMzMzMzMzXCIsY3Vyc29yOlwicG9pbnRlclwiLGZvbnRTaXplOlwiMC44ZW1cIix0ZXh0RGVjb3JhdGlvbjpcIm5vbmVcIix0ZXh0T3ZlcmZsb3c6XCJlbGxpcHNpc1wifSxpdGVtSG92ZXJTdHlsZTp7Y29sb3I6XCIjMDAwMDAwXCJ9LGl0ZW1IaWRkZW5TdHlsZTp7Y29sb3I6XCIjNjY2NjY2XCIsdGV4dERlY29yYXRpb246XCJsaW5lLXRocm91Z2hcIn0sc2hhZG93OiExLGl0ZW1DaGVja2JveFN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxM3B4XCIsaGVpZ2h0OlwiMTNweFwifSxzcXVhcmVTeW1ib2w6ITAsc3ltYm9sUGFkZGluZzo1LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowLHRpdGxlOntzdHlsZTp7Zm9udFNpemU6XCIwLjhlbVwiLGZvbnRXZWlnaHQ6XCJib2xkXCJ9fX0sbG9hZGluZzp7bGFiZWxTdHlsZTp7Zm9udFdlaWdodDpcImJvbGRcIixwb3NpdGlvbjpcInJlbGF0aXZlXCIsdG9wOlwiNDUlXCJ9LHN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsYmFja2dyb3VuZENvbG9yOlwiI2ZmZmZmZlwiLG9wYWNpdHk6LjUsdGV4dEFsaWduOlwiY2VudGVyXCJ9fSx0b29sdGlwOntlbmFibGVkOiEwLGFuaW1hdGlvbjpuLGJvcmRlclJhZGl1czozLGRhdGVUaW1lTGFiZWxGb3JtYXRzOnttaWxsaXNlY29uZDpcIiVBLCAlZSAlYiwgJUg6JU06JVMuJUxcIixzZWNvbmQ6XCIlQSwgJWUgJWIsICVIOiVNOiVTXCIsbWludXRlOlwiJUEsICVlICViLCAlSDolTVwiLGhvdXI6XCIlQSwgJWUgJWIsICVIOiVNXCIsZGF5OlwiJUEsICVlICViICVZXCIsd2VlazpcIldlZWsgZnJvbSAlQSwgJWUgJWIgJVlcIixtb250aDpcIiVCICVZXCIseWVhcjpcIiVZXCJ9LGZvb3RlckZvcm1hdDpcIlwiLGhlYWRlclNoYXBlOlwiY2FsbG91dFwiLGhpZGVEZWxheTo1MDAscGFkZGluZzo4LHNoYXBlOlwiY2FsbG91dFwiLHNoYXJlZDohMSxzbmFwOnI/MjU6MTAsaGVhZGVyRm9ybWF0Oic8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMC44ZW1cIj57cG9pbnQua2V5fTwvc3Bhbj48YnIvPicscG9pbnRGb3JtYXQ6JzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPuKXjzwvc3Bhbj4ge3Nlcmllcy5uYW1lfTogPGI+e3BvaW50Lnl9PC9iPjxici8+JyxiYWNrZ3JvdW5kQ29sb3I6XCIjZmZmZmZmXCIsYm9yZGVyV2lkdGg6dm9pZCAwLHNoYWRvdzohMCxzdGlja09uQ29udGFjdDohMSxzdHlsZTp7Y29sb3I6XCIjMzMzMzMzXCIsY3Vyc29yOlwiZGVmYXVsdFwiLGZvbnRTaXplOlwiMC44ZW1cIn0sdXNlSFRNTDohMX0sY3JlZGl0czp7ZW5hYmxlZDohMCxocmVmOlwiaHR0cHM6Ly93d3cuaGlnaGNoYXJ0cy5jb20/Y3JlZGl0c1wiLHBvc2l0aW9uOnthbGlnbjpcInJpZ2h0XCIseDotMTAsdmVydGljYWxBbGlnbjpcImJvdHRvbVwiLHk6LTV9LHN0eWxlOntjdXJzb3I6XCJwb2ludGVyXCIsY29sb3I6XCIjOTk5OTk5XCIsZm9udFNpemU6XCIwLjZlbVwifSx0ZXh0OlwiSGlnaGNoYXJ0cy5jb21cIn19O2guY2hhcnQuc3R5bGVkTW9kZT0hMTtsZXQgbD1uZXcgcyhoLnRpbWUpO3JldHVybntkZWZhdWx0T3B0aW9uczpoLGRlZmF1bHRUaW1lOmwsZ2V0T3B0aW9uczpmdW5jdGlvbigpe3JldHVybiBofSxzZXRPcHRpb25zOmZ1bmN0aW9uKHQpe3JldHVybiBhKCEwLGgsdCksKHQudGltZXx8dC5nbG9iYWwpJiYoZS50aW1lP2UudGltZS51cGRhdGUoYShoLmdsb2JhbCxoLnRpbWUsdC5nbG9iYWwsdC50aW1lKSk6ZS50aW1lPWwpLGh9fX0pLGkoZSxcIkNvcmUvQ29sb3IvQ29sb3IuanNcIixbZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSl7bGV0e2lzTnVtYmVyOmksbWVyZ2U6cyxwSW50Om99PWU7Y2xhc3MgcntzdGF0aWMgcGFyc2UodCl7cmV0dXJuIHQ/bmV3IHIodCk6ci5Ob25lfWNvbnN0cnVjdG9yKGUpe2xldCBpLHMsbyxuO3RoaXMucmdiYT1bTmFOLE5hTixOYU4sTmFOXSx0aGlzLmlucHV0PWU7bGV0IGE9dC5Db2xvcjtpZihhJiZhIT09cilyZXR1cm4gbmV3IGEoZSk7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJnZvaWQgMCE9PWUuc3RvcHMpdGhpcy5zdG9wcz1lLnN0b3BzLm1hcCh0PT5uZXcgcih0WzFdKSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYodGhpcy5pbnB1dD1lPXIubmFtZXNbZS50b0xvd2VyQ2FzZSgpXXx8ZSxcIiNcIj09PWUuY2hhckF0KDApKXtsZXQgdD1lLmxlbmd0aCxpPXBhcnNlSW50KGUuc3Vic3RyKDEpLDE2KTs3PT09dD9zPVsoMTY3MTE2ODAmaSk+PjE2LCg2NTI4MCZpKT4+OCwyNTUmaSwxXTo0PT09dCYmKHM9WygzODQwJmkpPj40fCgzODQwJmkpPj44LCgyNDAmaSk+PjR8MjQwJmksKDE1JmkpPDw0fDE1JmksMV0pfWlmKCFzKWZvcihvPXIucGFyc2Vycy5sZW5ndGg7by0tJiYhczspKGk9KG49ci5wYXJzZXJzW29dKS5yZWdleC5leGVjKGUpKSYmKHM9bi5wYXJzZShpKSl9cyYmKHRoaXMucmdiYT1zKX1nZXQodCl7bGV0IGU9dGhpcy5pbnB1dCxvPXRoaXMucmdiYTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmdm9pZCAwIT09dGhpcy5zdG9wcyl7bGV0IGk9cyhlKTtyZXR1cm4gaS5zdG9wcz1bXS5zbGljZS5jYWxsKGkuc3RvcHMpLHRoaXMuc3RvcHMuZm9yRWFjaCgoZSxzKT0+e2kuc3RvcHNbc109W2kuc3RvcHNbc11bMF0sZS5nZXQodCldfSksaX1yZXR1cm4gbyYmaShvWzBdKT9cInJnYlwiIT09dCYmKHR8fDEhPT1vWzNdKT9cImFcIj09PXQ/YCR7b1szXX1gOlwicmdiYShcIitvLmpvaW4oXCIsXCIpK1wiKVwiOlwicmdiKFwiK29bMF0rXCIsXCIrb1sxXStcIixcIitvWzJdK1wiKVwiOmV9YnJpZ2h0ZW4odCl7bGV0IGU9dGhpcy5yZ2JhO2lmKHRoaXMuc3RvcHMpdGhpcy5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYnJpZ2h0ZW4odCl9KTtlbHNlIGlmKGkodCkmJjAhPT10KWZvcihsZXQgaT0wO2k8MztpKyspZVtpXSs9bygyNTUqdCksZVtpXTwwJiYoZVtpXT0wKSxlW2ldPjI1NSYmKGVbaV09MjU1KTtyZXR1cm4gdGhpc31zZXRPcGFjaXR5KHQpe3JldHVybiB0aGlzLnJnYmFbM109dCx0aGlzfXR3ZWVuVG8odCxlKXtsZXQgcz10aGlzLnJnYmEsbz10LnJnYmE7aWYoIWkoc1swXSl8fCFpKG9bMF0pKXJldHVybiB0LmlucHV0fHxcIm5vbmVcIjtsZXQgcj0xIT09b1szXXx8MSE9PXNbM107cmV0dXJuKHI/XCJyZ2JhKFwiOlwicmdiKFwiKStNYXRoLnJvdW5kKG9bMF0rKHNbMF0tb1swXSkqKDEtZSkpK1wiLFwiK01hdGgucm91bmQob1sxXSsoc1sxXS1vWzFdKSooMS1lKSkrXCIsXCIrTWF0aC5yb3VuZChvWzJdKyhzWzJdLW9bMl0pKigxLWUpKSsocj9cIixcIisob1szXSsoc1szXS1vWzNdKSooMS1lKSk6XCJcIikrXCIpXCJ9fXJldHVybiByLm5hbWVzPXt3aGl0ZTpcIiNmZmZmZmZcIixibGFjazpcIiMwMDAwMDBcIn0sci5wYXJzZXJzPVt7cmVnZXg6L3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKHQpe3JldHVybltvKHRbMV0pLG8odFsyXSksbyh0WzNdKSxwYXJzZUZsb2F0KHRbNF0sMTApXX19LHtyZWdleDovcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKHQpe3JldHVybltvKHRbMV0pLG8odFsyXSksbyh0WzNdKSwxXX19XSxyLk5vbmU9bmV3IHIoXCJcIikscn0pLGkoZSxcIkNvcmUvQW5pbWF0aW9uL0Z4LmpzXCIsW2VbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7bGV0e3BhcnNlOnN9PXQse3dpbjpvfT1lLHtpc051bWJlcjpyLG9iamVjdEVhY2g6bn09aTtjbGFzcyBhe2NvbnN0cnVjdG9yKHQsZSxpKXt0aGlzLnBvcz1OYU4sdGhpcy5vcHRpb25zPWUsdGhpcy5lbGVtPXQsdGhpcy5wcm9wPWl9ZFNldHRlcigpe2xldCB0PXRoaXMucGF0aHMsZT10JiZ0WzBdLGk9dCYmdFsxXSxzPXRoaXMubm93fHwwLG89W107aWYoMSE9PXMmJmUmJmkpe2lmKGUubGVuZ3RoPT09aS5sZW5ndGgmJnM8MSlmb3IobGV0IHQ9MDt0PGkubGVuZ3RoO3QrKyl7bGV0IG49ZVt0XSxhPWlbdF0saD1bXTtmb3IobGV0IHQ9MDt0PGEubGVuZ3RoO3QrKyl7bGV0IGU9blt0XSxpPWFbdF07cihlKSYmcihpKSYmIShcIkFcIj09PWFbMF0mJig0PT09dHx8NT09PXQpKT9oW3RdPWUrcyooaS1lKTpoW3RdPWl9by5wdXNoKGgpfWVsc2Ugbz1pfWVsc2Ugbz10aGlzLnRvRHx8W107dGhpcy5lbGVtLmF0dHIoXCJkXCIsbyx2b2lkIDAsITApfXVwZGF0ZSgpe2xldCB0PXRoaXMuZWxlbSxlPXRoaXMucHJvcCxpPXRoaXMubm93LHM9dGhpcy5vcHRpb25zLnN0ZXA7dGhpc1tlK1wiU2V0dGVyXCJdP3RoaXNbZStcIlNldHRlclwiXSgpOnQuYXR0cj90LmVsZW1lbnQmJnQuYXR0cihlLGksbnVsbCwhMCk6dC5zdHlsZVtlXT1pK3RoaXMudW5pdCxzJiZzLmNhbGwodCxpLHRoaXMpfXJ1bih0LGUsaSl7bGV0IHM9dGhpcyxyPXMub3B0aW9ucyxuPWZ1bmN0aW9uKHQpe3JldHVybiFuLnN0b3BwZWQmJnMuc3RlcCh0KX0saD1vLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24odCl7c2V0VGltZW91dCh0LDEzKX0sbD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8YS50aW1lcnMubGVuZ3RoO3QrKylhLnRpbWVyc1t0XSgpfHxhLnRpbWVycy5zcGxpY2UodC0tLDEpO2EudGltZXJzLmxlbmd0aCYmaChsKX07dCE9PWV8fHRoaXMuZWxlbVtcImZvcmNlQW5pbWF0ZTpcIit0aGlzLnByb3BdPyh0aGlzLnN0YXJ0VGltZT0rbmV3IERhdGUsdGhpcy5zdGFydD10LHRoaXMuZW5kPWUsdGhpcy51bml0PWksdGhpcy5ub3c9dGhpcy5zdGFydCx0aGlzLnBvcz0wLG4uZWxlbT10aGlzLmVsZW0sbi5wcm9wPXRoaXMucHJvcCxuKCkmJjE9PT1hLnRpbWVycy5wdXNoKG4pJiZoKGwpKTooZGVsZXRlIHIuY3VyQW5pbVt0aGlzLnByb3BdLHIuY29tcGxldGUmJjA9PT1PYmplY3Qua2V5cyhyLmN1ckFuaW0pLmxlbmd0aCYmci5jb21wbGV0ZS5jYWxsKHRoaXMuZWxlbSkpfXN0ZXAodCl7bGV0IGUsaTtsZXQgcz0rbmV3IERhdGUsbz10aGlzLm9wdGlvbnMscj10aGlzLmVsZW0sYT1vLmNvbXBsZXRlLGg9by5kdXJhdGlvbixsPW8uY3VyQW5pbTtyZXR1cm4gci5hdHRyJiYhci5lbGVtZW50P2U9ITE6dHx8cz49aCt0aGlzLnN0YXJ0VGltZT8odGhpcy5ub3c9dGhpcy5lbmQsdGhpcy5wb3M9MSx0aGlzLnVwZGF0ZSgpLGxbdGhpcy5wcm9wXT0hMCxpPSEwLG4obCxmdW5jdGlvbih0KXshMCE9PXQmJihpPSExKX0pLGkmJmEmJmEuY2FsbChyKSxlPSExKToodGhpcy5wb3M9by5lYXNpbmcoKHMtdGhpcy5zdGFydFRpbWUpL2gpLHRoaXMubm93PXRoaXMuc3RhcnQrKHRoaXMuZW5kLXRoaXMuc3RhcnQpKnRoaXMucG9zLHRoaXMudXBkYXRlKCksZT0hMCksZX1pbml0UGF0aCh0LGUsaSl7bGV0IHM9dC5zdGFydFgsbz10LmVuZFgsbj1pLnNsaWNlKCksYT10LmlzQXJlYSxoPWE/MjoxLGwsZCxjLHAsdT1lJiZlLnNsaWNlKCk7aWYoIXUpcmV0dXJuW24sbl07ZnVuY3Rpb24gZyh0LGUpe2Zvcig7dC5sZW5ndGg8ZDspe2xldCBpPXRbMF0scz1lW2QtdC5sZW5ndGhdO2lmKHMmJlwiTVwiPT09aVswXSYmKFwiQ1wiPT09c1swXT90WzBdPVtcIkNcIixpWzFdLGlbMl0saVsxXSxpWzJdLGlbMV0saVsyXV06dFswXT1bXCJMXCIsaVsxXSxpWzJdXSksdC51bnNoaWZ0KGkpLGEpe2xldCBlPXQucG9wKCk7dC5wdXNoKHRbdC5sZW5ndGgtMV0sZSl9fX1mdW5jdGlvbiBmKHQsZSl7Zm9yKDt0Lmxlbmd0aDxkOyl7bGV0IGU9dFtNYXRoLmZsb29yKHQubGVuZ3RoL2gpLTFdLnNsaWNlKCk7aWYoXCJDXCI9PT1lWzBdJiYoZVsxXT1lWzVdLGVbMl09ZVs2XSksYSl7bGV0IGk9dFtNYXRoLmZsb29yKHQubGVuZ3RoL2gpXS5zbGljZSgpO3Quc3BsaWNlKHQubGVuZ3RoLzIsMCxlLGkpfWVsc2UgdC5wdXNoKGUpfX1pZihzJiZvJiZvLmxlbmd0aCl7Zm9yKGM9MDtjPHMubGVuZ3RoO2MrKyl7aWYoc1tjXT09PW9bMF0pe2w9YzticmVha31pZihzWzBdPT09b1tvLmxlbmd0aC1zLmxlbmd0aCtjXSl7bD1jLHA9ITA7YnJlYWt9aWYoc1tzLmxlbmd0aC0xXT09PW9bby5sZW5ndGgtcy5sZW5ndGgrY10pe2w9cy5sZW5ndGgtYzticmVha319dm9pZCAwPT09bCYmKHU9W10pfXJldHVybiB1Lmxlbmd0aCYmcihsKSYmKGQ9bi5sZW5ndGgrbCpoLHA/KGcodSxuKSxmKG4sdSkpOihnKG4sdSksZih1LG4pKSksW3Usbl19ZmlsbFNldHRlcigpe2EucHJvdG90eXBlLnN0cm9rZVNldHRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3Ryb2tlU2V0dGVyKCl7dGhpcy5lbGVtLmF0dHIodGhpcy5wcm9wLHModGhpcy5zdGFydCkudHdlZW5UbyhzKHRoaXMuZW5kKSx0aGlzLnBvcyksdm9pZCAwLCEwKX19cmV0dXJuIGEudGltZXJzPVtdLGF9KSxpKGUsXCJDb3JlL0FuaW1hdGlvbi9BbmltYXRpb25VdGlsaXRpZXMuanNcIixbZVtcIkNvcmUvQW5pbWF0aW9uL0Z4LmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlKXtsZXR7ZGVmaW5lZDppLGdldFN0eWxlOnMsaXNBcnJheTpvLGlzTnVtYmVyOnIsaXNPYmplY3Q6bixtZXJnZTphLG9iamVjdEVhY2g6aCxwaWNrOmx9PWU7ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbih0KT9hKHtkdXJhdGlvbjo1MDAsZGVmZXI6MH0sdCk6e2R1cmF0aW9uOnQ/NTAwOjAsZGVmZXI6MH19ZnVuY3Rpb24gYyhlLGkpe2xldCBzPXQudGltZXJzLmxlbmd0aDtmb3IoO3MtLTspdC50aW1lcnNbc10uZWxlbSE9PWV8fGkmJmkhPT10LnRpbWVyc1tzXS5wcm9wfHwodC50aW1lcnNbc10uc3RvcHBlZD0hMCl9cmV0dXJue2FuaW1hdGU6ZnVuY3Rpb24oZSxpLGwpe2xldCBkLHA9XCJcIix1LGcsZjtuKGwpfHwoZj1hcmd1bWVudHMsbD17ZHVyYXRpb246ZlsyXSxlYXNpbmc6ZlszXSxjb21wbGV0ZTpmWzRdfSkscihsLmR1cmF0aW9uKXx8KGwuZHVyYXRpb249NDAwKSxsLmVhc2luZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBsLmVhc2luZz9sLmVhc2luZzpNYXRoW2wuZWFzaW5nXXx8TWF0aC5lYXNlSW5PdXRTaW5lLGwuY3VyQW5pbT1hKGkpLGgoaSxmdW5jdGlvbihyLG4pe2MoZSxuKSxnPW5ldyB0KGUsbCxuKSx1PXZvaWQgMCxcImRcIj09PW4mJm8oaS5kKT8oZy5wYXRocz1nLmluaXRQYXRoKGUsZS5wYXRoQXJyYXksaS5kKSxnLnRvRD1pLmQsZD0wLHU9MSk6ZS5hdHRyP2Q9ZS5hdHRyKG4pOihkPXBhcnNlRmxvYXQocyhlLG4pKXx8MCxcIm9wYWNpdHlcIiE9PW4mJihwPVwicHhcIikpLHV8fCh1PXIpLFwic3RyaW5nXCI9PXR5cGVvZiB1JiZ1Lm1hdGNoKFwicHhcIikmJih1PXUucmVwbGFjZSgvcHgvZyxcIlwiKSksZy5ydW4oZCx1LHApfSl9LGFuaW1PYmplY3Q6ZCxnZXREZWZlcnJlZEFuaW1hdGlvbjpmdW5jdGlvbih0LGUscyl7bGV0IG89ZChlKSxyPXM/W3NdOnQuc2VyaWVzLGE9MCxoPTA7ci5mb3JFYWNoKHQ9PntsZXQgcz1kKHQub3B0aW9ucy5hbmltYXRpb24pO2E9bihlKSYmaShlLmRlZmVyKT9vLmRlZmVyOk1hdGgubWF4KGEscy5kdXJhdGlvbitzLmRlZmVyKSxoPU1hdGgubWluKG8uZHVyYXRpb24scy5kdXJhdGlvbil9KSx0LnJlbmRlcmVyLmZvckV4cG9ydCYmKGE9MCk7bGV0IGw9e2RlZmVyOk1hdGgubWF4KDAsYS1oKSxkdXJhdGlvbjpNYXRoLm1pbihhLGgpfTtyZXR1cm4gbH0sc2V0QW5pbWF0aW9uOmZ1bmN0aW9uKHQsZSl7ZS5yZW5kZXJlci5nbG9iYWxBbmltYXRpb249bCh0LGUub3B0aW9ucy5jaGFydC5hbmltYXRpb24sITApfSxzdG9wOmN9fSksaShlLFwiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiLFtlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlKXtsZXR7U1ZHX05TOmksd2luOnN9PXQse2F0dHI6byxjcmVhdGVFbGVtZW50OnIsY3NzOm4sZXJyb3I6YSxpc0Z1bmN0aW9uOmgsaXNTdHJpbmc6bCxvYmplY3RFYWNoOmQsc3BsYXQ6Y309ZSx7dHJ1c3RlZFR5cGVzOnB9PXMsdT1wJiZoKHAuY3JlYXRlUG9saWN5KSYmcC5jcmVhdGVQb2xpY3koXCJoaWdoY2hhcnRzXCIse2NyZWF0ZUhUTUw6dD0+dH0pLGc9dT91LmNyZWF0ZUhUTUwoXCJcIik6XCJcIixmPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiEhbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhnLFwidGV4dC9odG1sXCIpfWNhdGNoKHQpe3JldHVybiExfX0oKTtjbGFzcyBte3N0YXRpYyBmaWx0ZXJVc2VyQXR0cmlidXRlcyh0KXtyZXR1cm4gZCh0LChlLGkpPT57bGV0IHM9ITA7LTE9PT1tLmFsbG93ZWRBdHRyaWJ1dGVzLmluZGV4T2YoaSkmJihzPSExKSwtMSE9PVtcImJhY2tncm91bmRcIixcImR5bnNyY1wiLFwiaHJlZlwiLFwibG93c3JjXCIsXCJzcmNcIl0uaW5kZXhPZihpKSYmKHM9bChlKSYmbS5hbGxvd2VkUmVmZXJlbmNlcy5zb21lKHQ9PjA9PT1lLmluZGV4T2YodCkpKSxzfHwoYSgzMywhMSx2b2lkIDAse1wiSW52YWxpZCBhdHRyaWJ1dGUgaW4gY29uZmlnXCI6YCR7aX1gfSksZGVsZXRlIHRbaV0pLGwoZSkmJnRbaV0mJih0W2ldPWUucmVwbGFjZSgvPC9nLFwiJmx0O1wiKSl9KSx0fXN0YXRpYyBwYXJzZVN0eWxlKHQpe3JldHVybiB0LnNwbGl0KFwiO1wiKS5yZWR1Y2UoKHQsZSk9PntsZXQgaT1lLnNwbGl0KFwiOlwiKS5tYXAodD0+dC50cmltKCkpLHM9aS5zaGlmdCgpO3JldHVybiBzJiZpLmxlbmd0aCYmKHRbcy5yZXBsYWNlKC8tKFthLXpdKS9nLHQ9PnRbMV0udG9VcHBlckNhc2UoKSldPWkuam9pbihcIjpcIikpLHR9LHt9KX1zdGF0aWMgc2V0RWxlbWVudEhUTUwodCxlKXtpZih0LmlubmVySFRNTD1tLmVtcHR5SFRNTCxlKXtsZXQgaT1uZXcgbShlKTtpLmFkZFRvRE9NKHQpfX1jb25zdHJ1Y3Rvcih0KXt0aGlzLm5vZGVzPVwic3RyaW5nXCI9PXR5cGVvZiB0P3RoaXMucGFyc2VNYXJrdXAodCk6dH1hZGRUb0RPTShlKXtyZXR1cm4gZnVuY3Rpb24gZShzLHIpe2xldCBoO3JldHVybiBjKHMpLmZvckVhY2goZnVuY3Rpb24ocyl7bGV0IGw7bGV0IGM9cy50YWdOYW1lLHA9cy50ZXh0Q29udGVudD90LmRvYy5jcmVhdGVUZXh0Tm9kZShzLnRleHRDb250ZW50KTp2b2lkIDAsdT1tLmJ5cGFzc0hUTUxGaWx0ZXJpbmc7aWYoYyl7aWYoXCIjdGV4dFwiPT09YylsPXA7ZWxzZSBpZigtMSE9PW0uYWxsb3dlZFRhZ3MuaW5kZXhPZihjKXx8dSl7bGV0IGE9XCJzdmdcIj09PWM/aTpyLm5hbWVzcGFjZVVSSXx8aSxoPXQuZG9jLmNyZWF0ZUVsZW1lbnROUyhhLGMpLGc9cy5hdHRyaWJ1dGVzfHx7fTtkKHMsZnVuY3Rpb24odCxlKXtcInRhZ05hbWVcIiE9PWUmJlwiYXR0cmlidXRlc1wiIT09ZSYmXCJjaGlsZHJlblwiIT09ZSYmXCJzdHlsZVwiIT09ZSYmXCJ0ZXh0Q29udGVudFwiIT09ZSYmKGdbZV09dCl9KSxvKGgsdT9nOm0uZmlsdGVyVXNlckF0dHJpYnV0ZXMoZykpLHMuc3R5bGUmJm4oaCxzLnN0eWxlKSxwJiZoLmFwcGVuZENoaWxkKHApLGUocy5jaGlsZHJlbnx8W10saCksbD1ofWVsc2UgYSgzMywhMSx2b2lkIDAse1wiSW52YWxpZCB0YWdOYW1lIGluIGNvbmZpZ1wiOmN9KX1sJiZyLmFwcGVuZENoaWxkKGwpLGg9bH0pLGh9KHRoaXMubm9kZXMsZSl9cGFyc2VNYXJrdXAodCl7bGV0IGU7bGV0IGk9W107aWYodD10LnRyaW0oKS5yZXBsYWNlKC8gc3R5bGU9KFtcIiddKS9nLFwiIGRhdGEtc3R5bGU9JDFcIiksZillPW5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodT91LmNyZWF0ZUhUTUwodCk6dCxcInRleHQvaHRtbFwiKTtlbHNle2xldCBpPXIoXCJkaXZcIik7aS5pbm5lckhUTUw9dCxlPXtib2R5Oml9fWxldCBzPSh0LGUpPT57bGV0IGk9dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLG89e3RhZ05hbWU6aX07XCIjdGV4dFwiPT09aSYmKG8udGV4dENvbnRlbnQ9dC50ZXh0Q29udGVudHx8XCJcIik7bGV0IHI9dC5hdHRyaWJ1dGVzO2lmKHIpe2xldCB0PXt9O1tdLmZvckVhY2guY2FsbChyLGU9PntcImRhdGEtc3R5bGVcIj09PWUubmFtZT9vLnN0eWxlPW0ucGFyc2VTdHlsZShlLnZhbHVlKTp0W2UubmFtZV09ZS52YWx1ZX0pLG8uYXR0cmlidXRlcz10fWlmKHQuY2hpbGROb2Rlcy5sZW5ndGgpe2xldCBlPVtdO1tdLmZvckVhY2guY2FsbCh0LmNoaWxkTm9kZXMsdD0+e3ModCxlKX0pLGUubGVuZ3RoJiYoby5jaGlsZHJlbj1lKX1lLnB1c2gobyl9O3JldHVybltdLmZvckVhY2guY2FsbChlLmJvZHkuY2hpbGROb2Rlcyx0PT5zKHQsaSkpLGl9fXJldHVybiBtLmFsbG93ZWRBdHRyaWJ1dGVzPVtcImFsdFwiLFwiYXJpYS1jb250cm9sc1wiLFwiYXJpYS1kZXNjcmliZWRieVwiLFwiYXJpYS1leHBhbmRlZFwiLFwiYXJpYS1oYXNwb3B1cFwiLFwiYXJpYS1oaWRkZW5cIixcImFyaWEtbGFiZWxcIixcImFyaWEtbGFiZWxsZWRieVwiLFwiYXJpYS1saXZlXCIsXCJhcmlhLXByZXNzZWRcIixcImFyaWEtcmVhZG9ubHlcIixcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsXCJhcmlhLXNlbGVjdGVkXCIsXCJjbGFzc1wiLFwiY2xpcC1wYXRoXCIsXCJjb2xvclwiLFwiY29sc3BhblwiLFwiY3hcIixcImN5XCIsXCJkXCIsXCJkeFwiLFwiZHlcIixcImRpc2FibGVkXCIsXCJmaWxsXCIsXCJmaWx0ZXJVbml0c1wiLFwiZmxvb2QtY29sb3JcIixcImZsb29kLW9wYWNpdHlcIixcImhlaWdodFwiLFwiaHJlZlwiLFwiaWRcIixcImluXCIsXCJtYXJrZXJIZWlnaHRcIixcIm1hcmtlcldpZHRoXCIsXCJvZmZzZXRcIixcIm9wYWNpdHlcIixcIm9yaWVudFwiLFwicGFkZGluZ1wiLFwicGFkZGluZ0xlZnRcIixcInBhZGRpbmdSaWdodFwiLFwicGF0dGVyblVuaXRzXCIsXCJyXCIsXCJyZWZYXCIsXCJyZWZZXCIsXCJyb2xlXCIsXCJzY29wZVwiLFwic2xvcGVcIixcInNyY1wiLFwic3RhcnRPZmZzZXRcIixcInN0ZERldmlhdGlvblwiLFwic3Ryb2tlXCIsXCJzdHJva2UtbGluZWNhcFwiLFwic3Ryb2tlLXdpZHRoXCIsXCJzdHlsZVwiLFwidGFibGVWYWx1ZXNcIixcInJlc3VsdFwiLFwicm93c3BhblwiLFwic3VtbWFyeVwiLFwidGFyZ2V0XCIsXCJ0YWJpbmRleFwiLFwidGV4dC1hbGlnblwiLFwidGV4dC1hbmNob3JcIixcInRleHRBbmNob3JcIixcInRleHRMZW5ndGhcIixcInRpdGxlXCIsXCJ0eXBlXCIsXCJ2YWxpZ25cIixcIndpZHRoXCIsXCJ4XCIsXCJ4MVwiLFwieDJcIixcInhsaW5rOmhyZWZcIixcInlcIixcInkxXCIsXCJ5MlwiLFwiekluZGV4XCJdLG0uYWxsb3dlZFJlZmVyZW5jZXM9W1wiaHR0cHM6Ly9cIixcImh0dHA6Ly9cIixcIm1haWx0bzpcIixcIi9cIixcIi4uL1wiLFwiLi9cIixcIiNcIl0sbS5hbGxvd2VkVGFncz1bXCJhXCIsXCJhYmJyXCIsXCJiXCIsXCJiclwiLFwiYnV0dG9uXCIsXCJjYXB0aW9uXCIsXCJjaXJjbGVcIixcImNsaXBQYXRoXCIsXCJjb2RlXCIsXCJkZFwiLFwiZGVmc1wiLFwiZGl2XCIsXCJkbFwiLFwiZHRcIixcImVtXCIsXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsXCJmZURyb3BTaGFkb3dcIixcImZlRnVuY0FcIixcImZlRnVuY0JcIixcImZlRnVuY0dcIixcImZlRnVuY1JcIixcImZlR2F1c3NpYW5CbHVyXCIsXCJmZU9mZnNldFwiLFwiZmVNZXJnZVwiLFwiZmVNZXJnZU5vZGVcIixcImZpbHRlclwiLFwiaDFcIixcImgyXCIsXCJoM1wiLFwiaDRcIixcImg1XCIsXCJoNlwiLFwiaHJcIixcImlcIixcImltZ1wiLFwibGlcIixcImxpbmVhckdyYWRpZW50XCIsXCJtYXJrZXJcIixcIm9sXCIsXCJwXCIsXCJwYXRoXCIsXCJwYXR0ZXJuXCIsXCJwcmVcIixcInJlY3RcIixcInNtYWxsXCIsXCJzcGFuXCIsXCJzdG9wXCIsXCJzdHJvbmdcIixcInN0eWxlXCIsXCJzdWJcIixcInN1cFwiLFwic3ZnXCIsXCJ0YWJsZVwiLFwidGV4dFwiLFwidGV4dFBhdGhcIixcInRoZWFkXCIsXCJ0aXRsZVwiLFwidGJvZHlcIixcInRzcGFuXCIsXCJ0ZFwiLFwidGhcIixcInRyXCIsXCJ1XCIsXCJ1bFwiLFwiI3RleHRcIl0sbS5lbXB0eUhUTUw9ZyxtLmJ5cGFzc0hUTUxGaWx0ZXJpbmc9ITEsbX0pLGkoZSxcIkNvcmUvVGVtcGxhdGluZy5qc1wiLFtlW1wiQ29yZS9EZWZhdWx0cy5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSl7bGV0e2RlZmF1bHRPcHRpb25zOmksZGVmYXVsdFRpbWU6c309dCx7ZXh0ZW5kOm8sZ2V0TmVzdGVkUHJvcGVydHk6cixpc0FycmF5Om4saXNOdW1iZXI6YSxpc09iamVjdDpoLGlzU3RyaW5nOmwscGljazpkLHBJbnQ6Y309ZSxwPXthZGQ6KHQsZSk9PnQrZSxkaXZpZGU6KHQsZSk9PjAhPT1lP3QvZTpcIlwiLGVxOih0LGUpPT50PT1lLGVhY2g6ZnVuY3Rpb24odCl7bGV0IGU9YXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV07cmV0dXJuISFuKHQpJiZ0Lm1hcCgoaSxzKT0+dShlLmJvZHksbyhoKGkpP2k6e1wiQHRoaXNcIjppfSx7XCJAaW5kZXhcIjpzLFwiQGZpcnN0XCI6MD09PXMsXCJAbGFzdFwiOnM9PT10Lmxlbmd0aC0xfSkpKS5qb2luKFwiXCIpfSxnZToodCxlKT0+dD49ZSxndDoodCxlKT0+dD5lLGlmOnQ9PiEhdCxsZToodCxlKT0+dDw9ZSxsdDoodCxlKT0+dDxlLG11bHRpcGx5Oih0LGUpPT50KmUsbmU6KHQsZSk9PnQhPWUsc3VidHJhY3Q6KHQsZSk9PnQtZSx1bmxlc3M6dD0+IXR9O2Z1bmN0aW9uIHUodD1cIlwiLGUsbyl7bGV0IG49L1xceyhbYS16QS1aMC05XFw6XFwuXFwsO1xcLVxcLzw+JV9AXCInPSAjXFwoXFwpXSspXFx9L2csYT0vXFwoKFthLXpBLVowLTlcXDpcXC5cXCw7XFwtXFwvPD4lX0BcIic9IF0rKVxcKS9nLGg9W10sbD0vZiQvLGM9L1xcLihbMC05XSkvLGY9aS5sYW5nLG09byYmby50aW1lfHxzLHg9byYmby5udW1iZXJGb3JtYXR0ZXJ8fGcseT0odD1cIlwiKT0+e2xldCBpO3JldHVyblwidHJ1ZVwiPT09dHx8XCJmYWxzZVwiIT09dCYmKChpPU51bWJlcih0KSkudG9TdHJpbmcoKT09PXQ/aTpyKHQsZSkpfSxiLHYsUz0wLGs7Zm9yKDtudWxsIT09KGI9bi5leGVjKHQpKTspe2xldCBpPWEuZXhlYyhiWzFdKTtpJiYoYj1pLGs9ITApLHYmJnYuaXNCbG9ja3x8KHY9e2N0eDplLGV4cHJlc3Npb246YlsxXSxmaW5kOmJbMF0saXNCbG9jazpcIiNcIj09PWJbMV0uY2hhckF0KDApLHN0YXJ0OmIuaW5kZXgsc3RhcnRJbm5lcjpiLmluZGV4K2JbMF0ubGVuZ3RoLGxlbmd0aDpiWzBdLmxlbmd0aH0pO2xldCBzPWJbMV0uc3BsaXQoXCIgXCIpWzBdLnJlcGxhY2UoXCIjXCIsXCJcIik7cFtzXSYmKHYuaXNCbG9jayYmcz09PXYuZm4mJlMrKyx2LmZufHwodi5mbj1zKSk7bGV0IG89XCJlbHNlXCI9PT1iWzFdO2lmKHYuaXNCbG9jayYmdi5mbiYmKGJbMV09PT1gLyR7di5mbn1gfHxvKSl7aWYoUykhbyYmUy0tO2Vsc2V7bGV0IGU9di5zdGFydElubmVyLGk9dC5zdWJzdHIoZSxiLmluZGV4LWUpO3ZvaWQgMD09PXYuYm9keT8odi5ib2R5PWksdi5zdGFydElubmVyPWIuaW5kZXgrYlswXS5sZW5ndGgpOnYuZWxzZUJvZHk9aSx2LmZpbmQrPWkrYlswXSxvfHwoaC5wdXNoKHYpLHY9dm9pZCAwKX19ZWxzZSB2LmlzQmxvY2t8fGgucHVzaCh2KTtpZihpJiYhdj8uaXNCbG9jaylicmVha31yZXR1cm4gaC5mb3JFYWNoKGk9PntsZXQgcyxvO2xldHtib2R5OnIsZWxzZUJvZHk6bixleHByZXNzaW9uOmEsZm46aH09aTtpZihoKXtsZXQgdD1baV0sbD1hLnNwbGl0KFwiIFwiKTtmb3Iobz1wW2hdLmxlbmd0aDtvLS07KXQudW5zaGlmdCh5KGxbbysxXSkpO3M9cFtoXS5hcHBseShlLHQpLGkuaXNCbG9jayYmXCJib29sZWFuXCI9PXR5cGVvZiBzJiYocz11KHM/cjpuLGUpKX1lbHNle2xldCB0PWEuc3BsaXQoXCI6XCIpO2lmKHM9eSh0LnNoaWZ0KCl8fFwiXCIpLHQubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2Ygcyl7bGV0IGU9dC5qb2luKFwiOlwiKTtpZihsLnRlc3QoZSkpe2xldCB0PXBhcnNlSW50KChlLm1hdGNoKGMpfHxbXCJcIixcIi0xXCJdKVsxXSwxMCk7bnVsbCE9PXMmJihzPXgocyx0LGYuZGVjaW1hbFBvaW50LGUuaW5kZXhPZihcIixcIik+LTE/Zi50aG91c2FuZHNTZXA6XCJcIikpfWVsc2Ugcz1tLmRhdGVGb3JtYXQoZSxzKX19dD10LnJlcGxhY2UoaS5maW5kLGQocyxcIlwiKSl9KSxrP3UodCxlLG8pOnR9ZnVuY3Rpb24gZyh0LGUscyxvKXtsZXQgcixuO3Q9K3R8fDAsZT0rZTtsZXQgaD1pLmxhbmcsbD0odC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXXx8XCJcIikuc3BsaXQoXCJlXCIpWzBdLmxlbmd0aCxwPXQudG9TdHJpbmcoKS5zcGxpdChcImVcIiksdT1lOy0xPT09ZT9lPU1hdGgubWluKGwsMjApOmEoZSk/ZSYmcFsxXSYmcFsxXTwwJiYoKG49ZSsgK3BbMV0pPj0wPyhwWzBdPSgrcFswXSkudG9FeHBvbmVudGlhbChuKS5zcGxpdChcImVcIilbMF0sZT1uKToocFswXT1wWzBdLnNwbGl0KFwiLlwiKVswXXx8MCx0PWU8MjA/KHBbMF0qTWF0aC5wb3coMTAscFsxXSkpLnRvRml4ZWQoZSk6MCxwWzFdPTApKTplPTI7bGV0IGc9KE1hdGguYWJzKHBbMV0/cFswXTp0KStNYXRoLnBvdygxMCwtTWF0aC5tYXgoZSxsKS0xKSkudG9GaXhlZChlKSxmPVN0cmluZyhjKGcpKSxtPWYubGVuZ3RoPjM/Zi5sZW5ndGglMzowO3JldHVybiBzPWQocyxoLmRlY2ltYWxQb2ludCksbz1kKG8saC50aG91c2FuZHNTZXApLHI9KHQ8MD9cIi1cIjpcIlwiKSsobT9mLnN1YnN0cigwLG0pK286XCJcIiksMD4rcFsxXSYmIXU/cj1cIjBcIjpyKz1mLnN1YnN0cihtKS5yZXBsYWNlKC8oXFxkezN9KSg/PVxcZCkvZyxcIiQxXCIrbyksZSYmKHIrPXMrZy5zbGljZSgtZSkpLHBbMV0mJjAhPStyJiYocis9XCJlXCIrcFsxXSkscn1yZXR1cm57ZGF0ZUZvcm1hdDpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHMuZGF0ZUZvcm1hdCh0LGUsaSl9LGZvcm1hdDp1LGhlbHBlcnM6cCxudW1iZXJGb3JtYXQ6Z319KSxpKGUsXCJDb3JlL1JlbmRlcmVyL1JlbmRlcmVyVXRpbGl0aWVzLmpzXCIsW2VbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCl7dmFyIGU7bGV0e2NsYW1wOmkscGljazpzLHB1c2hVbmlxdWU6byxzdGFibGVTb3J0OnJ9PXQ7cmV0dXJuKGV8fChlPXt9KSkuZGlzdHJpYnV0ZT1mdW5jdGlvbiB0KGUsbixhKXtsZXQgaD1lLGw9aC5yZWR1Y2VkTGVufHxuLGQ9KHQsZSk9PnQudGFyZ2V0LWUudGFyZ2V0LGM9W10scD1lLmxlbmd0aCx1PVtdLGc9Yy5wdXNoLGYsbSx4LHk9ITAsYix2LFM9MCxrO2ZvcihmPXA7Zi0tOylTKz1lW2ZdLnNpemU7aWYoUz5sKXtmb3IocihlLCh0LGUpPT4oZS5yYW5rfHwwKS0odC5yYW5rfHwwKSkseD0oaz1lWzBdLnJhbms9PT1lW2UubGVuZ3RoLTFdLnJhbmspP3AvMjotMSxtPWs/eDpwLTE7eCYmUz5sOyliPWVbZj1NYXRoLmZsb29yKG0pXSxvKHUsZikmJihTLT1iLnNpemUpLG0rPXgsayYmbT49ZS5sZW5ndGgmJih4Lz0yLG09eCk7dS5zb3J0KCh0LGUpPT5lLXQpLmZvckVhY2godD0+Zy5hcHBseShjLGUuc3BsaWNlKHQsMSkpKX1mb3IocihlLGQpLGU9ZS5tYXAodD0+KHtzaXplOnQuc2l6ZSx0YXJnZXRzOlt0LnRhcmdldF0sYWxpZ246cyh0LmFsaWduLC41KX0pKTt5Oyl7Zm9yKGY9ZS5sZW5ndGg7Zi0tOyliPWVbZl0sdj0oTWF0aC5taW4uYXBwbHkoMCxiLnRhcmdldHMpK01hdGgubWF4LmFwcGx5KDAsYi50YXJnZXRzKSkvMixiLnBvcz1pKHYtYi5zaXplKmIuYWxpZ24sMCxuLWIuc2l6ZSk7Zm9yKGY9ZS5sZW5ndGgseT0hMTtmLS07KWY+MCYmZVtmLTFdLnBvcytlW2YtMV0uc2l6ZT5lW2ZdLnBvcyYmKGVbZi0xXS5zaXplKz1lW2ZdLnNpemUsZVtmLTFdLnRhcmdldHM9ZVtmLTFdLnRhcmdldHMuY29uY2F0KGVbZl0udGFyZ2V0cyksZVtmLTFdLmFsaWduPS41LGVbZi0xXS5wb3MrZVtmLTFdLnNpemU+biYmKGVbZi0xXS5wb3M9bi1lW2YtMV0uc2l6ZSksZS5zcGxpY2UoZiwxKSx5PSEwKX1yZXR1cm4gZy5hcHBseShoLGMpLGY9MCxlLnNvbWUoZT0+e2xldCBpPTA7cmV0dXJuKGUudGFyZ2V0c3x8W10pLnNvbWUoKCk9PihoW2ZdLnBvcz1lLnBvcytpLHZvaWQgMCE9PWEmJk1hdGguYWJzKGhbZl0ucG9zLWhbZl0udGFyZ2V0KT5hKT8oaC5zbGljZSgwLGYrMSkuZm9yRWFjaCh0PT5kZWxldGUgdC5wb3MpLGgucmVkdWNlZExlbj0oaC5yZWR1Y2VkTGVufHxuKS0uMSpuLGgucmVkdWNlZExlbj4uMSpuJiZ0KGgsbixhKSwhMCk6KGkrPWhbZl0uc2l6ZSxmKyssITEpKX0pLHIoaCxkKSxofSxlfSksaShlLFwiQ29yZS9SZW5kZXJlci9TVkcvU1ZHRWxlbWVudC5qc1wiLFtlW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSxzKXtsZXR7YW5pbWF0ZTpvLGFuaW1PYmplY3Q6cixzdG9wOm59PXQse2RlZzJyYWQ6YSxkb2M6aCxub29wOmwsc3ZnOmQsU1ZHX05TOmMsd2luOnB9PWkse2FkZEV2ZW50OnUsYXR0cjpnLGNyZWF0ZUVsZW1lbnQ6Zixjc3M6bSxkZWZpbmVkOngsZXJhc2U6eSxleHRlbmQ6YixmaXJlRXZlbnQ6dixpc0FycmF5OlMsaXNGdW5jdGlvbjprLGlzT2JqZWN0Ok0saXNTdHJpbmc6QyxtZXJnZTp3LG9iamVjdEVhY2g6VCxwaWNrOkEscEludDpQLHN5bmNUaW1lb3V0OkwsdW5pcXVlS2V5Ok99PXM7Y2xhc3MgRHtfZGVmYXVsdEdldHRlcih0KXtsZXQgZT1BKHRoaXNbdCtcIlZhbHVlXCJdLHRoaXNbdF0sdGhpcy5lbGVtZW50P3RoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUodCk6bnVsbCwwKTtyZXR1cm4vXltcXC0wLTlcXC5dKyQvLnRlc3QoZSkmJihlPXBhcnNlRmxvYXQoZSkpLGV9X2RlZmF1bHRTZXR0ZXIodCxlLGkpe2kuc2V0QXR0cmlidXRlKGUsdCl9YWRkKHQpe2xldCBlO2xldCBpPXRoaXMucmVuZGVyZXIscz10aGlzLmVsZW1lbnQ7cmV0dXJuIHQmJih0aGlzLnBhcmVudEdyb3VwPXQpLHZvaWQgMCE9PXRoaXMudGV4dFN0ciYmXCJ0ZXh0XCI9PT10aGlzLmVsZW1lbnQubm9kZU5hbWUmJmkuYnVpbGRUZXh0KHRoaXMpLHRoaXMuYWRkZWQ9ITAsKCF0fHx0LmhhbmRsZVp8fHRoaXMuekluZGV4KSYmKGU9dGhpcy56SW5kZXhTZXR0ZXIoKSksZXx8KHQ/dC5lbGVtZW50OmkuYm94KS5hcHBlbmRDaGlsZChzKSx0aGlzLm9uQWRkJiZ0aGlzLm9uQWRkKCksdGhpc31hZGRDbGFzcyh0LGUpe2xldCBpPWU/XCJcIjp0aGlzLmF0dHIoXCJjbGFzc1wiKXx8XCJcIjtyZXR1cm4odD0odHx8XCJcIikuc3BsaXQoLyAvZykucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIC0xPT09aS5pbmRleE9mKGUpJiZ0LnB1c2goZSksdH0saT9baV06W10pLmpvaW4oXCIgXCIpKSE9PWkmJnRoaXMuYXR0cihcImNsYXNzXCIsdCksdGhpc31hZnRlclNldHRlcnMoKXt0aGlzLmRvVHJhbnNmb3JtJiYodGhpcy51cGRhdGVUcmFuc2Zvcm0oKSx0aGlzLmRvVHJhbnNmb3JtPSExKX1hbGlnbih0LGUsaSl7bGV0IHMsbyxyLG4sYTtsZXQgaD17fSxsPXRoaXMucmVuZGVyZXIsZD1sLmFsaWduZWRPYmplY3RzO3Q/KHRoaXMuYWxpZ25PcHRpb25zPXQsdGhpcy5hbGlnbkJ5VHJhbnNsYXRlPWUsKCFpfHxDKGkpKSYmKHRoaXMuYWxpZ25Ubz1yPWl8fFwicmVuZGVyZXJcIix5KGQsdGhpcyksZC5wdXNoKHRoaXMpLGk9dm9pZCAwKSk6KHQ9dGhpcy5hbGlnbk9wdGlvbnMsZT10aGlzLmFsaWduQnlUcmFuc2xhdGUscj10aGlzLmFsaWduVG8pLGk9QShpLGxbcl0sXCJzY3JvbGxhYmxlUGxvdEJveFwiPT09cj9sLnBsb3RCb3g6dm9pZCAwLGwpO2xldCBjPXQuYWxpZ24scD10LnZlcnRpY2FsQWxpZ247cmV0dXJuIHM9KGkueHx8MCkrKHQueHx8MCksbz0oaS55fHwwKSsodC55fHwwKSxcInJpZ2h0XCI9PT1jP249MTpcImNlbnRlclwiPT09YyYmKG49MiksbiYmKHMrPShpLndpZHRoLSh0LndpZHRofHwwKSkvbiksaFtlP1widHJhbnNsYXRlWFwiOlwieFwiXT1NYXRoLnJvdW5kKHMpLFwiYm90dG9tXCI9PT1wP2E9MTpcIm1pZGRsZVwiPT09cCYmKGE9MiksYSYmKG8rPShpLmhlaWdodC0odC5oZWlnaHR8fDApKS9hKSxoW2U/XCJ0cmFuc2xhdGVZXCI6XCJ5XCJdPU1hdGgucm91bmQobyksdGhpc1t0aGlzLnBsYWNlZD9cImFuaW1hdGVcIjpcImF0dHJcIl0oaCksdGhpcy5wbGFjZWQ9ITAsdGhpcy5hbGlnbkF0dHI9aCx0aGlzfWFsaWduU2V0dGVyKHQpe2xldCBlPXtsZWZ0Olwic3RhcnRcIixjZW50ZXI6XCJtaWRkbGVcIixyaWdodDpcImVuZFwifTtlW3RdJiYodGhpcy5hbGlnblZhbHVlPXQsdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsZVt0XSkpfWFuaW1hdGUodCxlLGkpe2xldCBzPXIoQShlLHRoaXMucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCEwKSksbj1zLmRlZmVyO3JldHVybiBoLmhpZGRlbiYmKHMuZHVyYXRpb249MCksMCE9PXMuZHVyYXRpb24/KGkmJihzLmNvbXBsZXRlPWkpLEwoKCk9Pnt0aGlzLmVsZW1lbnQmJm8odGhpcyx0LHMpfSxuKSk6KHRoaXMuYXR0cih0LHZvaWQgMCxpfHxzLmNvbXBsZXRlKSxUKHQsZnVuY3Rpb24odCxlKXtzLnN0ZXAmJnMuc3RlcC5jYWxsKHRoaXMsdCx7cHJvcDplLHBvczoxLGVsZW06dGhpc30pfSx0aGlzKSksdGhpc31hcHBseVRleHRPdXRsaW5lKHQpe2xldCBlPXRoaXMuZWxlbWVudCxzPS0xIT09dC5pbmRleE9mKFwiY29udHJhc3RcIik7cyYmKHQ9dC5yZXBsYWNlKC9jb250cmFzdC9nLHRoaXMucmVuZGVyZXIuZ2V0Q29udHJhc3QoZS5zdHlsZS5maWxsKSkpO2xldCBvPXQuc3BsaXQoXCIgXCIpLHI9b1tvLmxlbmd0aC0xXSxuPW9bMF07aWYobiYmXCJub25lXCIhPT1uJiZpLnN2Zyl7dGhpcy5mYWtlVFM9ITAsbj1uLnJlcGxhY2UoLyheW1xcZFxcLl0rKSguKj8pJC9nLGZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gMipOdW1iZXIoZSkraX0pLHRoaXMucmVtb3ZlVGV4dE91dGxpbmUoKTtsZXQgdD1oLmNyZWF0ZUVsZW1lbnROUyhjLFwidHNwYW5cIik7Zyh0LHtjbGFzczpcImhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIsZmlsbDpyLHN0cm9rZTpyLFwic3Ryb2tlLXdpZHRoXCI6bixcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIn0pO2xldCBpPWUucXVlcnlTZWxlY3RvcihcInRleHRQYXRoXCIpfHxlO1tdLmZvckVhY2guY2FsbChpLmNoaWxkTm9kZXMsZT0+e2xldCBpPWUuY2xvbmVOb2RlKCEwKTtpLnJlbW92ZUF0dHJpYnV0ZSYmW1wiZmlsbFwiLFwic3Ryb2tlXCIsXCJzdHJva2Utd2lkdGhcIixcInN0cm9rZVwiXS5mb3JFYWNoKHQ9PmkucmVtb3ZlQXR0cmlidXRlKHQpKSx0LmFwcGVuZENoaWxkKGkpfSk7bGV0IHM9MDtbXS5mb3JFYWNoLmNhbGwoaS5xdWVyeVNlbGVjdG9yQWxsKFwidGV4dCB0c3BhblwiKSx0PT57cys9TnVtYmVyKHQuZ2V0QXR0cmlidXRlKFwiZHlcIikpfSk7bGV0IG89aC5jcmVhdGVFbGVtZW50TlMoYyxcInRzcGFuXCIpO28udGV4dENvbnRlbnQ9XCLigItcIixnKG8se3g6TnVtYmVyKGUuZ2V0QXR0cmlidXRlKFwieFwiKSksZHk6LXN9KSx0LmFwcGVuZENoaWxkKG8pLGkuaW5zZXJ0QmVmb3JlKHQsaS5maXJzdENoaWxkKX19YXR0cih0LGUsaSxzKXtsZXQgbz10aGlzLmVsZW1lbnQscj1ELnN5bWJvbEN1c3RvbUF0dHJpYnMsYSxoLGw9dGhpcyxkO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0JiZ2b2lkIDAhPT1lJiYoYT10LCh0PXt9KVthXT1lKSxcInN0cmluZ1wiPT10eXBlb2YgdD9sPSh0aGlzW3QrXCJHZXR0ZXJcIl18fHRoaXMuX2RlZmF1bHRHZXR0ZXIpLmNhbGwodGhpcyx0LG8pOihUKHQsZnVuY3Rpb24oZSxpKXtkPSExLHN8fG4odGhpcyxpKSx0aGlzLnN5bWJvbE5hbWUmJi0xIT09ci5pbmRleE9mKGkpJiYoaHx8KHRoaXMuc3ltYm9sQXR0cih0KSxoPSEwKSxkPSEwKSx0aGlzLnJvdGF0aW9uJiYoXCJ4XCI9PT1pfHxcInlcIj09PWkpJiYodGhpcy5kb1RyYW5zZm9ybT0hMCksZHx8KHRoaXNbaStcIlNldHRlclwiXXx8dGhpcy5fZGVmYXVsdFNldHRlcikuY2FsbCh0aGlzLGUsaSxvKX0sdGhpcyksdGhpcy5hZnRlclNldHRlcnMoKSksaSYmaS5jYWxsKHRoaXMpLGx9Y2xpcCh0KXtpZih0JiYhdC5jbGlwUGF0aCl7bGV0IGU9TygpK1wiLVwiLGk9dGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIikuYXR0cih7aWQ6ZX0pLmFkZCh0aGlzLnJlbmRlcmVyLmRlZnMpO2IodCx7Y2xpcFBhdGg6aSxpZDplLGNvdW50OjB9KSx0LmFkZChpKX1yZXR1cm4gdGhpcy5hdHRyKFwiY2xpcC1wYXRoXCIsdD9gdXJsKCR7dGhpcy5yZW5kZXJlci51cmx9IyR7dC5pZH0pYDpcIm5vbmVcIil9Y3Jpc3AodCxlKXtlPWV8fHQuc3Ryb2tlV2lkdGh8fDA7bGV0IGk9TWF0aC5yb3VuZChlKSUyLzI7cmV0dXJuIHQueD1NYXRoLmZsb29yKHQueHx8dGhpcy54fHwwKStpLHQueT1NYXRoLmZsb29yKHQueXx8dGhpcy55fHwwKStpLHQud2lkdGg9TWF0aC5mbG9vcigodC53aWR0aHx8dGhpcy53aWR0aHx8MCktMippKSx0LmhlaWdodD1NYXRoLmZsb29yKCh0LmhlaWdodHx8dGhpcy5oZWlnaHR8fDApLTIqaSkseCh0LnN0cm9rZVdpZHRoKSYmKHQuc3Ryb2tlV2lkdGg9ZSksdH1jb21wbGV4Q29sb3IodCxpLHMpe2xldCBvPXRoaXMucmVuZGVyZXIscixuLGEsaCxsLGQsYyxwLHUsZyxmPVtdLG07dih0aGlzLnJlbmRlcmVyLFwiY29tcGxleENvbG9yXCIse2FyZ3M6YXJndW1lbnRzfSxmdW5jdGlvbigpe2lmKHQucmFkaWFsR3JhZGllbnQ/bj1cInJhZGlhbEdyYWRpZW50XCI6dC5saW5lYXJHcmFkaWVudCYmKG49XCJsaW5lYXJHcmFkaWVudFwiKSxuKXtpZihhPXRbbl0sbD1vLmdyYWRpZW50cyxkPXQuc3RvcHMsdT1zLnJhZGlhbFJlZmVyZW5jZSxTKGEpJiYodFtuXT1hPXt4MTphWzBdLHkxOmFbMV0seDI6YVsyXSx5MjphWzNdLGdyYWRpZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwifSksXCJyYWRpYWxHcmFkaWVudFwiPT09biYmdSYmIXgoYS5ncmFkaWVudFVuaXRzKSYmKGg9YSxhPXcoYSxvLmdldFJhZGlhbEF0dHIodSxoKSx7Z3JhZGllbnRVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9KSksVChhLGZ1bmN0aW9uKHQsZSl7XCJpZFwiIT09ZSYmZi5wdXNoKGUsdCl9KSxUKGQsZnVuY3Rpb24odCl7Zi5wdXNoKHQpfSksbFtmPWYuam9pbihcIixcIildKWc9bFtmXS5hdHRyKFwiaWRcIik7ZWxzZXthLmlkPWc9TygpO2xldCB0PWxbZl09by5jcmVhdGVFbGVtZW50KG4pLmF0dHIoYSkuYWRkKG8uZGVmcyk7dC5yYWRBdHRyPWgsdC5zdG9wcz1bXSxkLmZvckVhY2goZnVuY3Rpb24oaSl7MD09PWlbMV0uaW5kZXhPZihcInJnYmFcIik/KGM9KHI9ZS5wYXJzZShpWzFdKSkuZ2V0KFwicmdiXCIpLHA9ci5nZXQoXCJhXCIpKTooYz1pWzFdLHA9MSk7bGV0IHM9by5jcmVhdGVFbGVtZW50KFwic3RvcFwiKS5hdHRyKHtvZmZzZXQ6aVswXSxcInN0b3AtY29sb3JcIjpjLFwic3RvcC1vcGFjaXR5XCI6cH0pLmFkZCh0KTt0LnN0b3BzLnB1c2gocyl9KX1tPVwidXJsKFwiK28udXJsK1wiI1wiK2crXCIpXCIscy5zZXRBdHRyaWJ1dGUoaSxtKSxzLmdyYWRpZW50PWYsdC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBtfX19KX1jc3ModCl7bGV0IGU9dGhpcy5zdHlsZXMsaT17fSxzPXRoaXMuZWxlbWVudCxvLHI9IWU7aWYoZSYmVCh0LGZ1bmN0aW9uKHQscyl7ZSYmZVtzXSE9PXQmJihpW3NdPXQscj0hMCl9KSxyKXtlJiYodD1iKGUsaSkpLG51bGw9PT10LndpZHRofHxcImF1dG9cIj09PXQud2lkdGg/ZGVsZXRlIHRoaXMudGV4dFdpZHRoOlwidGV4dFwiPT09cy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiZ0LndpZHRoJiYobz10aGlzLnRleHRXaWR0aD1QKHQud2lkdGgpKSx0aGlzLnN0eWxlcz10LG8mJiFkJiZ0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCYmZGVsZXRlIHQud2lkdGg7bGV0IHI9dyh0KTtzLm5hbWVzcGFjZVVSST09PXRoaXMuU1ZHX05TJiYoW1widGV4dE91dGxpbmVcIixcInRleHRPdmVyZmxvd1wiLFwid2lkdGhcIl0uZm9yRWFjaCh0PT5yJiZkZWxldGUgclt0XSksci5jb2xvciYmKHIuZmlsbD1yLmNvbG9yKSksbShzLHIpfXJldHVybiB0aGlzLmFkZGVkJiYoXCJ0ZXh0XCI9PT10aGlzLmVsZW1lbnQubm9kZU5hbWUmJnRoaXMucmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpLHQudGV4dE91dGxpbmUmJnRoaXMuYXBwbHlUZXh0T3V0bGluZSh0LnRleHRPdXRsaW5lKSksdGhpc31kYXNoc3R5bGVTZXR0ZXIodCl7bGV0IGUsaT10aGlzW1wic3Ryb2tlLXdpZHRoXCJdO2lmKFwiaW5oZXJpdFwiPT09aSYmKGk9MSksdD10JiZ0LnRvTG93ZXJDYXNlKCkpe2xldCBzPXQucmVwbGFjZShcInNob3J0ZGFzaGRvdGRvdFwiLFwiMywxLDEsMSwxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hkb3RcIixcIjMsMSwxLDFcIikucmVwbGFjZShcInNob3J0ZG90XCIsXCIxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hcIixcIjMsMSxcIikucmVwbGFjZShcImxvbmdkYXNoXCIsXCI4LDMsXCIpLnJlcGxhY2UoL2RvdC9nLFwiMSwzLFwiKS5yZXBsYWNlKFwiZGFzaFwiLFwiNCwzLFwiKS5yZXBsYWNlKC8sJC8sXCJcIikuc3BsaXQoXCIsXCIpO2ZvcihlPXMubGVuZ3RoO2UtLTspc1tlXT1cIlwiK1Aoc1tlXSkqQShpLE5hTik7dD1zLmpvaW4oXCIsXCIpLnJlcGxhY2UoL05hTi9nLFwibm9uZVwiKSx0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLHQpfX1kZXN0cm95KCl7bGV0IHQ9dGhpcyxlPXQuZWxlbWVudHx8e30saT10LnJlbmRlcmVyLHM9ZS5vd25lclNWR0VsZW1lbnQsbz1cIlNQQU5cIj09PWUubm9kZU5hbWUmJnQucGFyZW50R3JvdXB8fHZvaWQgMCxyLGE7aWYoZS5vbmNsaWNrPWUub25tb3VzZW91dD1lLm9ubW91c2VvdmVyPWUub25tb3VzZW1vdmU9ZS5wb2ludD1udWxsLG4odCksdC5jbGlwUGF0aCYmcyl7bGV0IGU9dC5jbGlwUGF0aDtbXS5mb3JFYWNoLmNhbGwocy5xdWVyeVNlbGVjdG9yQWxsKFwiW2NsaXAtcGF0aF0sW0NMSVAtUEFUSF1cIiksZnVuY3Rpb24odCl7dC5nZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIikuaW5kZXhPZihlLmVsZW1lbnQuaWQpPi0xJiZ0LnJlbW92ZUF0dHJpYnV0ZShcImNsaXAtcGF0aFwiKX0pLHQuY2xpcFBhdGg9ZS5kZXN0cm95KCl9aWYodC5jb25uZWN0b3I9dC5jb25uZWN0b3I/LmRlc3Ryb3koKSx0LnN0b3BzKXtmb3IoYT0wO2E8dC5zdG9wcy5sZW5ndGg7YSsrKXQuc3RvcHNbYV0uZGVzdHJveSgpO3Quc3RvcHMubGVuZ3RoPTAsdC5zdG9wcz12b2lkIDB9Zm9yKHQuc2FmZVJlbW92ZUNoaWxkKGUpO28mJm8uZGl2JiYwPT09by5kaXYuY2hpbGROb2Rlcy5sZW5ndGg7KXI9by5wYXJlbnRHcm91cCx0LnNhZmVSZW1vdmVDaGlsZChvLmRpdiksZGVsZXRlIG8uZGl2LG89cjt0LmFsaWduVG8mJnkoaS5hbGlnbmVkT2JqZWN0cyx0KSxUKHQsZnVuY3Rpb24oZSxpKXt0W2ldJiZ0W2ldLnBhcmVudEdyb3VwPT09dCYmdFtpXS5kZXN0cm95JiZ0W2ldLmRlc3Ryb3koKSxkZWxldGUgdFtpXX0pfWRTZXR0ZXIodCxlLGkpe1ModCkmJihcInN0cmluZ1wiPT10eXBlb2YgdFswXSYmKHQ9dGhpcy5yZW5kZXJlci5wYXRoVG9TZWdtZW50cyh0KSksdGhpcy5wYXRoQXJyYXk9dCx0PXQucmVkdWNlKCh0LGUsaSk9PmUmJmUuam9pbj8oaT90K1wiIFwiOlwiXCIpK2Uuam9pbihcIiBcIik6KGV8fFwiXCIpLnRvU3RyaW5nKCksXCJcIikpLC8oTmFOfCB7Mn18XiQpLy50ZXN0KHQpJiYodD1cIk0gMCAwXCIpLHRoaXNbZV0hPT10JiYoaS5zZXRBdHRyaWJ1dGUoZSx0KSx0aGlzW2VdPXQpfWZpbGxTZXR0ZXIodCxlLGkpe1wic3RyaW5nXCI9PXR5cGVvZiB0P2kuc2V0QXR0cmlidXRlKGUsdCk6dCYmdGhpcy5jb21wbGV4Q29sb3IodCxlLGkpfWhyZWZTZXR0ZXIodCxlLGkpe2kuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsZSx0KX1nZXRCQm94KHQsZSl7bGV0IGkscyxvLHIsbjtsZXR7YWxpZ25WYWx1ZTpoLGVsZW1lbnQ6bCxyZW5kZXJlcjpkLHN0eWxlczpjLHRleHRTdHI6cH09dGhpcyx7Y2FjaGU6dSxjYWNoZUtleXM6Z309ZCxmPWwubmFtZXNwYWNlVVJJPT09dGhpcy5TVkdfTlMseT1BKGUsdGhpcy5yb3RhdGlvbiwwKSx2PWQuc3R5bGVkTW9kZT9sJiZELnByb3RvdHlwZS5nZXRTdHlsZS5jYWxsKGwsXCJmb250LXNpemVcIik6YyYmYy5mb250U2l6ZTtpZih4KHApJiYoLTE9PT0obj1wLnRvU3RyaW5nKCkpLmluZGV4T2YoXCI8XCIpJiYobj1uLnJlcGxhY2UoL1swLTldL2csXCIwXCIpKSxuKz1bXCJcIixkLnJvb3RGb250U2l6ZSx2LHksdGhpcy50ZXh0V2lkdGgsaCxjJiZjLnRleHRPdmVyZmxvdyxjJiZjLmZvbnRXZWlnaHRdLmpvaW4oXCIsXCIpKSxuJiYhdCYmKGk9dVtuXSksIWkpe2lmKGZ8fGQuZm9yRXhwb3J0KXt0cnl7cj10aGlzLmZha2VUUyYmZnVuY3Rpb24odCl7bGV0IGU9bC5xdWVyeVNlbGVjdG9yKFwiLmhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIpO2UmJm0oZSx7ZGlzcGxheTp0fSl9LGsocikmJnIoXCJub25lXCIpLGk9bC5nZXRCQm94P2Ioe30sbC5nZXRCQm94KCkpOnt3aWR0aDpsLm9mZnNldFdpZHRoLGhlaWdodDpsLm9mZnNldEhlaWdodCx4OjAseTowfSxrKHIpJiZyKFwiXCIpfWNhdGNoKHQpe30oIWl8fGkud2lkdGg8MCkmJihpPXt4OjAseTowLHdpZHRoOjAsaGVpZ2h0OjB9KX1lbHNlIGk9dGhpcy5odG1sR2V0QkJveCgpO2lmKHM9aS53aWR0aCxvPWkuaGVpZ2h0LGYmJihpLmhlaWdodD1vPSh7XCIxMXB4LDE3XCI6MTQsXCIxM3B4LDIwXCI6MTZ9KVtgJHt2fHxcIlwifSwke01hdGgucm91bmQobyl9YF18fG8pLHkpe2xldCB0PU51bWJlcihsLmdldEF0dHJpYnV0ZShcInlcIil8fDApLWkueSxlPXtyaWdodDoxLGNlbnRlcjouNX1baHx8MF18fDAscj15KmEsbj0oeS05MCkqYSxkPXMqTWF0aC5jb3MociksYz1zKk1hdGguc2luKHIpLHA9TWF0aC5jb3MobiksdT1NYXRoLnNpbihuKSxnPWkueCtlKihzLWQpLGY9aS55K3QtZSpjLG09Zyt0KnAseD1tK2QsYj14LW8qcCx2PWItZCxTPWYrdCp1LGs9UytjLE09ay1vKnUsQz1NLWM7aS54PU1hdGgubWluKG0seCxiLHYpLGkueT1NYXRoLm1pbihTLGssTSxDKSxpLndpZHRoPU1hdGgubWF4KG0seCxiLHYpLWkueCxpLmhlaWdodD1NYXRoLm1heChTLGssTSxDKS1pLnl9fWlmKG4mJihcIlwiPT09cHx8aS5oZWlnaHQ+MCkpe2Zvcig7Zy5sZW5ndGg+MjUwOylkZWxldGUgdVtnLnNoaWZ0KCldO3Vbbl18fGcucHVzaChuKSx1W25dPWl9cmV0dXJuIGl9Z2V0U3R5bGUodCl7cmV0dXJuIHAuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnR8fHRoaXMsXCJcIikuZ2V0UHJvcGVydHlWYWx1ZSh0KX1oYXNDbGFzcyh0KXtyZXR1cm4gLTEhPT0oXCJcIit0aGlzLmF0dHIoXCJjbGFzc1wiKSkuc3BsaXQoXCIgXCIpLmluZGV4T2YodCl9aGlkZSgpe3JldHVybiB0aGlzLmF0dHIoe3Zpc2liaWxpdHk6XCJoaWRkZW5cIn0pfWh0bWxHZXRCQm94KCl7cmV0dXJue2hlaWdodDowLHdpZHRoOjAseDowLHk6MH19Y29uc3RydWN0b3IodCxlKXt0aGlzLm9uRXZlbnRzPXt9LHRoaXMub3BhY2l0eT0xLHRoaXMuU1ZHX05TPWMsdGhpcy5lbGVtZW50PVwic3BhblwiPT09ZT9mKGUpOmguY3JlYXRlRWxlbWVudE5TKHRoaXMuU1ZHX05TLGUpLHRoaXMucmVuZGVyZXI9dCx2KHRoaXMsXCJhZnRlckluaXRcIil9b24odCxlKXtsZXR7b25FdmVudHM6aX09dGhpcztyZXR1cm4gaVt0XSYmaVt0XSgpLGlbdF09dSh0aGlzLmVsZW1lbnQsdCxlKSx0aGlzfW9wYWNpdHlTZXR0ZXIodCxlLGkpe2xldCBzPU51bWJlcihOdW1iZXIodCkudG9GaXhlZCgzKSk7dGhpcy5vcGFjaXR5PXMsaS5zZXRBdHRyaWJ1dGUoZSxzKX1yZW1vdmVDbGFzcyh0KXtyZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwoXCJcIit0aGlzLmF0dHIoXCJjbGFzc1wiKSkucmVwbGFjZShDKHQpP1JlZ0V4cChgKF58ICkke3R9KCB8JClgKTp0LFwiIFwiKS5yZXBsYWNlKC8gKy9nLFwiIFwiKS50cmltKCkpfXJlbW92ZVRleHRPdXRsaW5lKCl7bGV0IHQ9dGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0c3Bhbi5oaWdoY2hhcnRzLXRleHQtb3V0bGluZVwiKTt0JiZ0aGlzLnNhZmVSZW1vdmVDaGlsZCh0KX1zYWZlUmVtb3ZlQ2hpbGQodCl7bGV0IGU9dC5wYXJlbnROb2RlO2UmJmUucmVtb3ZlQ2hpbGQodCl9c2V0UmFkaWFsUmVmZXJlbmNlKHQpe2xldCBlPXRoaXMuZWxlbWVudC5ncmFkaWVudCYmdGhpcy5yZW5kZXJlci5ncmFkaWVudHNbdGhpcy5lbGVtZW50LmdyYWRpZW50XTtyZXR1cm4gdGhpcy5lbGVtZW50LnJhZGlhbFJlZmVyZW5jZT10LGUmJmUucmFkQXR0ciYmZS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0UmFkaWFsQXR0cih0LGUucmFkQXR0cikpLHRoaXN9c2V0VGV4dFBhdGgodCxlKXtlPXcoITAse2VuYWJsZWQ6ITAsYXR0cmlidXRlczp7ZHk6LTUsc3RhcnRPZmZzZXQ6XCI1MCVcIix0ZXh0QW5jaG9yOlwibWlkZGxlXCJ9fSxlKTtsZXQgaT10aGlzLnJlbmRlcmVyLnVybCxzPXRoaXMudGV4dHx8dGhpcyxvPXMudGV4dFBhdGgse2F0dHJpYnV0ZXM6cixlbmFibGVkOm59PWU7aWYodD10fHxvJiZvLnBhdGgsbyYmby51bmRvKCksdCYmbil7bGV0IGU9dShzLFwiYWZ0ZXJNb2RpZnlUcmVlXCIsZT0+e2lmKHQmJm4pe2xldCBvPXQuYXR0cihcImlkXCIpO298fHQuYXR0cihcImlkXCIsbz1PKCkpO2xldCBuPXt4OjAseTowfTt4KHIuZHgpJiYobi5keD1yLmR4LGRlbGV0ZSByLmR4KSx4KHIuZHkpJiYobi5keT1yLmR5LGRlbGV0ZSByLmR5KSxzLmF0dHIobiksdGhpcy5hdHRyKHt0cmFuc2Zvcm06XCJcIn0pLHRoaXMuYm94JiYodGhpcy5ib3g9dGhpcy5ib3guZGVzdHJveSgpKTtsZXQgYT1lLm5vZGVzLnNsaWNlKDApO2Uubm9kZXMubGVuZ3RoPTAsZS5ub2Rlc1swXT17dGFnTmFtZTpcInRleHRQYXRoXCIsYXR0cmlidXRlczpiKHIse1widGV4dC1hbmNob3JcIjpyLnRleHRBbmNob3IsaHJlZjpgJHtpfSMke299YH0pLGNoaWxkcmVuOmF9fX0pO3MudGV4dFBhdGg9e3BhdGg6dCx1bmRvOmV9fWVsc2Ugcy5hdHRyKHtkeDowLGR5OjB9KSxkZWxldGUgcy50ZXh0UGF0aDtyZXR1cm4gdGhpcy5hZGRlZCYmKHMudGV4dENhY2hlPVwiXCIsdGhpcy5yZW5kZXJlci5idWlsZFRleHQocykpLHRoaXN9c2hhZG93KHQpe2xldHtyZW5kZXJlcjplfT10aGlzLGk9dyh0aGlzLnBhcmVudEdyb3VwPy5yb3RhdGlvbj09PTkwP3tvZmZzZXRYOi0xLG9mZnNldFk6LTF9Ont9LE0odCk/dDp7fSkscz1lLnNoYWRvd0RlZmluaXRpb24oaSk7cmV0dXJuIHRoaXMuYXR0cih7ZmlsdGVyOnQ/YHVybCgke2UudXJsfSMke3N9KWA6XCJub25lXCJ9KX1zaG93KHQ9ITApe3JldHVybiB0aGlzLmF0dHIoe3Zpc2liaWxpdHk6dD9cImluaGVyaXRcIjpcInZpc2libGVcIn0pfVwic3Ryb2tlLXdpZHRoU2V0dGVyXCIodCxlLGkpe3RoaXNbZV09dCxpLnNldEF0dHJpYnV0ZShlLHQpfXN0cm9rZVdpZHRoKCl7aWYoIXRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZSlyZXR1cm4gdGhpc1tcInN0cm9rZS13aWR0aFwiXXx8MDtsZXQgdD10aGlzLmdldFN0eWxlKFwic3Ryb2tlLXdpZHRoXCIpLGU9MCxpO3JldHVybiB0LmluZGV4T2YoXCJweFwiKT09PXQubGVuZ3RoLTI/ZT1QKHQpOlwiXCIhPT10JiYoZyhpPWguY3JlYXRlRWxlbWVudE5TKGMsXCJyZWN0XCIpLHt3aWR0aDp0LFwic3Ryb2tlLXdpZHRoXCI6MH0pLHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGkpLGU9aS5nZXRCQm94KCkud2lkdGgsaS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGkpKSxlfXN5bWJvbEF0dHIodCl7bGV0IGU9dGhpcztELnN5bWJvbEN1c3RvbUF0dHJpYnMuZm9yRWFjaChmdW5jdGlvbihpKXtlW2ldPUEodFtpXSxlW2ldKX0pLGUuYXR0cih7ZDplLnJlbmRlcmVyLnN5bWJvbHNbZS5zeW1ib2xOYW1lXShlLngsZS55LGUud2lkdGgsZS5oZWlnaHQsZSl9KX10ZXh0U2V0dGVyKHQpe3QhPT10aGlzLnRleHRTdHImJihkZWxldGUgdGhpcy50ZXh0UHhMZW5ndGgsdGhpcy50ZXh0U3RyPXQsdGhpcy5hZGRlZCYmdGhpcy5yZW5kZXJlci5idWlsZFRleHQodGhpcykpfXRpdGxlU2V0dGVyKHQpe2xldCBlPXRoaXMuZWxlbWVudCxpPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aXRsZVwiKVswXXx8aC5jcmVhdGVFbGVtZW50TlModGhpcy5TVkdfTlMsXCJ0aXRsZVwiKTtlLmluc2VydEJlZm9yZT9lLmluc2VydEJlZm9yZShpLGUuZmlyc3RDaGlsZCk6ZS5hcHBlbmRDaGlsZChpKSxpLnRleHRDb250ZW50PVN0cmluZyhBKHQsXCJcIikpLnJlcGxhY2UoLzxbXj5dKj4vZyxcIlwiKS5yZXBsYWNlKC8mbHQ7L2csXCI8XCIpLnJlcGxhY2UoLyZndDsvZyxcIj5cIil9dG9Gcm9udCgpe2xldCB0PXRoaXMuZWxlbWVudDtyZXR1cm4gdC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpLHRoaXN9dHJhbnNsYXRlKHQsZSl7cmV0dXJuIHRoaXMuYXR0cih7dHJhbnNsYXRlWDp0LHRyYW5zbGF0ZVk6ZX0pfXVwZGF0ZVRyYW5zZm9ybSh0PVwidHJhbnNmb3JtXCIpe2xldHtlbGVtZW50OmUsbWF0cml4Omkscm90YXRpb246cz0wLHNjYWxlWDpvLHNjYWxlWTpyLHRyYW5zbGF0ZVg6bj0wLHRyYW5zbGF0ZVk6YT0wfT10aGlzLGg9W1widHJhbnNsYXRlKFwiK24rXCIsXCIrYStcIilcIl07eChpKSYmaC5wdXNoKFwibWF0cml4KFwiK2kuam9pbihcIixcIikrXCIpXCIpLHMmJmgucHVzaChcInJvdGF0ZShcIitzK1wiIFwiK0EodGhpcy5yb3RhdGlvbk9yaWdpblgsZS5nZXRBdHRyaWJ1dGUoXCJ4XCIpLDApK1wiIFwiK0EodGhpcy5yb3RhdGlvbk9yaWdpblksZS5nZXRBdHRyaWJ1dGUoXCJ5XCIpfHwwKStcIilcIiksKHgobyl8fHgocikpJiZoLnB1c2goXCJzY2FsZShcIitBKG8sMSkrXCIgXCIrQShyLDEpK1wiKVwiKSxoLmxlbmd0aCYmISh0aGlzLnRleHR8fHRoaXMpLnRleHRQYXRoJiZlLnNldEF0dHJpYnV0ZSh0LGguam9pbihcIiBcIikpfXZpc2liaWxpdHlTZXR0ZXIodCxlLGkpe1wiaW5oZXJpdFwiPT09dD9pLnJlbW92ZUF0dHJpYnV0ZShlKTp0aGlzW2VdIT09dCYmaS5zZXRBdHRyaWJ1dGUoZSx0KSx0aGlzW2VdPXR9eEdldHRlcih0KXtyZXR1cm5cImNpcmNsZVwiPT09dGhpcy5lbGVtZW50Lm5vZGVOYW1lJiYoXCJ4XCI9PT10P3Q9XCJjeFwiOlwieVwiPT09dCYmKHQ9XCJjeVwiKSksdGhpcy5fZGVmYXVsdEdldHRlcih0KX16SW5kZXhTZXR0ZXIodCxlKXtsZXQgaT10aGlzLnJlbmRlcmVyLHM9dGhpcy5wYXJlbnRHcm91cCxvPXN8fGkscj1vLmVsZW1lbnR8fGkuYm94LG49dGhpcy5lbGVtZW50LGE9cj09PWkuYm94LGgsbCxkLGM9ITEscCx1PXRoaXMuYWRkZWQsZztpZih4KHQpPyhuLnNldEF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiLHQpLHQ9K3QsdGhpc1tlXT09PXQmJih1PSExKSk6eCh0aGlzW2VdKSYmbi5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXotaW5kZXhcIiksdGhpc1tlXT10LHUpe2ZvcigodD10aGlzLnpJbmRleCkmJnMmJihzLmhhbmRsZVo9ITApLGc9KGg9ci5jaGlsZE5vZGVzKS5sZW5ndGgtMTtnPj0wJiYhYztnLS0pcD0heChkPShsPWhbZ10pLmdldEF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiKSksbCE9PW4mJih0PDAmJnAmJiFhJiYhZz8oci5pbnNlcnRCZWZvcmUobixoW2ddKSxjPSEwKTooUChkKTw9dHx8cCYmKCF4KHQpfHx0Pj0wKSkmJihyLmluc2VydEJlZm9yZShuLGhbZysxXSksYz0hMCkpO2N8fChyLmluc2VydEJlZm9yZShuLGhbYT8zOjBdKSxjPSEwKX1yZXR1cm4gY319cmV0dXJuIEQuc3ltYm9sQ3VzdG9tQXR0cmlicz1bXCJhbmNob3JYXCIsXCJhbmNob3JZXCIsXCJjbG9ja3dpc2VcIixcImVuZFwiLFwiaGVpZ2h0XCIsXCJpbm5lclJcIixcInJcIixcInN0YXJ0XCIsXCJ3aWR0aFwiLFwieFwiLFwieVwiXSxELnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9RC5wcm90b3R5cGUuZmlsbFNldHRlcixELnByb3RvdHlwZS55R2V0dGVyPUQucHJvdG90eXBlLnhHZXR0ZXIsRC5wcm90b3R5cGUubWF0cml4U2V0dGVyPUQucHJvdG90eXBlLnJvdGF0aW9uT3JpZ2luWFNldHRlcj1ELnByb3RvdHlwZS5yb3RhdGlvbk9yaWdpbllTZXR0ZXI9RC5wcm90b3R5cGUucm90YXRpb25TZXR0ZXI9RC5wcm90b3R5cGUuc2NhbGVYU2V0dGVyPUQucHJvdG90eXBlLnNjYWxlWVNldHRlcj1ELnByb3RvdHlwZS50cmFuc2xhdGVYU2V0dGVyPUQucHJvdG90eXBlLnRyYW5zbGF0ZVlTZXR0ZXI9RC5wcm90b3R5cGUudmVydGljYWxBbGlnblNldHRlcj1mdW5jdGlvbih0LGUpe3RoaXNbZV09dCx0aGlzLmRvVHJhbnNmb3JtPSEwfSxEfSksaShlLFwiQ29yZS9SZW5kZXJlci9SZW5kZXJlclJlZ2lzdHJ5LmpzXCIsW2VbXCJDb3JlL0dsb2JhbHMuanNcIl1dLGZ1bmN0aW9uKHQpe3ZhciBlLGk7bGV0IHM7cmV0dXJuKGk9ZXx8KGU9e30pKS5yZW5kZXJlclR5cGVzPXt9LGkuZ2V0UmVuZGVyZXJUeXBlPWZ1bmN0aW9uKHQ9cyl7cmV0dXJuIGkucmVuZGVyZXJUeXBlc1t0XXx8aS5yZW5kZXJlclR5cGVzW3NdfSxpLnJlZ2lzdGVyUmVuZGVyZXJUeXBlPWZ1bmN0aW9uKGUsbyxyKXtpLnJlbmRlcmVyVHlwZXNbZV09bywoIXN8fHIpJiYocz1lLHQuUmVuZGVyZXI9byl9LGV9KSxpKGUsXCJDb3JlL1JlbmRlcmVyL1NWRy9TVkdMYWJlbC5qc1wiLFtlW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHRWxlbWVudC5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSl7bGV0e2RlZmluZWQ6aSxleHRlbmQ6cyxpc051bWJlcjpvLG1lcmdlOnIscGljazpuLHJlbW92ZUV2ZW50OmF9PWU7Y2xhc3MgaCBleHRlbmRzIHR7Y29uc3RydWN0b3IodCxlLGkscyxvLHIsbixhLGwsZCl7bGV0IGM7c3VwZXIodCxcImdcIiksdGhpcy5wYWRkaW5nTGVmdFNldHRlcj10aGlzLnBhZGRpbmdTZXR0ZXIsdGhpcy5wYWRkaW5nUmlnaHRTZXR0ZXI9dGhpcy5wYWRkaW5nU2V0dGVyLHRoaXMudGV4dFN0cj1lLHRoaXMueD1pLHRoaXMueT1zLHRoaXMuYW5jaG9yWD1yLHRoaXMuYW5jaG9yWT1uLHRoaXMuYmFzZWxpbmU9bCx0aGlzLmNsYXNzTmFtZT1kLHRoaXMuYWRkQ2xhc3MoXCJidXR0b25cIj09PWQ/XCJoaWdoY2hhcnRzLW5vLXRvb2x0aXBcIjpcImhpZ2hjaGFydHMtbGFiZWxcIiksZCYmdGhpcy5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrZCksdGhpcy50ZXh0PXQudGV4dCh2b2lkIDAsMCwwLGEpLmF0dHIoe3pJbmRleDoxfSksXCJzdHJpbmdcIj09dHlwZW9mIG8mJigoYz0vXnVybFxcKCguKj8pXFwpJC8udGVzdChvKSl8fHRoaXMucmVuZGVyZXIuc3ltYm9sc1tvXSkmJih0aGlzLnN5bWJvbEtleT1vKSx0aGlzLmJCb3g9aC5lbXB0eUJCb3gsdGhpcy5wYWRkaW5nPTMsdGhpcy5iYXNlbGluZU9mZnNldD0wLHRoaXMubmVlZHNCb3g9dC5zdHlsZWRNb2RlfHxjLHRoaXMuZGVmZXJyZWRBdHRyPXt9LHRoaXMuYWxpZ25GYWN0b3I9MH1hbGlnblNldHRlcih0KXtsZXQgZT17bGVmdDowLGNlbnRlcjouNSxyaWdodDoxfVt0XTtlIT09dGhpcy5hbGlnbkZhY3RvciYmKHRoaXMuYWxpZ25GYWN0b3I9ZSx0aGlzLmJCb3gmJm8odGhpcy54U2V0dGluZykmJnRoaXMuYXR0cih7eDp0aGlzLnhTZXR0aW5nfSkpfWFuY2hvclhTZXR0ZXIodCxlKXt0aGlzLmFuY2hvclg9dCx0aGlzLmJveEF0dHIoZSxNYXRoLnJvdW5kKHQpLXRoaXMuZ2V0Q3Jpc3BBZGp1c3QoKS10aGlzLnhTZXR0aW5nKX1hbmNob3JZU2V0dGVyKHQsZSl7dGhpcy5hbmNob3JZPXQsdGhpcy5ib3hBdHRyKGUsdC10aGlzLnlTZXR0aW5nKX1ib3hBdHRyKHQsZSl7dGhpcy5ib3g/dGhpcy5ib3guYXR0cih0LGUpOnRoaXMuZGVmZXJyZWRBdHRyW3RdPWV9Y3NzKGUpe2lmKGUpe2xldCB0PXt9O2U9cihlKSxoLnRleHRQcm9wcy5mb3JFYWNoKGk9Pnt2b2lkIDAhPT1lW2ldJiYodFtpXT1lW2ldLGRlbGV0ZSBlW2ldKX0pLHRoaXMudGV4dC5jc3ModCksXCJmb250U2l6ZVwiaW4gdHx8XCJmb250V2VpZ2h0XCJpbiB0P3RoaXMudXBkYXRlVGV4dFBhZGRpbmcoKTooXCJ3aWR0aFwiaW4gdHx8XCJ0ZXh0T3ZlcmZsb3dcImluIHQpJiZ0aGlzLnVwZGF0ZUJveFNpemUoKX1yZXR1cm4gdC5wcm90b3R5cGUuY3NzLmNhbGwodGhpcyxlKX1kZXN0cm95KCl7YSh0aGlzLmVsZW1lbnQsXCJtb3VzZWVudGVyXCIpLGEodGhpcy5lbGVtZW50LFwibW91c2VsZWF2ZVwiKSx0aGlzLnRleHQmJnRoaXMudGV4dC5kZXN0cm95KCksdGhpcy5ib3gmJih0aGlzLmJveD10aGlzLmJveC5kZXN0cm95KCkpLHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKX1maWxsU2V0dGVyKHQsZSl7dCYmKHRoaXMubmVlZHNCb3g9ITApLHRoaXMuZmlsbD10LHRoaXMuYm94QXR0cihlLHQpfWdldEJCb3goKXt0aGlzLnRleHRTdHImJjA9PT10aGlzLmJCb3gud2lkdGgmJjA9PT10aGlzLmJCb3guaGVpZ2h0JiZ0aGlzLnVwZGF0ZUJveFNpemUoKTtsZXQgdD10aGlzLnBhZGRpbmcsZT1uKHRoaXMucGFkZGluZ0xlZnQsdCk7cmV0dXJue3dpZHRoOnRoaXMud2lkdGh8fDAsaGVpZ2h0OnRoaXMuaGVpZ2h0fHwwLHg6dGhpcy5iQm94LngtZSx5OnRoaXMuYkJveC55LXR9fWdldENyaXNwQWRqdXN0KCl7cmV0dXJuIHRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZSYmdGhpcy5ib3g/dGhpcy5ib3guc3Ryb2tlV2lkdGgoKSUyLzI6KHRoaXNbXCJzdHJva2Utd2lkdGhcIl0/cGFyc2VJbnQodGhpc1tcInN0cm9rZS13aWR0aFwiXSwxMCk6MCklMi8yfWhlaWdodFNldHRlcih0KXt0aGlzLmhlaWdodFNldHRpbmc9dH1vbkFkZCgpe3RoaXMudGV4dC5hZGQodGhpcyksdGhpcy5hdHRyKHt0ZXh0Om4odGhpcy50ZXh0U3RyLFwiXCIpLHg6dGhpcy54fHwwLHk6dGhpcy55fHwwfSksdGhpcy5ib3gmJmkodGhpcy5hbmNob3JYKSYmdGhpcy5hdHRyKHthbmNob3JYOnRoaXMuYW5jaG9yWCxhbmNob3JZOnRoaXMuYW5jaG9yWX0pfXBhZGRpbmdTZXR0ZXIodCxlKXtvKHQpP3QhPT10aGlzW2VdJiYodGhpc1tlXT10LHRoaXMudXBkYXRlVGV4dFBhZGRpbmcoKSk6dGhpc1tlXT12b2lkIDB9clNldHRlcih0LGUpe3RoaXMuYm94QXR0cihlLHQpfXN0cm9rZVNldHRlcih0LGUpe3RoaXMuc3Ryb2tlPXQsdGhpcy5ib3hBdHRyKGUsdCl9XCJzdHJva2Utd2lkdGhTZXR0ZXJcIih0LGUpe3QmJih0aGlzLm5lZWRzQm94PSEwKSx0aGlzW1wic3Ryb2tlLXdpZHRoXCJdPXQsdGhpcy5ib3hBdHRyKGUsdCl9XCJ0ZXh0LWFsaWduU2V0dGVyXCIodCl7dGhpcy50ZXh0QWxpZ249dH10ZXh0U2V0dGVyKHQpe3ZvaWQgMCE9PXQmJnRoaXMudGV4dC5hdHRyKHt0ZXh0OnR9KSx0aGlzLnVwZGF0ZVRleHRQYWRkaW5nKCl9dXBkYXRlQm94U2l6ZSgpe2xldCB0O2xldCBlPXRoaXMudGV4dCxyPXt9LG49dGhpcy5wYWRkaW5nLGE9dGhpcy5iQm94PSghbyh0aGlzLndpZHRoU2V0dGluZyl8fCFvKHRoaXMuaGVpZ2h0U2V0dGluZyl8fHRoaXMudGV4dEFsaWduKSYmaShlLnRleHRTdHIpP2UuZ2V0QkJveCgpOmguZW1wdHlCQm94O3RoaXMud2lkdGg9dGhpcy5nZXRQYWRkZWRXaWR0aCgpLHRoaXMuaGVpZ2h0PSh0aGlzLmhlaWdodFNldHRpbmd8fGEuaGVpZ2h0fHwwKSsyKm47bGV0IGw9dGhpcy5yZW5kZXJlci5mb250TWV0cmljcyhlKTtpZih0aGlzLmJhc2VsaW5lT2Zmc2V0PW4rTWF0aC5taW4oKHRoaXMudGV4dC5maXJzdExpbmVNZXRyaWNzfHxsKS5iLGEuaGVpZ2h0fHwxLzApLHRoaXMuaGVpZ2h0U2V0dGluZyYmKHRoaXMuYmFzZWxpbmVPZmZzZXQrPSh0aGlzLmhlaWdodFNldHRpbmctbC5oKS8yKSx0aGlzLm5lZWRzQm94JiYhZS50ZXh0UGF0aCl7aWYoIXRoaXMuYm94KXtsZXQgdD10aGlzLmJveD10aGlzLnN5bWJvbEtleT90aGlzLnJlbmRlcmVyLnN5bWJvbCh0aGlzLnN5bWJvbEtleSk6dGhpcy5yZW5kZXJlci5yZWN0KCk7dC5hZGRDbGFzcygoXCJidXR0b25cIj09PXRoaXMuY2xhc3NOYW1lP1wiXCI6XCJoaWdoY2hhcnRzLWxhYmVsLWJveFwiKSsodGhpcy5jbGFzc05hbWU/XCIgaGlnaGNoYXJ0cy1cIit0aGlzLmNsYXNzTmFtZStcIi1ib3hcIjpcIlwiKSksdC5hZGQodGhpcyl9dD10aGlzLmdldENyaXNwQWRqdXN0KCksci54PXQsci55PSh0aGlzLmJhc2VsaW5lPy10aGlzLmJhc2VsaW5lT2Zmc2V0OjApK3Qsci53aWR0aD1NYXRoLnJvdW5kKHRoaXMud2lkdGgpLHIuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5oZWlnaHQpLHRoaXMuYm94LmF0dHIocyhyLHRoaXMuZGVmZXJyZWRBdHRyKSksdGhpcy5kZWZlcnJlZEF0dHI9e319fXVwZGF0ZVRleHRQYWRkaW5nKCl7bGV0IHQ9dGhpcy50ZXh0O2lmKCF0LnRleHRQYXRoKXt0aGlzLnVwZGF0ZUJveFNpemUoKTtsZXQgZT10aGlzLmJhc2VsaW5lPzA6dGhpcy5iYXNlbGluZU9mZnNldCxzPW4odGhpcy5wYWRkaW5nTGVmdCx0aGlzLnBhZGRpbmcpO2kodGhpcy53aWR0aFNldHRpbmcpJiZ0aGlzLmJCb3gmJihcImNlbnRlclwiPT09dGhpcy50ZXh0QWxpZ258fFwicmlnaHRcIj09PXRoaXMudGV4dEFsaWduKSYmKHMrPSh7Y2VudGVyOi41LHJpZ2h0OjF9KVt0aGlzLnRleHRBbGlnbl0qKHRoaXMud2lkdGhTZXR0aW5nLXRoaXMuYkJveC53aWR0aCkpLChzIT09dC54fHxlIT09dC55KSYmKHQuYXR0cihcInhcIixzKSx0Lmhhc0JveFdpZHRoQ2hhbmdlZCYmKHRoaXMuYkJveD10LmdldEJCb3goITApKSx2b2lkIDAhPT1lJiZ0LmF0dHIoXCJ5XCIsZSkpLHQueD1zLHQueT1lfX13aWR0aFNldHRlcih0KXt0aGlzLndpZHRoU2V0dGluZz1vKHQpP3Q6dm9pZCAwfWdldFBhZGRlZFdpZHRoKCl7bGV0IHQ9dGhpcy5wYWRkaW5nLGU9bih0aGlzLnBhZGRpbmdMZWZ0LHQpLGk9bih0aGlzLnBhZGRpbmdSaWdodCx0KTtyZXR1cm4odGhpcy53aWR0aFNldHRpbmd8fHRoaXMuYkJveC53aWR0aHx8MCkrZStpfXhTZXR0ZXIodCl7dGhpcy54PXQsdGhpcy5hbGlnbkZhY3RvciYmKHQtPXRoaXMuYWxpZ25GYWN0b3IqdGhpcy5nZXRQYWRkZWRXaWR0aCgpLHRoaXNbXCJmb3JjZUFuaW1hdGU6eFwiXT0hMCksdGhpcy54U2V0dGluZz1NYXRoLnJvdW5kKHQpLHRoaXMuYXR0cihcInRyYW5zbGF0ZVhcIix0aGlzLnhTZXR0aW5nKX15U2V0dGVyKHQpe3RoaXMueVNldHRpbmc9dGhpcy55PU1hdGgucm91bmQodCksdGhpcy5hdHRyKFwidHJhbnNsYXRlWVwiLHRoaXMueVNldHRpbmcpfX1yZXR1cm4gaC5lbXB0eUJCb3g9e3dpZHRoOjAsaGVpZ2h0OjAseDowLHk6MH0saC50ZXh0UHJvcHM9W1wiY29sb3JcIixcImRpcmVjdGlvblwiLFwiZm9udEZhbWlseVwiLFwiZm9udFNpemVcIixcImZvbnRTdHlsZVwiLFwiZm9udFdlaWdodFwiLFwibGluZUhlaWdodFwiLFwidGV4dEFsaWduXCIsXCJ0ZXh0RGVjb3JhdGlvblwiLFwidGV4dE91dGxpbmVcIixcInRleHRPdmVyZmxvd1wiLFwid2hpdGVTcGFjZVwiLFwid2lkdGhcIl0saH0pLGkoZSxcIkNvcmUvUmVuZGVyZXIvU1ZHL1N5bWJvbHMuanNcIixbZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0KXtsZXR7ZGVmaW5lZDplLGlzTnVtYmVyOmkscGljazpzfT10O2Z1bmN0aW9uIG8odCxpLG8scixuKXtsZXQgYT1bXTtpZihuKXtsZXQgaD1uLnN0YXJ0fHwwLGw9cyhuLnIsbyksZD1zKG4ucixyfHxvKSxjPS4wMDE+TWF0aC5hYnMoKG4uZW5kfHwwKS1oLTIqTWF0aC5QSSkscD0obi5lbmR8fDApLS4wMDEsdT1uLmlubmVyUixnPXMobi5vcGVuLGMpLGY9TWF0aC5jb3MoaCksbT1NYXRoLnNpbihoKSx4PU1hdGguY29zKHApLHk9TWF0aC5zaW4ocCksYj1zKG4ubG9uZ0FyYyxwLWgtTWF0aC5QSTwuMDAxPzA6MSksdj1bXCJBXCIsbCxkLDAsYixzKG4uY2xvY2t3aXNlLDEpLHQrbCp4LGkrZCp5XTt2LnBhcmFtcz17c3RhcnQ6aCxlbmQ6cCxjeDp0LGN5Oml9LGEucHVzaChbXCJNXCIsdCtsKmYsaStkKm1dLHYpLGUodSkmJigodj1bXCJBXCIsdSx1LDAsYixlKG4uY2xvY2t3aXNlKT8xLW4uY2xvY2t3aXNlOjAsdCt1KmYsaSt1Km1dKS5wYXJhbXM9e3N0YXJ0OnAsZW5kOmgsY3g6dCxjeTppfSxhLnB1c2goZz9bXCJNXCIsdCt1KngsaSt1KnldOltcIkxcIix0K3UqeCxpK3UqeV0sdikpLGd8fGEucHVzaChbXCJaXCJdKX1yZXR1cm4gYX1mdW5jdGlvbiByKHQsZSxpLHMsbyl7cmV0dXJuIG8mJm8ucj9uKHQsZSxpLHMsbyk6W1tcIk1cIix0LGVdLFtcIkxcIix0K2ksZV0sW1wiTFwiLHQraSxlK3NdLFtcIkxcIix0LGUrc10sW1wiWlwiXV19ZnVuY3Rpb24gbih0LGUsaSxzLG8pe2xldCByPW8/LnJ8fDA7cmV0dXJuW1tcIk1cIix0K3IsZV0sW1wiTFwiLHQraS1yLGVdLFtcIkFcIixyLHIsMCwwLDEsdCtpLGUrcl0sW1wiTFwiLHQraSxlK3Mtcl0sW1wiQVwiLHIsciwwLDAsMSx0K2ktcixlK3NdLFtcIkxcIix0K3IsZStzXSxbXCJBXCIscixyLDAsMCwxLHQsZStzLXJdLFtcIkxcIix0LGUrcl0sW1wiQVwiLHIsciwwLDAsMSx0K3IsZV0sW1wiWlwiXV19cmV0dXJue2FyYzpvLGNhbGxvdXQ6ZnVuY3Rpb24odCxlLHMsbyxyKXtsZXQgYT1NYXRoLm1pbihyJiZyLnJ8fDAscyxvKSxoPWErNixsPXImJnIuYW5jaG9yWCxkPXImJnIuYW5jaG9yWXx8MCxjPW4odCxlLHMsbyx7cjphfSk7aWYoIWkobCl8fGw8cyYmbD4wJiZkPG8mJmQ+MClyZXR1cm4gYztpZih0K2w+cy1oKXtpZihkPmUraCYmZDxlK28taCljLnNwbGljZSgzLDEsW1wiTFwiLHQrcyxkLTZdLFtcIkxcIix0K3MrNixkXSxbXCJMXCIsdCtzLGQrNl0sW1wiTFwiLHQrcyxlK28tYV0pO2Vsc2UgaWYobDxzKXtsZXQgaT1kPGUraCxyPWk/ZTplK287Yy5zcGxpY2UoaT8yOjUsMCxbXCJMXCIsbCxkXSxbXCJMXCIsdCtzLWEscl0pfWVsc2UgYy5zcGxpY2UoMywxLFtcIkxcIix0K3Msby8yXSxbXCJMXCIsbCxkXSxbXCJMXCIsdCtzLG8vMl0sW1wiTFwiLHQrcyxlK28tYV0pfWVsc2UgaWYodCtsPGgpe2lmKGQ+ZStoJiZkPGUrby1oKWMuc3BsaWNlKDcsMSxbXCJMXCIsdCxkKzZdLFtcIkxcIix0LTYsZF0sW1wiTFwiLHQsZC02XSxbXCJMXCIsdCxlK2FdKTtlbHNlIGlmKGw+MCl7bGV0IGk9ZDxlK2gscz1pP2U6ZStvO2Muc3BsaWNlKGk/MTo2LDAsW1wiTFwiLGwsZF0sW1wiTFwiLHQrYSxzXSl9ZWxzZSBjLnNwbGljZSg3LDEsW1wiTFwiLHQsby8yXSxbXCJMXCIsbCxkXSxbXCJMXCIsdCxvLzJdLFtcIkxcIix0LGUrYV0pfWVsc2UgZD5vJiZsPHMtaD9jLnNwbGljZSg1LDEsW1wiTFwiLGwrNixlK29dLFtcIkxcIixsLGUrbys2XSxbXCJMXCIsbC02LGUrb10sW1wiTFwiLHQrYSxlK29dKTpkPDAmJmw+aCYmYy5zcGxpY2UoMSwxLFtcIkxcIixsLTYsZV0sW1wiTFwiLGwsZS02XSxbXCJMXCIsbCs2LGVdLFtcIkxcIixzLWEsZV0pO3JldHVybiBjfSxjaXJjbGU6ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIG8odCtpLzIsZStzLzIsaS8yLHMvMix7c3RhcnQ6LjUqTWF0aC5QSSxlbmQ6Mi41Kk1hdGguUEksb3BlbjohMX0pfSxkaWFtb25kOmZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybltbXCJNXCIsdCtpLzIsZV0sW1wiTFwiLHQraSxlK3MvMl0sW1wiTFwiLHQraS8yLGUrc10sW1wiTFwiLHQsZStzLzJdLFtcIlpcIl1dfSxyZWN0OnIscm91bmRlZFJlY3Q6bixzcXVhcmU6cix0cmlhbmdsZTpmdW5jdGlvbih0LGUsaSxzKXtyZXR1cm5bW1wiTVwiLHQraS8yLGVdLFtcIkxcIix0K2ksZStzXSxbXCJMXCIsdCxlK3NdLFtcIlpcIl1dfSxcInRyaWFuZ2xlLWRvd25cIjpmdW5jdGlvbih0LGUsaSxzKXtyZXR1cm5bW1wiTVwiLHQsZV0sW1wiTFwiLHQraSxlXSxbXCJMXCIsdCtpLzIsZStzXSxbXCJaXCJdXX19fSksaShlLFwiQ29yZS9SZW5kZXJlci9TVkcvVGV4dEJ1aWxkZXIuanNcIixbZVtcIkNvcmUvUmVuZGVyZXIvSFRNTC9BU1QuanNcIl0sZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpKXtsZXR7ZG9jOnMsU1ZHX05TOm8sd2luOnJ9PWUse2F0dHI6bixleHRlbmQ6YSxmaXJlRXZlbnQ6aCxpc1N0cmluZzpsLG9iamVjdEVhY2g6ZCxwaWNrOmN9PWk7cmV0dXJuIGNsYXNze2NvbnN0cnVjdG9yKHQpe2xldCBlPXQuc3R5bGVzO3RoaXMucmVuZGVyZXI9dC5yZW5kZXJlcix0aGlzLnN2Z0VsZW1lbnQ9dCx0aGlzLndpZHRoPXQudGV4dFdpZHRoLHRoaXMudGV4dExpbmVIZWlnaHQ9ZSYmZS5saW5lSGVpZ2h0LHRoaXMudGV4dE91dGxpbmU9ZSYmZS50ZXh0T3V0bGluZSx0aGlzLmVsbGlwc2lzPSEhKGUmJlwiZWxsaXBzaXNcIj09PWUudGV4dE92ZXJmbG93KSx0aGlzLm5vV3JhcD0hIShlJiZcIm5vd3JhcFwiPT09ZS53aGl0ZVNwYWNlKX1idWlsZFNWRygpe2xldCBlPXRoaXMuc3ZnRWxlbWVudCxpPWUuZWxlbWVudCxvPWUucmVuZGVyZXIscj1jKGUudGV4dFN0cixcIlwiKS50b1N0cmluZygpLG49LTEhPT1yLmluZGV4T2YoXCI8XCIpLGE9aS5jaGlsZE5vZGVzLGg9IWUuYWRkZWQmJm8uYm94LGQ9W3IsdGhpcy5lbGxpcHNpcyx0aGlzLm5vV3JhcCx0aGlzLnRleHRMaW5lSGVpZ2h0LHRoaXMudGV4dE91dGxpbmUsZS5nZXRTdHlsZShcImZvbnQtc2l6ZVwiKSx0aGlzLndpZHRoXS5qb2luKFwiLFwiKTtpZihkIT09ZS50ZXh0Q2FjaGUpe2UudGV4dENhY2hlPWQsZGVsZXRlIGUuYWN0dWFsV2lkdGg7Zm9yKGxldCB0PWEubGVuZ3RoO3QtLTspaS5yZW1vdmVDaGlsZChhW3RdKTtpZihufHx0aGlzLmVsbGlwc2lzfHx0aGlzLndpZHRofHxlLnRleHRQYXRofHwtMSE9PXIuaW5kZXhPZihcIiBcIikmJighdGhpcy5ub1dyYXB8fC88YnIuKj8+L2cudGVzdChyKSkpe2lmKFwiXCIhPT1yKXtoJiZoLmFwcGVuZENoaWxkKGkpO2xldCBzPW5ldyB0KHIpO3RoaXMubW9kaWZ5VHJlZShzLm5vZGVzKSxzLmFkZFRvRE9NKGkpLHRoaXMubW9kaWZ5RE9NKCksdGhpcy5lbGxpcHNpcyYmLTEhPT0oaS50ZXh0Q29udGVudHx8XCJcIikuaW5kZXhPZihcIuKAplwiKSYmZS5hdHRyKFwidGl0bGVcIix0aGlzLnVuZXNjYXBlRW50aXRpZXMoZS50ZXh0U3RyfHxcIlwiLFtcIiZsdDtcIixcIiZndDtcIl0pKSxoJiZoLnJlbW92ZUNoaWxkKGkpfX1lbHNlIGkuYXBwZW5kQ2hpbGQocy5jcmVhdGVUZXh0Tm9kZSh0aGlzLnVuZXNjYXBlRW50aXRpZXMocikpKTtsKHRoaXMudGV4dE91dGxpbmUpJiZlLmFwcGx5VGV4dE91dGxpbmUmJmUuYXBwbHlUZXh0T3V0bGluZSh0aGlzLnRleHRPdXRsaW5lKX19bW9kaWZ5RE9NKCl7bGV0IHQ7bGV0IGU9dGhpcy5zdmdFbGVtZW50LGk9bihlLmVsZW1lbnQsXCJ4XCIpO2ZvcihlLmZpcnN0TGluZU1ldHJpY3M9dm9pZCAwO3Q9ZS5lbGVtZW50LmZpcnN0Q2hpbGQ7KWlmKC9eW1xcc1xcdTIwMEJdKiQvLnRlc3QodC50ZXh0Q29udGVudHx8XCIgXCIpKWUuZWxlbWVudC5yZW1vdmVDaGlsZCh0KTtlbHNlIGJyZWFrO1tdLmZvckVhY2guY2FsbChlLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInRzcGFuLmhpZ2hjaGFydHMtYnJcIiksKHQscyk9Pnt0Lm5leHRTaWJsaW5nJiZ0LnByZXZpb3VzU2libGluZyYmKDA9PT1zJiYxPT09dC5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGUmJihlLmZpcnN0TGluZU1ldHJpY3M9ZS5yZW5kZXJlci5mb250TWV0cmljcyh0LnByZXZpb3VzU2libGluZykpLG4odCx7ZHk6dGhpcy5nZXRMaW5lSGVpZ2h0KHQubmV4dFNpYmxpbmcpLHg6aX0pKX0pO2xldCBhPXRoaXMud2lkdGh8fDA7aWYoIWEpcmV0dXJuO2xldCBoPSh0LHIpPT57bGV0IGg9dC50ZXh0Q29udGVudHx8XCJcIixsPWgucmVwbGFjZSgvKFteXFxeXSktL2csXCIkMS0gXCIpLnNwbGl0KFwiIFwiKSxkPSF0aGlzLm5vV3JhcCYmKGwubGVuZ3RoPjF8fGUuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aD4xKSxjPXRoaXMuZ2V0TGluZUhlaWdodChyKSxwPTAsdT1lLmFjdHVhbFdpZHRoO2lmKHRoaXMuZWxsaXBzaXMpaCYmdGhpcy50cnVuY2F0ZSh0LGgsdm9pZCAwLDAsTWF0aC5tYXgoMCxhLS44KmMpLCh0LGUpPT50LnN1YnN0cmluZygwLGUpK1wi4oCmXCIpO2Vsc2UgaWYoZCl7bGV0IGg9W10sZD1bXTtmb3IoO3IuZmlyc3RDaGlsZCYmci5maXJzdENoaWxkIT09dDspZC5wdXNoKHIuZmlyc3RDaGlsZCksci5yZW1vdmVDaGlsZChyLmZpcnN0Q2hpbGQpO2Zvcig7bC5sZW5ndGg7KWwubGVuZ3RoJiYhdGhpcy5ub1dyYXAmJnA+MCYmKGgucHVzaCh0LnRleHRDb250ZW50fHxcIlwiKSx0LnRleHRDb250ZW50PWwuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZyxcIi1cIikpLHRoaXMudHJ1bmNhdGUodCx2b2lkIDAsbCwwPT09cCYmdXx8MCxhLCh0LGUpPT5sLnNsaWNlKDAsZSkuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZyxcIi1cIikpLHU9ZS5hY3R1YWxXaWR0aCxwKys7ZC5mb3JFYWNoKGU9PntyLmluc2VydEJlZm9yZShlLHQpfSksaC5mb3JFYWNoKGU9PntyLmluc2VydEJlZm9yZShzLmNyZWF0ZVRleHROb2RlKGUpLHQpO2xldCBhPXMuY3JlYXRlRWxlbWVudE5TKG8sXCJ0c3BhblwiKTthLnRleHRDb250ZW50PVwi4oCLXCIsbihhLHtkeTpjLHg6aX0pLHIuaW5zZXJ0QmVmb3JlKGEsdCl9KX19LGw9dD0+e2xldCBpPVtdLnNsaWNlLmNhbGwodC5jaGlsZE5vZGVzKTtpLmZvckVhY2goaT0+e2kubm9kZVR5cGU9PT1yLk5vZGUuVEVYVF9OT0RFP2goaSx0KTooLTEhPT1pLmNsYXNzTmFtZS5iYXNlVmFsLmluZGV4T2YoXCJoaWdoY2hhcnRzLWJyXCIpJiYoZS5hY3R1YWxXaWR0aD0wKSxsKGkpKX0pfTtsKGUuZWxlbWVudCl9Z2V0TGluZUhlaWdodCh0KXtsZXQgZT10Lm5vZGVUeXBlPT09ci5Ob2RlLlRFWFRfTk9ERT90LnBhcmVudEVsZW1lbnQ6dDtyZXR1cm4gdGhpcy50ZXh0TGluZUhlaWdodD9wYXJzZUludCh0aGlzLnRleHRMaW5lSGVpZ2h0LnRvU3RyaW5nKCksMTApOnRoaXMucmVuZGVyZXIuZm9udE1ldHJpY3MoZXx8dGhpcy5zdmdFbGVtZW50LmVsZW1lbnQpLmh9bW9kaWZ5VHJlZSh0KXtsZXQgZT0oaSxzKT0+e2xldHthdHRyaWJ1dGVzOm89e30sY2hpbGRyZW46cixzdHlsZTpuPXt9LHRhZ05hbWU6aH09aSxsPXRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZTtpZihcImJcIj09PWh8fFwic3Ryb25nXCI9PT1oP2w/by5jbGFzcz1cImhpZ2hjaGFydHMtc3Ryb25nXCI6bi5mb250V2VpZ2h0PVwiYm9sZFwiOihcImlcIj09PWh8fFwiZW1cIj09PWgpJiYobD9vLmNsYXNzPVwiaGlnaGNoYXJ0cy1lbXBoYXNpemVkXCI6bi5mb250U3R5bGU9XCJpdGFsaWNcIiksbiYmbi5jb2xvciYmKG4uZmlsbD1uLmNvbG9yKSxcImJyXCI9PT1oKXtvLmNsYXNzPVwiaGlnaGNoYXJ0cy1iclwiLGkudGV4dENvbnRlbnQ9XCLigItcIjtsZXQgZT10W3MrMV07ZSYmZS50ZXh0Q29udGVudCYmKGUudGV4dENvbnRlbnQ9ZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eICsvZ20sXCJcIikpfWVsc2VcImFcIj09PWgmJnImJnIuc29tZSh0PT5cIiN0ZXh0XCI9PT10LnRhZ05hbWUpJiYoaS5jaGlsZHJlbj1be2NoaWxkcmVuOnIsdGFnTmFtZTpcInRzcGFuXCJ9XSk7XCIjdGV4dFwiIT09aCYmXCJhXCIhPT1oJiYoaS50YWdOYW1lPVwidHNwYW5cIiksYShpLHthdHRyaWJ1dGVzOm8sc3R5bGU6bn0pLHImJnIuZmlsdGVyKHQ9PlwiI3RleHRcIiE9PXQudGFnTmFtZSkuZm9yRWFjaChlKX07dC5mb3JFYWNoKGUpLGgodGhpcy5zdmdFbGVtZW50LFwiYWZ0ZXJNb2RpZnlUcmVlXCIse25vZGVzOnR9KX10cnVuY2F0ZSh0LGUsaSxzLG8scil7bGV0IG4sYTtsZXQgaD10aGlzLnN2Z0VsZW1lbnQse3JlbmRlcmVyOmwscm90YXRpb246ZH09aCxjPVtdLHA9aT8xOjAsdT0oZXx8aXx8XCJcIikubGVuZ3RoLGc9dSxmPWZ1bmN0aW9uKGUsbyl7bGV0IHI9b3x8ZSxuPXQucGFyZW50Tm9kZTtpZihuJiZ2b2lkIDA9PT1jW3JdJiZuLmdldFN1YlN0cmluZ0xlbmd0aCl0cnl7Y1tyXT1zK24uZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsaT9yKzE6cil9Y2F0Y2godCl7fXJldHVybiBjW3JdfTtpZihoLnJvdGF0aW9uPTAscysoYT1mKHQudGV4dENvbnRlbnQubGVuZ3RoKSk+byl7Zm9yKDtwPD11OylnPU1hdGguY2VpbCgocCt1KS8yKSxpJiYobj1yKGksZykpLGE9ZihnLG4mJm4ubGVuZ3RoLTEpLHA9PT11P3A9dSsxOmE+bz91PWctMTpwPWc7MD09PXU/dC50ZXh0Q29udGVudD1cIlwiOmUmJnU9PT1lLmxlbmd0aC0xfHwodC50ZXh0Q29udGVudD1ufHxyKGV8fGksZykpfWkmJmkuc3BsaWNlKDAsZyksaC5hY3R1YWxXaWR0aD1hLGgucm90YXRpb249ZH11bmVzY2FwZUVudGl0aWVzKHQsZSl7cmV0dXJuIGQodGhpcy5yZW5kZXJlci5lc2NhcGVzLGZ1bmN0aW9uKGkscyl7ZSYmLTEhPT1lLmluZGV4T2YoaSl8fCh0PXQudG9TdHJpbmcoKS5yZXBsYWNlKFJlZ0V4cChpLFwiZ1wiKSxzKSl9KSx0fX19KSxpKGUsXCJDb3JlL1JlbmRlcmVyL1NWRy9TVkdSZW5kZXJlci5qc1wiLFtlW1wiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiXSxlW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1JlbmRlcmVyUmVnaXN0cnkuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0VsZW1lbnQuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0xhYmVsLmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1NWRy9TeW1ib2xzLmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1NWRy9UZXh0QnVpbGRlci5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpLHMsbyxyLG4sYSxoKXtsZXQgbDtsZXR7Y2hhcnRzOmQsZGVnMnJhZDpjLGRvYzpwLGlzRmlyZWZveDp1LGlzTVM6Zyxpc1dlYktpdDpmLG5vb3A6bSxTVkdfTlM6eCxzeW1ib2xTaXplczp5LHdpbjpifT1pLHthZGRFdmVudDp2LGF0dHI6UyxjcmVhdGVFbGVtZW50OmssY3NzOk0sZGVmaW5lZDpDLGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzOncsZXh0ZW5kOlQsaXNBcnJheTpBLGlzTnVtYmVyOlAsaXNPYmplY3Q6TCxpc1N0cmluZzpPLG1lcmdlOkQscGljazpFLHBJbnQ6aix1bmlxdWVLZXk6SX09aDtjbGFzcyBCe2NvbnN0cnVjdG9yKHQsZSxpLHMsbyxyLG4pe2xldCBhLGg7bGV0IGw9dGhpcy5jcmVhdGVFbGVtZW50KFwic3ZnXCIpLmF0dHIoe3ZlcnNpb246XCIxLjFcIixjbGFzczpcImhpZ2hjaGFydHMtcm9vdFwifSksZD1sLmVsZW1lbnQ7bnx8bC5jc3ModGhpcy5nZXRTdHlsZShzfHx7fSkpLHQuYXBwZW5kQ2hpbGQoZCksUyh0LFwiZGlyXCIsXCJsdHJcIiksLTE9PT10LmlubmVySFRNTC5pbmRleE9mKFwieG1sbnNcIikmJlMoZCxcInhtbG5zXCIsdGhpcy5TVkdfTlMpLHRoaXMuYm94PWQsdGhpcy5ib3hXcmFwcGVyPWwsdGhpcy5hbGlnbmVkT2JqZWN0cz1bXSx0aGlzLnVybD10aGlzLmdldFJlZmVyZW5jZVVSTCgpO2xldCBjPXRoaXMuY3JlYXRlRWxlbWVudChcImRlc2NcIikuYWRkKCk7Yy5lbGVtZW50LmFwcGVuZENoaWxkKHAuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggSGlnaGNoYXJ0cyAxMS4zLjBcIikpLHRoaXMuZGVmcz10aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpLmFkZCgpLHRoaXMuYWxsb3dIVE1MPXIsdGhpcy5mb3JFeHBvcnQ9byx0aGlzLnN0eWxlZE1vZGU9bix0aGlzLmdyYWRpZW50cz17fSx0aGlzLmNhY2hlPXt9LHRoaXMuY2FjaGVLZXlzPVtdLHRoaXMuaW1nQ291bnQ9MCx0aGlzLnJvb3RGb250U2l6ZT1sLmdldFN0eWxlKFwiZm9udC1zaXplXCIpLHRoaXMuc2V0U2l6ZShlLGksITEpLHUmJnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0JiYoKGE9ZnVuY3Rpb24oKXtNKHQse2xlZnQ6MCx0b3A6MH0pLGg9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxNKHQse2xlZnQ6TWF0aC5jZWlsKGgubGVmdCktaC5sZWZ0K1wicHhcIix0b3A6TWF0aC5jZWlsKGgudG9wKS1oLnRvcCtcInB4XCJ9KX0pKCksdGhpcy51blN1YlBpeGVsRml4PXYoYixcInJlc2l6ZVwiLGEpKX1kZWZpbml0aW9uKGUpe2xldCBpPW5ldyB0KFtlXSk7cmV0dXJuIGkuYWRkVG9ET00odGhpcy5kZWZzLmVsZW1lbnQpfWdldFJlZmVyZW5jZVVSTCgpe2lmKCh1fHxmKSYmcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJhc2VcIikubGVuZ3RoKXtpZighQyhsKSl7bGV0IGU9SSgpLGk9bmV3IHQoW3t0YWdOYW1lOlwic3ZnXCIsYXR0cmlidXRlczp7d2lkdGg6OCxoZWlnaHQ6OH0sY2hpbGRyZW46W3t0YWdOYW1lOlwiZGVmc1wiLGNoaWxkcmVuOlt7dGFnTmFtZTpcImNsaXBQYXRoXCIsYXR0cmlidXRlczp7aWQ6ZX0sY2hpbGRyZW46W3t0YWdOYW1lOlwicmVjdFwiLGF0dHJpYnV0ZXM6e3dpZHRoOjQsaGVpZ2h0OjR9fV19XX0se3RhZ05hbWU6XCJyZWN0XCIsYXR0cmlidXRlczp7aWQ6XCJoaXRtZVwiLHdpZHRoOjgsaGVpZ2h0OjgsXCJjbGlwLXBhdGhcIjpgdXJsKCMke2V9KWAsZmlsbDpcInJnYmEoMCwwLDAsMC4wMDEpXCJ9fV19XSkscz1pLmFkZFRvRE9NKHAuYm9keSk7TShzLHtwb3NpdGlvbjpcImZpeGVkXCIsdG9wOjAsbGVmdDowLHpJbmRleDo5ZTV9KTtsZXQgbz1wLmVsZW1lbnRGcm9tUG9pbnQoNiw2KTtsPVwiaGl0bWVcIj09PShvJiZvLmlkKSxwLmJvZHkucmVtb3ZlQ2hpbGQocyl9aWYobClyZXR1cm4gYi5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiI1wiKVswXS5yZXBsYWNlKC88W14+XSo+L2csXCJcIikucmVwbGFjZSgvKFtcXCgnXFwpXSkvZyxcIlxcXFwkMVwiKS5yZXBsYWNlKC8gL2csXCIlMjBcIil9cmV0dXJuXCJcIn1nZXRTdHlsZSh0KXtyZXR1cm4gdGhpcy5zdHlsZT1UKHtmb250RmFtaWx5OlwiSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZlwiLGZvbnRTaXplOlwiMXJlbVwifSx0KSx0aGlzLnN0eWxlfXNldFN0eWxlKHQpe3RoaXMuYm94V3JhcHBlci5jc3ModGhpcy5nZXRTdHlsZSh0KSl9aXNIaWRkZW4oKXtyZXR1cm4hdGhpcy5ib3hXcmFwcGVyLmdldEJCb3goKS53aWR0aH1kZXN0cm95KCl7bGV0IHQ9dGhpcy5kZWZzO3JldHVybiB0aGlzLmJveD1udWxsLHRoaXMuYm94V3JhcHBlcj10aGlzLmJveFdyYXBwZXIuZGVzdHJveSgpLHcodGhpcy5ncmFkaWVudHN8fHt9KSx0aGlzLmdyYWRpZW50cz1udWxsLHRoaXMuZGVmcz10LmRlc3Ryb3koKSx0aGlzLnVuU3ViUGl4ZWxGaXgmJnRoaXMudW5TdWJQaXhlbEZpeCgpLHRoaXMuYWxpZ25lZE9iamVjdHM9bnVsbCxudWxsfWNyZWF0ZUVsZW1lbnQodCl7cmV0dXJuIG5ldyB0aGlzLkVsZW1lbnQodGhpcyx0KX1nZXRSYWRpYWxBdHRyKHQsZSl7cmV0dXJue2N4OnRbMF0tdFsyXS8yKyhlLmN4fHwwKSp0WzJdLGN5OnRbMV0tdFsyXS8yKyhlLmN5fHwwKSp0WzJdLHI6KGUucnx8MCkqdFsyXX19c2hhZG93RGVmaW5pdGlvbih0KXtsZXQgZT1bYGhpZ2hjaGFydHMtZHJvcC1zaGFkb3ctJHt0aGlzLmNoYXJ0SW5kZXh9YCwuLi5PYmplY3Qua2V5cyh0KS5tYXAoZT0+YCR7ZX0tJHt0W2VdfWApXS5qb2luKFwiLVwiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XFwtXS9nLFwiXCIpLGk9RCh7Y29sb3I6XCIjMDAwMDAwXCIsb2Zmc2V0WDoxLG9mZnNldFk6MSxvcGFjaXR5Oi4xNSx3aWR0aDo1fSx0KTtyZXR1cm4gdGhpcy5kZWZzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihgIyR7ZX1gKXx8dGhpcy5kZWZpbml0aW9uKHt0YWdOYW1lOlwiZmlsdGVyXCIsYXR0cmlidXRlczp7aWQ6ZSxmaWx0ZXJVbml0czppLmZpbHRlclVuaXRzfSxjaGlsZHJlbjpbe3RhZ05hbWU6XCJmZURyb3BTaGFkb3dcIixhdHRyaWJ1dGVzOntkeDppLm9mZnNldFgsZHk6aS5vZmZzZXRZLFwiZmxvb2QtY29sb3JcIjppLmNvbG9yLFwiZmxvb2Qtb3BhY2l0eVwiOk1hdGgubWluKDUqaS5vcGFjaXR5LDEpLHN0ZERldmlhdGlvbjppLndpZHRoLzJ9fV19KSxlfWJ1aWxkVGV4dCh0KXtuZXcgYSh0KS5idWlsZFNWRygpfWdldENvbnRyYXN0KHQpe2xldCBpPWUucGFyc2UodCkucmdiYS5tYXAodD0+e2xldCBlPXQvMjU1O3JldHVybiBlPD0uMDM5Mjg/ZS8xMi45MjpNYXRoLnBvdygoZSsuMDU1KS8xLjA1NSwyLjQpfSkscz0uMjEyNippWzBdKy43MTUyKmlbMV0rLjA3MjIqaVsyXTtyZXR1cm4gMS4wNS8ocysuMDUpPihzKy4wNSkvLjA1P1wiI0ZGRkZGRlwiOlwiIzAwMDAwMFwifWJ1dHRvbihlLGkscyxvLHI9e30sbixhLGgsbCxkKXtsZXQgYyxwLHU7bGV0IGY9dGhpcy5sYWJlbChlLGkscyxsLHZvaWQgMCx2b2lkIDAsZCx2b2lkIDAsXCJidXR0b25cIiksbT10aGlzLnN0eWxlZE1vZGUseD1yLnN0YXRlc3x8e30seT0wO3I9RChyKSxkZWxldGUgci5zdGF0ZXM7bGV0IGI9RCh7Y29sb3I6XCIjMzMzMzMzXCIsY3Vyc29yOlwicG9pbnRlclwiLGZvbnRTaXplOlwiMC44ZW1cIixmb250V2VpZ2h0Olwibm9ybWFsXCJ9LHIuc3R5bGUpO2RlbGV0ZSByLnN0eWxlO2xldCBTPXQuZmlsdGVyVXNlckF0dHJpYnV0ZXMocik7cmV0dXJuIGYuYXR0cihEKHtwYWRkaW5nOjgscjoyfSxTKSksbXx8KFM9RCh7ZmlsbDpcIiNmN2Y3ZjdcIixzdHJva2U6XCIjY2NjY2NjXCIsXCJzdHJva2Utd2lkdGhcIjoxfSxTKSxjPShuPUQoUyx7ZmlsbDpcIiNlNmU2ZTZcIn0sdC5maWx0ZXJVc2VyQXR0cmlidXRlcyhufHx4LmhvdmVyfHx7fSkpKS5zdHlsZSxkZWxldGUgbi5zdHlsZSxwPShhPUQoUyx7ZmlsbDpcIiNlNmU5ZmZcIixzdHlsZTp7Y29sb3I6XCIjMDAwMDAwXCIsZm9udFdlaWdodDpcImJvbGRcIn19LHQuZmlsdGVyVXNlckF0dHJpYnV0ZXMoYXx8eC5zZWxlY3R8fHt9KSkpLnN0eWxlLGRlbGV0ZSBhLnN0eWxlLHU9KGg9RChTLHtzdHlsZTp7Y29sb3I6XCIjY2NjY2NjXCJ9fSx0LmZpbHRlclVzZXJBdHRyaWJ1dGVzKGh8fHguZGlzYWJsZWR8fHt9KSkpLnN0eWxlLGRlbGV0ZSBoLnN0eWxlKSx2KGYuZWxlbWVudCxnP1wibW91c2VvdmVyXCI6XCJtb3VzZWVudGVyXCIsZnVuY3Rpb24oKXszIT09eSYmZi5zZXRTdGF0ZSgxKX0pLHYoZi5lbGVtZW50LGc/XCJtb3VzZW91dFwiOlwibW91c2VsZWF2ZVwiLGZ1bmN0aW9uKCl7MyE9PXkmJmYuc2V0U3RhdGUoeSl9KSxmLnNldFN0YXRlPWZ1bmN0aW9uKHQpe2lmKDEhPT10JiYoZi5zdGF0ZT15PXQpLGYucmVtb3ZlQ2xhc3MoL2hpZ2hjaGFydHMtYnV0dG9uLShub3JtYWx8aG92ZXJ8cHJlc3NlZHxkaXNhYmxlZCkvKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYnV0dG9uLVwiK1tcIm5vcm1hbFwiLFwiaG92ZXJcIixcInByZXNzZWRcIixcImRpc2FibGVkXCJdW3R8fDBdKSwhbSl7Zi5hdHRyKFtTLG4sYSxoXVt0fHwwXSk7bGV0IGU9W2IsYyxwLHVdW3R8fDBdO0woZSkmJmYuY3NzKGUpfX0sIW0mJihmLmF0dHIoUykuY3NzKFQoe2N1cnNvcjpcImRlZmF1bHRcIn0sYikpLGQmJmYudGV4dC5jc3Moe3BvaW50ZXJFdmVudHM6XCJub25lXCJ9KSksZi5vbihcInRvdWNoc3RhcnRcIix0PT50LnN0b3BQcm9wYWdhdGlvbigpKS5vbihcImNsaWNrXCIsZnVuY3Rpb24odCl7MyE9PXkmJm8uY2FsbChmLHQpfSl9Y3Jpc3BMaW5lKHQsZSxpPVwicm91bmRcIil7bGV0IHM9dFswXSxvPXRbMV07cmV0dXJuIEMoc1sxXSkmJnNbMV09PT1vWzFdJiYoc1sxXT1vWzFdPU1hdGhbaV0oc1sxXSktZSUyLzIpLEMoc1syXSkmJnNbMl09PT1vWzJdJiYoc1syXT1vWzJdPU1hdGhbaV0oc1syXSkrZSUyLzIpLHR9cGF0aCh0KXtsZXQgZT10aGlzLnN0eWxlZE1vZGU/e306e2ZpbGw6XCJub25lXCJ9O3JldHVybiBBKHQpP2UuZD10OkwodCkmJlQoZSx0KSx0aGlzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpLmF0dHIoZSl9Y2lyY2xlKHQsZSxpKXtsZXQgcz1MKHQpP3Q6dm9pZCAwPT09dD97fTp7eDp0LHk6ZSxyOml9LG89dGhpcy5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIpO3JldHVybiBvLnhTZXR0ZXI9by55U2V0dGVyPWZ1bmN0aW9uKHQsZSxpKXtpLnNldEF0dHJpYnV0ZShcImNcIitlLHQpfSxvLmF0dHIocyl9YXJjKHQsZSxpLHMsbyxyKXtsZXQgbjtMKHQpPyhlPShuPXQpLnksaT1uLnIscz1uLmlubmVyUixvPW4uc3RhcnQscj1uLmVuZCx0PW4ueCk6bj17aW5uZXJSOnMsc3RhcnQ6byxlbmQ6cn07bGV0IGE9dGhpcy5zeW1ib2woXCJhcmNcIix0LGUsaSxpLG4pO3JldHVybiBhLnI9aSxhfXJlY3QodCxlLGkscyxvLHIpe2xldCBuPUwodCk/dDp2b2lkIDA9PT10P3t9Ont4OnQseTplLHI6byx3aWR0aDpNYXRoLm1heChpfHwwLDApLGhlaWdodDpNYXRoLm1heChzfHwwLDApfSxhPXRoaXMuY3JlYXRlRWxlbWVudChcInJlY3RcIik7cmV0dXJuIHRoaXMuc3R5bGVkTW9kZXx8KHZvaWQgMCE9PXImJihuW1wic3Ryb2tlLXdpZHRoXCJdPXIsVChuLGEuY3Jpc3AobikpKSxuLmZpbGw9XCJub25lXCIpLGEuclNldHRlcj1mdW5jdGlvbih0LGUsaSl7YS5yPXQsUyhpLHtyeDp0LHJ5OnR9KX0sYS5yR2V0dGVyPWZ1bmN0aW9uKCl7cmV0dXJuIGEucnx8MH0sYS5hdHRyKG4pfXJvdW5kZWRSZWN0KHQpe3JldHVybiB0aGlzLnN5bWJvbChcInJvdW5kZWRSZWN0XCIpLmF0dHIodCl9c2V0U2l6ZSh0LGUsaSl7dGhpcy53aWR0aD10LHRoaXMuaGVpZ2h0PWUsdGhpcy5ib3hXcmFwcGVyLmFuaW1hdGUoe3dpZHRoOnQsaGVpZ2h0OmV9LHtzdGVwOmZ1bmN0aW9uKCl7dGhpcy5hdHRyKHt2aWV3Qm94OlwiMCAwIFwiK3RoaXMuYXR0cihcIndpZHRoXCIpK1wiIFwiK3RoaXMuYXR0cihcImhlaWdodFwiKX0pfSxkdXJhdGlvbjpFKGksITApP3ZvaWQgMDowfSksdGhpcy5hbGlnbkVsZW1lbnRzKCl9Zyh0KXtsZXQgZT10aGlzLmNyZWF0ZUVsZW1lbnQoXCJnXCIpO3JldHVybiB0P2UuYXR0cih7Y2xhc3M6XCJoaWdoY2hhcnRzLVwiK3R9KTplfWltYWdlKHQsZSxpLHMsbyxyKXtsZXQgbj17cHJlc2VydmVBc3BlY3RSYXRpbzpcIm5vbmVcIn07UChlKSYmKG4ueD1lKSxQKGkpJiYobi55PWkpLFAocykmJihuLndpZHRoPXMpLFAobykmJihuLmhlaWdodD1vKTtsZXQgYT10aGlzLmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiKS5hdHRyKG4pLGg9ZnVuY3Rpb24oZSl7YS5hdHRyKHtocmVmOnR9KSxyLmNhbGwoYSxlKX07aWYocil7YS5hdHRyKHtocmVmOlwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIn0pO2xldCBlPW5ldyBiLkltYWdlO3YoZSxcImxvYWRcIixoKSxlLnNyYz10LGUuY29tcGxldGUmJmgoe30pfWVsc2UgYS5hdHRyKHtocmVmOnR9KTtyZXR1cm4gYX1zeW1ib2wodCxlLGkscyxvLHIpe2xldCBuLGEsaCxsO2xldCBjPXRoaXMsdT0vXnVybFxcKCguKj8pXFwpJC8sZz11LnRlc3QodCksZj0hZyYmKHRoaXMuc3ltYm9sc1t0XT90OlwiY2lyY2xlXCIpLG09ZiYmdGhpcy5zeW1ib2xzW2ZdO2lmKG0pXCJudW1iZXJcIj09dHlwZW9mIGUmJihhPW0uY2FsbCh0aGlzLnN5bWJvbHMsTWF0aC5yb3VuZChlfHwwKSxNYXRoLnJvdW5kKGl8fDApLHN8fDAsb3x8MCxyKSksbj10aGlzLnBhdGgoYSksYy5zdHlsZWRNb2RlfHxuLmF0dHIoXCJmaWxsXCIsXCJub25lXCIpLFQobix7c3ltYm9sTmFtZTpmfHx2b2lkIDAseDplLHk6aSx3aWR0aDpzLGhlaWdodDpvfSksciYmVChuLHIpO2Vsc2UgaWYoZyl7aD10Lm1hdGNoKHUpWzFdO2xldCBzPW49dGhpcy5pbWFnZShoKTtzLmltZ3dpZHRoPUUociYmci53aWR0aCx5W2hdJiZ5W2hdLndpZHRoKSxzLmltZ2hlaWdodD1FKHImJnIuaGVpZ2h0LHlbaF0mJnlbaF0uaGVpZ2h0KSxsPXQ9PnQuYXR0cih7d2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHR9KSxbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLmZvckVhY2godD0+e3NbYCR7dH1TZXR0ZXJgXT1mdW5jdGlvbih0LGUpe3RoaXNbZV09dDtsZXR7YWxpZ25CeVRyYW5zbGF0ZTppLGVsZW1lbnQ6cyx3aWR0aDpvLGhlaWdodDpuLGltZ3dpZHRoOmEsaW1naGVpZ2h0Omh9PXRoaXMsbD1cIndpZHRoXCI9PT1lP2E6aCxkPTE7ciYmXCJ3aXRoaW5cIj09PXIuYmFja2dyb3VuZFNpemUmJm8mJm4mJmEmJmg/KGQ9TWF0aC5taW4oby9hLG4vaCksUyhzLHt3aWR0aDpNYXRoLnJvdW5kKGEqZCksaGVpZ2h0Ok1hdGgucm91bmQoaCpkKX0pKTpzJiZsJiZzLnNldEF0dHJpYnV0ZShlLGwpLCFpJiZhJiZoJiZ0aGlzLnRyYW5zbGF0ZSgoKG98fDApLWEqZCkvMiwoKG58fDApLWgqZCkvMil9fSksQyhlKSYmcy5hdHRyKHt4OmUseTppfSkscy5pc0ltZz0hMCxDKHMuaW1nd2lkdGgpJiZDKHMuaW1naGVpZ2h0KT9sKHMpOihzLmF0dHIoe3dpZHRoOjAsaGVpZ2h0OjB9KSxrKFwiaW1nXCIse29ubG9hZDpmdW5jdGlvbigpe2xldCB0PWRbYy5jaGFydEluZGV4XTswPT09dGhpcy53aWR0aCYmKE0odGhpcyx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi05OTllbVwifSkscC5ib2R5LmFwcGVuZENoaWxkKHRoaXMpKSx5W2hdPXt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH0scy5pbWd3aWR0aD10aGlzLndpZHRoLHMuaW1naGVpZ2h0PXRoaXMuaGVpZ2h0LHMuZWxlbWVudCYmbChzKSx0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKSxjLmltZ0NvdW50LS0sYy5pbWdDb3VudHx8IXR8fHQuaGFzTG9hZGVkfHx0Lm9ubG9hZCgpfSxzcmM6aH0pLHRoaXMuaW1nQ291bnQrKyl9cmV0dXJuIG59Y2xpcFJlY3QodCxlLGkscyl7cmV0dXJuIHRoaXMucmVjdCh0LGUsaSxzLDApfXRleHQodCxlLGkscyl7bGV0IG89e307aWYocyYmKHRoaXMuYWxsb3dIVE1MfHwhdGhpcy5mb3JFeHBvcnQpKXJldHVybiB0aGlzLmh0bWwodCxlLGkpO28ueD1NYXRoLnJvdW5kKGV8fDApLGkmJihvLnk9TWF0aC5yb3VuZChpKSksQyh0KSYmKG8udGV4dD10KTtsZXQgcj10aGlzLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIpLmF0dHIobyk7cmV0dXJuIHMmJighdGhpcy5mb3JFeHBvcnR8fHRoaXMuYWxsb3dIVE1MKXx8KHIueFNldHRlcj1mdW5jdGlvbih0LGUsaSl7bGV0IHM9aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpLG89aS5nZXRBdHRyaWJ1dGUoZSk7Zm9yKGxldCBpPTAscjtpPHMubGVuZ3RoO2krKykocj1zW2ldKS5nZXRBdHRyaWJ1dGUoZSk9PT1vJiZyLnNldEF0dHJpYnV0ZShlLHQpO2kuc2V0QXR0cmlidXRlKGUsdCl9KSxyfWZvbnRNZXRyaWNzKHQpe2xldCBlPWooby5wcm90b3R5cGUuZ2V0U3R5bGUuY2FsbCh0LFwiZm9udC1zaXplXCIpfHwwKSxpPWU8MjQ/ZSszOk1hdGgucm91bmQoMS4yKmUpLHM9TWF0aC5yb3VuZCguOCppKTtyZXR1cm57aDppLGI6cyxmOmV9fXJvdENvcnIodCxlLGkpe2xldCBzPXQ7cmV0dXJuIGUmJmkmJihzPU1hdGgubWF4KHMqTWF0aC5jb3MoZSpjKSw0KSkse3g6LXQvMypNYXRoLnNpbihlKmMpLHk6c319cGF0aFRvU2VnbWVudHModCl7bGV0IGU9W10saT1bXSxzPXtBOjgsQzo3LEg6MixMOjMsTTozLFE6NSxTOjUsVDozLFY6Mn07Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspTyhpWzBdKSYmUCh0W29dKSYmaS5sZW5ndGg9PT1zW2lbMF0udG9VcHBlckNhc2UoKV0mJnQuc3BsaWNlKG8sMCxpWzBdLnJlcGxhY2UoXCJNXCIsXCJMXCIpLnJlcGxhY2UoXCJtXCIsXCJsXCIpKSxcInN0cmluZ1wiPT10eXBlb2YgdFtvXSYmKGkubGVuZ3RoJiZlLnB1c2goaS5zbGljZSgwKSksaS5sZW5ndGg9MCksaS5wdXNoKHRbb10pO3JldHVybiBlLnB1c2goaS5zbGljZSgwKSksZX1sYWJlbCh0LGUsaSxzLG8sbixhLGgsbCl7cmV0dXJuIG5ldyByKHRoaXMsdCxlLGkscyxvLG4sYSxoLGwpfWFsaWduRWxlbWVudHMoKXt0aGlzLmFsaWduZWRPYmplY3RzLmZvckVhY2godD0+dC5hbGlnbigpKX19cmV0dXJuIFQoQi5wcm90b3R5cGUse0VsZW1lbnQ6byxTVkdfTlM6eCxlc2NhcGVzOntcIiZcIjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsXCInXCI6XCImIzM5O1wiLCdcIic6XCImcXVvdDtcIn0sc3ltYm9sczpuLGRyYXc6bX0pLHMucmVnaXN0ZXJSZW5kZXJlclR5cGUoXCJzdmdcIixCLCEwKSxCfSksaShlLFwiQ29yZS9SZW5kZXJlci9IVE1ML0hUTUxFbGVtZW50LmpzXCIsW2VbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0VsZW1lbnQuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7bGV0e2NvbXBvc2VkOnN9PXQse2NzczpvLGRlZmluZWQ6cixleHRlbmQ6bixwdXNoVW5pcXVlOmEscEludDpofT1pO2NsYXNzIGwgZXh0ZW5kcyBle3N0YXRpYyBjb21wb3NlKHQpe2lmKGEocyx0aGlzLmNvbXBvc2UpKXtsZXQgZT1sLnByb3RvdHlwZSxpPXQucHJvdG90eXBlO2kuZ2V0U3BhbkNvcnJlY3Rpb249ZS5nZXRTcGFuQ29ycmVjdGlvbixpLmh0bWxDc3M9ZS5odG1sQ3NzLGkuaHRtbEdldEJCb3g9ZS5odG1sR2V0QkJveCxpLmh0bWxVcGRhdGVUcmFuc2Zvcm09ZS5odG1sVXBkYXRlVHJhbnNmb3JtLGkuc2V0U3BhblJvdGF0aW9uPWUuc2V0U3BhblJvdGF0aW9ufXJldHVybiB0fWdldFNwYW5Db3JyZWN0aW9uKHQsZSxpKXt0aGlzLnhDb3JyPS10KmksdGhpcy55Q29ycj0tZX1odG1sQ3NzKHQpe2xldCBlO2xldHtlbGVtZW50Oml9PXRoaXMscz1cIlNQQU5cIj09PWkudGFnTmFtZSYmdCYmXCJ3aWR0aFwiaW4gdCxyPXMmJnQud2lkdGg7cmV0dXJuIHMmJihkZWxldGUgdC53aWR0aCx0aGlzLnRleHRXaWR0aD1oKHIpfHx2b2lkIDAsZT0hMCksdD8udGV4dE92ZXJmbG93PT09XCJlbGxpcHNpc1wiJiYodC53aGl0ZVNwYWNlPVwibm93cmFwXCIsdC5vdmVyZmxvdz1cImhpZGRlblwiKSxuKHRoaXMuc3R5bGVzLHQpLG8oaSx0KSxlJiZ0aGlzLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKSx0aGlzfWh0bWxHZXRCQm94KCl7bGV0e2VsZW1lbnQ6dH09dGhpcztyZXR1cm57eDp0Lm9mZnNldExlZnQseTp0Lm9mZnNldFRvcCx3aWR0aDp0Lm9mZnNldFdpZHRoLGhlaWdodDp0Lm9mZnNldEhlaWdodH19aHRtbFVwZGF0ZVRyYW5zZm9ybSgpe2lmKCF0aGlzLmFkZGVkKXt0aGlzLmFsaWduT25BZGQ9ITA7cmV0dXJufWxldHtlbGVtZW50OnQscmVuZGVyZXI6ZSxyb3RhdGlvbjppLHN0eWxlczpzLHRleHRBbGlnbjpuPVwibGVmdFwiLHRleHRXaWR0aDphLHRyYW5zbGF0ZVg6aD0wLHRyYW5zbGF0ZVk6bD0wLHg6ZD0wLHk6Yz0wfT10aGlzLHA9e2xlZnQ6MCxjZW50ZXI6LjUscmlnaHQ6MX1bbl0sdT1zPy53aGl0ZVNwYWNlO2lmKG8odCx7bWFyZ2luTGVmdDpgJHtofXB4YCxtYXJnaW5Ub3A6YCR7bH1weGB9KSxcIlNQQU5cIj09PXQudGFnTmFtZSl7bGV0IHM9W2ksbix0LmlubmVySFRNTCxhLHRoaXMudGV4dEFsaWduXS5qb2luKFwiLFwiKSxoLGw9ITE7aWYoYSE9PXRoaXMub2xkVGV4dFdpZHRoKXtsZXQgZT10aGlzLnRleHRQeExlbmd0aD90aGlzLnRleHRQeExlbmd0aDoobyh0LHt3aWR0aDpcIlwiLHdoaXRlU3BhY2U6dXx8XCJub3dyYXBcIn0pLHQub2Zmc2V0V2lkdGgpLHM9YXx8MDsocz50aGlzLm9sZFRleHRXaWR0aHx8ZT5zKSYmKC9bIFxcLV0vLnRlc3QodC50ZXh0Q29udGVudHx8dC5pbm5lclRleHQpfHxcImVsbGlwc2lzXCI9PT10LnN0eWxlLnRleHRPdmVyZmxvdykmJihvKHQse3dpZHRoOmU+c3x8aT9hK1wicHhcIjpcImF1dG9cIixkaXNwbGF5OlwiYmxvY2tcIix3aGl0ZVNwYWNlOnV8fFwibm9ybWFsXCJ9KSx0aGlzLm9sZFRleHRXaWR0aD1hLGw9ITApfXRoaXMuaGFzQm94V2lkdGhDaGFuZ2VkPWwscyE9PXRoaXMuY1RUJiYoaD1lLmZvbnRNZXRyaWNzKHQpLmIscihpKSYmKGkhPT0odGhpcy5vbGRSb3RhdGlvbnx8MCl8fG4hPT10aGlzLm9sZEFsaWduKSYmdGhpcy5zZXRTcGFuUm90YXRpb24oaSxwLGgpLHRoaXMuZ2V0U3BhbkNvcnJlY3Rpb24oIXIoaSkmJnRoaXMudGV4dFB4TGVuZ3RofHx0Lm9mZnNldFdpZHRoLGgscCkpLG8odCx7bGVmdDpkKyh0aGlzLnhDb3JyfHwwKStcInB4XCIsdG9wOmMrKHRoaXMueUNvcnJ8fDApK1wicHhcIn0pLHRoaXMuY1RUPXMsdGhpcy5vbGRSb3RhdGlvbj1pLHRoaXMub2xkQWxpZ249bn19c2V0U3BhblJvdGF0aW9uKHQsZSxpKXtvKHRoaXMuZWxlbWVudCx7dHJhbnNmb3JtOmByb3RhdGUoJHt0fWRlZylgLHRyYW5zZm9ybU9yaWdpbjpgJHsxMDAqZX0lICR7aX1weGB9KX19cmV0dXJuIGx9KSxpKGUsXCJDb3JlL1JlbmRlcmVyL0hUTUwvSFRNTFJlbmRlcmVyLmpzXCIsW2VbXCJDb3JlL1JlbmRlcmVyL0hUTUwvQVNULmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0VsZW1lbnQuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR1JlbmRlcmVyLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyxvKXtsZXR7Y29tcG9zZWQ6cn09ZSx7YXR0cjpuLGNyZWF0ZUVsZW1lbnQ6YSxleHRlbmQ6aCxwaWNrOmwscHVzaFVuaXF1ZTpkfT1vO2NsYXNzIGMgZXh0ZW5kcyBze3N0YXRpYyBjb21wb3NlKHQpe2lmKGQocix0aGlzLmNvbXBvc2UpKXtsZXQgZT1jLnByb3RvdHlwZSxpPXQucHJvdG90eXBlO2kuaHRtbD1lLmh0bWx9cmV0dXJuIHR9aHRtbChlLHMsbyl7bGV0IHI9dGhpcy5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxkPXIuZWxlbWVudCxjPXIucmVuZGVyZXIscD1mdW5jdGlvbih0LGUpe1tcIm9wYWNpdHlcIixcInZpc2liaWxpdHlcIl0uZm9yRWFjaChmdW5jdGlvbihzKXt0W3MrXCJTZXR0ZXJcIl09ZnVuY3Rpb24obyxyLG4pe2xldCBhPXQuZGl2P3QuZGl2LnN0eWxlOmU7aS5wcm90b3R5cGVbcytcIlNldHRlclwiXS5jYWxsKHRoaXMsbyxyLG4pLGEmJihhW3JdPW8pfX0pLHQuYWRkZWRTZXR0ZXJzPSEwfTtyZXR1cm4gci50ZXh0U2V0dGVyPWZ1bmN0aW9uKGUpe2UhPT10aGlzLnRleHRTdHImJihkZWxldGUgdGhpcy5iQm94LGRlbGV0ZSB0aGlzLm9sZFRleHRXaWR0aCx0LnNldEVsZW1lbnRIVE1MKHRoaXMuZWxlbWVudCxsKGUsXCJcIikpLHRoaXMudGV4dFN0cj1lLHIuZG9UcmFuc2Zvcm09ITApfSxwKHIsci5lbGVtZW50LnN0eWxlKSxyLnhTZXR0ZXI9ci55U2V0dGVyPXIuYWxpZ25TZXR0ZXI9ci5yb3RhdGlvblNldHRlcj1mdW5jdGlvbih0LGUpe1wiYWxpZ25cIj09PWU/ci5hbGlnblZhbHVlPXIudGV4dEFsaWduPXQ6cltlXT10LHIuZG9UcmFuc2Zvcm09ITB9LHIuYWZ0ZXJTZXR0ZXJzPWZ1bmN0aW9uKCl7dGhpcy5kb1RyYW5zZm9ybSYmKHRoaXMuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpLHRoaXMuZG9UcmFuc2Zvcm09ITEpfSxyLmF0dHIoe3RleHQ6ZSx4Ok1hdGgucm91bmQocykseTpNYXRoLnJvdW5kKG8pfSkuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCJ9KSxjLnN0eWxlZE1vZGV8fHIuY3NzKHtmb250RmFtaWx5OnRoaXMuc3R5bGUuZm9udEZhbWlseSxmb250U2l6ZTp0aGlzLnN0eWxlLmZvbnRTaXplfSksZC5zdHlsZS53aGl0ZVNwYWNlPVwibm93cmFwXCIsci5jc3M9ci5odG1sQ3NzLHIuYWRkPWZ1bmN0aW9uKHQpe2xldCBlLGk7bGV0IHM9Yy5ib3gucGFyZW50Tm9kZSxvPVtdO2lmKHRoaXMucGFyZW50R3JvdXA9dCx0KXtpZighKGU9dC5kaXYpKXtmb3IoaT10O2k7KW8ucHVzaChpKSxpPWkucGFyZW50R3JvdXA7by5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgaTtsZXQgbD1uKHQuZWxlbWVudCxcImNsYXNzXCIpLGQ9dC5jc3M7ZnVuY3Rpb24gYyhlLGkpe3RbaV09ZSxcInRyYW5zbGF0ZVhcIj09PWk/Zy5sZWZ0PWUrXCJweFwiOmcudG9wPWUrXCJweFwiLHQuZG9UcmFuc2Zvcm09ITB9bGV0IHU9dC5zdHlsZXN8fHt9O2U9dC5kaXY9dC5kaXZ8fGEoXCJkaXZcIixsP3tjbGFzc05hbWU6bH06dm9pZCAwLHtwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDoodC50cmFuc2xhdGVYfHwwKStcInB4XCIsdG9wOih0LnRyYW5zbGF0ZVl8fDApK1wicHhcIixkaXNwbGF5OnQuZGlzcGxheSxvcGFjaXR5OnQub3BhY2l0eSx2aXNpYmlsaXR5OnQudmlzaWJpbGl0eX0sZXx8cyk7bGV0IGc9ZS5zdHlsZTtoKHQse2NsYXNzU2V0dGVyOihpPWUsZnVuY3Rpb24odCl7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsdCksaS5jbGFzc05hbWU9dH0pLGNzczpmdW5jdGlvbihlKXtyZXR1cm4gZC5jYWxsKHQsZSksW1wiY3Vyc29yXCIsXCJwb2ludGVyRXZlbnRzXCJdLmZvckVhY2godD0+e2VbdF0mJihnW3RdPWVbdF0pfSksdH0sb246ZnVuY3Rpb24oKXtyZXR1cm4gb1swXS5kaXYmJnIub24uYXBwbHkoe2VsZW1lbnQ6b1swXS5kaXYsb25FdmVudHM6dC5vbkV2ZW50c30sYXJndW1lbnRzKSx0fSx0cmFuc2xhdGVYU2V0dGVyOmMsdHJhbnNsYXRlWVNldHRlcjpjfSksdC5hZGRlZFNldHRlcnN8fHAodCksdC5jc3ModSl9KX19ZWxzZSBlPXM7cmV0dXJuIGUuYXBwZW5kQ2hpbGQoZCksci5hZGRlZD0hMCxyLmFsaWduT25BZGQmJnIuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpLHJ9LHJ9fXJldHVybiBjfSksaShlLFwiQ29yZS9BeGlzL0F4aXNEZWZhdWx0cy5qc1wiLFtdLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4oZT10fHwodD17fSkpLnhBeGlzPXthbGlnblRpY2tzOiEwLGFsbG93RGVjaW1hbHM6dm9pZCAwLHBhbm5pbmdFbmFibGVkOiEwLHpJbmRleDoyLHpvb21FbmFibGVkOiEwLGRhdGVUaW1lTGFiZWxGb3JtYXRzOnttaWxsaXNlY29uZDp7bWFpbjpcIiVIOiVNOiVTLiVMXCIscmFuZ2U6ITF9LHNlY29uZDp7bWFpbjpcIiVIOiVNOiVTXCIscmFuZ2U6ITF9LG1pbnV0ZTp7bWFpbjpcIiVIOiVNXCIscmFuZ2U6ITF9LGhvdXI6e21haW46XCIlSDolTVwiLHJhbmdlOiExfSxkYXk6e21haW46XCIlZSAlYlwifSx3ZWVrOnttYWluOlwiJWUgJWJcIn0sbW9udGg6e21haW46XCIlYiAnJXlcIn0seWVhcjp7bWFpbjpcIiVZXCJ9fSxlbmRPblRpY2s6ITEsZ3JpZExpbmVEYXNoU3R5bGU6XCJTb2xpZFwiLGdyaWRaSW5kZXg6MSxsYWJlbHM6e2F1dG9Sb3RhdGlvbkxpbWl0OjgwLGRpc3RhbmNlOjE1LGVuYWJsZWQ6ITAsaW5kZW50YXRpb246MTAsb3ZlcmZsb3c6XCJqdXN0aWZ5XCIscGFkZGluZzo1LHJlc2VydmVTcGFjZTp2b2lkIDAscm90YXRpb246dm9pZCAwLHN0YWdnZXJMaW5lczowLHN0ZXA6MCx1c2VIVE1MOiExLHpJbmRleDo3LHN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIwLjhlbVwifX0sbWF4UGFkZGluZzouMDEsbWlub3JHcmlkTGluZURhc2hTdHlsZTpcIlNvbGlkXCIsbWlub3JUaWNrTGVuZ3RoOjIsbWlub3JUaWNrUG9zaXRpb246XCJvdXRzaWRlXCIsbWlub3JUaWNrc1Blck1ham9yOjUsbWluUGFkZGluZzouMDEsb2Zmc2V0OnZvaWQgMCxyZXZlcnNlZDp2b2lkIDAscmV2ZXJzZWRTdGFja3M6ITEsc2hvd0VtcHR5OiEwLHNob3dGaXJzdExhYmVsOiEwLHNob3dMYXN0TGFiZWw6ITAsc3RhcnRPZldlZWs6MSxzdGFydE9uVGljazohMSx0aWNrTGVuZ3RoOjEwLHRpY2tQaXhlbEludGVydmFsOjEwMCx0aWNrbWFya1BsYWNlbWVudDpcImJldHdlZW5cIix0aWNrUG9zaXRpb246XCJvdXRzaWRlXCIsdGl0bGU6e2FsaWduOlwibWlkZGxlXCIsdXNlSFRNTDohMSx4OjAseTowLHN0eWxlOntjb2xvcjpcIiM2NjY2NjZcIixmb250U2l6ZTpcIjAuOGVtXCJ9fSx0eXBlOlwibGluZWFyXCIsdW5pcXVlTmFtZXM6ITAsdmlzaWJsZTohMCxtaW5vckdyaWRMaW5lQ29sb3I6XCIjZjJmMmYyXCIsbWlub3JHcmlkTGluZVdpZHRoOjEsbWlub3JUaWNrQ29sb3I6XCIjOTk5OTk5XCIsbGluZUNvbG9yOlwiIzMzMzMzM1wiLGxpbmVXaWR0aDoxLGdyaWRMaW5lQ29sb3I6XCIjZTZlNmU2XCIsZ3JpZExpbmVXaWR0aDp2b2lkIDAsdGlja0NvbG9yOlwiIzMzMzMzM1wifSxlLnlBeGlzPXtyZXZlcnNlZFN0YWNrczohMCxlbmRPblRpY2s6ITAsbWF4UGFkZGluZzouMDUsbWluUGFkZGluZzouMDUsdGlja1BpeGVsSW50ZXJ2YWw6NzIsc2hvd0xhc3RMYWJlbDohMCxsYWJlbHM6e3g6dm9pZCAwfSxzdGFydE9uVGljazohMCx0aXRsZTp7dGV4dDpcIlZhbHVlc1wifSxzdGFja0xhYmVsczp7YW5pbWF0aW9uOnt9LGFsbG93T3ZlcmxhcDohMSxlbmFibGVkOiExLGNyb3A6ITAsb3ZlcmZsb3c6XCJqdXN0aWZ5XCIsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7bGV0e251bWJlckZvcm1hdHRlcjp0fT10aGlzLmF4aXMuY2hhcnQ7cmV0dXJuIHQodGhpcy50b3RhbHx8MCwtMSl9LHN0eWxlOntjb2xvcjpcIiMwMDAwMDBcIixmb250U2l6ZTpcIjAuN2VtXCIsZm9udFdlaWdodDpcImJvbGRcIix0ZXh0T3V0bGluZTpcIjFweCBjb250cmFzdFwifX0sZ3JpZExpbmVXaWR0aDoxLGxpbmVXaWR0aDowfSx0fSksaShlLFwiQ29yZS9Gb3VuZGF0aW9uLmpzXCIsW2VbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCl7dmFyIGU7bGV0e2FkZEV2ZW50OmksaXNGdW5jdGlvbjpzLG9iamVjdEVhY2g6byxyZW1vdmVFdmVudDpyfT10O3JldHVybihlfHwoZT17fSkpLnJlZ2lzdGVyRXZlbnRPcHRpb25zPWZ1bmN0aW9uKHQsZSl7dC5ldmVudE9wdGlvbnM9dC5ldmVudE9wdGlvbnN8fHt9LG8oZS5ldmVudHMsZnVuY3Rpb24oZSxvKXt0LmV2ZW50T3B0aW9uc1tvXSE9PWUmJih0LmV2ZW50T3B0aW9uc1tvXSYmKHIodCxvLHQuZXZlbnRPcHRpb25zW29dKSxkZWxldGUgdC5ldmVudE9wdGlvbnNbb10pLHMoZSkmJih0LmV2ZW50T3B0aW9uc1tvXT1lLGkodCxvLGUse29yZGVyOjB9KSkpfSl9LGV9KSxpKGUsXCJDb3JlL0F4aXMvVGljay5qc1wiLFtlW1wiQ29yZS9UZW1wbGF0aW5nLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7bGV0e2RlZzJyYWQ6c309ZSx7Y2xhbXA6byxjb3JyZWN0RmxvYXQ6cixkZWZpbmVkOm4sZGVzdHJveU9iamVjdFByb3BlcnRpZXM6YSxleHRlbmQ6aCxmaXJlRXZlbnQ6bCxpc051bWJlcjpkLG1lcmdlOmMsb2JqZWN0RWFjaDpwLHBpY2s6dX09aTtyZXR1cm4gY2xhc3N7Y29uc3RydWN0b3IodCxlLGkscyxvKXt0aGlzLmlzTmV3PSEwLHRoaXMuaXNOZXdMYWJlbD0hMCx0aGlzLmF4aXM9dCx0aGlzLnBvcz1lLHRoaXMudHlwZT1pfHxcIlwiLHRoaXMucGFyYW1ldGVycz1vfHx7fSx0aGlzLnRpY2ttYXJrT2Zmc2V0PXRoaXMucGFyYW1ldGVycy50aWNrbWFya09mZnNldCx0aGlzLm9wdGlvbnM9dGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnMsbCh0aGlzLFwiaW5pdFwiKSxpfHxzfHx0aGlzLmFkZExhYmVsKCl9YWRkTGFiZWwoKXtsZXQgZT10aGlzLGk9ZS5heGlzLHM9aS5vcHRpb25zLG89aS5jaGFydCxhPWkuY2F0ZWdvcmllcyxjPWkubG9nYXJpdGhtaWMscD1pLm5hbWVzLGc9ZS5wb3MsZj11KGUub3B0aW9ucyYmZS5vcHRpb25zLmxhYmVscyxzLmxhYmVscyksbT1pLnRpY2tQb3NpdGlvbnMseD1nPT09bVswXSx5PWc9PT1tW20ubGVuZ3RoLTFdLGI9KCFmLnN0ZXB8fDE9PT1mLnN0ZXApJiYxPT09aS50aWNrSW50ZXJ2YWwsdj1tLmluZm8sUz1lLmxhYmVsLGssTSxDLHc9dGhpcy5wYXJhbWV0ZXJzLmNhdGVnb3J5fHwoYT91KGFbZ10scFtnXSxnKTpnKTtjJiZkKHcpJiYodz1yKGMubGluMmxvZyh3KSkpLGkuZGF0ZVRpbWUmJih2P2s9KE09by50aW1lLnJlc29sdmVEVExGb3JtYXQocy5kYXRlVGltZUxhYmVsRm9ybWF0c1shcy5ncmlkJiZ2LmhpZ2hlclJhbmtzW2ddfHx2LnVuaXROYW1lXSkpLm1haW46ZCh3KSYmKGs9aS5kYXRlVGltZS5nZXRYRGF0ZUZvcm1hdCh3LHMuZGF0ZVRpbWVMYWJlbEZvcm1hdHN8fHt9KSkpLGUuaXNGaXJzdD14LGUuaXNMYXN0PXk7bGV0IFQ9e2F4aXM6aSxjaGFydDpvLGRhdGVUaW1lTGFiZWxGb3JtYXQ6ayxpc0ZpcnN0OngsaXNMYXN0OnkscG9zOmcsdGljazplLHRpY2tQb3NpdGlvbkluZm86dix2YWx1ZTp3fTtsKHRoaXMsXCJsYWJlbEZvcm1hdFwiLFQpO2xldCBBPWU9PmYuZm9ybWF0dGVyP2YuZm9ybWF0dGVyLmNhbGwoZSxlKTpmLmZvcm1hdD8oZS50ZXh0PWkuZGVmYXVsdExhYmVsRm9ybWF0dGVyLmNhbGwoZSxlKSx0LmZvcm1hdChmLmZvcm1hdCxlLG8pKTppLmRlZmF1bHRMYWJlbEZvcm1hdHRlci5jYWxsKGUsZSksUD1BLmNhbGwoVCxUKSxMPU0mJk0ubGlzdDtMP2Uuc2hvcnRlbkxhYmVsPWZ1bmN0aW9uKCl7Zm9yKEM9MDtDPEwubGVuZ3RoO0MrKylpZihoKFQse2RhdGVUaW1lTGFiZWxGb3JtYXQ6TFtDXX0pLFMuYXR0cih7dGV4dDpBLmNhbGwoVCxUKX0pLFMuZ2V0QkJveCgpLndpZHRoPGkuZ2V0U2xvdFdpZHRoKGUpLTIqZi5wYWRkaW5nKXJldHVybjtTLmF0dHIoe3RleHQ6XCJcIn0pfTplLnNob3J0ZW5MYWJlbD12b2lkIDAsYiYmaS5fYWRkZWRQbG90TEImJmUubW92ZUxhYmVsKFAsZiksbihTKXx8ZS5tb3ZlZExhYmVsP1MmJlMudGV4dFN0ciE9PVAmJiFiJiYoIVMudGV4dFdpZHRofHxmLnN0eWxlLndpZHRofHxTLnN0eWxlcy53aWR0aHx8Uy5jc3Moe3dpZHRoOm51bGx9KSxTLmF0dHIoe3RleHQ6UH0pLFMudGV4dFB4TGVuZ3RoPVMuZ2V0QkJveCgpLndpZHRoKTooZS5sYWJlbD1TPWUuY3JlYXRlTGFiZWwoUCxmKSxlLnJvdGF0aW9uPTApfWNyZWF0ZUxhYmVsKHQsZSxpKXtsZXQgcz10aGlzLmF4aXMsbz1zLmNoYXJ0LHI9bih0KSYmZS5lbmFibGVkP28ucmVuZGVyZXIudGV4dCh0LGk/LngsaT8ueSxlLnVzZUhUTUwpLmFkZChzLmxhYmVsR3JvdXApOnZvaWQgMDtyZXR1cm4gciYmKG8uc3R5bGVkTW9kZXx8ci5jc3MoYyhlLnN0eWxlKSksci50ZXh0UHhMZW5ndGg9ci5nZXRCQm94KCkud2lkdGgpLHJ9ZGVzdHJveSgpe2EodGhpcyx0aGlzLmF4aXMpfWdldFBvc2l0aW9uKHQsZSxpLHMpe2xldCBuPXRoaXMuYXhpcyxhPW4uY2hhcnQsaD1zJiZhLm9sZENoYXJ0SGVpZ2h0fHxhLmNoYXJ0SGVpZ2h0LGQ9e3g6dD9yKG4udHJhbnNsYXRlKGUraSx2b2lkIDAsdm9pZCAwLHMpK24udHJhbnNCKTpuLmxlZnQrbi5vZmZzZXQrKG4ub3Bwb3NpdGU/KHMmJmEub2xkQ2hhcnRXaWR0aHx8YS5jaGFydFdpZHRoKS1uLnJpZ2h0LW4ubGVmdDowKSx5OnQ/aC1uLmJvdHRvbStuLm9mZnNldC0obi5vcHBvc2l0ZT9uLmhlaWdodDowKTpyKGgtbi50cmFuc2xhdGUoZStpLHZvaWQgMCx2b2lkIDAscyktbi50cmFuc0IpfTtyZXR1cm4gZC55PW8oZC55LC0xZTUsMWU1KSxsKHRoaXMsXCJhZnRlckdldFBvc2l0aW9uXCIse3BvczpkfSksZH1nZXRMYWJlbFBvc2l0aW9uKHQsZSxpLG8scixhLGgsZCl7bGV0IGMscDtsZXQgZz10aGlzLmF4aXMsZj1nLnRyYW5zQSxtPWcuaXNMaW5rZWQmJmcubGlua2VkUGFyZW50P2cubGlua2VkUGFyZW50LnJldmVyc2VkOmcucmV2ZXJzZWQseD1nLnN0YWdnZXJMaW5lcyx5PWcudGlja1JvdENvcnJ8fHt4OjAseTowfSxiPW98fGcucmVzZXJ2ZVNwYWNlRGVmYXVsdD8wOi1nLmxhYmVsT2Zmc2V0KihcImNlbnRlclwiPT09Zy5sYWJlbEFsaWduPy41OjEpLHY9ci5kaXN0YW5jZSxTPXt9O3JldHVybiBjPTA9PT1nLnNpZGU/aS5yb3RhdGlvbj8tdjotaS5nZXRCQm94KCkuaGVpZ2h0OjI9PT1nLnNpZGU/eS55K3Y6TWF0aC5jb3MoaS5yb3RhdGlvbipzKSooeS55LWkuZ2V0QkJveCghMSwwKS5oZWlnaHQvMiksbihyLnkpJiYoYz0wPT09Zy5zaWRlJiZnLmhvcml6P3IueStjOnIueSksdD10K3Uoci54LFswLDEsMCwtMV1bZy5zaWRlXSp2KStiK3kueC0oYSYmbz9hKmYqKG0/LTE6MSk6MCksZT1lK2MtKGEmJiFvP2EqZioobT8xOi0xKTowKSx4JiYocD1oLyhkfHwxKSV4LGcub3Bwb3NpdGUmJihwPXgtcC0xKSxlKz1wKihnLmxhYmVsT2Zmc2V0L3gpKSxTLng9dCxTLnk9TWF0aC5yb3VuZChlKSxsKHRoaXMsXCJhZnRlckdldExhYmVsUG9zaXRpb25cIix7cG9zOlMsdGlja21hcmtPZmZzZXQ6YSxpbmRleDpofSksU31nZXRMYWJlbFNpemUoKXtyZXR1cm4gdGhpcy5sYWJlbD90aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXo/XCJoZWlnaHRcIjpcIndpZHRoXCJdOjB9Z2V0TWFya1BhdGgodCxlLGkscyxvLHIpe3JldHVybiByLmNyaXNwTGluZShbW1wiTVwiLHQsZV0sW1wiTFwiLHQrKG8/MDotaSksZSsobz9pOjApXV0scyl9aGFuZGxlT3ZlcmZsb3codCl7bGV0IGU9dGhpcy5heGlzLGk9ZS5vcHRpb25zLmxhYmVscyxvPXQueCxyPWUuY2hhcnQuY2hhcnRXaWR0aCxuPWUuY2hhcnQuc3BhY2luZyxhPXUoZS5sYWJlbExlZnQsTWF0aC5taW4oZS5wb3MsblszXSkpLGg9dShlLmxhYmVsUmlnaHQsTWF0aC5tYXgoZS5pc1JhZGlhbD8wOmUucG9zK2UubGVuLHItblsxXSkpLGw9dGhpcy5sYWJlbCxkPXRoaXMucm90YXRpb24sYz17bGVmdDowLGNlbnRlcjouNSxyaWdodDoxfVtlLmxhYmVsQWxpZ258fGwuYXR0cihcImFsaWduXCIpXSxwPWwuZ2V0QkJveCgpLndpZHRoLGc9ZS5nZXRTbG90V2lkdGgodGhpcyksZj17fSxtPWcseD0xLHk7ZHx8XCJqdXN0aWZ5XCIhPT1pLm92ZXJmbG93P2Q8MCYmby1jKnA8YT95PU1hdGgucm91bmQoby9NYXRoLmNvcyhkKnMpLWEpOmQ+MCYmbytjKnA+aCYmKHk9TWF0aC5yb3VuZCgoci1vKS9NYXRoLmNvcyhkKnMpKSk6KG8tYypwPGE/bT10LngrbSooMS1jKS1hOm8rKDEtYykqcD5oJiYobT1oLXQueCttKmMseD0tMSksKG09TWF0aC5taW4oZyxtKSk8ZyYmXCJjZW50ZXJcIj09PWUubGFiZWxBbGlnbiYmKHQueCs9eCooZy1tLWMqKGctTWF0aC5taW4ocCxtKSkpKSwocD5tfHxlLmF1dG9Sb3RhdGlvbiYmKGwuc3R5bGVzfHx7fSkud2lkdGgpJiYoeT1tKSkseSYmKHRoaXMuc2hvcnRlbkxhYmVsP3RoaXMuc2hvcnRlbkxhYmVsKCk6KGYud2lkdGg9TWF0aC5mbG9vcih5KStcInB4XCIsKGkuc3R5bGV8fHt9KS50ZXh0T3ZlcmZsb3d8fChmLnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIpLGwuY3NzKGYpKSl9bW92ZUxhYmVsKHQsZSl7bGV0IGk9dGhpcyxzPWkubGFiZWwsbz1pLmF4aXMscj0hMSxuO3MmJnMudGV4dFN0cj09PXQ/KGkubW92ZWRMYWJlbD1zLHI9ITAsZGVsZXRlIGkubGFiZWwpOnAoby50aWNrcyxmdW5jdGlvbihlKXtyfHxlLmlzTmV3fHxlPT09aXx8IWUubGFiZWx8fGUubGFiZWwudGV4dFN0ciE9PXR8fChpLm1vdmVkTGFiZWw9ZS5sYWJlbCxyPSEwLGUubGFiZWxQb3M9aS5tb3ZlZExhYmVsLnh5LGRlbGV0ZSBlLmxhYmVsKX0pLCFyJiYoaS5sYWJlbFBvc3x8cykmJihuPWkubGFiZWxQb3N8fHMueHksaS5tb3ZlZExhYmVsPWkuY3JlYXRlTGFiZWwodCxlLG4pLGkubW92ZWRMYWJlbCYmaS5tb3ZlZExhYmVsLmF0dHIoe29wYWNpdHk6MH0pKX1yZW5kZXIodCxlLGkpe2xldCBzPXRoaXMuYXhpcyxvPXMuaG9yaXoscj10aGlzLnBvcyxuPXUodGhpcy50aWNrbWFya09mZnNldCxzLnRpY2ttYXJrT2Zmc2V0KSxhPXRoaXMuZ2V0UG9zaXRpb24obyxyLG4sZSksaD1hLngsZD1hLnksYz1vJiZoPT09cy5wb3Mrcy5sZW58fCFvJiZkPT09cy5wb3M/LTE6MSxwPXUoaSx0aGlzLmxhYmVsJiZ0aGlzLmxhYmVsLm5ld09wYWNpdHksMSk7aT11KGksMSksdGhpcy5pc0FjdGl2ZT0hMCx0aGlzLnJlbmRlckdyaWRMaW5lKGUsaSxjKSx0aGlzLnJlbmRlck1hcmsoYSxpLGMpLHRoaXMucmVuZGVyTGFiZWwoYSxlLHAsdCksdGhpcy5pc05ldz0hMSxsKHRoaXMsXCJhZnRlclJlbmRlclwiKX1yZW5kZXJHcmlkTGluZSh0LGUsaSl7bGV0IHM9dGhpcy5heGlzLG89cy5vcHRpb25zLHI9e30sbj10aGlzLnBvcyxhPXRoaXMudHlwZSxoPXUodGhpcy50aWNrbWFya09mZnNldCxzLnRpY2ttYXJrT2Zmc2V0KSxsPXMuY2hhcnQucmVuZGVyZXIsZD10aGlzLmdyaWRMaW5lLGMscD1vLmdyaWRMaW5lV2lkdGgsZz1vLmdyaWRMaW5lQ29sb3IsZj1vLmdyaWRMaW5lRGFzaFN0eWxlO1wibWlub3JcIj09PXRoaXMudHlwZSYmKHA9by5taW5vckdyaWRMaW5lV2lkdGgsZz1vLm1pbm9yR3JpZExpbmVDb2xvcixmPW8ubWlub3JHcmlkTGluZURhc2hTdHlsZSksZHx8KHMuY2hhcnQuc3R5bGVkTW9kZXx8KHIuc3Ryb2tlPWcscltcInN0cm9rZS13aWR0aFwiXT1wfHwwLHIuZGFzaHN0eWxlPWYpLGF8fChyLnpJbmRleD0xKSx0JiYoZT0wKSx0aGlzLmdyaWRMaW5lPWQ9bC5wYXRoKCkuYXR0cihyKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrKGE/YStcIi1cIjpcIlwiKStcImdyaWQtbGluZVwiKS5hZGQocy5ncmlkR3JvdXApKSxkJiYoYz1zLmdldFBsb3RMaW5lUGF0aCh7dmFsdWU6bitoLGxpbmVXaWR0aDpkLnN0cm9rZVdpZHRoKCkqaSxmb3JjZTpcInBhc3NcIixvbGQ6dCxhY3Jvc3NQYW5lczohMX0pKSYmZFt0fHx0aGlzLmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDpjLG9wYWNpdHk6ZX0pfXJlbmRlck1hcmsodCxlLGkpe2xldCBzPXRoaXMuYXhpcyxvPXMub3B0aW9ucyxyPXMuY2hhcnQucmVuZGVyZXIsbj10aGlzLnR5cGUsYT1zLnRpY2tTaXplKG4/bitcIlRpY2tcIjpcInRpY2tcIiksaD10LngsbD10LnksZD11KG9bXCJtaW5vclwiIT09bj9cInRpY2tXaWR0aFwiOlwibWlub3JUaWNrV2lkdGhcIl0sIW4mJnMuaXNYQXhpcz8xOjApLGM9b1tcIm1pbm9yXCIhPT1uP1widGlja0NvbG9yXCI6XCJtaW5vclRpY2tDb2xvclwiXSxwPXRoaXMubWFyayxnPSFwO2EmJihzLm9wcG9zaXRlJiYoYVswXT0tYVswXSkscHx8KHRoaXMubWFyaz1wPXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIisobj9uK1wiLVwiOlwiXCIpK1widGlja1wiKS5hZGQocy5heGlzR3JvdXApLHMuY2hhcnQuc3R5bGVkTW9kZXx8cC5hdHRyKHtzdHJva2U6YyxcInN0cm9rZS13aWR0aFwiOmR9KSkscFtnP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDp0aGlzLmdldE1hcmtQYXRoKGgsbCxhWzBdLHAuc3Ryb2tlV2lkdGgoKSppLHMuaG9yaXosciksb3BhY2l0eTplfSkpfXJlbmRlckxhYmVsKHQsZSxpLHMpe2xldCBvPXRoaXMuYXhpcyxyPW8uaG9yaXosbj1vLm9wdGlvbnMsYT10aGlzLmxhYmVsLGg9bi5sYWJlbHMsbD1oLnN0ZXAsYz11KHRoaXMudGlja21hcmtPZmZzZXQsby50aWNrbWFya09mZnNldCkscD10LngsZz10LnksZj0hMDthJiZkKHApJiYoYS54eT10PXRoaXMuZ2V0TGFiZWxQb3NpdGlvbihwLGcsYSxyLGgsYyxzLGwpLCghdGhpcy5pc0ZpcnN0fHx0aGlzLmlzTGFzdHx8bi5zaG93Rmlyc3RMYWJlbCkmJighdGhpcy5pc0xhc3R8fHRoaXMuaXNGaXJzdHx8bi5zaG93TGFzdExhYmVsKT8hcnx8aC5zdGVwfHxoLnJvdGF0aW9ufHxlfHwwPT09aXx8dGhpcy5oYW5kbGVPdmVyZmxvdyh0KTpmPSExLGwmJnMlbCYmKGY9ITEpLGYmJmQodC55KT8odC5vcGFjaXR5PWksYVt0aGlzLmlzTmV3TGFiZWw/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHQpLnNob3coITApLHRoaXMuaXNOZXdMYWJlbD0hMSk6KGEuaGlkZSgpLHRoaXMuaXNOZXdMYWJlbD0hMCkpfXJlcGxhY2VNb3ZlZExhYmVsKCl7bGV0IHQ9dGhpcy5sYWJlbCxlPXRoaXMuYXhpczt0JiYhdGhpcy5pc05ldyYmKHQuYW5pbWF0ZSh7b3BhY2l0eTowfSx2b2lkIDAsdC5kZXN0cm95KSxkZWxldGUgdGhpcy5sYWJlbCksZS5pc0RpcnR5PSEwLHRoaXMubGFiZWw9dGhpcy5tb3ZlZExhYmVsLGRlbGV0ZSB0aGlzLm1vdmVkTGFiZWx9fX0pLGkoZSxcIkNvcmUvQXhpcy9BeGlzLmpzXCIsW2VbXCJDb3JlL0FuaW1hdGlvbi9BbmltYXRpb25VdGlsaXRpZXMuanNcIl0sZVtcIkNvcmUvQXhpcy9BeGlzRGVmYXVsdHMuanNcIl0sZVtcIkNvcmUvQ29sb3IvQ29sb3IuanNcIl0sZVtcIkNvcmUvRGVmYXVsdHMuanNcIl0sZVtcIkNvcmUvRm91bmRhdGlvbi5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL0F4aXMvVGljay5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpLHMsbyxyLG4sYSl7bGV0e2FuaW1PYmplY3Q6aH09dCx7eEF4aXM6bCx5QXhpczpkfT1lLHtkZWZhdWx0T3B0aW9uczpjfT1zLHtyZWdpc3RlckV2ZW50T3B0aW9uczpwfT1vLHtkZWcycmFkOnV9PXIse2FycmF5TWF4OmcsYXJyYXlNaW46ZixjbGFtcDptLGNvcnJlY3RGbG9hdDp4LGRlZmluZWQ6eSxkZXN0cm95T2JqZWN0UHJvcGVydGllczpiLGVyYXNlOnYsZXJyb3I6UyxleHRlbmQ6ayxmaXJlRXZlbnQ6TSxnZXRDbG9zZXN0RGlzdGFuY2U6QyxpbnNlcnRJdGVtOncsaXNBcnJheTpULGlzTnVtYmVyOkEsaXNTdHJpbmc6UCxtZXJnZTpMLG5vcm1hbGl6ZVRpY2tJbnRlcnZhbDpPLG9iamVjdEVhY2g6RCxwaWNrOkUscmVsYXRpdmVMZW5ndGg6aixyZW1vdmVFdmVudDpJLHNwbGF0OkIsc3luY1RpbWVvdXQ6Un09YSx6PSh0LGUpPT5PKGUsdm9pZCAwLHZvaWQgMCxFKHQub3B0aW9ucy5hbGxvd0RlY2ltYWxzLGU8LjV8fHZvaWQgMCE9PXQudGlja0Ftb3VudCksISF0LnRpY2tBbW91bnQpO2soYyx7eEF4aXM6bCx5QXhpczpMKGwsZCl9KTtjbGFzcyBOe2NvbnN0cnVjdG9yKHQsZSxpKXt0aGlzLmluaXQodCxlLGkpfWluaXQodCxlLGk9dGhpcy5jb2xsKXtsZXQgcz1cInhBeGlzXCI9PT1pLG89dGhpcy5pc1pBeGlzfHwodC5pbnZlcnRlZD8hczpzKTt0aGlzLmNoYXJ0PXQsdGhpcy5ob3Jpej1vLHRoaXMuaXNYQXhpcz1zLHRoaXMuY29sbD1pLE0odGhpcyxcImluaXRcIix7dXNlck9wdGlvbnM6ZX0pLHRoaXMub3Bwb3NpdGU9RShlLm9wcG9zaXRlLHRoaXMub3Bwb3NpdGUpLHRoaXMuc2lkZT1FKGUuc2lkZSx0aGlzLnNpZGUsbz90aGlzLm9wcG9zaXRlPzA6Mjp0aGlzLm9wcG9zaXRlPzE6MyksdGhpcy5zZXRPcHRpb25zKGUpO2xldCByPXRoaXMub3B0aW9ucyxuPXIubGFiZWxzLGE9ci50eXBlO3RoaXMudXNlck9wdGlvbnM9ZSx0aGlzLm1pblBpeGVsUGFkZGluZz0wLHRoaXMucmV2ZXJzZWQ9RShyLnJldmVyc2VkLHRoaXMucmV2ZXJzZWQpLHRoaXMudmlzaWJsZT1yLnZpc2libGUsdGhpcy56b29tRW5hYmxlZD1yLnpvb21FbmFibGVkLHRoaXMuaGFzTmFtZXM9XCJjYXRlZ29yeVwiPT09YXx8ITA9PT1yLmNhdGVnb3JpZXMsdGhpcy5jYXRlZ29yaWVzPVQoci5jYXRlZ29yaWVzKSYmci5jYXRlZ29yaWVzfHwodGhpcy5oYXNOYW1lcz9bXTp2b2lkIDApLHRoaXMubmFtZXN8fCh0aGlzLm5hbWVzPVtdLHRoaXMubmFtZXMua2V5cz17fSksdGhpcy5wbG90TGluZXNBbmRCYW5kc0dyb3Vwcz17fSx0aGlzLnBvc2l0aXZlVmFsdWVzT25seT0hIXRoaXMubG9nYXJpdGhtaWMsdGhpcy5pc0xpbmtlZD15KHIubGlua2VkVG8pLHRoaXMudGlja3M9e30sdGhpcy5sYWJlbEVkZ2U9W10sdGhpcy5taW5vclRpY2tzPXt9LHRoaXMucGxvdExpbmVzQW5kQmFuZHM9W10sdGhpcy5hbHRlcm5hdGVCYW5kcz17fSx0aGlzLmxlbj0wLHRoaXMubWluUmFuZ2U9dGhpcy51c2VyTWluUmFuZ2U9ci5taW5SYW5nZXx8ci5tYXhab29tLHRoaXMucmFuZ2U9ci5yYW5nZSx0aGlzLm9mZnNldD1yLm9mZnNldHx8MCx0aGlzLm1heD12b2lkIDAsdGhpcy5taW49dm9pZCAwO2xldCBoPUUoci5jcm9zc2hhaXIsQih0Lm9wdGlvbnMudG9vbHRpcC5jcm9zc2hhaXJzKVtzPzA6MV0pO3RoaXMuY3Jvc3NoYWlyPSEwPT09aD97fTpoLC0xPT09dC5heGVzLmluZGV4T2YodGhpcykmJihzP3QuYXhlcy5zcGxpY2UodC54QXhpcy5sZW5ndGgsMCx0aGlzKTp0LmF4ZXMucHVzaCh0aGlzKSx3KHRoaXMsdFt0aGlzLmNvbGxdKSksdC5vcmRlckl0ZW1zKHRoaXMuY29sbCksdGhpcy5zZXJpZXM9dGhpcy5zZXJpZXN8fFtdLHQuaW52ZXJ0ZWQmJiF0aGlzLmlzWkF4aXMmJnMmJiF5KHRoaXMucmV2ZXJzZWQpJiYodGhpcy5yZXZlcnNlZD0hMCksdGhpcy5sYWJlbFJvdGF0aW9uPUEobi5yb3RhdGlvbik/bi5yb3RhdGlvbjp2b2lkIDAscCh0aGlzLHIpLE0odGhpcyxcImFmdGVySW5pdFwiKX1zZXRPcHRpb25zKHQpe2xldCBlPXRoaXMuaG9yaXo/e2xhYmVsczp7YXV0b1JvdGF0aW9uOlstNDVdfSxtYXJnaW46MTV9Ont0aXRsZTp7cm90YXRpb246OTAqdGhpcy5zaWRlfX07dGhpcy5vcHRpb25zPUwoZSxjW3RoaXMuY29sbF0sdCksTSh0aGlzLFwiYWZ0ZXJTZXRPcHRpb25zXCIse3VzZXJPcHRpb25zOnR9KX1kZWZhdWx0TGFiZWxGb3JtYXR0ZXIodCl7bGV0IGU9dGhpcy5heGlzLGk9dGhpcy5jaGFydCx7bnVtYmVyRm9ybWF0dGVyOnN9PWksbz1BKHRoaXMudmFsdWUpP3RoaXMudmFsdWU6TmFOLHI9ZS5jaGFydC50aW1lLG49ZS5jYXRlZ29yaWVzLGE9dGhpcy5kYXRlVGltZUxhYmVsRm9ybWF0LGg9Yy5sYW5nLGw9aC5udW1lcmljU3ltYm9scyxkPWgubnVtZXJpY1N5bWJvbE1hZ25pdHVkZXx8MWUzLHA9ZS5sb2dhcml0aG1pYz9NYXRoLmFicyhvKTplLnRpY2tJbnRlcnZhbCx1PWwmJmwubGVuZ3RoLGcsZjtpZihuKWY9YCR7dGhpcy52YWx1ZX1gO2Vsc2UgaWYoYSlmPXIuZGF0ZUZvcm1hdChhLG8pO2Vsc2UgaWYodSYmbCYmcD49MWUzKWZvcig7dS0tJiZ2b2lkIDA9PT1mOylwPj0oZz1NYXRoLnBvdyhkLHUrMSkpJiYxMCpvJWc9PTAmJm51bGwhPT1sW3VdJiYwIT09byYmKGY9cyhvL2csLTEpK2xbdV0pO3JldHVybiB2b2lkIDA9PT1mJiYoZj1NYXRoLmFicyhvKT49MWU0P3MobywtMSk6cyhvLC0xLHZvaWQgMCxcIlwiKSksZn1nZXRTZXJpZXNFeHRyZW1lcygpe2xldCB0O2xldCBlPXRoaXM7TSh0aGlzLFwiZ2V0U2VyaWVzRXh0cmVtZXNcIixudWxsLGZ1bmN0aW9uKCl7ZS5oYXNWaXNpYmxlU2VyaWVzPSExLGUuZGF0YU1pbj1lLmRhdGFNYXg9ZS50aHJlc2hvbGQ9dm9pZCAwLGUuc29mdFRocmVzaG9sZD0hZS5pc1hBeGlzLGUuc2VyaWVzLmZvckVhY2goaT0+e2lmKGkucmVzZXJ2ZVNwYWNlKCkpe2xldCBzPWkub3B0aW9ucyxvLHI9cy50aHJlc2hvbGQsbixhO2lmKGUuaGFzVmlzaWJsZVNlcmllcz0hMCxlLnBvc2l0aXZlVmFsdWVzT25seSYmMD49KHJ8fDApJiYocj12b2lkIDApLGUuaXNYQXhpcykobz1pLnhEYXRhKSYmby5sZW5ndGgmJihvPWUubG9nYXJpdGhtaWM/by5maWx0ZXIodD0+dD4wKTpvLG49KHQ9aS5nZXRYRXh0cmVtZXMobykpLm1pbixhPXQubWF4LEEobil8fG4gaW5zdGFuY2VvZiBEYXRlfHwobz1vLmZpbHRlcihBKSxuPSh0PWkuZ2V0WEV4dHJlbWVzKG8pKS5taW4sYT10Lm1heCksby5sZW5ndGgmJihlLmRhdGFNaW49TWF0aC5taW4oRShlLmRhdGFNaW4sbiksbiksZS5kYXRhTWF4PU1hdGgubWF4KEUoZS5kYXRhTWF4LGEpLGEpKSk7ZWxzZXtsZXQgdD1pLmFwcGx5RXh0cmVtZXMoKTtBKHQuZGF0YU1pbikmJihuPXQuZGF0YU1pbixlLmRhdGFNaW49TWF0aC5taW4oRShlLmRhdGFNaW4sbiksbikpLEEodC5kYXRhTWF4KSYmKGE9dC5kYXRhTWF4LGUuZGF0YU1heD1NYXRoLm1heChFKGUuZGF0YU1heCxhKSxhKSkseShyKSYmKGUudGhyZXNob2xkPXIpLCghcy5zb2Z0VGhyZXNob2xkfHxlLnBvc2l0aXZlVmFsdWVzT25seSkmJihlLnNvZnRUaHJlc2hvbGQ9ITEpfX19KX0pLE0odGhpcyxcImFmdGVyR2V0U2VyaWVzRXh0cmVtZXNcIil9dHJhbnNsYXRlKHQsZSxpLHMsbyxyKXtsZXQgbj10aGlzLmxpbmtlZFBhcmVudHx8dGhpcyxhPXMmJm4ub2xkP24ub2xkLm1pbjpuLm1pbjtpZighQShhKSlyZXR1cm4gTmFOO2xldCBoPW4ubWluUGl4ZWxQYWRkaW5nLGw9KG4uaXNPcmRpbmFsfHxuLmJyb2tlbkF4aXM/Lmhhc0JyZWFrc3x8bi5sb2dhcml0aG1pYyYmbykmJm4ubGluMnZhbCxkPTEsYz0wLHA9cyYmbi5vbGQ/bi5vbGQudHJhbnNBOm4udHJhbnNBLHU9MDtpZihwfHwocD1uLnRyYW5zQSksaSYmKGQqPS0xLGM9bi5sZW4pLG4ucmV2ZXJzZWQmJihkKj0tMSxjLT1kKihuLnNlY3Rvcnx8bi5sZW4pKSxlKXU9KHQ9dCpkK2MtaCkvcCthLGwmJih1PW4ubGluMnZhbCh1KSk7ZWxzZXtsJiYodD1uLnZhbDJsaW4odCkpO2xldCBlPWQqKHQtYSkqcDt1PShuLmlzUmFkaWFsP2U6eChlKSkrYytkKmgrKEEocik/cCpyOjApfXJldHVybiB1fXRvUGl4ZWxzKHQsZSl7cmV0dXJuIHRoaXMudHJhbnNsYXRlKHQsITEsIXRoaXMuaG9yaXosdm9pZCAwLCEwKSsoZT8wOnRoaXMucG9zKX10b1ZhbHVlKHQsZSl7cmV0dXJuIHRoaXMudHJhbnNsYXRlKHQtKGU/MDp0aGlzLnBvcyksITAsIXRoaXMuaG9yaXosdm9pZCAwLCEwKX1nZXRQbG90TGluZVBhdGgodCl7bGV0IGU9dGhpcyxpPWUuY2hhcnQscz1lLmxlZnQsbz1lLnRvcCxyPXQub2xkLG49dC52YWx1ZSxhPXQubGluZVdpZHRoLGg9ciYmaS5vbGRDaGFydEhlaWdodHx8aS5jaGFydEhlaWdodCxsPXImJmkub2xkQ2hhcnRXaWR0aHx8aS5jaGFydFdpZHRoLGQ9ZS50cmFuc0IsYz10LnRyYW5zbGF0ZWRWYWx1ZSxwPXQuZm9yY2UsdSxnLGYseCx5O2Z1bmN0aW9uIGIodCxlLGkpe3JldHVyblwicGFzc1wiIT09cCYmKHQ8ZXx8dD5pKSYmKHA/dD1tKHQsZSxpKTp5PSEwKSx0fWxldCB2PXt2YWx1ZTpuLGxpbmVXaWR0aDphLG9sZDpyLGZvcmNlOnAsYWNyb3NzUGFuZXM6dC5hY3Jvc3NQYW5lcyx0cmFuc2xhdGVkVmFsdWU6Y307cmV0dXJuIE0odGhpcyxcImdldFBsb3RMaW5lUGF0aFwiLHYsZnVuY3Rpb24odCl7dT1mPU1hdGgucm91bmQoKGM9bShjPUUoYyxlLnRyYW5zbGF0ZShuLHZvaWQgMCx2b2lkIDAscikpLC0xZTUsMWU1KSkrZCksZz14PU1hdGgucm91bmQoaC1jLWQpLEEoYyk/ZS5ob3Jpej8oZz1vLHg9aC1lLmJvdHRvbSx1PWY9Yih1LHMscytlLndpZHRoKSk6KHU9cyxmPWwtZS5yaWdodCxnPXg9YihnLG8sbytlLmhlaWdodCkpOih5PSEwLHA9ITEpLHQucGF0aD15JiYhcD92b2lkIDA6aS5yZW5kZXJlci5jcmlzcExpbmUoW1tcIk1cIix1LGddLFtcIkxcIixmLHhdXSxhfHwxKX0pLHYucGF0aH1nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHQsZSxpKXtsZXQgcyxvLHI7bGV0IG49eChNYXRoLmZsb29yKGUvdCkqdCksYT14KE1hdGguY2VpbChpL3QpKnQpLGg9W107aWYoeChuK3QpPT09biYmKHI9MjApLHRoaXMuc2luZ2xlKXJldHVybltlXTtmb3Iocz1uO3M8PWEmJihoLnB1c2gocyksKHM9eChzK3QscikpIT09byk7KW89cztyZXR1cm4gaH1nZXRNaW5vclRpY2tJbnRlcnZhbCgpe2xldHttaW5vclRpY2tzOnQsbWlub3JUaWNrSW50ZXJ2YWw6ZX09dGhpcy5vcHRpb25zO3JldHVybiEwPT09dD9FKGUsXCJhdXRvXCIpOiExIT09dD9lOnZvaWQgMH1nZXRNaW5vclRpY2tQb3NpdGlvbnMoKXtsZXQgdD10aGlzLm9wdGlvbnMsZT10aGlzLnRpY2tQb3NpdGlvbnMsaT10aGlzLm1pbm9yVGlja0ludGVydmFsLHM9dGhpcy5wb2ludFJhbmdlUGFkZGluZ3x8MCxvPSh0aGlzLm1pbnx8MCktcyxyPSh0aGlzLm1heHx8MCkrcyxuPXItbyxhPVtdLGg7aWYobiYmbi9pPHRoaXMubGVuLzMpe2xldCBzPXRoaXMubG9nYXJpdGhtaWM7aWYocyl0aGlzLnBhZGRlZFRpY2tzLmZvckVhY2goZnVuY3Rpb24odCxlLG8pe2UmJmEucHVzaC5hcHBseShhLHMuZ2V0TG9nVGlja1Bvc2l0aW9ucyhpLG9bZS0xXSxvW2VdLCEwKSl9KTtlbHNlIGlmKHRoaXMuZGF0ZVRpbWUmJlwiYXV0b1wiPT09dGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpKWE9YS5jb25jYXQodGhpcy5nZXRUaW1lVGlja3ModGhpcy5kYXRlVGltZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKGkpLG8scix0LnN0YXJ0T2ZXZWVrKSk7ZWxzZSBmb3IoaD1vKyhlWzBdLW8pJWk7aDw9ciYmaCE9PWFbMF07aCs9aSlhLnB1c2goaCl9cmV0dXJuIDAhPT1hLmxlbmd0aCYmdGhpcy50cmltVGlja3MoYSksYX1hZGp1c3RGb3JNaW5SYW5nZSgpe2xldCB0PXRoaXMub3B0aW9ucyxlPXRoaXMubG9nYXJpdGhtaWMse21heDppLG1pbjpzLG1pblJhbmdlOm99PXRoaXMscixuLGEsaDt0aGlzLmlzWEF4aXMmJnZvaWQgMD09PW8mJiFlJiYobz15KHQubWluKXx8eSh0Lm1heCl8fHkodC5mbG9vcil8fHkodC5jZWlsaW5nKT9udWxsOk1hdGgubWluKDUqKEModGhpcy5zZXJpZXMubWFwKHQ9Pih0LnhJbmNyZW1lbnQ/dC54RGF0YT8uc2xpY2UoMCwyKTp0LnhEYXRhKXx8W10pKXx8MCksdGhpcy5kYXRhTWF4LXRoaXMuZGF0YU1pbikpLEEoaSkmJkEocykmJkEobykmJmktczxvJiYobj10aGlzLmRhdGFNYXgtdGhpcy5kYXRhTWluPj1vLHI9KG8taStzKS8yLGE9W3MtcixFKHQubWluLHMtcildLG4mJihhWzJdPWU/ZS5sb2cybGluKHRoaXMuZGF0YU1pbik6dGhpcy5kYXRhTWluKSxoPVsocz1nKGEpKStvLEUodC5tYXgscytvKV0sbiYmKGhbMl09ZT9lLmxvZzJsaW4odGhpcy5kYXRhTWF4KTp0aGlzLmRhdGFNYXgpLChpPWYoaCkpLXM8byYmKGFbMF09aS1vLGFbMV09RSh0Lm1pbixpLW8pLHM9ZyhhKSkpLHRoaXMubWluUmFuZ2U9byx0aGlzLm1pbj1zLHRoaXMubWF4PWl9Z2V0Q2xvc2VzdCgpe2xldCB0LGU7aWYodGhpcy5jYXRlZ29yaWVzKWU9MTtlbHNle2xldCBpPVtdO3RoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IHM9dC5jbG9zZXN0UG9pbnRSYW5nZTt0LnhEYXRhPy5sZW5ndGg9PT0xP2kucHVzaCh0LnhEYXRhWzBdKTohdC5ub1NoYXJlZFRvb2x0aXAmJnkocykmJnQucmVzZXJ2ZVNwYWNlKCkmJihlPXkoZSk/TWF0aC5taW4oZSxzKTpzKX0pLGkubGVuZ3RoJiYoaS5zb3J0KCh0LGUpPT50LWUpLHQ9QyhbaV0pKX1yZXR1cm4gdCYmZT9NYXRoLm1pbih0LGUpOnR8fGV9bmFtZVRvWCh0KXtsZXQgZT1UKHRoaXMub3B0aW9ucy5jYXRlZ29yaWVzKSxpPWU/dGhpcy5jYXRlZ29yaWVzOnRoaXMubmFtZXMscz10Lm9wdGlvbnMueCxvO3JldHVybiB0LnNlcmllcy5yZXF1aXJlU29ydGluZz0hMSx5KHMpfHwocz10aGlzLm9wdGlvbnMudW5pcXVlTmFtZXMmJmk/ZT9pLmluZGV4T2YodC5uYW1lKTpFKGkua2V5c1t0Lm5hbWVdLC0xKTp0LnNlcmllcy5hdXRvSW5jcmVtZW50KCkpLC0xPT09cz8hZSYmaSYmKG89aS5sZW5ndGgpOm89cyx2b2lkIDAhPT1vPyh0aGlzLm5hbWVzW29dPXQubmFtZSx0aGlzLm5hbWVzLmtleXNbdC5uYW1lXT1vKTp0LngmJihvPXQueCksb311cGRhdGVOYW1lcygpe2xldCB0PXRoaXMsZT10aGlzLm5hbWVzLGk9ZS5sZW5ndGg7aT4wJiYoT2JqZWN0LmtleXMoZS5rZXlzKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2RlbGV0ZSBlLmtleXNbdF19KSxlLmxlbmd0aD0wLHRoaXMubWluUmFuZ2U9dGhpcy51c2VyTWluUmFuZ2UsKHRoaXMuc2VyaWVzfHxbXSkuZm9yRWFjaChlPT57ZS54SW5jcmVtZW50PW51bGwsKCFlLnBvaW50c3x8ZS5pc0RpcnR5RGF0YSkmJih0Lm1heD1NYXRoLm1heCh0Lm1heCxlLnhEYXRhLmxlbmd0aC0xKSxlLnByb2Nlc3NEYXRhKCksZS5nZW5lcmF0ZVBvaW50cygpKSxlLmRhdGEuZm9yRWFjaChmdW5jdGlvbihpLHMpe2xldCBvO2k/Lm9wdGlvbnMmJnZvaWQgMCE9PWkubmFtZSYmdm9pZCAwIT09KG89dC5uYW1lVG9YKGkpKSYmbyE9PWkueCYmKGkueD1vLGUueERhdGFbc109byl9KX0pKX1zZXRBeGlzVHJhbnNsYXRpb24oKXtsZXQgdD10aGlzLGU9dC5tYXgtdC5taW4saT10LmxpbmtlZFBhcmVudCxzPSEhdC5jYXRlZ29yaWVzLG89dC5pc1hBeGlzLHI9dC5heGlzUG9pbnRSYW5nZXx8MCxuLGE9MCxoPTAsbCxkPXQudHJhbnNBOyhvfHxzfHxyKSYmKG49dC5nZXRDbG9zZXN0KCksaT8oYT1pLm1pblBvaW50T2Zmc2V0LGg9aS5wb2ludFJhbmdlUGFkZGluZyk6dC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihlKXtsZXQgaT1zPzE6bz9FKGUub3B0aW9ucy5wb2ludFJhbmdlLG4sMCk6dC5heGlzUG9pbnRSYW5nZXx8MCxsPWUub3B0aW9ucy5wb2ludFBsYWNlbWVudDtpZihyPU1hdGgubWF4KHIsaSksIXQuc2luZ2xlfHxzKXtsZXQgdD1lLmlzKFwieHJhbmdlXCIpPyFvOm87YT1NYXRoLm1heChhLHQmJlAobCk/MDppLzIpLGg9TWF0aC5tYXgoaCx0JiZcIm9uXCI9PT1sPzA6aSl9fSksbD10Lm9yZGluYWwmJnQub3JkaW5hbC5zbG9wZSYmbj90Lm9yZGluYWwuc2xvcGUvbjoxLHQubWluUG9pbnRPZmZzZXQ9YSo9bCx0LnBvaW50UmFuZ2VQYWRkaW5nPWgqPWwsdC5wb2ludFJhbmdlPU1hdGgubWluKHIsdC5zaW5nbGUmJnM/MTplKSxvJiZuJiYodC5jbG9zZXN0UG9pbnRSYW5nZT1uKSksdC50cmFuc2xhdGlvblNsb3BlPXQudHJhbnNBPWQ9dC5zdGF0aWNTY2FsZXx8dC5sZW4vKGUraHx8MSksdC50cmFuc0I9dC5ob3Jpej90LmxlZnQ6dC5ib3R0b20sdC5taW5QaXhlbFBhZGRpbmc9ZCphLE0odGhpcyxcImFmdGVyU2V0QXhpc1RyYW5zbGF0aW9uXCIpfW1pbkZyb21SYW5nZSgpe2xldHttYXg6dCxtaW46ZX09dGhpcztyZXR1cm4gQSh0KSYmQShlKSYmdC1lfHx2b2lkIDB9c2V0VGlja0ludGVydmFsKHQpe2xldHtjYXRlZ29yaWVzOmUsY2hhcnQ6aSxkYXRhTWF4OnMsZGF0YU1pbjpvLGRhdGVUaW1lOnIsaXNYQXhpczpuLGxvZ2FyaXRobWljOmEsb3B0aW9uczpoLHNvZnRUaHJlc2hvbGQ6bH09dGhpcyxkPUEodGhpcy50aHJlc2hvbGQpP3RoaXMudGhyZXNob2xkOnZvaWQgMCxjPXRoaXMubWluUmFuZ2V8fDAse2NlaWxpbmc6cCxmbG9vcjp1LGxpbmtlZFRvOmcsc29mdE1heDpmLHNvZnRNaW46bX09aCxiPUEoZykmJmlbdGhpcy5jb2xsXT8uW2ddLHY9aC50aWNrUGl4ZWxJbnRlcnZhbCxrPWgubWF4UGFkZGluZyxDPWgubWluUGFkZGluZyx3PTAsVCxQPUEoaC50aWNrSW50ZXJ2YWwpJiZoLnRpY2tJbnRlcnZhbD49MD9oLnRpY2tJbnRlcnZhbDp2b2lkIDAsTCxPLEQsajtpZihyfHxlfHxifHx0aGlzLmdldFRpY2tBbW91bnQoKSxEPUUodGhpcy51c2VyTWluLGgubWluKSxqPUUodGhpcy51c2VyTWF4LGgubWF4KSxiPyh0aGlzLmxpbmtlZFBhcmVudD1iLFQ9Yi5nZXRFeHRyZW1lcygpLHRoaXMubWluPUUoVC5taW4sVC5kYXRhTWluKSx0aGlzLm1heD1FKFQubWF4LFQuZGF0YU1heCksaC50eXBlIT09Yi5vcHRpb25zLnR5cGUmJlMoMTEsITAsaSkpOihsJiZ5KGQpJiZBKHMpJiZBKG8pJiYobz49ZD8oTD1kLEM9MCk6czw9ZCYmKE89ZCxrPTApKSx0aGlzLm1pbj1FKEQsTCxvKSx0aGlzLm1heD1FKGosTyxzKSksQSh0aGlzLm1heCkmJkEodGhpcy5taW4pJiYoYSYmKHRoaXMucG9zaXRpdmVWYWx1ZXNPbmx5JiYhdCYmMD49TWF0aC5taW4odGhpcy5taW4sRShvLHRoaXMubWluKSkmJlMoMTAsITAsaSksdGhpcy5taW49eChhLmxvZzJsaW4odGhpcy5taW4pLDE2KSx0aGlzLm1heD14KGEubG9nMmxpbih0aGlzLm1heCksMTYpKSx0aGlzLnJhbmdlJiZBKG8pJiYodGhpcy51c2VyTWluPXRoaXMubWluPUQ9TWF0aC5tYXgobyx0aGlzLm1pbkZyb21SYW5nZSgpfHwwKSx0aGlzLnVzZXJNYXg9aj10aGlzLm1heCx0aGlzLnJhbmdlPXZvaWQgMCkpLE0odGhpcyxcImZvdW5kRXh0cmVtZXNcIiksdGhpcy5hZGp1c3RGb3JNaW5SYW5nZSgpLEEodGhpcy5taW4pJiZBKHRoaXMubWF4KSl7aWYoIUEodGhpcy51c2VyTWluKSYmQShtKSYmbTx0aGlzLm1pbiYmKHRoaXMubWluPUQ9bSksIUEodGhpcy51c2VyTWF4KSYmQShmKSYmZj50aGlzLm1heCYmKHRoaXMubWF4PWo9ZiksZXx8dGhpcy5heGlzUG9pbnRSYW5nZXx8dGhpcy5zdGFja2luZz8udXNlUGVyY2VudGFnZXx8Ynx8ISh3PXRoaXMubWF4LXRoaXMubWluKXx8KCF5KEQpJiZDJiYodGhpcy5taW4tPXcqQykseShqKXx8IWt8fCh0aGlzLm1heCs9dyprKSksIUEodGhpcy51c2VyTWluKSYmQSh1KSYmKHRoaXMubWluPU1hdGgubWF4KHRoaXMubWluLHUpKSwhQSh0aGlzLnVzZXJNYXgpJiZBKHApJiYodGhpcy5tYXg9TWF0aC5taW4odGhpcy5tYXgscCkpLGwmJkEobykmJkEocykpe2xldCB0PWR8fDA7IXkoRCkmJnRoaXMubWluPHQmJm8+PXQ/dGhpcy5taW49aC5taW5SYW5nZT9NYXRoLm1pbih0LHRoaXMubWF4LWMpOnQ6IXkoaikmJnRoaXMubWF4PnQmJnM8PXQmJih0aGlzLm1heD1oLm1pblJhbmdlP01hdGgubWF4KHQsdGhpcy5taW4rYyk6dCl9IWkucG9sYXImJnRoaXMubWluPnRoaXMubWF4JiYoeShoLm1pbik/dGhpcy5tYXg9dGhpcy5taW46eShoLm1heCkmJih0aGlzLm1pbj10aGlzLm1heCkpLHc9dGhpcy5tYXgtdGhpcy5taW59aWYodGhpcy5taW4hPT10aGlzLm1heCYmQSh0aGlzLm1pbikmJkEodGhpcy5tYXgpP2ImJiFQJiZ2PT09Yi5vcHRpb25zLnRpY2tQaXhlbEludGVydmFsP3RoaXMudGlja0ludGVydmFsPVA9Yi50aWNrSW50ZXJ2YWw6dGhpcy50aWNrSW50ZXJ2YWw9RShQLHRoaXMudGlja0Ftb3VudD93L01hdGgubWF4KHRoaXMudGlja0Ftb3VudC0xLDEpOnZvaWQgMCxlPzE6dyp2L01hdGgubWF4KHRoaXMubGVuLHYpKTp0aGlzLnRpY2tJbnRlcnZhbD0xLG4mJiF0KXtsZXQgdD10aGlzLm1pbiE9PXRoaXMub2xkPy5taW58fHRoaXMubWF4IT09dGhpcy5vbGQ/Lm1heDt0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZm9yY2VDcm9wPWUuZm9yY2VDcm9wcGluZz8uKCksZS5wcm9jZXNzRGF0YSh0KX0pLE0odGhpcyxcInBvc3RQcm9jZXNzRGF0YVwiLHtoYXNFeHRyZW1lc0NoYW5nZWQ6dH0pfXRoaXMuc2V0QXhpc1RyYW5zbGF0aW9uKCksTSh0aGlzLFwiaW5pdGlhbEF4aXNUcmFuc2xhdGlvblwiKSx0aGlzLnBvaW50UmFuZ2UmJiFQJiYodGhpcy50aWNrSW50ZXJ2YWw9TWF0aC5tYXgodGhpcy5wb2ludFJhbmdlLHRoaXMudGlja0ludGVydmFsKSk7bGV0IEk9RShoLm1pblRpY2tJbnRlcnZhbCxyJiYhdGhpcy5zZXJpZXMuc29tZSh0PT50Lm5vU2hhcmVkVG9vbHRpcCk/dGhpcy5jbG9zZXN0UG9pbnRSYW5nZTowKTshUCYmdGhpcy50aWNrSW50ZXJ2YWw8SSYmKHRoaXMudGlja0ludGVydmFsPUkpLHJ8fGF8fFB8fCh0aGlzLnRpY2tJbnRlcnZhbD16KHRoaXMsdGhpcy50aWNrSW50ZXJ2YWwpKSx0aGlzLnRpY2tBbW91bnR8fCh0aGlzLnRpY2tJbnRlcnZhbD10aGlzLnVuc3F1aXNoKCkpLHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpfXNldFRpY2tQb3NpdGlvbnMoKXtsZXQgdD10aGlzLm9wdGlvbnMsZT10LnRpY2tQb3NpdGlvbnMsaT10LnRpY2tQb3NpdGlvbmVyLHM9dGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpLG89dGhpcy5oYXNWZXJ0aWNhbFBhbm5pbmcoKSxyPVwiY29sb3JBeGlzXCI9PT10aGlzLmNvbGwsbj0ocnx8IW8pJiZ0LnN0YXJ0T25UaWNrLGE9KHJ8fCFvKSYmdC5lbmRPblRpY2ssaD1bXSxsO2lmKHRoaXMudGlja21hcmtPZmZzZXQ9dGhpcy5jYXRlZ29yaWVzJiZcImJldHdlZW5cIj09PXQudGlja21hcmtQbGFjZW1lbnQmJjE9PT10aGlzLnRpY2tJbnRlcnZhbD8uNTowLHRoaXMubWlub3JUaWNrSW50ZXJ2YWw9XCJhdXRvXCI9PT1zJiZ0aGlzLnRpY2tJbnRlcnZhbD90aGlzLnRpY2tJbnRlcnZhbC90Lm1pbm9yVGlja3NQZXJNYWpvcjpzLHRoaXMuc2luZ2xlPXRoaXMubWluPT09dGhpcy5tYXgmJnkodGhpcy5taW4pJiYhdGhpcy50aWNrQW1vdW50JiYodGhpcy5taW4lMT09MHx8ITEhPT10LmFsbG93RGVjaW1hbHMpLGUpaD1lLnNsaWNlKCk7ZWxzZSBpZihBKHRoaXMubWluKSYmQSh0aGlzLm1heCkpe2lmKCF0aGlzLm9yZGluYWw/LnBvc2l0aW9ucyYmKHRoaXMubWF4LXRoaXMubWluKS90aGlzLnRpY2tJbnRlcnZhbD5NYXRoLm1heCgyKnRoaXMubGVuLDIwMCkpaD1bdGhpcy5taW4sdGhpcy5tYXhdLFMoMTksITEsdGhpcy5jaGFydCk7ZWxzZSBpZih0aGlzLmRhdGVUaW1lKWg9dGhpcy5nZXRUaW1lVGlja3ModGhpcy5kYXRlVGltZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKHRoaXMudGlja0ludGVydmFsLHQudW5pdHMpLHRoaXMubWluLHRoaXMubWF4LHQuc3RhcnRPZldlZWssdGhpcy5vcmRpbmFsPy5wb3NpdGlvbnMsdGhpcy5jbG9zZXN0UG9pbnRSYW5nZSwhMCk7ZWxzZSBpZih0aGlzLmxvZ2FyaXRobWljKWg9dGhpcy5sb2dhcml0aG1pYy5nZXRMb2dUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLHRoaXMubWluLHRoaXMubWF4KTtlbHNle2xldCB0PXRoaXMudGlja0ludGVydmFsLGU9dDtmb3IoO2U8PTIqdDspaWYoaD10aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsdGhpcy5taW4sdGhpcy5tYXgpLHRoaXMudGlja0Ftb3VudCYmaC5sZW5ndGg+dGhpcy50aWNrQW1vdW50KXRoaXMudGlja0ludGVydmFsPXoodGhpcyxlKj0xLjEpO2Vsc2UgYnJlYWt9aC5sZW5ndGg+dGhpcy5sZW4mJihoPVtoWzBdLGhbaC5sZW5ndGgtMV1dKVswXT09PWhbMV0mJihoLmxlbmd0aD0xKSxpJiYodGhpcy50aWNrUG9zaXRpb25zPWgsKGw9aS5hcHBseSh0aGlzLFt0aGlzLm1pbix0aGlzLm1heF0pKSYmKGg9bCkpfXRoaXMudGlja1Bvc2l0aW9ucz1oLHRoaXMucGFkZGVkVGlja3M9aC5zbGljZSgwKSx0aGlzLnRyaW1UaWNrcyhoLG4sYSksIXRoaXMuaXNMaW5rZWQmJkEodGhpcy5taW4pJiZBKHRoaXMubWF4KSYmKHRoaXMuc2luZ2xlJiZoLmxlbmd0aDwyJiYhdGhpcy5jYXRlZ29yaWVzJiYhdGhpcy5zZXJpZXMuc29tZSh0PT50LmlzKFwiaGVhdG1hcFwiKSYmXCJiZXR3ZWVuXCI9PT10Lm9wdGlvbnMucG9pbnRQbGFjZW1lbnQpJiYodGhpcy5taW4tPS41LHRoaXMubWF4Kz0uNSksZXx8bHx8dGhpcy5hZGp1c3RUaWNrQW1vdW50KCkpLE0odGhpcyxcImFmdGVyU2V0VGlja1Bvc2l0aW9uc1wiKX10cmltVGlja3ModCxlLGkpe2xldCBzPXRbMF0sbz10W3QubGVuZ3RoLTFdLHI9IXRoaXMuaXNPcmRpbmFsJiZ0aGlzLm1pblBvaW50T2Zmc2V0fHwwO2lmKE0odGhpcyxcInRyaW1UaWNrc1wiKSwhdGhpcy5pc0xpbmtlZCl7aWYoZSYmcyE9PS0xLzApdGhpcy5taW49cztlbHNlIGZvcig7dGhpcy5taW4tcj50WzBdOyl0LnNoaWZ0KCk7aWYoaSl0aGlzLm1heD1vO2Vsc2UgZm9yKDt0aGlzLm1heCtyPHRbdC5sZW5ndGgtMV07KXQucG9wKCk7MD09PXQubGVuZ3RoJiZ5KHMpJiYhdGhpcy5vcHRpb25zLnRpY2tQb3NpdGlvbnMmJnQucHVzaCgobytzKS8yKX19YWxpZ25Ub090aGVycygpe2xldCB0O2xldCBlPXRoaXMsaT1bdGhpc10scz1lLm9wdGlvbnMsbz10aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQscj1cInlBeGlzXCI9PT10aGlzLmNvbGwmJm8uYWxpZ25UaHJlc2hvbGRzLG49W107aWYoZS50aHJlc2hvbGRBbGlnbm1lbnQ9dm9pZCAwLCghMSE9PW8uYWxpZ25UaWNrcyYmcy5hbGlnblRpY2tzfHxyKSYmITEhPT1zLnN0YXJ0T25UaWNrJiYhMSE9PXMuZW5kT25UaWNrJiYhZS5sb2dhcml0aG1pYyl7bGV0IHM9dD0+e2xldHtob3JpejplLG9wdGlvbnM6aX09dDtyZXR1cm5bZT9pLmxlZnQ6aS50b3AsaS53aWR0aCxpLmhlaWdodCxpLnBhbmVdLmpvaW4oXCIsXCIpfSxvPXModGhpcyk7dGhpcy5jaGFydFt0aGlzLmNvbGxdLmZvckVhY2goZnVuY3Rpb24ocil7bGV0e3NlcmllczpufT1yO24ubGVuZ3RoJiZuLnNvbWUodD0+dC52aXNpYmxlKSYmciE9PWUmJnMocik9PT1vJiYodD0hMCxpLnB1c2gocikpfSl9aWYodCYmcil7aS5mb3JFYWNoKHQ9PntsZXQgaT10LmdldFRocmVzaG9sZEFsaWdubWVudChlKTtBKGkpJiZuLnB1c2goaSl9KTtsZXQgdD1uLmxlbmd0aD4xP24ucmVkdWNlKCh0LGUpPT50Kz1lLDApL24ubGVuZ3RoOnZvaWQgMDtpLmZvckVhY2goZT0+e2UudGhyZXNob2xkQWxpZ25tZW50PXR9KX1yZXR1cm4gdH1nZXRUaHJlc2hvbGRBbGlnbm1lbnQodCl7aWYoKCFBKHRoaXMuZGF0YU1pbil8fHRoaXMhPT10JiZ0aGlzLnNlcmllcy5zb21lKHQ9PnQuaXNEaXJ0eXx8dC5pc0RpcnR5RGF0YSkpJiZ0aGlzLmdldFNlcmllc0V4dHJlbWVzKCksQSh0aGlzLnRocmVzaG9sZCkpe2xldCB0PW0oKHRoaXMudGhyZXNob2xkLSh0aGlzLmRhdGFNaW58fDApKS8oKHRoaXMuZGF0YU1heHx8MCktKHRoaXMuZGF0YU1pbnx8MCkpLDAsMSk7cmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlZCYmKHQ9MS10KSx0fX1nZXRUaWNrQW1vdW50KCl7bGV0IHQ9dGhpcy5vcHRpb25zLGU9dC50aWNrUGl4ZWxJbnRlcnZhbCxpPXQudGlja0Ftb3VudDt5KHQudGlja0ludGVydmFsKXx8aXx8ISh0aGlzLmxlbjxlKXx8dGhpcy5pc1JhZGlhbHx8dGhpcy5sb2dhcml0aG1pY3x8IXQuc3RhcnRPblRpY2t8fCF0LmVuZE9uVGlja3x8KGk9MiksIWkmJnRoaXMuYWxpZ25Ub090aGVycygpJiYoaT1NYXRoLmNlaWwodGhpcy5sZW4vZSkrMSksaTw0JiYodGhpcy5maW5hbFRpY2tBbXQ9aSxpPTUpLHRoaXMudGlja0Ftb3VudD1pfWFkanVzdFRpY2tBbW91bnQoKXtsZXQgdD10aGlzLHtmaW5hbFRpY2tBbXQ6ZSxtYXg6aSxtaW46cyxvcHRpb25zOm8sdGlja1Bvc2l0aW9uczpyLHRpY2tBbW91bnQ6bix0aHJlc2hvbGRBbGlnbm1lbnQ6YX09dCxoPXI/Lmxlbmd0aCxsPUUodC50aHJlc2hvbGQsdC5zb2Z0VGhyZXNob2xkPzA6bnVsbCksZCxjLHA9dC50aWNrSW50ZXJ2YWwsdSxnPSgpPT5yLnB1c2goeChyW3IubGVuZ3RoLTFdK3ApKSxmPSgpPT5yLnVuc2hpZnQoeChyWzBdLXApKTtpZihBKGEpJiYodT1hPC41P01hdGguY2VpbChhKihuLTEpKTpNYXRoLmZsb29yKGEqKG4tMSkpLG8ucmV2ZXJzZWQmJih1PW4tMS11KSksdC5oYXNEYXRhKCkmJkEocykmJkEoaSkpe2xldCBhPSgpPT57dC50cmFuc0EqPShoLTEpLyhuLTEpLHQubWluPW8uc3RhcnRPblRpY2s/clswXTpNYXRoLm1pbihzLHJbMF0pLHQubWF4PW8uZW5kT25UaWNrP3Jbci5sZW5ndGgtMV06TWF0aC5tYXgoaSxyW3IubGVuZ3RoLTFdKX07aWYoQSh1KSYmQSh0LnRocmVzaG9sZCkpe2Zvcig7clt1XSE9PWx8fHIubGVuZ3RoIT09bnx8clswXT5zfHxyW3IubGVuZ3RoLTFdPGk7KXtmb3Ioci5sZW5ndGg9MCxyLnB1c2godC50aHJlc2hvbGQpO3IubGVuZ3RoPG47KXZvaWQgMD09PXJbdV18fHJbdV0+dC50aHJlc2hvbGQ/ZigpOmcoKTtpZihwPjgqdC50aWNrSW50ZXJ2YWwpYnJlYWs7cCo9Mn1hKCl9ZWxzZSBpZihoPG4pe2Zvcig7ci5sZW5ndGg8bjspci5sZW5ndGglMnx8cz09PWw/ZygpOmYoKTthKCl9aWYoeShlKSl7Zm9yKGM9ZD1yLmxlbmd0aDtjLS07KSgzPT09ZSYmYyUyPT0xfHxlPD0yJiZjPjAmJmM8ZC0xKSYmci5zcGxpY2UoYywxKTt0LmZpbmFsVGlja0FtdD12b2lkIDB9fX1zZXRTY2FsZSgpe2xldHtjb2xsOnQsc3RhY2tpbmc6ZX09dGhpcyxpPSExLHM9ITE7dGhpcy5zZXJpZXMuZm9yRWFjaCh0PT57aT1pfHx0LmlzRGlydHlEYXRhfHx0LmlzRGlydHkscz1zfHx0LnhBeGlzJiZ0LnhBeGlzLmlzRGlydHl8fCExfSksdGhpcy5zZXRBeGlzU2l6ZSgpO2xldCBvPXRoaXMubGVuIT09KHRoaXMub2xkJiZ0aGlzLm9sZC5sZW4pO298fGl8fHN8fHRoaXMuaXNMaW5rZWR8fHRoaXMuZm9yY2VSZWRyYXd8fHRoaXMudXNlck1pbiE9PSh0aGlzLm9sZCYmdGhpcy5vbGQudXNlck1pbil8fHRoaXMudXNlck1heCE9PSh0aGlzLm9sZCYmdGhpcy5vbGQudXNlck1heCl8fHRoaXMuYWxpZ25Ub090aGVycygpPyhlJiZcInlBeGlzXCI9PT10JiZlLmJ1aWxkU3RhY2tzKCksdGhpcy5mb3JjZVJlZHJhdz0hMSx0aGlzLnVzZXJNaW5SYW5nZXx8KHRoaXMubWluUmFuZ2U9dm9pZCAwKSx0aGlzLmdldFNlcmllc0V4dHJlbWVzKCksdGhpcy5zZXRUaWNrSW50ZXJ2YWwoKSxlJiZcInhBeGlzXCI9PT10JiZlLmJ1aWxkU3RhY2tzKCksdGhpcy5pc0RpcnR5fHwodGhpcy5pc0RpcnR5PW98fHRoaXMubWluIT09dGhpcy5vbGQ/Lm1pbnx8dGhpcy5tYXghPT10aGlzLm9sZD8ubWF4KSk6ZSYmZS5jbGVhblN0YWNrcygpLGkmJnRoaXMucGFubmluZ1N0YXRlJiYodGhpcy5wYW5uaW5nU3RhdGUuaXNEaXJ0eT0hMCksTSh0aGlzLFwiYWZ0ZXJTZXRTY2FsZVwiKX1zZXRFeHRyZW1lcyh0LGUsaT0hMCxzLG8pe2xldCByPXRoaXMsbj1yLmNoYXJ0O3Iuc2VyaWVzLmZvckVhY2godD0+e2RlbGV0ZSB0LmtkVHJlZX0pLE0ocixcInNldEV4dHJlbWVzXCIsbz1rKG8se21pbjp0LG1heDplfSksKCk9PntyLnVzZXJNaW49dCxyLnVzZXJNYXg9ZSxyLmV2ZW50QXJncz1vLGkmJm4ucmVkcmF3KHMpfSl9em9vbSh0LGUpe2xldCBpPXRoaXMscz10aGlzLmRhdGFNaW4sbz10aGlzLmRhdGFNYXgscj10aGlzLm9wdGlvbnMsbj1NYXRoLm1pbihzLEUoci5taW4scykpLGE9TWF0aC5tYXgobyxFKHIubWF4LG8pKSxoPXtuZXdNaW46dCxuZXdNYXg6ZX07cmV0dXJuIE0odGhpcyxcInpvb21cIixoLGZ1bmN0aW9uKHQpe2xldCBlPXQubmV3TWluLHI9dC5uZXdNYXg7KGUhPT1pLm1pbnx8ciE9PWkubWF4KSYmKCFpLmFsbG93Wm9vbU91dHNpZGUmJih5KHMpJiYoZTxuJiYoZT1uKSxlPmEmJihlPWEpKSx5KG8pJiYocjxuJiYocj1uKSxyPmEmJihyPWEpKSksaS5kaXNwbGF5QnRuPXZvaWQgMCE9PWV8fHZvaWQgMCE9PXIsaS5zZXRFeHRyZW1lcyhlLHIsITEsdm9pZCAwLHt0cmlnZ2VyOlwiem9vbVwifSkpLHQuem9vbWVkPSEwfSksaC56b29tZWR9c2V0QXhpc1NpemUoKXtsZXQgdD10aGlzLmNoYXJ0LGU9dGhpcy5vcHRpb25zLGk9ZS5vZmZzZXRzfHxbMCwwLDAsMF0scz10aGlzLmhvcml6LG89dGhpcy53aWR0aD1NYXRoLnJvdW5kKGooRShlLndpZHRoLHQucGxvdFdpZHRoLWlbM10raVsxXSksdC5wbG90V2lkdGgpKSxyPXRoaXMuaGVpZ2h0PU1hdGgucm91bmQoaihFKGUuaGVpZ2h0LHQucGxvdEhlaWdodC1pWzBdK2lbMl0pLHQucGxvdEhlaWdodCkpLG49dGhpcy50b3A9TWF0aC5yb3VuZChqKEUoZS50b3AsdC5wbG90VG9wK2lbMF0pLHQucGxvdEhlaWdodCx0LnBsb3RUb3ApKSxhPXRoaXMubGVmdD1NYXRoLnJvdW5kKGooRShlLmxlZnQsdC5wbG90TGVmdCtpWzNdKSx0LnBsb3RXaWR0aCx0LnBsb3RMZWZ0KSk7dGhpcy5ib3R0b209dC5jaGFydEhlaWdodC1yLW4sdGhpcy5yaWdodD10LmNoYXJ0V2lkdGgtby1hLHRoaXMubGVuPU1hdGgubWF4KHM/bzpyLDApLHRoaXMucG9zPXM/YTpufWdldEV4dHJlbWVzKCl7bGV0IHQ9dGhpcy5sb2dhcml0aG1pYztyZXR1cm57bWluOnQ/eCh0LmxpbjJsb2codGhpcy5taW4pKTp0aGlzLm1pbixtYXg6dD94KHQubGluMmxvZyh0aGlzLm1heCkpOnRoaXMubWF4LGRhdGFNaW46dGhpcy5kYXRhTWluLGRhdGFNYXg6dGhpcy5kYXRhTWF4LHVzZXJNaW46dGhpcy51c2VyTWluLHVzZXJNYXg6dGhpcy51c2VyTWF4fX1nZXRUaHJlc2hvbGQodCl7bGV0IGU9dGhpcy5sb2dhcml0aG1pYyxpPWU/ZS5saW4ybG9nKHRoaXMubWluKTp0aGlzLm1pbixzPWU/ZS5saW4ybG9nKHRoaXMubWF4KTp0aGlzLm1heDtyZXR1cm4gbnVsbD09PXR8fHQ9PT0tMS8wP3Q9aTp0PT09MS8wP3Q9czppPnQ/dD1pOnM8dCYmKHQ9cyksdGhpcy50cmFuc2xhdGUodCwwLDEsMCwxKX1hdXRvTGFiZWxBbGlnbih0KXtsZXQgZT0oRSh0LDApLTkwKnRoaXMuc2lkZSs3MjApJTM2MCxpPXthbGlnbjpcImNlbnRlclwifTtyZXR1cm4gTSh0aGlzLFwiYXV0b0xhYmVsQWxpZ25cIixpLGZ1bmN0aW9uKHQpe2U+MTUmJmU8MTY1P3QuYWxpZ249XCJyaWdodFwiOmU+MTk1JiZlPDM0NSYmKHQuYWxpZ249XCJsZWZ0XCIpfSksaS5hbGlnbn10aWNrU2l6ZSh0KXtsZXQgZT10aGlzLm9wdGlvbnMsaT1FKGVbXCJ0aWNrXCI9PT10P1widGlja1dpZHRoXCI6XCJtaW5vclRpY2tXaWR0aFwiXSxcInRpY2tcIj09PXQmJnRoaXMuaXNYQXhpcyYmIXRoaXMuY2F0ZWdvcmllcz8xOjApLHM9ZVtcInRpY2tcIj09PXQ/XCJ0aWNrTGVuZ3RoXCI6XCJtaW5vclRpY2tMZW5ndGhcIl0sbztpJiZzJiYoXCJpbnNpZGVcIj09PWVbdCtcIlBvc2l0aW9uXCJdJiYocz0tcyksbz1bcyxpXSk7bGV0IHI9e3RpY2tTaXplOm99O3JldHVybiBNKHRoaXMsXCJhZnRlclRpY2tTaXplXCIsciksci50aWNrU2l6ZX1sYWJlbE1ldHJpY3MoKXtsZXQgdD10aGlzLmNoYXJ0LnJlbmRlcmVyLGU9dGhpcy50aWNrcyxpPWVbT2JqZWN0LmtleXMoZSlbMF1dfHx7fTtyZXR1cm4gdGhpcy5jaGFydC5yZW5kZXJlci5mb250TWV0cmljcyhpLmxhYmVsfHxpLm1vdmVkTGFiZWx8fHQuYm94KX11bnNxdWlzaCgpe2xldCB0PXRoaXMub3B0aW9ucy5sYWJlbHMsZT10aGlzLmhvcml6LGk9dGhpcy50aWNrSW50ZXJ2YWwscz10aGlzLmxlbi8oKCh0aGlzLmNhdGVnb3JpZXM/MTowKSt0aGlzLm1heC10aGlzLm1pbikvaSksbz10LnJvdGF0aW9uLHI9dGhpcy5sYWJlbE1ldHJpY3MoKS5oLG49TWF0aC5tYXgodGhpcy5tYXgtdGhpcy5taW4sMCksYT1mdW5jdGlvbih0KXtsZXQgZT10LyhzfHwxKTtyZXR1cm4oZT1lPjE/TWF0aC5jZWlsKGUpOjEpKmk+biYmdCE9PTEvMCYmcyE9PTEvMCYmbiYmKGU9TWF0aC5jZWlsKG4vaSkpLHgoZSppKX0saD1pLGwsZD1OdW1iZXIuTUFYX1ZBTFVFLGM7aWYoZSl7aWYoIXQuc3RhZ2dlckxpbmVzJiYoQShvKT9jPVtvXTpzPHQuYXV0b1JvdGF0aW9uTGltaXQmJihjPXQuYXV0b1JvdGF0aW9uKSksYyl7bGV0IHQsZTtmb3IobGV0IGkgb2YgYykoaT09PW98fGkmJmk+PS05MCYmaTw9OTApJiYoZT0odD1hKE1hdGguYWJzKHIvTWF0aC5zaW4odSppKSkpKStNYXRoLmFicyhpLzM2MCkpPGQmJihkPWUsbD1pLGg9dCl9fWVsc2UgaD1hKC43NSpyKTtyZXR1cm4gdGhpcy5hdXRvUm90YXRpb249Yyx0aGlzLmxhYmVsUm90YXRpb249RShsLEEobyk/bzowKSx0LnN0ZXA/aTpofWdldFNsb3RXaWR0aCh0KXtsZXQgZT10aGlzLmNoYXJ0LGk9dGhpcy5ob3JpeixzPXRoaXMub3B0aW9ucy5sYWJlbHMsbz1NYXRoLm1heCh0aGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoLSh0aGlzLmNhdGVnb3JpZXM/MDoxKSwxKSxyPWUubWFyZ2luWzNdO2lmKHQmJkEodC5zbG90V2lkdGgpKXJldHVybiB0LnNsb3RXaWR0aDtpZihpJiZzLnN0ZXA8MilyZXR1cm4gcy5yb3RhdGlvbj8wOih0aGlzLnN0YWdnZXJMaW5lc3x8MSkqdGhpcy5sZW4vbztpZighaSl7bGV0IHQ9cy5zdHlsZS53aWR0aDtpZih2b2lkIDAhPT10KXJldHVybiBwYXJzZUludChTdHJpbmcodCksMTApO2lmKHIpcmV0dXJuIHItZS5zcGFjaW5nWzNdfXJldHVybiAuMzMqZS5jaGFydFdpZHRofXJlbmRlclVuc3F1aXNoKCl7bGV0IHQ9dGhpcy5jaGFydCxlPXQucmVuZGVyZXIsaT10aGlzLnRpY2tQb3NpdGlvbnMscz10aGlzLnRpY2tzLG89dGhpcy5vcHRpb25zLmxhYmVscyxyPW8uc3R5bGUsbj10aGlzLmhvcml6LGE9dGhpcy5nZXRTbG90V2lkdGgoKSxoPU1hdGgubWF4KDEsTWF0aC5yb3VuZChhLTIqby5wYWRkaW5nKSksbD17fSxkPXRoaXMubGFiZWxNZXRyaWNzKCksYz1yLnRleHRPdmVyZmxvdyxwLHUsZz0wLGYsbTtpZihQKG8ucm90YXRpb24pfHwobC5yb3RhdGlvbj1vLnJvdGF0aW9ufHwwKSxpLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IGU9c1t0XTtlLm1vdmVkTGFiZWwmJmUucmVwbGFjZU1vdmVkTGFiZWwoKSxlJiZlLmxhYmVsJiZlLmxhYmVsLnRleHRQeExlbmd0aD5nJiYoZz1lLmxhYmVsLnRleHRQeExlbmd0aCl9KSx0aGlzLm1heExhYmVsTGVuZ3RoPWcsdGhpcy5hdXRvUm90YXRpb24pZz5oJiZnPmQuaD9sLnJvdGF0aW9uPXRoaXMubGFiZWxSb3RhdGlvbjp0aGlzLmxhYmVsUm90YXRpb249MDtlbHNlIGlmKGEmJihwPWgsIWMpKWZvcih1PVwiY2xpcFwiLG09aS5sZW5ndGg7IW4mJm0tLTspKGY9c1tpW21dXS5sYWJlbCkmJihmLnN0eWxlcyYmXCJlbGxpcHNpc1wiPT09Zi5zdHlsZXMudGV4dE92ZXJmbG93P2YuY3NzKHt0ZXh0T3ZlcmZsb3c6XCJjbGlwXCJ9KTpmLnRleHRQeExlbmd0aD5hJiZmLmNzcyh7d2lkdGg6YStcInB4XCJ9KSxmLmdldEJCb3goKS5oZWlnaHQ+dGhpcy5sZW4vaS5sZW5ndGgtKGQuaC1kLmYpJiYoZi5zcGVjaWZpY1RleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIpKTtsLnJvdGF0aW9uJiYocD1nPi41KnQuY2hhcnRIZWlnaHQ/LjMzKnQuY2hhcnRIZWlnaHQ6ZyxjfHwodT1cImVsbGlwc2lzXCIpKSx0aGlzLmxhYmVsQWxpZ249by5hbGlnbnx8dGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pLHRoaXMubGFiZWxBbGlnbiYmKGwuYWxpZ249dGhpcy5sYWJlbEFsaWduKSxpLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IGU9c1t0XSxpPWUmJmUubGFiZWwsbz1yLndpZHRoLG49e307aSYmKGkuYXR0cihsKSxlLnNob3J0ZW5MYWJlbD9lLnNob3J0ZW5MYWJlbCgpOnAmJiFvJiZcIm5vd3JhcFwiIT09ci53aGl0ZVNwYWNlJiYocDxpLnRleHRQeExlbmd0aHx8XCJTUEFOXCI9PT1pLmVsZW1lbnQudGFnTmFtZSk/KG4ud2lkdGg9cCtcInB4XCIsY3x8KG4udGV4dE92ZXJmbG93PWkuc3BlY2lmaWNUZXh0T3ZlcmZsb3d8fHUpLGkuY3NzKG4pKTppLnN0eWxlcyYmaS5zdHlsZXMud2lkdGgmJiFuLndpZHRoJiYhbyYmaS5jc3Moe3dpZHRoOm51bGx9KSxkZWxldGUgaS5zcGVjaWZpY1RleHRPdmVyZmxvdyxlLnJvdGF0aW9uPWwucm90YXRpb24pfSx0aGlzKSx0aGlzLnRpY2tSb3RDb3JyPWUucm90Q29ycihkLmIsdGhpcy5sYWJlbFJvdGF0aW9ufHwwLDAhPT10aGlzLnNpZGUpfWhhc0RhdGEoKXtyZXR1cm4gdGhpcy5zZXJpZXMuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdC5oYXNEYXRhKCl9KXx8dGhpcy5vcHRpb25zLnNob3dFbXB0eSYmeSh0aGlzLm1pbikmJnkodGhpcy5tYXgpfWFkZFRpdGxlKHQpe2xldCBlO2xldCBpPXRoaXMuY2hhcnQucmVuZGVyZXIscz10aGlzLmhvcml6LG89dGhpcy5vcHBvc2l0ZSxyPXRoaXMub3B0aW9ucyxuPXIudGl0bGUsYT10aGlzLmNoYXJ0LnN0eWxlZE1vZGU7dGhpcy5heGlzVGl0bGV8fCgoZT1uLnRleHRBbGlnbil8fChlPShzP3tsb3c6XCJsZWZ0XCIsbWlkZGxlOlwiY2VudGVyXCIsaGlnaDpcInJpZ2h0XCJ9Ontsb3c6bz9cInJpZ2h0XCI6XCJsZWZ0XCIsbWlkZGxlOlwiY2VudGVyXCIsaGlnaDpvP1wibGVmdFwiOlwicmlnaHRcIn0pW24uYWxpZ25dKSx0aGlzLmF4aXNUaXRsZT1pLnRleHQobi50ZXh0fHxcIlwiLDAsMCxuLnVzZUhUTUwpLmF0dHIoe3pJbmRleDo3LHJvdGF0aW9uOm4ucm90YXRpb258fDAsYWxpZ246ZX0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1heGlzLXRpdGxlXCIpLGF8fHRoaXMuYXhpc1RpdGxlLmNzcyhMKG4uc3R5bGUpKSx0aGlzLmF4aXNUaXRsZS5hZGQodGhpcy5heGlzR3JvdXApLHRoaXMuYXhpc1RpdGxlLmlzTmV3PSEwKSxhfHxuLnN0eWxlLndpZHRofHx0aGlzLmlzUmFkaWFsfHx0aGlzLmF4aXNUaXRsZS5jc3Moe3dpZHRoOnRoaXMubGVuK1wicHhcIn0pLHRoaXMuYXhpc1RpdGxlW3Q/XCJzaG93XCI6XCJoaWRlXCJdKHQpfWdlbmVyYXRlVGljayh0KXtsZXQgZT10aGlzLnRpY2tzO2VbdF0/ZVt0XS5hZGRMYWJlbCgpOmVbdF09bmV3IG4odGhpcyx0KX1jcmVhdGVHcm91cHMoKXtsZXR7YXhpc1BhcmVudDp0LGNoYXJ0OmUsY29sbDppLG9wdGlvbnM6c309dGhpcyxvPWUucmVuZGVyZXIscj0oZSxyLG4pPT5vLmcoZSkuYXR0cih7ekluZGV4Om59KS5hZGRDbGFzcyhgaGlnaGNoYXJ0cy0ke2kudG9Mb3dlckNhc2UoKX0ke3J9IGArKHRoaXMuaXNSYWRpYWw/YGhpZ2hjaGFydHMtcmFkaWFsLWF4aXMke3J9IGA6XCJcIikrKHMuY2xhc3NOYW1lfHxcIlwiKSkuYWRkKHQpO3RoaXMuYXhpc0dyb3VwfHwodGhpcy5ncmlkR3JvdXA9cihcImdyaWRcIixcIi1ncmlkXCIscy5ncmlkWkluZGV4KSx0aGlzLmF4aXNHcm91cD1yKFwiYXhpc1wiLFwiXCIscy56SW5kZXgpLHRoaXMubGFiZWxHcm91cD1yKFwiYXhpcy1sYWJlbHNcIixcIi1sYWJlbHNcIixzLmxhYmVscy56SW5kZXgpKX1nZXRPZmZzZXQoKXtsZXQgdD10aGlzLHtjaGFydDplLGhvcml6Omksb3B0aW9uczpzLHNpZGU6byx0aWNrczpyLHRpY2tQb3NpdGlvbnM6bixjb2xsOmF9PXQsaD1lLmludmVydGVkJiYhdC5pc1pBeGlzP1sxLDAsMywyXVtvXTpvLGw9dC5oYXNEYXRhKCksZD1zLnRpdGxlLGM9cy5sYWJlbHMscD1BKHMuY3Jvc3NpbmcpLHU9ZS5heGlzT2Zmc2V0LGc9ZS5jbGlwT2Zmc2V0LGY9Wy0xLDEsMSwtMV1bb10sbSx4PTAsYix2PTAsUz0wLGssQztpZih0LnNob3dBeGlzPW09bHx8cy5zaG93RW1wdHksdC5zdGFnZ2VyTGluZXM9dC5ob3JpeiYmYy5zdGFnZ2VyTGluZXN8fHZvaWQgMCx0LmNyZWF0ZUdyb3VwcygpLGx8fHQuaXNMaW5rZWQ/KG4uZm9yRWFjaChmdW5jdGlvbihlKXt0LmdlbmVyYXRlVGljayhlKX0pLHQucmVuZGVyVW5zcXVpc2goKSx0LnJlc2VydmVTcGFjZURlZmF1bHQ9MD09PW98fDI9PT1vfHwoezE6XCJsZWZ0XCIsMzpcInJpZ2h0XCJ9KVtvXT09PXQubGFiZWxBbGlnbixFKGMucmVzZXJ2ZVNwYWNlLCFwJiZudWxsLFwiY2VudGVyXCI9PT10LmxhYmVsQWxpZ258fG51bGwsdC5yZXNlcnZlU3BhY2VEZWZhdWx0KSYmbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe1M9TWF0aC5tYXgoclt0XS5nZXRMYWJlbFNpemUoKSxTKX0pLHQuc3RhZ2dlckxpbmVzJiYoUyo9dC5zdGFnZ2VyTGluZXMpLHQubGFiZWxPZmZzZXQ9UyoodC5vcHBvc2l0ZT8tMToxKSk6RChyLGZ1bmN0aW9uKHQsZSl7dC5kZXN0cm95KCksZGVsZXRlIHJbZV19KSxkPy50ZXh0JiYhMSE9PWQuZW5hYmxlZCYmKHQuYWRkVGl0bGUobSksbSYmIXAmJiExIT09ZC5yZXNlcnZlU3BhY2UmJih0LnRpdGxlT2Zmc2V0PXg9dC5heGlzVGl0bGUuZ2V0QkJveCgpW2k/XCJoZWlnaHRcIjpcIndpZHRoXCJdLHY9eShiPWQub2Zmc2V0KT8wOkUoZC5tYXJnaW4saT81OjEwKSkpLHQucmVuZGVyTGluZSgpLHQub2Zmc2V0PWYqRShzLm9mZnNldCx1W29dP3Vbb10rKHMubWFyZ2lufHwwKTowKSx0LnRpY2tSb3RDb3JyPXQudGlja1JvdENvcnJ8fHt4OjAseTowfSxDPTA9PT1vPy10LmxhYmVsTWV0cmljcygpLmg6Mj09PW8/dC50aWNrUm90Q29yci55OjAsaz1NYXRoLmFicyhTKSt2LFMmJihrLT1DLGsrPWYqKGk/RShjLnksdC50aWNrUm90Q29yci55K2YqYy5kaXN0YW5jZSk6RShjLngsZipjLmRpc3RhbmNlKSkpLHQuYXhpc1RpdGxlTWFyZ2luPUUoYixrKSx0LmdldE1heExhYmVsRGltZW5zaW9ucyYmKHQubWF4TGFiZWxEaW1lbnNpb25zPXQuZ2V0TWF4TGFiZWxEaW1lbnNpb25zKHIsbikpLFwiY29sb3JBeGlzXCIhPT1hKXtsZXQgZT10aGlzLnRpY2tTaXplKFwidGlja1wiKTt1W29dPU1hdGgubWF4KHVbb10sKHQuYXhpc1RpdGxlTWFyZ2lufHwwKSt4K2YqdC5vZmZzZXQsayxuJiZuLmxlbmd0aCYmZT9lWzBdK2YqdC5vZmZzZXQ6MCk7bGV0IGk9IXQuYXhpc0xpbmV8fHMub2Zmc2V0PzA6MipNYXRoLmZsb29yKHQuYXhpc0xpbmUuc3Ryb2tlV2lkdGgoKS8yKTtnW2hdPU1hdGgubWF4KGdbaF0saSl9TSh0aGlzLFwiYWZ0ZXJHZXRPZmZzZXRcIil9Z2V0TGluZVBhdGgodCl7bGV0IGU9dGhpcy5jaGFydCxpPXRoaXMub3Bwb3NpdGUscz10aGlzLm9mZnNldCxvPXRoaXMuaG9yaXoscj10aGlzLmxlZnQrKGk/dGhpcy53aWR0aDowKStzLG49ZS5jaGFydEhlaWdodC10aGlzLmJvdHRvbS0oaT90aGlzLmhlaWdodDowKStzO3JldHVybiBpJiYodCo9LTEpLGUucmVuZGVyZXIuY3Jpc3BMaW5lKFtbXCJNXCIsbz90aGlzLmxlZnQ6cixvP246dGhpcy50b3BdLFtcIkxcIixvP2UuY2hhcnRXaWR0aC10aGlzLnJpZ2h0OnIsbz9uOmUuY2hhcnRIZWlnaHQtdGhpcy5ib3R0b21dXSx0KX1yZW5kZXJMaW5lKCl7dGhpcy5heGlzTGluZXx8KHRoaXMuYXhpc0xpbmU9dGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWF4aXMtbGluZVwiKS5hZGQodGhpcy5heGlzR3JvdXApLHRoaXMuY2hhcnQuc3R5bGVkTW9kZXx8dGhpcy5heGlzTGluZS5hdHRyKHtzdHJva2U6dGhpcy5vcHRpb25zLmxpbmVDb2xvcixcInN0cm9rZS13aWR0aFwiOnRoaXMub3B0aW9ucy5saW5lV2lkdGgsekluZGV4Ojd9KSl9Z2V0VGl0bGVQb3NpdGlvbih0KXtsZXQgZT10aGlzLmhvcml6LGk9dGhpcy5sZWZ0LHM9dGhpcy50b3Asbz10aGlzLmxlbixyPXRoaXMub3B0aW9ucy50aXRsZSxuPWU/aTpzLGE9dGhpcy5vcHBvc2l0ZSxoPXRoaXMub2Zmc2V0LGw9ci54LGQ9ci55LGM9dGhpcy5jaGFydC5yZW5kZXJlci5mb250TWV0cmljcyh0KSxwPXQ/TWF0aC5tYXgodC5nZXRCQm94KCExLDApLmhlaWdodC1jLmgtMSwwKTowLHU9e2xvdzpuKyhlPzA6byksbWlkZGxlOm4rby8yLGhpZ2g6bisoZT9vOjApfVtyLmFsaWduXSxnPShlP3MrdGhpcy5oZWlnaHQ6aSkrKGU/MTotMSkqKGE/LTE6MSkqKHRoaXMuYXhpc1RpdGxlTWFyZ2lufHwwKStbLXAscCxjLmYsLXBdW3RoaXMuc2lkZV0sZj17eDplP3UrbDpnKyhhP3RoaXMud2lkdGg6MCkraCtsLHk6ZT9nK2QtKGE/dGhpcy5oZWlnaHQ6MCkraDp1K2R9O3JldHVybiBNKHRoaXMsXCJhZnRlckdldFRpdGxlUG9zaXRpb25cIix7dGl0bGVQb3NpdGlvbjpmfSksZn1yZW5kZXJNaW5vclRpY2sodCxlKXtsZXQgaT10aGlzLm1pbm9yVGlja3M7aVt0XXx8KGlbdF09bmV3IG4odGhpcyx0LFwibWlub3JcIikpLGUmJmlbdF0uaXNOZXcmJmlbdF0ucmVuZGVyKG51bGwsITApLGlbdF0ucmVuZGVyKG51bGwsITEsMSl9cmVuZGVyVGljayh0LGUsaSl7bGV0IHM9dGhpcy5pc0xpbmtlZCxvPXRoaXMudGlja3M7KCFzfHx0Pj10aGlzLm1pbiYmdDw9dGhpcy5tYXh8fHRoaXMuZ3JpZCYmdGhpcy5ncmlkLmlzQ29sdW1uKSYmKG9bdF18fChvW3RdPW5ldyBuKHRoaXMsdCkpLGkmJm9bdF0uaXNOZXcmJm9bdF0ucmVuZGVyKGUsITAsLTEpLG9bdF0ucmVuZGVyKGUpKX1yZW5kZXIoKXtsZXQgdCxlO2xldCBpPXRoaXMscz1pLmNoYXJ0LG89aS5sb2dhcml0aG1pYyxhPXMucmVuZGVyZXIsbD1pLm9wdGlvbnMsZD1pLmlzTGlua2VkLGM9aS50aWNrUG9zaXRpb25zLHA9aS5heGlzVGl0bGUsdT1pLnRpY2tzLGc9aS5taW5vclRpY2tzLGY9aS5hbHRlcm5hdGVCYW5kcyxtPWwuc3RhY2tMYWJlbHMseD1sLmFsdGVybmF0ZUdyaWRDb2xvcix5PWwuY3Jvc3NpbmcsYj1pLnRpY2ttYXJrT2Zmc2V0LHY9aS5heGlzTGluZSxTPWkuc2hvd0F4aXMsaz1oKGEuZ2xvYmFsQW5pbWF0aW9uKTtpZihpLmxhYmVsRWRnZS5sZW5ndGg9MCxpLm92ZXJsYXA9ITEsW3UsZyxmXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe0QodCxmdW5jdGlvbih0KXt0LmlzQWN0aXZlPSExfSl9KSxBKHkpKXtsZXQgdD10aGlzLmlzWEF4aXM/cy55QXhpc1swXTpzLnhBeGlzWzBdLGU9WzEsLTEsLTEsMV1bdGhpcy5zaWRlXTtpZih0KXtsZXQgcz10LnRvUGl4ZWxzKHksITApO2kuaG9yaXomJihzPXQubGVuLXMpLGkub2Zmc2V0PWUqc319aWYoaS5oYXNEYXRhKCl8fGQpe2xldCBhPWkuY2hhcnQuaGFzUmVuZGVyZWQmJmkub2xkJiZBKGkub2xkLm1pbik7aS5taW5vclRpY2tJbnRlcnZhbCYmIWkuY2F0ZWdvcmllcyYmaS5nZXRNaW5vclRpY2tQb3NpdGlvbnMoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2kucmVuZGVyTWlub3JUaWNrKHQsYSl9KSxjLmxlbmd0aCYmKGMuZm9yRWFjaChmdW5jdGlvbih0LGUpe2kucmVuZGVyVGljayh0LGUsYSl9KSxiJiYoMD09PWkubWlufHxpLnNpbmdsZSkmJih1Wy0xXXx8KHVbLTFdPW5ldyBuKGksLTEsbnVsbCwhMCkpLHVbLTFdLnJlbmRlcigtMSkpKSx4JiZjLmZvckVhY2goZnVuY3Rpb24obixhKXtlPXZvaWQgMCE9PWNbYSsxXT9jW2ErMV0rYjppLm1heC1iLGElMj09MCYmbjxpLm1heCYmZTw9aS5tYXgrKHMucG9sYXI/LWI6YikmJihmW25dfHwoZltuXT1uZXcgci5QbG90TGluZU9yQmFuZChpLHt9KSksdD1uK2IsZltuXS5vcHRpb25zPXtmcm9tOm8/by5saW4ybG9nKHQpOnQsdG86bz9vLmxpbjJsb2coZSk6ZSxjb2xvcjp4LGNsYXNzTmFtZTpcImhpZ2hjaGFydHMtYWx0ZXJuYXRlLWdyaWRcIn0sZltuXS5yZW5kZXIoKSxmW25dLmlzQWN0aXZlPSEwKX0pLGkuX2FkZGVkUGxvdExCfHwoaS5fYWRkZWRQbG90TEI9ITAsKGwucGxvdExpbmVzfHxbXSkuY29uY2F0KGwucGxvdEJhbmRzfHxbXSkuZm9yRWFjaChmdW5jdGlvbih0KXtpLmFkZFBsb3RCYW5kT3JMaW5lKHQpfSkpfVt1LGcsZl0uZm9yRWFjaChmdW5jdGlvbih0KXtsZXQgZT1bXSxpPWsuZHVyYXRpb247RCh0LGZ1bmN0aW9uKHQsaSl7dC5pc0FjdGl2ZXx8KHQucmVuZGVyKGksITEsMCksdC5pc0FjdGl2ZT0hMSxlLnB1c2goaSkpfSksUihmdW5jdGlvbigpe2xldCBpPWUubGVuZ3RoO2Zvcig7aS0tOyl0W2VbaV1dJiYhdFtlW2ldXS5pc0FjdGl2ZSYmKHRbZVtpXV0uZGVzdHJveSgpLGRlbGV0ZSB0W2VbaV1dKX0sdCE9PWYmJnMuaGFzUmVuZGVyZWQmJmk/aTowKX0pLHYmJih2W3YuaXNQbGFjZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHtkOnRoaXMuZ2V0TGluZVBhdGgodi5zdHJva2VXaWR0aCgpKX0pLHYuaXNQbGFjZWQ9ITAsdltTP1wic2hvd1wiOlwiaGlkZVwiXShTKSkscCYmUyYmKHBbcC5pc05ldz9cImF0dHJcIjpcImFuaW1hdGVcIl0oaS5nZXRUaXRsZVBvc2l0aW9uKHApKSxwLmlzTmV3PSExKSxtJiZtLmVuYWJsZWQmJmkuc3RhY2tpbmcmJmkuc3RhY2tpbmcucmVuZGVyU3RhY2tUb3RhbHMoKSxpLm9sZD17bGVuOmkubGVuLG1heDppLm1heCxtaW46aS5taW4sdHJhbnNBOmkudHJhbnNBLHVzZXJNYXg6aS51c2VyTWF4LHVzZXJNaW46aS51c2VyTWlufSxpLmlzRGlydHk9ITEsTSh0aGlzLFwiYWZ0ZXJSZW5kZXJcIil9cmVkcmF3KCl7dGhpcy52aXNpYmxlJiYodGhpcy5yZW5kZXIoKSx0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLmZvckVhY2goZnVuY3Rpb24odCl7dC5yZW5kZXIoKX0pKSx0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuaXNEaXJ0eT0hMH0pfWdldEtlZXBQcm9wcygpe3JldHVybiB0aGlzLmtlZXBQcm9wc3x8Ti5rZWVwUHJvcHN9ZGVzdHJveSh0KXtsZXQgZT10aGlzLGk9ZS5wbG90TGluZXNBbmRCYW5kcyxzPXRoaXMuZXZlbnRPcHRpb25zO2lmKE0odGhpcyxcImRlc3Ryb3lcIix7a2VlcEV2ZW50czp0fSksdHx8SShlKSxbZS50aWNrcyxlLm1pbm9yVGlja3MsZS5hbHRlcm5hdGVCYW5kc10uZm9yRWFjaChmdW5jdGlvbih0KXtiKHQpfSksaSl7bGV0IHQ9aS5sZW5ndGg7Zm9yKDt0LS07KWlbdF0uZGVzdHJveSgpfWZvcihsZXQgdCBpbltcImF4aXNMaW5lXCIsXCJheGlzVGl0bGVcIixcImF4aXNHcm91cFwiLFwiZ3JpZEdyb3VwXCIsXCJsYWJlbEdyb3VwXCIsXCJjcm9zc1wiLFwic2Nyb2xsYmFyXCJdLmZvckVhY2goZnVuY3Rpb24odCl7ZVt0XSYmKGVbdF09ZVt0XS5kZXN0cm95KCkpfSksZS5wbG90TGluZXNBbmRCYW5kc0dyb3VwcyllLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW3RdPWUucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbdF0uZGVzdHJveSgpO0QoZSxmdW5jdGlvbih0LGkpey0xPT09ZS5nZXRLZWVwUHJvcHMoKS5pbmRleE9mKGkpJiZkZWxldGUgZVtpXX0pLHRoaXMuZXZlbnRPcHRpb25zPXN9ZHJhd0Nyb3NzaGFpcih0LGUpe2xldCBzPXRoaXMuY3Jvc3NoYWlyLG89RShzJiZzLnNuYXAsITApLHI9dGhpcy5jaGFydCxuLGEsaCxsPXRoaXMuY3Jvc3MsZDtpZihNKHRoaXMsXCJkcmF3Q3Jvc3NoYWlyXCIse2U6dCxwb2ludDplfSksdHx8KHQ9dGhpcy5jcm9zcyYmdGhpcy5jcm9zcy5lKSxzJiYhMSE9PSh5KGUpfHwhbykpe2lmKG8/eShlKSYmKGE9RShcImNvbG9yQXhpc1wiIT09dGhpcy5jb2xsP2UuY3Jvc3NoYWlyUG9zOm51bGwsdGhpcy5pc1hBeGlzP2UucGxvdFg6dGhpcy5sZW4tZS5wbG90WSkpOmE9dCYmKHRoaXMuaG9yaXo/dC5jaGFydFgtdGhpcy5wb3M6dGhpcy5sZW4tdC5jaGFydFkrdGhpcy5wb3MpLHkoYSkmJihkPXt2YWx1ZTplJiYodGhpcy5pc1hBeGlzP2UueDpFKGUuc3RhY2tZLGUueSkpLHRyYW5zbGF0ZWRWYWx1ZTphfSxyLnBvbGFyJiZrKGQse2lzQ3Jvc3NoYWlyOiEwLGNoYXJ0WDp0JiZ0LmNoYXJ0WCxjaGFydFk6dCYmdC5jaGFydFkscG9pbnQ6ZX0pLG49dGhpcy5nZXRQbG90TGluZVBhdGgoZCl8fG51bGwpLCF5KG4pKXt0aGlzLmhpZGVDcm9zc2hhaXIoKTtyZXR1cm59aD10aGlzLmNhdGVnb3JpZXMmJiF0aGlzLmlzUmFkaWFsLGx8fCh0aGlzLmNyb3NzPWw9ci5yZW5kZXJlci5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyb3NzaGFpciBoaWdoY2hhcnRzLWNyb3NzaGFpci1cIisoaD9cImNhdGVnb3J5IFwiOlwidGhpbiBcIikrKHMuY2xhc3NOYW1lfHxcIlwiKSkuYXR0cih7ekluZGV4OkUocy56SW5kZXgsMil9KS5hZGQoKSwhci5zdHlsZWRNb2RlJiYobC5hdHRyKHtzdHJva2U6cy5jb2xvcnx8KGg/aS5wYXJzZShcIiNjY2QzZmZcIikuc2V0T3BhY2l0eSguMjUpLmdldCgpOlwiI2NjY2NjY1wiKSxcInN0cm9rZS13aWR0aFwiOkUocy53aWR0aCwxKX0pLmNzcyh7XCJwb2ludGVyLWV2ZW50c1wiOlwibm9uZVwifSkscy5kYXNoU3R5bGUmJmwuYXR0cih7ZGFzaHN0eWxlOnMuZGFzaFN0eWxlfSkpKSxsLnNob3coKS5hdHRyKHtkOm59KSxoJiYhcy53aWR0aCYmbC5hdHRyKHtcInN0cm9rZS13aWR0aFwiOnRoaXMudHJhbnNBfSksdGhpcy5jcm9zcy5lPXR9ZWxzZSB0aGlzLmhpZGVDcm9zc2hhaXIoKTtNKHRoaXMsXCJhZnRlckRyYXdDcm9zc2hhaXJcIix7ZTp0LHBvaW50OmV9KX1oaWRlQ3Jvc3NoYWlyKCl7dGhpcy5jcm9zcyYmdGhpcy5jcm9zcy5oaWRlKCksTSh0aGlzLFwiYWZ0ZXJIaWRlQ3Jvc3NoYWlyXCIpfWhhc1ZlcnRpY2FsUGFubmluZygpe2xldCB0PXRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5wYW5uaW5nO3JldHVybiEhKHQmJnQuZW5hYmxlZCYmL3kvLnRlc3QodC50eXBlKSl9dXBkYXRlKHQsZSl7bGV0IGk9dGhpcy5jaGFydDt0PUwodGhpcy51c2VyT3B0aW9ucyx0KSx0aGlzLmRlc3Ryb3koITApLHRoaXMuaW5pdChpLHQpLGkuaXNEaXJ0eUJveD0hMCxFKGUsITApJiZpLnJlZHJhdygpfXJlbW92ZSh0KXtsZXQgZT10aGlzLmNoYXJ0LGk9dGhpcy5jb2xsLHM9dGhpcy5zZXJpZXMsbz1zLmxlbmd0aDtmb3IoO28tLTspc1tvXSYmc1tvXS5yZW1vdmUoITEpO3YoZS5heGVzLHRoaXMpLHYoZVtpXXx8W10sdGhpcyksZS5vcmRlckl0ZW1zKGkpLHRoaXMuZGVzdHJveSgpLGUuaXNEaXJ0eUJveD0hMCxFKHQsITApJiZlLnJlZHJhdygpfXNldFRpdGxlKHQsZSl7dGhpcy51cGRhdGUoe3RpdGxlOnR9LGUpfXNldENhdGVnb3JpZXModCxlKXt0aGlzLnVwZGF0ZSh7Y2F0ZWdvcmllczp0fSxlKX19cmV0dXJuIE4ua2VlcFByb3BzPVtcImNvbGxcIixcImV4dEtleVwiLFwiaGNFdmVudHNcIixcIm5hbWVzXCIsXCJzZXJpZXNcIixcInVzZXJNYXhcIixcInVzZXJNaW5cIl0sTn0pLGkoZSxcIkNvcmUvQXhpcy9EYXRlVGltZUF4aXMuanNcIixbZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSl7dmFyIGk7bGV0e2NvbXBvc2VkOnN9PXQse2FkZEV2ZW50Om8sZ2V0TWFnbml0dWRlOnIsbm9ybWFsaXplVGlja0ludGVydmFsOm4scHVzaFVuaXF1ZTphLHRpbWVVbml0czpofT1lO3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHRoaXMuY2hhcnQudGltZS5nZXRUaW1lVGlja3MuYXBwbHkodGhpcy5jaGFydC50aW1lLGFyZ3VtZW50cyl9ZnVuY3Rpb24gaSgpe2lmKFwiZGF0ZXRpbWVcIiE9PXRoaXMub3B0aW9ucy50eXBlKXt0aGlzLmRhdGVUaW1lPXZvaWQgMDtyZXR1cm59dGhpcy5kYXRlVGltZXx8KHRoaXMuZGF0ZVRpbWU9bmV3IGwodGhpcykpfXQuY29tcG9zZT1mdW5jdGlvbiB0KHIpe2lmKGEocyx0KSl7ci5rZWVwUHJvcHMucHVzaChcImRhdGVUaW1lXCIpO2xldCB0PXIucHJvdG90eXBlO3QuZ2V0VGltZVRpY2tzPWUsbyhyLFwiYWZ0ZXJTZXRPcHRpb25zXCIsaSl9cmV0dXJuIHJ9O2NsYXNzIGx7Y29uc3RydWN0b3IodCl7dGhpcy5heGlzPXR9bm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0LGUpe2xldCBpPWV8fFtbXCJtaWxsaXNlY29uZFwiLFsxLDIsNSwxMCwyMCwyNSw1MCwxMDAsMjAwLDUwMF1dLFtcInNlY29uZFwiLFsxLDIsNSwxMCwxNSwzMF1dLFtcIm1pbnV0ZVwiLFsxLDIsNSwxMCwxNSwzMF1dLFtcImhvdXJcIixbMSwyLDMsNCw2LDgsMTJdXSxbXCJkYXlcIixbMSwyXV0sW1wid2Vla1wiLFsxLDJdXSxbXCJtb250aFwiLFsxLDIsMyw0LDZdXSxbXCJ5ZWFyXCIsbnVsbF1dLHM9aVtpLmxlbmd0aC0xXSxvPWhbc1swXV0sYT1zWzFdLGw7Zm9yKGw9MDtsPGkubGVuZ3RoO2wrKylpZihvPWhbKHM9aVtsXSlbMF1dLGE9c1sxXSxpW2wrMV0pe2xldCBlPShvKmFbYS5sZW5ndGgtMV0raFtpW2wrMV1bMF1dKS8yO2lmKHQ8PWUpYnJlYWt9bz09PWgueWVhciYmdDw1Km8mJihhPVsxLDIsNV0pO2xldCBkPW4odC9vLGEsXCJ5ZWFyXCI9PT1zWzBdP01hdGgubWF4KHIodC9vKSwxKToxKTtyZXR1cm57dW5pdFJhbmdlOm8sY291bnQ6ZCx1bml0TmFtZTpzWzBdfX1nZXRYRGF0ZUZvcm1hdCh0LGUpe2xldHtheGlzOml9PXRoaXMscz1pLmNoYXJ0LnRpbWU7cmV0dXJuIGkuY2xvc2VzdFBvaW50UmFuZ2U/cy5nZXREYXRlRm9ybWF0KGkuY2xvc2VzdFBvaW50UmFuZ2UsdCxpLm9wdGlvbnMuc3RhcnRPZldlZWssZSl8fHMucmVzb2x2ZURUTEZvcm1hdChlLnllYXIpLm1haW46cy5yZXNvbHZlRFRMRm9ybWF0KGUuZGF5KS5tYWlufX10LkFkZGl0aW9ucz1sfShpfHwoaT17fSkpLGl9KSxpKGUsXCJDb3JlL0F4aXMvTG9nYXJpdGhtaWNBeGlzLmpzXCIsW2VbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUpe3ZhciBpO2xldHtjb21wb3NlZDpzfT10LHthZGRFdmVudDpvLG5vcm1hbGl6ZVRpY2tJbnRlcnZhbDpyLHBpY2s6bixwdXNoVW5pcXVlOmF9PWU7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7bGV0IGU9dC51c2VyT3B0aW9ucyxpPXRoaXMubG9nYXJpdGhtaWM7XCJsb2dhcml0aG1pY1wiIT09ZS50eXBlP3RoaXMubG9nYXJpdGhtaWM9dm9pZCAwOml8fChpPXRoaXMubG9nYXJpdGhtaWM9bmV3IGgodGhpcykpfWZ1bmN0aW9uIGkoKXtsZXQgdD10aGlzLmxvZ2FyaXRobWljO3QmJih0aGlzLmxpbjJ2YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHQubGluMmxvZyhlKX0sdGhpcy52YWwybGluPWZ1bmN0aW9uKGUpe3JldHVybiB0LmxvZzJsaW4oZSl9KX10LmNvbXBvc2U9ZnVuY3Rpb24gdChyKXtyZXR1cm4gYShzLHQpJiYoci5rZWVwUHJvcHMucHVzaChcImxvZ2FyaXRobWljXCIpLG8ocixcImluaXRcIixlKSxvKHIsXCJhZnRlckluaXRcIixpKSkscn07Y2xhc3MgaHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmF4aXM9dH1nZXRMb2dUaWNrUG9zaXRpb25zKHQsZSxpLHMpe2xldCBvPXRoaXMuYXhpcyxhPW8ubGVuLGg9by5vcHRpb25zLGw9W107aWYoc3x8KHRoaXMubWlub3JBdXRvSW50ZXJ2YWw9dm9pZCAwKSx0Pj0uNSl0PU1hdGgucm91bmQodCksbD1vLmdldExpbmVhclRpY2tQb3NpdGlvbnModCxlLGkpO2Vsc2UgaWYodD49LjA4KXtsZXQgbyxyLG4sYSxoLGQsYztsZXQgcD1NYXRoLmZsb29yKGUpO2ZvcihvPXQ+LjM/WzEsMiw0XTp0Pi4xNT9bMSwyLDQsNiw4XTpbMSwyLDMsNCw1LDYsNyw4LDldLHI9cDtyPGkrMSYmIWM7cisrKWZvcihuPTAsYT1vLmxlbmd0aDtuPGEmJiFjO24rKykoaD10aGlzLmxvZzJsaW4odGhpcy5saW4ybG9nKHIpKm9bbl0pKT5lJiYoIXN8fGQ8PWkpJiZ2b2lkIDAhPT1kJiZsLnB1c2goZCksZD5pJiYoYz0hMCksZD1ofWVsc2V7bGV0IGQ9dGhpcy5saW4ybG9nKGUpLGM9dGhpcy5saW4ybG9nKGkpLHA9cz9vLmdldE1pbm9yVGlja0ludGVydmFsKCk6aC50aWNrSW50ZXJ2YWwsdT1cImF1dG9cIj09PXA/bnVsbDpwLGc9aC50aWNrUGl4ZWxJbnRlcnZhbC8ocz81OjEpLGY9cz9hL28udGlja1Bvc2l0aW9ucy5sZW5ndGg6YTt0PXIodD1uKHUsdGhpcy5taW5vckF1dG9JbnRlcnZhbCwoYy1kKSpnLyhmfHwxKSkpLGw9by5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHQsZCxjKS5tYXAodGhpcy5sb2cybGluKSxzfHwodGhpcy5taW5vckF1dG9JbnRlcnZhbD10LzUpfXJldHVybiBzfHwoby50aWNrSW50ZXJ2YWw9dCksbH1saW4ybG9nKHQpe3JldHVybiBNYXRoLnBvdygxMCx0KX1sb2cybGluKHQpe3JldHVybiBNYXRoLmxvZyh0KS9NYXRoLkxOMTB9fXQuQWRkaXRpb25zPWh9KGl8fChpPXt9KSksaX0pLGkoZSxcIkNvcmUvQXhpcy9QbG90TGluZU9yQmFuZC9QbG90TGluZU9yQmFuZEF4aXMuanNcIixbZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSl7dmFyIGk7bGV0e2NvbXBvc2VkOnN9PXQse2VyYXNlOm8sZXh0ZW5kOnIsaXNOdW1iZXI6bixwdXNoVW5pcXVlOmF9PWU7cmV0dXJuIGZ1bmN0aW9uKHQpe2xldCBlO2Z1bmN0aW9uIGkodCl7cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUodCxcInBsb3RCYW5kc1wiKX1mdW5jdGlvbiBoKHQsaSl7bGV0IHM9dGhpcy51c2VyT3B0aW9ucyxvPW5ldyBlKHRoaXMsdCk7aWYodGhpcy52aXNpYmxlJiYobz1vLnJlbmRlcigpKSxvKXtpZih0aGlzLl9hZGRlZFBsb3RMQnx8KHRoaXMuX2FkZGVkUGxvdExCPSEwLChzLnBsb3RMaW5lc3x8W10pLmNvbmNhdChzLnBsb3RCYW5kc3x8W10pLmZvckVhY2godD0+e3RoaXMuYWRkUGxvdEJhbmRPckxpbmUodCl9KSksaSl7bGV0IGU9c1tpXXx8W107ZS5wdXNoKHQpLHNbaV09ZX10aGlzLnBsb3RMaW5lc0FuZEJhbmRzLnB1c2gobyl9cmV0dXJuIG99ZnVuY3Rpb24gbCh0KXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZSh0LFwicGxvdExpbmVzXCIpfWZ1bmN0aW9uIGQodCxlLGkpe2k9aXx8dGhpcy5vcHRpb25zO2xldCBzPXRoaXMuZ2V0UGxvdExpbmVQYXRoKHt2YWx1ZTplLGZvcmNlOiEwLGFjcm9zc1BhbmVzOmkuYWNyb3NzUGFuZXN9KSxvPVtdLHI9dGhpcy5ob3JpeixhPSFuKHRoaXMubWluKXx8IW4odGhpcy5tYXgpfHx0PHRoaXMubWluJiZlPHRoaXMubWlufHx0PnRoaXMubWF4JiZlPnRoaXMubWF4LGg9dGhpcy5nZXRQbG90TGluZVBhdGgoe3ZhbHVlOnQsZm9yY2U6ITAsYWNyb3NzUGFuZXM6aS5hY3Jvc3NQYW5lc30pLGwsZD0xLGM7aWYoaCYmcylmb3IoYSYmKGM9aC50b1N0cmluZygpPT09cy50b1N0cmluZygpLGQ9MCksbD0wO2w8aC5sZW5ndGg7bCs9Mil7bGV0IHQ9aFtsXSxlPWhbbCsxXSxpPXNbbF0sbj1zW2wrMV07KFwiTVwiPT09dFswXXx8XCJMXCI9PT10WzBdKSYmKFwiTVwiPT09ZVswXXx8XCJMXCI9PT1lWzBdKSYmKFwiTVwiPT09aVswXXx8XCJMXCI9PT1pWzBdKSYmKFwiTVwiPT09blswXXx8XCJMXCI9PT1uWzBdKSYmKHImJmlbMV09PT10WzFdPyhpWzFdKz1kLG5bMV0rPWQpOnJ8fGlbMl0hPT10WzJdfHwoaVsyXSs9ZCxuWzJdKz1kKSxvLnB1c2goW1wiTVwiLHRbMV0sdFsyXV0sW1wiTFwiLGVbMV0sZVsyXV0sW1wiTFwiLG5bMV0sblsyXV0sW1wiTFwiLGlbMV0saVsyXV0sW1wiWlwiXSkpLG8uaXNGbGF0PWN9cmV0dXJuIG99ZnVuY3Rpb24gYyh0KXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKHQpfWZ1bmN0aW9uIHAodCl7bGV0IGU9dGhpcy5wbG90TGluZXNBbmRCYW5kcyxpPXRoaXMub3B0aW9ucyxzPXRoaXMudXNlck9wdGlvbnM7aWYoZSl7bGV0IHI9ZS5sZW5ndGg7Zm9yKDtyLS07KWVbcl0uaWQ9PT10JiZlW3JdLmRlc3Ryb3koKTtbaS5wbG90TGluZXN8fFtdLHMucGxvdExpbmVzfHxbXSxpLnBsb3RCYW5kc3x8W10scy5wbG90QmFuZHN8fFtdXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2ZvcihyPWUubGVuZ3RoO3ItLTspKGVbcl18fHt9KS5pZD09PXQmJm8oZSxlW3JdKX0pfX1mdW5jdGlvbiB1KHQpe3RoaXMucmVtb3ZlUGxvdEJhbmRPckxpbmUodCl9dC5jb21wb3NlPWZ1bmN0aW9uIHQobyxuKXtyZXR1cm4gYShzLHQpJiYoZT1vLHIobi5wcm90b3R5cGUse2FkZFBsb3RCYW5kOmksYWRkUGxvdExpbmU6bCxhZGRQbG90QmFuZE9yTGluZTpoLGdldFBsb3RCYW5kUGF0aDpkLHJlbW92ZVBsb3RCYW5kOmMscmVtb3ZlUGxvdExpbmU6dSxyZW1vdmVQbG90QmFuZE9yTGluZTpwfSkpLG59fShpfHwoaT17fSkpLGl9KSxpKGUsXCJDb3JlL0F4aXMvUGxvdExpbmVPckJhbmQvUGxvdExpbmVPckJhbmQuanNcIixbZVtcIkNvcmUvQXhpcy9QbG90TGluZU9yQmFuZC9QbG90TGluZU9yQmFuZEF4aXMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUpe2xldHthcnJheU1heDppLGFycmF5TWluOnMsZGVmaW5lZDpvLGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzOnIsZXJhc2U6bixmaXJlRXZlbnQ6YSxtZXJnZTpoLG9iamVjdEVhY2g6bCxwaWNrOmR9PWU7Y2xhc3MgY3tzdGF0aWMgY29tcG9zZShlKXtyZXR1cm4gdC5jb21wb3NlKGMsZSl9Y29uc3RydWN0b3IodCxlKXt0aGlzLmF4aXM9dCx0aGlzLm9wdGlvbnM9ZSx0aGlzLmlkPWUuaWR9cmVuZGVyKCl7YSh0aGlzLFwicmVuZGVyXCIpO2xldHtheGlzOnQsb3B0aW9uczplfT10aGlzLHtob3JpejppLGxvZ2FyaXRobWljOnN9PXQse2NvbG9yOnIsZXZlbnRzOm4sekluZGV4OmM9MH09ZSxwPXt9LHU9dC5jaGFydC5yZW5kZXJlcixnPWUudG8sZj1lLmZyb20sbT1lLnZhbHVlLHg9ZS5ib3JkZXJXaWR0aCx5PWUubGFiZWwse2xhYmVsOmIsc3ZnRWxlbTp2fT10aGlzLFM9W10sayxNPW8oZikmJm8oZyksQz1vKG0pLHc9IXYsVD17Y2xhc3M6XCJoaWdoY2hhcnRzLXBsb3QtXCIrKE0/XCJiYW5kIFwiOlwibGluZSBcIikrKGUuY2xhc3NOYW1lfHxcIlwiKX0sQT1NP1wiYmFuZHNcIjpcImxpbmVzXCI7aWYoIXQuY2hhcnQuc3R5bGVkTW9kZSYmKEM/KFQuc3Ryb2tlPXJ8fFwiIzk5OTk5OVwiLFRbXCJzdHJva2Utd2lkdGhcIl09ZChlLndpZHRoLDEpLGUuZGFzaFN0eWxlJiYoVC5kYXNoc3R5bGU9ZS5kYXNoU3R5bGUpKTpNJiYoVC5maWxsPXJ8fFwiI2U2ZTlmZlwiLHgmJihULnN0cm9rZT1lLmJvcmRlckNvbG9yLFRbXCJzdHJva2Utd2lkdGhcIl09eCkpKSxwLnpJbmRleD1jLEErPVwiLVwiK2MsKGs9dC5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tBXSl8fCh0LnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW0FdPWs9dS5nKFwicGxvdC1cIitBKS5hdHRyKHApLmFkZCgpKSx2fHwodGhpcy5zdmdFbGVtPXY9dS5wYXRoKCkuYXR0cihUKS5hZGQoaykpLG8obSkpUz10LmdldFBsb3RMaW5lUGF0aCh7dmFsdWU6cz8ubG9nMmxpbihtKT8/bSxsaW5lV2lkdGg6di5zdHJva2VXaWR0aCgpLGFjcm9zc1BhbmVzOmUuYWNyb3NzUGFuZXN9KTtlbHNle2lmKCEobyhmKSYmbyhnKSkpcmV0dXJuO1M9dC5nZXRQbG90QmFuZFBhdGgocz8ubG9nMmxpbihmKT8/ZixzPy5sb2cybGluKGcpPz9nLGUpfXJldHVybiF0aGlzLmV2ZW50c0FkZGVkJiZuJiYobChuLCh0LGUpPT57dj8ub24oZSxmdW5jdGlvbih0KXtuW2VdLmFwcGx5KHRoaXMsW3RdKX0pfSksdGhpcy5ldmVudHNBZGRlZD0hMCksKHd8fCF2LmQpJiZTPy5sZW5ndGg/di5hdHRyKHtkOlN9KTp2JiYoUz8odi5zaG93KCksdi5hbmltYXRlKHtkOlN9KSk6di5kJiYodi5oaWRlKCksYiYmKHRoaXMubGFiZWw9Yj1iLmRlc3Ryb3koKSkpKSx5JiYobyh5LnRleHQpfHxvKHkuZm9ybWF0dGVyKSkmJlM/Lmxlbmd0aCYmdC53aWR0aD4wJiZ0LmhlaWdodD4wJiYhUy5pc0ZsYXQ/KHk9aCh7YWxpZ246aSYmTSYmXCJjZW50ZXJcIix4Omk/IU0mJjQ6MTAsdmVydGljYWxBbGlnbjohaSYmTSYmXCJtaWRkbGVcIix5Omk/TT8xNjoxMDpNPzY6LTQscm90YXRpb246aSYmIU0mJjkwfSx5KSx0aGlzLnJlbmRlckxhYmVsKHksUyxNLGMpKTpiJiZiLmhpZGUoKSx0aGlzfXJlbmRlckxhYmVsKHQsZSxvLHIpe2xldCBuPXRoaXMuYXhpcyxhPW4uY2hhcnQucmVuZGVyZXIsbD10aGlzLmxhYmVsO2x8fCh0aGlzLmxhYmVsPWw9YS50ZXh0KHRoaXMuZ2V0TGFiZWxUZXh0KHQpLDAsMCx0LnVzZUhUTUwpLmF0dHIoe2FsaWduOnQudGV4dEFsaWdufHx0LmFsaWduLHJvdGF0aW9uOnQucm90YXRpb24sY2xhc3M6XCJoaWdoY2hhcnRzLXBsb3QtXCIrKG8/XCJiYW5kXCI6XCJsaW5lXCIpK1wiLWxhYmVsXCIrKHQuY2xhc3NOYW1lfHxcIlwiKSx6SW5kZXg6cn0pLG4uY2hhcnQuc3R5bGVkTW9kZXx8bC5jc3MoaCh7Zm9udFNpemU6XCIwLjhlbVwiLHRleHRPdmVyZmxvdzpcImVsbGlwc2lzXCJ9LHQuc3R5bGUpKSxsLmFkZCgpKTtsZXQgZD1lLnhCb3VuZHN8fFtlWzBdWzFdLGVbMV1bMV0sbz9lWzJdWzFdOmVbMF1bMV1dLGM9ZS55Qm91bmRzfHxbZVswXVsyXSxlWzFdWzJdLG8/ZVsyXVsyXTplWzBdWzJdXSxwPXMoZCksdT1zKGMpO2lmKGwuYWxpZ24odCwhMSx7eDpwLHk6dSx3aWR0aDppKGQpLXAsaGVpZ2h0OmkoYyktdX0pLCFsLmFsaWduVmFsdWV8fFwibGVmdFwiPT09bC5hbGlnblZhbHVlKXtsZXQgZT10LmNsaXA/bi53aWR0aDpuLmNoYXJ0LmNoYXJ0V2lkdGg7bC5jc3Moe3dpZHRoOig5MD09PWwucm90YXRpb24/bi5oZWlnaHQtKGwuYWxpZ25BdHRyLnktbi50b3ApOmUtKGwuYWxpZ25BdHRyLngtbi5sZWZ0KSkrXCJweFwifSl9bC5zaG93KCEwKX1nZXRMYWJlbFRleHQodCl7cmV0dXJuIG8odC5mb3JtYXR0ZXIpP3QuZm9ybWF0dGVyLmNhbGwodGhpcyk6dC50ZXh0fWRlc3Ryb3koKXtuKHRoaXMuYXhpcy5wbG90TGluZXNBbmRCYW5kcyx0aGlzKSxkZWxldGUgdGhpcy5heGlzLHIodGhpcyl9fXJldHVybiBjfSksaShlLFwiQ29yZS9Ub29sdGlwLmpzXCIsW2VbXCJDb3JlL1RlbXBsYXRpbmcuanNcIl0sZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9SZW5kZXJlci9SZW5kZXJlclV0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9SZW5kZXJlci9SZW5kZXJlclJlZ2lzdHJ5LmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyxvKXt2YXIgcjtsZXR7Zm9ybWF0Om59PXQse2NvbXBvc2VkOmEsZG9jOmgsaXNTYWZhcmk6bH09ZSx7ZGlzdHJpYnV0ZTpkfT1pLHthZGRFdmVudDpjLGNsYW1wOnAsY3NzOnUsZGlzY2FyZEVsZW1lbnQ6ZyxleHRlbmQ6ZixmaXJlRXZlbnQ6bSxpc0FycmF5OngsaXNOdW1iZXI6eSxpc1N0cmluZzpiLG1lcmdlOnYscGljazpTLHB1c2hVbmlxdWU6ayxzcGxhdDpNLHN5bmNUaW1lb3V0OkN9PW87Y2xhc3Mgd3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYWxsb3dTaGFyZWQ9ITAsdGhpcy5jcm9zc2hhaXJzPVtdLHRoaXMuZGlzdGFuY2U9MCx0aGlzLmlzSGlkZGVuPSEwLHRoaXMuaXNTdGlja3k9ITEsdGhpcy5ub3c9e30sdGhpcy5vcHRpb25zPXt9LHRoaXMub3V0c2lkZT0hMSx0aGlzLmNoYXJ0PXQsdGhpcy5pbml0KHQsZSl9Ym9keUZvcm1hdHRlcih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7bGV0IGU9dC5zZXJpZXMudG9vbHRpcE9wdGlvbnM7cmV0dXJuKGVbKHQucG9pbnQuZm9ybWF0UHJlZml4fHxcInBvaW50XCIpK1wiRm9ybWF0dGVyXCJdfHx0LnBvaW50LnRvb2x0aXBGb3JtYXR0ZXIpLmNhbGwodC5wb2ludCxlWyh0LnBvaW50LmZvcm1hdFByZWZpeHx8XCJwb2ludFwiKStcIkZvcm1hdFwiXXx8XCJcIil9KX1jbGVhblNwbGl0KHQpe3RoaXMuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oZSl7bGV0IGk9ZSYmZS50dDtpJiYoIWkuaXNBY3RpdmV8fHQ/ZS50dD1pLmRlc3Ryb3koKTppLmlzQWN0aXZlPSExKX0pfWRlZmF1bHRGb3JtYXR0ZXIodCl7bGV0IGU7bGV0IGk9dGhpcy5wb2ludHN8fE0odGhpcyk7cmV0dXJuKGU9KGU9W3QudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihpWzBdKV0pLmNvbmNhdCh0LmJvZHlGb3JtYXR0ZXIoaSkpKS5wdXNoKHQudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihpWzBdLCEwKSksZX1kZXN0cm95KCl7dGhpcy5sYWJlbCYmKHRoaXMubGFiZWw9dGhpcy5sYWJlbC5kZXN0cm95KCkpLHRoaXMuc3BsaXQmJih0aGlzLmNsZWFuU3BsaXQoITApLHRoaXMudHQmJih0aGlzLnR0PXRoaXMudHQuZGVzdHJveSgpKSksdGhpcy5yZW5kZXJlciYmKHRoaXMucmVuZGVyZXI9dGhpcy5yZW5kZXJlci5kZXN0cm95KCksZyh0aGlzLmNvbnRhaW5lcikpLG8uY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKSxvLmNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KX1nZXRBbmNob3IodCxlKXtsZXQgaTtsZXQgcz10aGlzLmNoYXJ0LG89cy5wb2ludGVyLHI9cy5pbnZlcnRlZCxuPXMucGxvdFRvcCxhPXMucGxvdExlZnQ7aWYoKHQ9TSh0KSlbMF0uc2VyaWVzJiZ0WzBdLnNlcmllcy55QXhpcyYmIXRbMF0uc2VyaWVzLnlBeGlzLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MmJih0PXQuc2xpY2UoKS5yZXZlcnNlKCkpLHRoaXMuZm9sbG93UG9pbnRlciYmZSl2b2lkIDA9PT1lLmNoYXJ0WCYmKGU9by5ub3JtYWxpemUoZSkpLGk9W2UuY2hhcnRYLWEsZS5jaGFydFktbl07ZWxzZSBpZih0WzBdLnRvb2x0aXBQb3MpaT10WzBdLnRvb2x0aXBQb3M7ZWxzZXtsZXQgcz0wLG89MDt0LmZvckVhY2goZnVuY3Rpb24odCl7bGV0IGU9dC5wb3MoITApO2UmJihzKz1lWzBdLG8rPWVbMV0pfSkscy89dC5sZW5ndGgsby89dC5sZW5ndGgsdGhpcy5zaGFyZWQmJnQubGVuZ3RoPjEmJmUmJihyP3M9ZS5jaGFydFg6bz1lLmNoYXJ0WSksaT1bcy1hLG8tbl19cmV0dXJuIGkubWFwKE1hdGgucm91bmQpfWdldENsYXNzTmFtZSh0LGUsaSl7bGV0IHM9dGhpcy5vcHRpb25zLG89dC5zZXJpZXMscj1vLm9wdGlvbnM7cmV0dXJuW3MuY2xhc3NOYW1lLFwiaGlnaGNoYXJ0cy1sYWJlbFwiLGkmJlwiaGlnaGNoYXJ0cy10b29sdGlwLWhlYWRlclwiLGU/XCJoaWdoY2hhcnRzLXRvb2x0aXAtYm94XCI6XCJoaWdoY2hhcnRzLXRvb2x0aXBcIiwhaSYmXCJoaWdoY2hhcnRzLWNvbG9yLVwiK1ModC5jb2xvckluZGV4LG8uY29sb3JJbmRleCksciYmci5jbGFzc05hbWVdLmZpbHRlcihiKS5qb2luKFwiIFwiKX1nZXRMYWJlbCgpe2xldCB0PXRoaXMsaT10aGlzLmNoYXJ0LnN0eWxlZE1vZGUsbz10aGlzLm9wdGlvbnMscj10aGlzLnNwbGl0JiZ0aGlzLmFsbG93U2hhcmVkLG49dGhpcy5jb250YWluZXIsYT10aGlzLmNoYXJ0LnJlbmRlcmVyO2lmKHRoaXMubGFiZWwpe2xldCB0PSF0aGlzLmxhYmVsLmhhc0NsYXNzKFwiaGlnaGNoYXJ0cy1sYWJlbFwiKTsoIXImJnR8fHImJiF0KSYmdGhpcy5kZXN0cm95KCl9aWYoIXRoaXMubGFiZWwpe2lmKHRoaXMub3V0c2lkZSl7bGV0IHQ9dGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LnN0eWxlLGk9cy5nZXRSZW5kZXJlclR5cGUoKTt0aGlzLmNvbnRhaW5lcj1uPWUuZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbi5jbGFzc05hbWU9XCJoaWdoY2hhcnRzLXRvb2x0aXAtY29udGFpbmVyXCIsdShuLHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiMXB4XCIscG9pbnRlckV2ZW50czpcIm5vbmVcIix6SW5kZXg6TWF0aC5tYXgodGhpcy5vcHRpb25zLnN0eWxlLnpJbmRleHx8MCwodCYmdC56SW5kZXh8fDApKzMpfSksdGhpcy5yZW5kZXJlcj1hPW5ldyBpKG4sMCwwLHQsdm9pZCAwLHZvaWQgMCxhLnN0eWxlZE1vZGUpfWlmKHI/dGhpcy5sYWJlbD1hLmcoXCJ0b29sdGlwXCIpOih0aGlzLmxhYmVsPWEubGFiZWwoXCJcIiwwLDAsby5zaGFwZSx2b2lkIDAsdm9pZCAwLG8udXNlSFRNTCx2b2lkIDAsXCJ0b29sdGlwXCIpLmF0dHIoe3BhZGRpbmc6by5wYWRkaW5nLHI6by5ib3JkZXJSYWRpdXN9KSxpfHx0aGlzLmxhYmVsLmF0dHIoe2ZpbGw6by5iYWNrZ3JvdW5kQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpvLmJvcmRlcldpZHRofHwwfSkuY3NzKG8uc3R5bGUpLmNzcyh7cG9pbnRlckV2ZW50czpvLnN0eWxlLnBvaW50ZXJFdmVudHN8fCh0aGlzLnNob3VsZFN0aWNrT25Db250YWN0KCk/XCJhdXRvXCI6XCJub25lXCIpfSkpLHQub3V0c2lkZSl7bGV0IGU9dGhpcy5sYWJlbCx7eFNldHRlcjppLHlTZXR0ZXI6c309ZTtlLnhTZXR0ZXI9ZnVuY3Rpb24ocyl7aS5jYWxsKGUsdC5kaXN0YW5jZSksbiYmKG4uc3R5bGUubGVmdD1zK1wicHhcIil9LGUueVNldHRlcj1mdW5jdGlvbihpKXtzLmNhbGwoZSx0LmRpc3RhbmNlKSxuJiYobi5zdHlsZS50b3A9aStcInB4XCIpfX10aGlzLmxhYmVsLmF0dHIoe3pJbmRleDo4fSkuc2hhZG93KG8uc2hhZG93KS5hZGQoKX1yZXR1cm4gbiYmIW4ucGFyZW50RWxlbWVudCYmZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuKSx0aGlzLmxhYmVsfWdldFBsYXlpbmdGaWVsZCgpe2xldHtib2R5OnQsZG9jdW1lbnRFbGVtZW50OmV9PWgse2NoYXJ0OmksZGlzdGFuY2U6cyxvdXRzaWRlOm99PXRoaXM7cmV0dXJue3dpZHRoOm8/TWF0aC5tYXgodC5zY3JvbGxXaWR0aCxlLnNjcm9sbFdpZHRoLHQub2Zmc2V0V2lkdGgsZS5vZmZzZXRXaWR0aCxlLmNsaWVudFdpZHRoKS0yKnM6aS5jaGFydFdpZHRoLGhlaWdodDpvP01hdGgubWF4KHQuc2Nyb2xsSGVpZ2h0LGUuc2Nyb2xsSGVpZ2h0LHQub2Zmc2V0SGVpZ2h0LGUub2Zmc2V0SGVpZ2h0LGUuY2xpZW50SGVpZ2h0KTppLmNoYXJ0SGVpZ2h0fX1nZXRQb3NpdGlvbih0LGUsaSl7bGV0e2Rpc3RhbmNlOnMsY2hhcnQ6byxvdXRzaWRlOnJ9PXRoaXMse2ludmVydGVkOm4scGxvdExlZnQ6YSxwbG90VG9wOmgscG9sYXI6bH09byx7cGxvdFg6ZD0wLHBsb3RZOmM9MH09aSxwPXt9LHU9biYmaS5ofHwwLHtoZWlnaHQ6Zyx3aWR0aDpmfT10aGlzLmdldFBsYXlpbmdGaWVsZCgpLG09by5wb2ludGVyLmdldENoYXJ0UG9zaXRpb24oKSx4PXQ9PnQqbS5zY2FsZVgseT10PT50Km0uc2NhbGVZLGI9aT0+e2xldCBuPVwieFwiPT09aTtyZXR1cm5baSxuP2Y6ZyxuP3Q6ZV0uY29uY2F0KHI/W24/eCh0KTp5KGUpLG4/bS5sZWZ0LXMreChkK2EpOm0udG9wLXMreShjK2gpLDAsbj9mOmddOltuP3Q6ZSxuP2QrYTpjK2gsbj9hOmgsbj9hK28ucGxvdFdpZHRoOmgrby5wbG90SGVpZ2h0XSl9LHY9YihcInlcIiksaz1iKFwieFwiKSxNLEM9ISFpLm5lZ2F0aXZlOyFsJiZvLmhvdmVyU2VyaWVzPy55QXhpcz8ucmV2ZXJzZWQmJihDPSFDKTtsZXQgdz0hdGhpcy5mb2xsb3dQb2ludGVyJiZTKGkudHRCZWxvdywhbCYmIW49PT1DKSxUPWZ1bmN0aW9uKHQsZSxpLG8sbixhLGgpe2xldCBsPXI/XCJ5XCI9PT10P3kocyk6eChzKTpzLGQ9KGktbykvMixjPW88bi1zLGc9bitzK288ZSxmPW4tbC1pK2QsbT1uK2wtZDtpZih3JiZnKXBbdF09bTtlbHNlIGlmKCF3JiZjKXBbdF09ZjtlbHNlIGlmKGMpcFt0XT1NYXRoLm1pbihoLW8sZi11PDA/ZjpmLXUpO2Vsc2V7aWYoIWcpcmV0dXJuITE7cFt0XT1NYXRoLm1heChhLG0rdStpPmU/bTptK3UpfX0sQT1mdW5jdGlvbih0LGUsaSxvLHIpe2lmKHI8c3x8cj5lLXMpcmV0dXJuITE7cjxpLzI/cFt0XT0xOnI+ZS1vLzI/cFt0XT1lLW8tMjpwW3RdPXItaS8yfSxQPWZ1bmN0aW9uKHQpe1t2LGtdPVtrLHZdLE09dH0sTD0oKT0+eyExIT09VC5hcHBseSgwLHYpPyExIT09QS5hcHBseSgwLGspfHxNfHwoUCghMCksTCgpKTpNP3AueD1wLnk9MDooUCghMCksTCgpKX07cmV0dXJuKG4mJiFsfHx0aGlzLmxlbj4xKSYmUCgpLEwoKSxwfWhpZGUodCl7bGV0IGU9dGhpcztvLmNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lciksdD1TKHQsdGhpcy5vcHRpb25zLmhpZGVEZWxheSksdGhpcy5pc0hpZGRlbnx8KHRoaXMuaGlkZVRpbWVyPUMoZnVuY3Rpb24oKXtsZXQgaT1lLmdldExhYmVsKCk7ZS5nZXRMYWJlbCgpLmFuaW1hdGUoe29wYWNpdHk6MH0se2R1cmF0aW9uOnQ/MTUwOnQsY29tcGxldGU6KCk9PntpLmhpZGUoKSxlLmNvbnRhaW5lciYmZS5jb250YWluZXIucmVtb3ZlKCl9fSksZS5pc0hpZGRlbj0hMH0sdCkpfWluaXQodCxlKXt0aGlzLmNoYXJ0PXQsdGhpcy5vcHRpb25zPWUsdGhpcy5jcm9zc2hhaXJzPVtdLHRoaXMubm93PXt4OjAseTowfSx0aGlzLmlzSGlkZGVuPSEwLHRoaXMuc3BsaXQ9ZS5zcGxpdCYmIXQuaW52ZXJ0ZWQmJiF0LnBvbGFyLHRoaXMuc2hhcmVkPWUuc2hhcmVkfHx0aGlzLnNwbGl0LHRoaXMub3V0c2lkZT1TKGUub3V0c2lkZSwhISh0LnNjcm9sbGFibGVQaXhlbHNYfHx0LnNjcm9sbGFibGVQaXhlbHNZKSl9c2hvdWxkU3RpY2tPbkNvbnRhY3QodCl7cmV0dXJuISEoIXRoaXMuZm9sbG93UG9pbnRlciYmdGhpcy5vcHRpb25zLnN0aWNrT25Db250YWN0JiYoIXR8fHRoaXMuY2hhcnQucG9pbnRlci5pbkNsYXNzKHQudGFyZ2V0LFwiaGlnaGNoYXJ0cy10b29sdGlwXCIpKSl9bW92ZSh0LGUsaSxzKXtsZXQgcj10aGlzLG49ci5ub3csYT0hMSE9PXIub3B0aW9ucy5hbmltYXRpb24mJiFyLmlzSGlkZGVuJiYoTWF0aC5hYnModC1uLngpPjF8fE1hdGguYWJzKGUtbi55KT4xKSxoPXIuZm9sbG93UG9pbnRlcnx8ci5sZW4+MTtmKG4se3g6YT8oMipuLngrdCkvMzp0LHk6YT8obi55K2UpLzI6ZSxhbmNob3JYOmg/dm9pZCAwOmE/KDIqbi5hbmNob3JYK2kpLzM6aSxhbmNob3JZOmg/dm9pZCAwOmE/KG4uYW5jaG9yWStzKS8yOnN9KSxyLmdldExhYmVsKCkuYXR0cihuKSxyLmRyYXdUcmFja2VyKCksYSYmKG8uY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpLHRoaXMudG9vbHRpcFRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3ImJnIubW92ZSh0LGUsaSxzKX0sMzIpKX1yZWZyZXNoKHQsZSl7bGV0IGk9dGhpcy5jaGFydCxzPXRoaXMub3B0aW9ucyxyPWkucG9pbnRlcixhPU0odCksaD1hWzBdLGw9W10sZD1zLmZvcm1hdCxjPXMuZm9ybWF0dGVyfHx0aGlzLmRlZmF1bHRGb3JtYXR0ZXIscD10aGlzLnNoYXJlZCx1PWkuc3R5bGVkTW9kZSxnPXt9O2lmKCFzLmVuYWJsZWR8fCFoLnNlcmllcylyZXR1cm47by5jbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpLHRoaXMuYWxsb3dTaGFyZWQ9ISgheCh0KSYmdC5zZXJpZXMmJnQuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCksdGhpcy5mb2xsb3dQb2ludGVyPSF0aGlzLnNwbGl0JiZoLnNlcmllcy50b29sdGlwT3B0aW9ucy5mb2xsb3dQb2ludGVyO2xldCBmPXRoaXMuZ2V0QW5jaG9yKHQsZSkseT1mWzBdLHY9ZlsxXTtwJiZ0aGlzLmFsbG93U2hhcmVkPyhyLmFwcGx5SW5hY3RpdmVTdGF0ZShhKSxhLmZvckVhY2goZnVuY3Rpb24odCl7dC5zZXRTdGF0ZShcImhvdmVyXCIpLGwucHVzaCh0LmdldExhYmVsQ29uZmlnKCkpfSksKGc9aC5nZXRMYWJlbENvbmZpZygpKS5wb2ludHM9bCk6Zz1oLmdldExhYmVsQ29uZmlnKCksdGhpcy5sZW49bC5sZW5ndGg7bGV0IGs9YihkKT9uKGQsZyxpKTpjLmNhbGwoZyx0aGlzKSxDPWguc2VyaWVzO2lmKHRoaXMuZGlzdGFuY2U9UyhDLnRvb2x0aXBPcHRpb25zLmRpc3RhbmNlLDE2KSwhMT09PWspdGhpcy5oaWRlKCk7ZWxzZXtpZih0aGlzLnNwbGl0JiZ0aGlzLmFsbG93U2hhcmVkKXRoaXMucmVuZGVyU3BsaXQoayxhKTtlbHNle2xldCB0PXksbz12O2lmKGUmJnIuaXNEaXJlY3RUb3VjaCYmKHQ9ZS5jaGFydFgtaS5wbG90TGVmdCxvPWUuY2hhcnRZLWkucGxvdFRvcCksaS5wb2xhcnx8ITE9PT1DLm9wdGlvbnMuY2xpcHx8YS5zb21lKGU9PnIuaXNEaXJlY3RUb3VjaHx8ZS5zZXJpZXMuc2hvdWxkU2hvd1Rvb2x0aXAodCxvKSkpe2xldCB0PXRoaXMuZ2V0TGFiZWwoKTsoIXMuc3R5bGUud2lkdGh8fHUpJiZ0LmNzcyh7d2lkdGg6KHRoaXMub3V0c2lkZT90aGlzLmdldFBsYXlpbmdGaWVsZCgpOmkuc3BhY2luZ0JveCkud2lkdGgrXCJweFwifSksdC5hdHRyKHt0ZXh0OmsmJmsuam9pbj9rLmpvaW4oXCJcIik6a30pLHQuYWRkQ2xhc3ModGhpcy5nZXRDbGFzc05hbWUoaCksITApLHV8fHQuYXR0cih7c3Ryb2tlOnMuYm9yZGVyQ29sb3J8fGguY29sb3J8fEMuY29sb3J8fFwiIzY2NjY2NlwifSksdGhpcy51cGRhdGVQb3NpdGlvbih7cGxvdFg6eSxwbG90WTp2LG5lZ2F0aXZlOmgubmVnYXRpdmUsdHRCZWxvdzpoLnR0QmVsb3csaDpmWzJdfHwwfSl9ZWxzZXt0aGlzLmhpZGUoKTtyZXR1cm59fXRoaXMuaXNIaWRkZW4mJnRoaXMubGFiZWwmJnRoaXMubGFiZWwuYXR0cih7b3BhY2l0eToxfSkuc2hvdygpLHRoaXMuaXNIaWRkZW49ITF9bSh0aGlzLFwicmVmcmVzaFwiKX1yZW5kZXJTcGxpdCh0LGUpe2xldCBpPXRoaXMse2NoYXJ0OnMsY2hhcnQ6e2NoYXJ0V2lkdGg6byxjaGFydEhlaWdodDpyLHBsb3RIZWlnaHQ6bixwbG90TGVmdDphLHBsb3RUb3A6Yyxwb2ludGVyOnUsc2Nyb2xsYWJsZVBpeGVsc1k6Zz0wLHNjcm9sbGFibGVQaXhlbHNYOm0sc2Nyb2xsaW5nQ29udGFpbmVyOntzY3JvbGxMZWZ0Ongsc2Nyb2xsVG9wOnl9PXtzY3JvbGxMZWZ0OjAsc2Nyb2xsVG9wOjB9LHN0eWxlZE1vZGU6dn0sZGlzdGFuY2U6ayxvcHRpb25zOk0sb3B0aW9uczp7cG9zaXRpb25lcjpDfX09aSx3PWkub3V0c2lkZSYmXCJudW1iZXJcIiE9dHlwZW9mIG0/aC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6e2xlZnQ6eCxyaWdodDp4K28sdG9wOnksYm90dG9tOnkrcn0sVD1pLmdldExhYmVsKCksQT10aGlzLnJlbmRlcmVyfHxzLnJlbmRlcmVyLFA9ISEocy54QXhpc1swXSYmcy54QXhpc1swXS5vcHBvc2l0ZSkse2xlZnQ6TCx0b3A6T309dS5nZXRDaGFydFBvc2l0aW9uKCksRD1jK3ksRT0wLGo9bi1nO2Z1bmN0aW9uIEkodCxlLHMsbyxyPSEwKXtsZXQgbixhO3JldHVybiBzPyhuPVA/MDpqLGE9cCh0LW8vMix3LmxlZnQsdy5yaWdodC1vLShpLm91dHNpZGU/TDowKSkpOihuPWUtRCxhPXAoYT1yP3Qtby1rOnQrayxyP2E6dy5sZWZ0LHcucmlnaHQpKSx7eDphLHk6bn19Yih0KSYmKHQ9WyExLHRdKTtsZXQgQj10LnNsaWNlKDAsZS5sZW5ndGgrMSkucmVkdWNlKGZ1bmN0aW9uKHQscyxvKXtpZighMSE9PXMmJlwiXCIhPT1zKXtsZXQgcj1lW28tMV18fHtpc0hlYWRlcjohMCxwbG90WDplWzBdLnBsb3RYLHBsb3RZOm4sc2VyaWVzOnt9fSxoPXIuaXNIZWFkZXIsbD1oP2k6ci5zZXJpZXMsZD1sLnR0PWZ1bmN0aW9uKHQsZSxzKXtsZXQgbz10LHtpc0hlYWRlcjpyLHNlcmllczpufT1lO2lmKCFvKXtsZXQgdD17cGFkZGluZzpNLnBhZGRpbmcscjpNLmJvcmRlclJhZGl1c307dnx8KHQuZmlsbD1NLmJhY2tncm91bmRDb2xvcix0W1wic3Ryb2tlLXdpZHRoXCJdPU0uYm9yZGVyV2lkdGg/PzEpLG89QS5sYWJlbChcIlwiLDAsMCxNW3I/XCJoZWFkZXJTaGFwZVwiOlwic2hhcGVcIl0sdm9pZCAwLHZvaWQgMCxNLnVzZUhUTUwpLmFkZENsYXNzKGkuZ2V0Q2xhc3NOYW1lKGUsITAscikpLmF0dHIodCkuYWRkKFQpfXJldHVybiBvLmlzQWN0aXZlPSEwLG8uYXR0cih7dGV4dDpzfSksdnx8by5jc3MoTS5zdHlsZSkuYXR0cih7c3Ryb2tlOk0uYm9yZGVyQ29sb3J8fGUuY29sb3J8fG4uY29sb3J8fFwiIzMzMzMzM1wifSksb30obC50dCxyLHMudG9TdHJpbmcoKSksdT1kLmdldEJCb3goKSxnPXUud2lkdGgrZC5zdHJva2VXaWR0aCgpO2gmJihFPXUuaGVpZ2h0LGorPUUsUCYmKEQtPUUpKTtsZXR7YW5jaG9yWDpmLGFuY2hvclk6bX09ZnVuY3Rpb24odCl7bGV0IGUsaTtsZXR7aXNIZWFkZXI6cyxwbG90WDpvPTAscGxvdFk6cj0wLHNlcmllczpofT10O2lmKHMpZT1NYXRoLm1heChhK28sYSksaT1jK24vMjtlbHNle2xldHt4QXhpczp0LHlBeGlzOnN9PWg7ZT10LnBvcytwKG8sLWssdC5sZW4rayksaC5zaG91bGRTaG93VG9vbHRpcCgwLHMucG9zLWMrcix7aWdub3JlWDohMH0pJiYoaT1zLnBvcytyKX1yZXR1cm57YW5jaG9yWDplPXAoZSx3LmxlZnQtayx3LnJpZ2h0K2spLGFuY2hvclk6aX19KHIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBtKXtsZXQgZT11LmhlaWdodCsxLHM9Qz9DLmNhbGwoaSxnLGUscik6SShmLG0saCxnKTt0LnB1c2goe2FsaWduOkM/MDp2b2lkIDAsYW5jaG9yWDpmLGFuY2hvclk6bSxib3hXaWR0aDpnLHBvaW50OnIscmFuazpTKHMucmFuayxoPzE6MCksc2l6ZTplLHRhcmdldDpzLnksdHQ6ZCx4OnMueH0pfWVsc2UgZC5pc0FjdGl2ZT0hMX1yZXR1cm4gdH0sW10pOyFDJiZCLnNvbWUodD0+e2xldHtvdXRzaWRlOmV9PWkscz0oZT9MOjApK3QuYW5jaG9yWDtyZXR1cm4gczx3LmxlZnQmJnMrdC5ib3hXaWR0aDx3LnJpZ2h0fHxzPEwtdy5sZWZ0K3QuYm94V2lkdGgmJncucmlnaHQtcz5zfSkmJihCPUIubWFwKHQ9PntsZXR7eDplLHk6aX09SSh0LmFuY2hvclgsdC5hbmNob3JZLHQucG9pbnQuaXNIZWFkZXIsdC5ib3hXaWR0aCwhMSk7cmV0dXJuIGYodCx7dGFyZ2V0OmkseDplfSl9KSksaS5jbGVhblNwbGl0KCksZChCLGopO2xldCBSPXtsZWZ0OkwscmlnaHQ6TH07Qi5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldHt4OmUsYm94V2lkdGg6cyxpc0hlYWRlcjpvfT10OyFvJiYoaS5vdXRzaWRlJiZMK2U8Ui5sZWZ0JiYoUi5sZWZ0PUwrZSksIW8mJmkub3V0c2lkZSYmUi5sZWZ0K3M+Ui5yaWdodCYmKFIucmlnaHQ9TCtlKSl9KSxCLmZvckVhY2goZnVuY3Rpb24odCl7bGV0e3g6ZSxhbmNob3JYOnMsYW5jaG9yWTpvLHBvczpyLHBvaW50Ontpc0hlYWRlcjpufX09dCxhPXt2aXNpYmlsaXR5OnZvaWQgMD09PXI/XCJoaWRkZW5cIjpcImluaGVyaXRcIix4OmUseToocnx8MCkrRCxhbmNob3JYOnMsYW5jaG9yWTpvfTtpZihpLm91dHNpZGUmJmU8cyl7bGV0IHQ9TC1SLmxlZnQ7dD4wJiYobnx8KGEueD1lK3QsYS5hbmNob3JYPXMrdCksbiYmKGEueD0oUi5yaWdodC1SLmxlZnQpLzIsYS5hbmNob3JYPXMrdCkpfXQudHQuYXR0cihhKX0pO2xldHtjb250YWluZXI6eixvdXRzaWRlOk4scmVuZGVyZXI6V309aTtpZihOJiZ6JiZXKXtsZXR7d2lkdGg6dCxoZWlnaHQ6ZSx4OmkseTpzfT1ULmdldEJCb3goKTtXLnNldFNpemUodCtpLGUrcywhMSksei5zdHlsZS5sZWZ0PVIubGVmdCtcInB4XCIsei5zdHlsZS50b3A9TytcInB4XCJ9bCYmVC5hdHRyKHtvcGFjaXR5OjE9PT1ULm9wYWNpdHk/Ljk5OToxfSl9ZHJhd1RyYWNrZXIoKXtpZighdGhpcy5zaG91bGRTdGlja09uQ29udGFjdCgpKXt0aGlzLnRyYWNrZXImJih0aGlzLnRyYWNrZXI9dGhpcy50cmFja2VyLmRlc3Ryb3koKSk7cmV0dXJufWxldCB0PXRoaXMuY2hhcnQsZT10aGlzLmxhYmVsLGk9dGhpcy5zaGFyZWQ/dC5ob3ZlclBvaW50czp0LmhvdmVyUG9pbnQ7aWYoIWV8fCFpKXJldHVybjtsZXQgcz17eDowLHk6MCx3aWR0aDowLGhlaWdodDowfSxvPXRoaXMuZ2V0QW5jaG9yKGkpLHI9ZS5nZXRCQm94KCk7b1swXSs9dC5wbG90TGVmdC0oZS50cmFuc2xhdGVYfHwwKSxvWzFdKz10LnBsb3RUb3AtKGUudHJhbnNsYXRlWXx8MCkscy54PU1hdGgubWluKDAsb1swXSkscy55PU1hdGgubWluKDAsb1sxXSkscy53aWR0aD1vWzBdPDA/TWF0aC5tYXgoTWF0aC5hYnMob1swXSksci53aWR0aC1vWzBdKTpNYXRoLm1heChNYXRoLmFicyhvWzBdKSxyLndpZHRoKSxzLmhlaWdodD1vWzFdPDA/TWF0aC5tYXgoTWF0aC5hYnMob1sxXSksci5oZWlnaHQtTWF0aC5hYnMob1sxXSkpOk1hdGgubWF4KE1hdGguYWJzKG9bMV0pLHIuaGVpZ2h0KSx0aGlzLnRyYWNrZXI/dGhpcy50cmFja2VyLmF0dHIocyk6KHRoaXMudHJhY2tlcj1lLnJlbmRlcmVyLnJlY3QocykuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikuYWRkKGUpLHQuc3R5bGVkTW9kZXx8dGhpcy50cmFja2VyLmF0dHIoe2ZpbGw6XCJyZ2JhKDAsMCwwLDApXCJ9KSl9c3R5bGVkTW9kZUZvcm1hdCh0KXtyZXR1cm4gdC5yZXBsYWNlKCdzdHlsZT1cImZvbnQtc2l6ZTogMC44ZW1cIicsJ2NsYXNzPVwiaGlnaGNoYXJ0cy1oZWFkZXJcIicpLnJlcGxhY2UoL3N0eWxlPVwiY29sb3I6eyhwb2ludHxzZXJpZXMpXFwuY29sb3J9XCIvZywnY2xhc3M9XCJoaWdoY2hhcnRzLWNvbG9yLXskMS5jb2xvckluZGV4fSB7c2VyaWVzLm9wdGlvbnMuY2xhc3NOYW1lfSB7cG9pbnQub3B0aW9ucy5jbGFzc05hbWV9XCInKX10b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKHQsZSl7bGV0IGk9dC5zZXJpZXMscz1pLnRvb2x0aXBPcHRpb25zLG89aS54QXhpcyxyPW8mJm8uZGF0ZVRpbWUsYT17aXNGb290ZXI6ZSxsYWJlbENvbmZpZzp0fSxoPXMueERhdGVGb3JtYXQsbD1zW2U/XCJmb290ZXJGb3JtYXRcIjpcImhlYWRlckZvcm1hdFwiXTtyZXR1cm4gbSh0aGlzLFwiaGVhZGVyRm9ybWF0dGVyXCIsYSxmdW5jdGlvbihlKXtyJiYhaCYmeSh0LmtleSkmJihoPXIuZ2V0WERhdGVGb3JtYXQodC5rZXkscy5kYXRlVGltZUxhYmVsRm9ybWF0cykpLHImJmgmJih0LnBvaW50JiZ0LnBvaW50LnRvb2x0aXBEYXRlS2V5c3x8W1wia2V5XCJdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2w9bC5yZXBsYWNlKFwie3BvaW50LlwiK3QrXCJ9XCIsXCJ7cG9pbnQuXCIrdCtcIjpcIitoK1wifVwiKX0pLGkuY2hhcnQuc3R5bGVkTW9kZSYmKGw9dGhpcy5zdHlsZWRNb2RlRm9ybWF0KGwpKSxlLnRleHQ9bihsLHtwb2ludDp0LHNlcmllczppfSx0aGlzLmNoYXJ0KX0pLGEudGV4dH11cGRhdGUodCl7dGhpcy5kZXN0cm95KCksdGhpcy5pbml0KHRoaXMuY2hhcnQsdighMCx0aGlzLm9wdGlvbnMsdCkpfXVwZGF0ZVBvc2l0aW9uKHQpe2xldHtjaGFydDplLGNvbnRhaW5lcjppLGRpc3RhbmNlOnMsb3B0aW9uczpvLHJlbmRlcmVyOnJ9PXRoaXMse2hlaWdodDpuPTAsd2lkdGg6YT0wfT10aGlzLmdldExhYmVsKCksaD1lLnBvaW50ZXIse2xlZnQ6bCx0b3A6ZCxzY2FsZVg6YyxzY2FsZVk6cH09aC5nZXRDaGFydFBvc2l0aW9uKCksZz0oby5wb3NpdGlvbmVyfHx0aGlzLmdldFBvc2l0aW9uKS5jYWxsKHRoaXMsYSxuLHQpLGY9KHQucGxvdFh8fDApK2UucGxvdExlZnQsbT0odC5wbG90WXx8MCkrZS5wbG90VG9wLHg7ciYmaSYmKG8ucG9zaXRpb25lciYmKGcueCs9bC1zLGcueSs9ZC1zKSx4PShvLmJvcmRlcldpZHRofHwwKSsyKnMrMixyLnNldFNpemUoYSt4LG4reCwhMSksKDEhPT1jfHwxIT09cCkmJih1KGkse3RyYW5zZm9ybTpgc2NhbGUoJHtjfSwgJHtwfSlgfSksZio9YyxtKj1wKSxmKz1sLWcueCxtKz1kLWcueSksdGhpcy5tb3ZlKE1hdGgucm91bmQoZy54KSxNYXRoLnJvdW5kKGcueXx8MCksZixtKX19cmV0dXJuKHI9d3x8KHc9e30pKS5jb21wb3NlPWZ1bmN0aW9uIHQoZSl7ayhhLHQpJiZjKGUsXCJhZnRlckluaXRcIixmdW5jdGlvbigpe2xldCB0PXRoaXMuY2hhcnQ7dC5vcHRpb25zLnRvb2x0aXAmJih0LnRvb2x0aXA9bmV3IHIodCx0Lm9wdGlvbnMudG9vbHRpcCkpfSl9LHd9KSxpKGUsXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiLFtlW1wiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiXSxlW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL0RlZmF1bHRzLmpzXCJdLGVbXCJDb3JlL1RlbXBsYXRpbmcuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSxzLG8pe2xldHthbmltT2JqZWN0OnJ9PWUse2RlZmF1bHRPcHRpb25zOm59PWkse2Zvcm1hdDphfT1zLHthZGRFdmVudDpoLGRlZmluZWQ6bCxlcmFzZTpkLGV4dGVuZDpjLGZpcmVFdmVudDpwLGdldE5lc3RlZFByb3BlcnR5OnUsaXNBcnJheTpnLGlzRnVuY3Rpb246Zixpc051bWJlcjptLGlzT2JqZWN0OngsbWVyZ2U6eSxvYmplY3RFYWNoOmIscGljazp2LHN5bmNUaW1lb3V0OlMscmVtb3ZlRXZlbnQ6ayx1bmlxdWVLZXk6TX09bztjbGFzcyBDe2FuaW1hdGVCZWZvcmVEZXN0cm95KCl7bGV0IHQ9dGhpcyxlPXt4OnQuc3RhcnRYUG9zLG9wYWNpdHk6MH0saT10LmdldEdyYXBoaWNhbFByb3BzKCk7aS5zaW5ndWxhci5mb3JFYWNoKGZ1bmN0aW9uKGkpe3RbaV09dFtpXS5hbmltYXRlKFwiZGF0YUxhYmVsXCI9PT1pP3t4OnRbaV0uc3RhcnRYUG9zLHk6dFtpXS5zdGFydFlQb3Msb3BhY2l0eTowfTplKX0pLGkucGx1cmFsLmZvckVhY2goZnVuY3Rpb24oZSl7dFtlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZWxlbWVudCYmZS5hbmltYXRlKGMoe3g6dC5zdGFydFhQb3N9LGUuc3RhcnRZUG9zP3t4OmUuc3RhcnRYUG9zLHk6ZS5zdGFydFlQb3N9Ont9KSl9KX0pfWFwcGx5T3B0aW9ucyh0LGUpe2xldCBpPXRoaXMuc2VyaWVzLHM9aS5vcHRpb25zLnBvaW50VmFsS2V5fHxpLnBvaW50VmFsS2V5O3JldHVybiBjKHRoaXMsdD1DLnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh0aGlzLHQpKSx0aGlzLm9wdGlvbnM9dGhpcy5vcHRpb25zP2ModGhpcy5vcHRpb25zLHQpOnQsdC5ncm91cCYmZGVsZXRlIHRoaXMuZ3JvdXAsdC5kYXRhTGFiZWxzJiZkZWxldGUgdGhpcy5kYXRhTGFiZWxzLHMmJih0aGlzLnk9Qy5wcm90b3R5cGUuZ2V0TmVzdGVkUHJvcGVydHkuY2FsbCh0aGlzLHMpKSx0aGlzLnNlbGVjdGVkJiYodGhpcy5zdGF0ZT1cInNlbGVjdFwiKSxcIm5hbWVcImluIHRoaXMmJnZvaWQgMD09PWUmJmkueEF4aXMmJmkueEF4aXMuaGFzTmFtZXMmJih0aGlzLng9aS54QXhpcy5uYW1lVG9YKHRoaXMpKSx2b2lkIDA9PT10aGlzLngmJmk/dm9pZCAwPT09ZT90aGlzLng9aS5hdXRvSW5jcmVtZW50KCk6dGhpcy54PWU6bSh0LngpJiZpLm9wdGlvbnMucmVsYXRpdmVYVmFsdWUmJih0aGlzLng9aS5hdXRvSW5jcmVtZW50KHQueCkpLHRoaXMuaXNOdWxsPXRoaXMuaXNWYWxpZCYmIXRoaXMuaXNWYWxpZCgpLHRoaXMuZm9ybWF0UHJlZml4PXRoaXMuaXNOdWxsP1wibnVsbFwiOlwicG9pbnRcIix0aGlzfWRlc3Ryb3koKXtpZighdGhpcy5kZXN0cm95ZWQpe2xldCB0PXRoaXMsZT10LnNlcmllcyxpPWUuY2hhcnQscz1lLm9wdGlvbnMuZGF0YVNvcnRpbmcsbz1pLmhvdmVyUG9pbnRzLG49dC5zZXJpZXMuY2hhcnQucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLGE9cihuKSxoPSgpPT57Zm9yKGxldCBlIGluKHQuZ3JhcGhpY3x8dC5ncmFwaGljc3x8dC5kYXRhTGFiZWx8fHQuZGF0YUxhYmVscykmJihrKHQpLHQuZGVzdHJveUVsZW1lbnRzKCkpLHQpZGVsZXRlIHRbZV19O3QubGVnZW5kSXRlbSYmaS5sZWdlbmQuZGVzdHJveUl0ZW0odCksbyYmKHQuc2V0U3RhdGUoKSxkKG8sdCksby5sZW5ndGh8fChpLmhvdmVyUG9pbnRzPW51bGwpKSx0PT09aS5ob3ZlclBvaW50JiZ0Lm9uTW91c2VPdXQoKSxzJiZzLmVuYWJsZWQ/KHRoaXMuYW5pbWF0ZUJlZm9yZURlc3Ryb3koKSxTKGgsYS5kdXJhdGlvbikpOmgoKSxpLnBvaW50Q291bnQtLX10aGlzLmRlc3Ryb3llZD0hMH1kZXN0cm95RWxlbWVudHModCl7bGV0IGU9dGhpcyxpPWUuZ2V0R3JhcGhpY2FsUHJvcHModCk7aS5zaW5ndWxhci5mb3JFYWNoKGZ1bmN0aW9uKHQpe2VbdF09ZVt0XS5kZXN0cm95KCl9KSxpLnBsdXJhbC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2VbdF0uZm9yRWFjaChmdW5jdGlvbih0KXt0JiZ0LmVsZW1lbnQmJnQuZGVzdHJveSgpfSksZGVsZXRlIGVbdF19KX1maXJlUG9pbnRFdmVudCh0LGUsaSl7bGV0IHM9dGhpcyxvPXRoaXMuc2VyaWVzLHI9by5vcHRpb25zOyhyLnBvaW50LmV2ZW50c1t0XXx8cy5vcHRpb25zJiZzLm9wdGlvbnMuZXZlbnRzJiZzLm9wdGlvbnMuZXZlbnRzW3RdKSYmcy5pbXBvcnRFdmVudHMoKSxcImNsaWNrXCI9PT10JiZyLmFsbG93UG9pbnRTZWxlY3QmJihpPWZ1bmN0aW9uKHQpeyFzLmRlc3Ryb3llZCYmcy5zZWxlY3QmJnMuc2VsZWN0KG51bGwsdC5jdHJsS2V5fHx0Lm1ldGFLZXl8fHQuc2hpZnRLZXkpfSkscChzLHQsZSxpKX1nZXRDbGFzc05hbWUoKXtyZXR1cm5cImhpZ2hjaGFydHMtcG9pbnRcIisodGhpcy5zZWxlY3RlZD9cIiBoaWdoY2hhcnRzLXBvaW50LXNlbGVjdFwiOlwiXCIpKyh0aGlzLm5lZ2F0aXZlP1wiIGhpZ2hjaGFydHMtbmVnYXRpdmVcIjpcIlwiKSsodGhpcy5pc051bGw/XCIgaGlnaGNoYXJ0cy1udWxsLXBvaW50XCI6XCJcIikrKHZvaWQgMCE9PXRoaXMuY29sb3JJbmRleD9cIiBoaWdoY2hhcnRzLWNvbG9yLVwiK3RoaXMuY29sb3JJbmRleDpcIlwiKSsodGhpcy5vcHRpb25zLmNsYXNzTmFtZT9cIiBcIit0aGlzLm9wdGlvbnMuY2xhc3NOYW1lOlwiXCIpKyh0aGlzLnpvbmUmJnRoaXMuem9uZS5jbGFzc05hbWU/XCIgXCIrdGhpcy56b25lLmNsYXNzTmFtZS5yZXBsYWNlKFwiaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiLFwiXCIpOlwiXCIpfWdldEdyYXBoaWNhbFByb3BzKHQpe2xldCBlLGk7bGV0IHM9dGhpcyxvPVtdLHI9e3Npbmd1bGFyOltdLHBsdXJhbDpbXX07Zm9yKCh0PXR8fHtncmFwaGljOjEsZGF0YUxhYmVsOjF9KS5ncmFwaGljJiZvLnB1c2goXCJncmFwaGljXCIsXCJjb25uZWN0b3JcIiksdC5kYXRhTGFiZWwmJm8ucHVzaChcImRhdGFMYWJlbFwiLFwiZGF0YUxhYmVsUGF0aFwiLFwiZGF0YUxhYmVsVXBwZXJcIiksaT1vLmxlbmd0aDtpLS07KXNbZT1vW2ldXSYmci5zaW5ndWxhci5wdXNoKGUpO3JldHVybltcImdyYXBoaWNcIixcImRhdGFMYWJlbFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2xldCBpPWUrXCJzXCI7dFtlXSYmc1tpXSYmci5wbHVyYWwucHVzaChpKX0pLHJ9Z2V0TGFiZWxDb25maWcoKXtyZXR1cm57eDp0aGlzLmNhdGVnb3J5LHk6dGhpcy55LGNvbG9yOnRoaXMuY29sb3IsY29sb3JJbmRleDp0aGlzLmNvbG9ySW5kZXgsa2V5OnRoaXMubmFtZXx8dGhpcy5jYXRlZ29yeSxzZXJpZXM6dGhpcy5zZXJpZXMscG9pbnQ6dGhpcyxwZXJjZW50YWdlOnRoaXMucGVyY2VudGFnZSx0b3RhbDp0aGlzLnRvdGFsfHx0aGlzLnN0YWNrVG90YWx9fWdldE5lc3RlZFByb3BlcnR5KHQpe3JldHVybiB0PzA9PT10LmluZGV4T2YoXCJjdXN0b20uXCIpP3UodCx0aGlzLm9wdGlvbnMpOnRoaXNbdF06dm9pZCAwfWdldFpvbmUoKXtsZXQgdD10aGlzLnNlcmllcyxlPXQuem9uZXMsaT10LnpvbmVBeGlzfHxcInlcIixzLG89MDtmb3Iocz1lWzBdO3RoaXNbaV0+PXMudmFsdWU7KXM9ZVsrK29dO3JldHVybiB0aGlzLm5vblpvbmVkQ29sb3J8fCh0aGlzLm5vblpvbmVkQ29sb3I9dGhpcy5jb2xvcikscyYmcy5jb2xvciYmIXRoaXMub3B0aW9ucy5jb2xvcj90aGlzLmNvbG9yPXMuY29sb3I6dGhpcy5jb2xvcj10aGlzLm5vblpvbmVkQ29sb3Isc31oYXNOZXdTaGFwZVR5cGUoKXtsZXQgdD10aGlzLmdyYXBoaWMmJih0aGlzLmdyYXBoaWMuc3ltYm9sTmFtZXx8dGhpcy5ncmFwaGljLmVsZW1lbnQubm9kZU5hbWUpO3JldHVybiB0IT09dGhpcy5zaGFwZVR5cGV9Y29uc3RydWN0b3IodCxlLGkpe3RoaXMuZm9ybWF0UHJlZml4PVwicG9pbnRcIix0aGlzLnZpc2libGU9ITAsdGhpcy5zZXJpZXM9dCx0aGlzLmFwcGx5T3B0aW9ucyhlLGkpLHRoaXMuaWQ/Pyh0aGlzLmlkPU0oKSksdGhpcy5yZXNvbHZlQ29sb3IoKSx0LmNoYXJ0LnBvaW50Q291bnQrKyxwKHRoaXMsXCJhZnRlckluaXRcIil9aXNWYWxpZCgpe3JldHVybihtKHRoaXMueCl8fHRoaXMueCBpbnN0YW5jZW9mIERhdGUpJiZtKHRoaXMueSl9b3B0aW9uc1RvT2JqZWN0KHQpe2xldCBlPXRoaXMuc2VyaWVzLGk9ZS5vcHRpb25zLmtleXMscz1pfHxlLnBvaW50QXJyYXlNYXB8fFtcInlcIl0sbz1zLmxlbmd0aCxyPXt9LG4sYT0wLGg9MDtpZihtKHQpfHxudWxsPT09dClyW3NbMF1dPXQ7ZWxzZSBpZihnKHQpKWZvcighaSYmdC5sZW5ndGg+byYmKFwic3RyaW5nXCI9PShuPXR5cGVvZiB0WzBdKT9yLm5hbWU9dFswXTpcIm51bWJlclwiPT09biYmKHIueD10WzBdKSxhKyspO2g8bzspaSYmdm9pZCAwPT09dFthXXx8KHNbaF0uaW5kZXhPZihcIi5cIik+MD9DLnByb3RvdHlwZS5zZXROZXN0ZWRQcm9wZXJ0eShyLHRbYV0sc1toXSk6cltzW2hdXT10W2FdKSxhKyssaCsrO2Vsc2VcIm9iamVjdFwiPT10eXBlb2YgdCYmKHI9dCx0LmRhdGFMYWJlbHMmJihlLmhhc0RhdGFMYWJlbHM9KCk9PiEwKSx0Lm1hcmtlciYmKGUuX2hhc1BvaW50TWFya2Vycz0hMCkpO3JldHVybiByfXBvcyh0LGU9dGhpcy5wbG90WSl7aWYoIXRoaXMuZGVzdHJveWVkKXtsZXR7cGxvdFg6aSxzZXJpZXM6c309dGhpcyx7Y2hhcnQ6byx4QXhpczpyLHlBeGlzOm59PXMsYT0wLGg9MDtpZihtKGkpJiZtKGUpKXJldHVybiB0JiYoYT1yP3IucG9zOm8ucGxvdExlZnQsaD1uP24ucG9zOm8ucGxvdFRvcCksby5pbnZlcnRlZCYmciYmbj9bbi5sZW4tZStoLHIubGVuLWkrYV06W2krYSxlK2hdfX1yZXNvbHZlQ29sb3IoKXtsZXQgdD10aGlzLnNlcmllcyxlPXQuY2hhcnQub3B0aW9ucy5jaGFydCxpPXQuY2hhcnQuc3R5bGVkTW9kZSxzLG8scj1lLmNvbG9yQ291bnQsbjtkZWxldGUgdGhpcy5ub25ab25lZENvbG9yLHQub3B0aW9ucy5jb2xvckJ5UG9pbnQ/KGl8fChzPShvPXQub3B0aW9ucy5jb2xvcnN8fHQuY2hhcnQub3B0aW9ucy5jb2xvcnMpW3QuY29sb3JDb3VudGVyXSxyPW8ubGVuZ3RoKSxuPXQuY29sb3JDb3VudGVyLHQuY29sb3JDb3VudGVyKyssdC5jb2xvckNvdW50ZXI9PT1yJiYodC5jb2xvckNvdW50ZXI9MCkpOihpfHwocz10LmNvbG9yKSxuPXQuY29sb3JJbmRleCksdGhpcy5jb2xvckluZGV4PXYodGhpcy5vcHRpb25zLmNvbG9ySW5kZXgsbiksdGhpcy5jb2xvcj12KHRoaXMub3B0aW9ucy5jb2xvcixzKX1zZXROZXN0ZWRQcm9wZXJ0eSh0LGUsaSl7bGV0IHM9aS5zcGxpdChcIi5cIik7cmV0dXJuIHMucmVkdWNlKGZ1bmN0aW9uKHQsaSxzLG8pe2xldCByPW8ubGVuZ3RoLTE9PT1zO3JldHVybiB0W2ldPXI/ZTp4KHRbaV0sITApP3RbaV06e30sdFtpXX0sdCksdH1zaG91bGREcmF3KCl7cmV0dXJuIXRoaXMuaXNOdWxsfXRvb2x0aXBGb3JtYXR0ZXIodCl7bGV0IGU9dGhpcy5zZXJpZXMsaT1lLnRvb2x0aXBPcHRpb25zLHM9dihpLnZhbHVlRGVjaW1hbHMsXCJcIiksbz1pLnZhbHVlUHJlZml4fHxcIlwiLHI9aS52YWx1ZVN1ZmZpeHx8XCJcIjtyZXR1cm4gZS5jaGFydC5zdHlsZWRNb2RlJiYodD1lLmNoYXJ0LnRvb2x0aXAuc3R5bGVkTW9kZUZvcm1hdCh0KSksKGUucG9pbnRBcnJheU1hcHx8W1wieVwiXSkuZm9yRWFjaChmdW5jdGlvbihlKXtlPVwie3BvaW50LlwiK2UsKG98fHIpJiYodD10LnJlcGxhY2UoUmVnRXhwKGUrXCJ9XCIsXCJnXCIpLG8rZStcIn1cIityKSksdD10LnJlcGxhY2UoUmVnRXhwKGUrXCJ9XCIsXCJnXCIpLGUrXCI6LC5cIitzK1wiZn1cIil9KSxhKHQse3BvaW50OnRoaXMsc2VyaWVzOnRoaXMuc2VyaWVzfSxlLmNoYXJ0KX11cGRhdGUodCxlLGkscyl7bGV0IG87bGV0IHI9dGhpcyxuPXIuc2VyaWVzLGE9ci5ncmFwaGljLGg9bi5jaGFydCxsPW4ub3B0aW9ucztmdW5jdGlvbiBkKCl7ci5hcHBseU9wdGlvbnModCk7bGV0IHM9YSYmci5oYXNNb2NrR3JhcGhpYyxkPW51bGw9PT1yLnk/IXM6czthJiZkJiYoci5ncmFwaGljPWEuZGVzdHJveSgpLGRlbGV0ZSByLmhhc01vY2tHcmFwaGljKSx4KHQsITApJiYoYSYmYS5lbGVtZW50JiZ0JiZ0Lm1hcmtlciYmdm9pZCAwIT09dC5tYXJrZXIuc3ltYm9sJiYoci5ncmFwaGljPWEuZGVzdHJveSgpKSx0Py5kYXRhTGFiZWxzJiZyLmRhdGFMYWJlbCYmKHIuZGF0YUxhYmVsPXIuZGF0YUxhYmVsLmRlc3Ryb3koKSkpLG89ci5pbmRleCxuLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHIsbyksbC5kYXRhW29dPXgobC5kYXRhW29dLCEwKXx8eCh0LCEwKT9yLm9wdGlvbnM6dih0LGwuZGF0YVtvXSksbi5pc0RpcnR5PW4uaXNEaXJ0eURhdGE9ITAsIW4uZml4ZWRCb3gmJm4uaGFzQ2FydGVzaWFuU2VyaWVzJiYoaC5pc0RpcnR5Qm94PSEwKSxcInBvaW50XCI9PT1sLmxlZ2VuZFR5cGUmJihoLmlzRGlydHlMZWdlbmQ9ITApLGUmJmgucmVkcmF3KGkpfWU9dihlLCEwKSwhMT09PXM/ZCgpOnIuZmlyZVBvaW50RXZlbnQoXCJ1cGRhdGVcIix7b3B0aW9uczp0fSxkKX1yZW1vdmUodCxlKXt0aGlzLnNlcmllcy5yZW1vdmVQb2ludCh0aGlzLnNlcmllcy5kYXRhLmluZGV4T2YodGhpcyksdCxlKX1zZWxlY3QodCxlKXtsZXQgaT10aGlzLHM9aS5zZXJpZXMsbz1zLmNoYXJ0O3Q9dih0LCFpLnNlbGVjdGVkKSx0aGlzLnNlbGVjdGVkU3RhZ2luZz10LGkuZmlyZVBvaW50RXZlbnQodD9cInNlbGVjdFwiOlwidW5zZWxlY3RcIix7YWNjdW11bGF0ZTplfSxmdW5jdGlvbigpe2kuc2VsZWN0ZWQ9aS5vcHRpb25zLnNlbGVjdGVkPXQscy5vcHRpb25zLmRhdGFbcy5kYXRhLmluZGV4T2YoaSldPWkub3B0aW9ucyxpLnNldFN0YXRlKHQmJlwic2VsZWN0XCIpLGV8fG8uZ2V0U2VsZWN0ZWRQb2ludHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldCBlPXQuc2VyaWVzO3Quc2VsZWN0ZWQmJnQhPT1pJiYodC5zZWxlY3RlZD10Lm9wdGlvbnMuc2VsZWN0ZWQ9ITEsZS5vcHRpb25zLmRhdGFbZS5kYXRhLmluZGV4T2YodCldPXQub3B0aW9ucyx0LnNldFN0YXRlKG8uaG92ZXJQb2ludHMmJmUub3B0aW9ucy5pbmFjdGl2ZU90aGVyUG9pbnRzP1wiaW5hY3RpdmVcIjpcIlwiKSx0LmZpcmVQb2ludEV2ZW50KFwidW5zZWxlY3RcIikpfSl9KSxkZWxldGUgdGhpcy5zZWxlY3RlZFN0YWdpbmd9b25Nb3VzZU92ZXIodCl7bGV0IGU9dGhpcy5zZXJpZXMsaT1lLmNoYXJ0LHM9aS5wb2ludGVyO3Q9dD9zLm5vcm1hbGl6ZSh0KTpzLmdldENoYXJ0Q29vcmRpbmF0ZXNGcm9tUG9pbnQodGhpcyxpLmludmVydGVkKSxzLnJ1blBvaW50QWN0aW9ucyh0LHRoaXMpfW9uTW91c2VPdXQoKXtsZXQgdD10aGlzLnNlcmllcy5jaGFydDt0aGlzLmZpcmVQb2ludEV2ZW50KFwibW91c2VPdXRcIiksdGhpcy5zZXJpZXMub3B0aW9ucy5pbmFjdGl2ZU90aGVyUG9pbnRzfHwodC5ob3ZlclBvaW50c3x8W10pLmZvckVhY2goZnVuY3Rpb24odCl7dC5zZXRTdGF0ZSgpfSksdC5ob3ZlclBvaW50cz10LmhvdmVyUG9pbnQ9bnVsbH1pbXBvcnRFdmVudHMoKXtpZighdGhpcy5oYXNJbXBvcnRlZEV2ZW50cyl7bGV0IHQ9dGhpcyxlPXkodC5zZXJpZXMub3B0aW9ucy5wb2ludCx0Lm9wdGlvbnMpLGk9ZS5ldmVudHM7dC5ldmVudHM9aSxiKGksZnVuY3Rpb24oZSxpKXtmKGUpJiZoKHQsaSxlKX0pLHRoaXMuaGFzSW1wb3J0ZWRFdmVudHM9ITB9fXNldFN0YXRlKGUsaSl7bGV0IHM9dGhpcy5zZXJpZXMsbz10aGlzLnN0YXRlLHI9cy5vcHRpb25zLnN0YXRlc1tlfHxcIm5vcm1hbFwiXXx8e30sYT1uLnBsb3RPcHRpb25zW3MudHlwZV0ubWFya2VyJiZzLm9wdGlvbnMubWFya2VyLGg9YSYmITE9PT1hLmVuYWJsZWQsbD1hJiZhLnN0YXRlcyYmYS5zdGF0ZXNbZXx8XCJub3JtYWxcIl18fHt9LGQ9ITE9PT1sLmVuYWJsZWQsdT10aGlzLm1hcmtlcnx8e30sZz1zLmNoYXJ0LGY9YSYmcy5tYXJrZXJBdHRyaWJzLHg9cy5oYWxvLHksYixTLGs9cy5zdGF0ZU1hcmtlckdyYXBoaWMsTTtpZigoZT1lfHxcIlwiKT09PXRoaXMuc3RhdGUmJiFpfHx0aGlzLnNlbGVjdGVkJiZcInNlbGVjdFwiIT09ZXx8ITE9PT1yLmVuYWJsZWR8fGUmJihkfHxoJiYhMT09PWwuZW5hYmxlZCl8fGUmJnUuc3RhdGVzJiZ1LnN0YXRlc1tlXSYmITE9PT11LnN0YXRlc1tlXS5lbmFibGVkKXJldHVybjtpZih0aGlzLnN0YXRlPWUsZiYmKHk9cy5tYXJrZXJBdHRyaWJzKHRoaXMsZSkpLHRoaXMuZ3JhcGhpYyYmIXRoaXMuaGFzTW9ja0dyYXBoaWMpe2lmKG8mJnRoaXMuZ3JhcGhpYy5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnQtXCIrbyksZSYmdGhpcy5ncmFwaGljLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1cIitlKSwhZy5zdHlsZWRNb2RlKXtiPXMucG9pbnRBdHRyaWJzKHRoaXMsZSksUz12KGcub3B0aW9ucy5jaGFydC5hbmltYXRpb24sci5hbmltYXRpb24pO2xldCB0PWIub3BhY2l0eTtzLm9wdGlvbnMuaW5hY3RpdmVPdGhlclBvaW50cyYmbSh0KSYmKHRoaXMuZGF0YUxhYmVsc3x8W10pLmZvckVhY2goZnVuY3Rpb24oZSl7ZSYmIWUuaGFzQ2xhc3MoXCJoaWdoY2hhcnRzLWRhdGEtbGFiZWwtaGlkZGVuXCIpJiYoZS5hbmltYXRlKHtvcGFjaXR5OnR9LFMpLGUuY29ubmVjdG9yJiZlLmNvbm5lY3Rvci5hbmltYXRlKHtvcGFjaXR5OnR9LFMpKX0pLHRoaXMuZ3JhcGhpYy5hbmltYXRlKGIsUyl9eSYmdGhpcy5ncmFwaGljLmFuaW1hdGUoeSx2KGcub3B0aW9ucy5jaGFydC5hbmltYXRpb24sbC5hbmltYXRpb24sYS5hbmltYXRpb24pKSxrJiZrLmhpZGUoKX1lbHNlIGUmJmwmJihNPXUuc3ltYm9sfHxzLnN5bWJvbCxrJiZrLmN1cnJlbnRTeW1ib2whPT1NJiYoaz1rLmRlc3Ryb3koKSkseSYmKGs/a1tpP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7eDp5LngseTp5Lnl9KTpNJiYocy5zdGF0ZU1hcmtlckdyYXBoaWM9az1nLnJlbmRlcmVyLnN5bWJvbChNLHkueCx5LnkseS53aWR0aCx5LmhlaWdodCkuYWRkKHMubWFya2VyR3JvdXApLGsuY3VycmVudFN5bWJvbD1NKSksIWcuc3R5bGVkTW9kZSYmayYmXCJpbmFjdGl2ZVwiIT09dGhpcy5zdGF0ZSYmay5hdHRyKHMucG9pbnRBdHRyaWJzKHRoaXMsZSkpKSxrJiYoa1tlJiZ0aGlzLmlzSW5zaWRlP1wic2hvd1wiOlwiaGlkZVwiXSgpLGsuZWxlbWVudC5wb2ludD10aGlzLGsuYWRkQ2xhc3ModGhpcy5nZXRDbGFzc05hbWUoKSwhMCkpO2xldCBDPXIuaGFsbyx3PXRoaXMuZ3JhcGhpY3x8ayxUPXcmJncudmlzaWJpbGl0eXx8XCJpbmhlcml0XCI7QyYmQy5zaXplJiZ3JiZcImhpZGRlblwiIT09VCYmIXRoaXMuaXNDbHVzdGVyPyh4fHwocy5oYWxvPXg9Zy5yZW5kZXJlci5wYXRoKCkuYWRkKHcucGFyZW50R3JvdXApKSx4LnNob3coKVtpP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7ZDp0aGlzLmhhbG9QYXRoKEMuc2l6ZSl9KSx4LmF0dHIoe2NsYXNzOlwiaGlnaGNoYXJ0cy1oYWxvIGhpZ2hjaGFydHMtY29sb3ItXCIrdih0aGlzLmNvbG9ySW5kZXgscy5jb2xvckluZGV4KSsodGhpcy5jbGFzc05hbWU/XCIgXCIrdGhpcy5jbGFzc05hbWU6XCJcIiksdmlzaWJpbGl0eTpULHpJbmRleDotMX0pLHgucG9pbnQ9dGhpcyxnLnN0eWxlZE1vZGV8fHguYXR0cihjKHtmaWxsOnRoaXMuY29sb3J8fHMuY29sb3IsXCJmaWxsLW9wYWNpdHlcIjpDLm9wYWNpdHl9LHQuZmlsdGVyVXNlckF0dHJpYnV0ZXMoQy5hdHRyaWJ1dGVzfHx7fSkpKSk6eCYmeC5wb2ludCYmeC5wb2ludC5oYWxvUGF0aCYmeC5hbmltYXRlKHtkOngucG9pbnQuaGFsb1BhdGgoMCl9LG51bGwseC5oaWRlKSxwKHRoaXMsXCJhZnRlclNldFN0YXRlXCIse3N0YXRlOmV9KX1oYWxvUGF0aCh0KXtsZXQgZT10aGlzLnBvcygpO3JldHVybiBlP3RoaXMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuY2lyY2xlKE1hdGguZmxvb3IoZVswXSktdCxlWzFdLXQsMip0LDIqdCk6W119fXJldHVybiBDfSksaShlLFwiQ29yZS9Qb2ludGVyLmpzXCIsW2VbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7dmFyIHM7bGV0e3BhcnNlOm99PXQse2NoYXJ0czpyLGNvbXBvc2VkOm4sbm9vcDphfT1lLHthZGRFdmVudDpoLGF0dHI6bCxjc3M6ZCxkZWZpbmVkOmMsZXh0ZW5kOnAsZmluZDp1LGZpcmVFdmVudDpnLGlzTnVtYmVyOmYsaXNPYmplY3Q6bSxvYmplY3RFYWNoOngsb2Zmc2V0OnkscGljazpiLHB1c2hVbmlxdWU6dixzcGxhdDpTfT1pO2NsYXNzIGt7YXBwbHlJbmFjdGl2ZVN0YXRlKHQpe2xldCBlPVtdLGk7KHR8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2k9dC5zZXJpZXMsZS5wdXNoKGkpLGkubGlua2VkUGFyZW50JiZlLnB1c2goaS5saW5rZWRQYXJlbnQpLGkubGlua2VkU2VyaWVzJiYoZT1lLmNvbmNhdChpLmxpbmtlZFNlcmllcykpLGkubmF2aWdhdG9yU2VyaWVzJiZlLnB1c2goaS5uYXZpZ2F0b3JTZXJpZXMpfSksdGhpcy5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbih0KXstMT09PWUuaW5kZXhPZih0KT90LnNldFN0YXRlKFwiaW5hY3RpdmVcIiwhMCk6dC5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHMmJnQuc2V0QWxsUG9pbnRzVG9TdGF0ZShcImluYWN0aXZlXCIpfSl9ZGVzdHJveSgpe2xldCB0PXRoaXM7dGhpcy5ldmVudHNUb1VuYmluZC5mb3JFYWNoKHQ9PnQoKSksdGhpcy5ldmVudHNUb1VuYmluZD1bXSwhZS5jaGFydENvdW50JiYoay51bmJpbmREb2N1bWVudE1vdXNlVXAmJihrLnVuYmluZERvY3VtZW50TW91c2VVcD1rLnVuYmluZERvY3VtZW50TW91c2VVcCgpKSxrLnVuYmluZERvY3VtZW50VG91Y2hFbmQmJihrLnVuYmluZERvY3VtZW50VG91Y2hFbmQ9ay51bmJpbmREb2N1bWVudFRvdWNoRW5kKCkpKSxjbGVhckludGVydmFsKHQudG9vbHRpcFRpbWVvdXQpLHgodCxmdW5jdGlvbihlLGkpe3RbaV09dm9pZCAwfSl9Z2V0U2VsZWN0aW9uTWFya2VyQXR0cnModCxlKXtsZXQgaT17YXJnczp7Y2hhcnRYOnQsY2hhcnRZOmV9LGF0dHJzOnt9LHNoYXBlVHlwZTpcInJlY3RcIn07cmV0dXJuIGcodGhpcyxcImdldFNlbGVjdGlvbk1hcmtlckF0dHJzXCIsaSxpPT57bGV0IHM7bGV0e2NoYXJ0Om8sbW91c2VEb3duWDpyPTAsbW91c2VEb3duWTpuPTAsem9vbUhvcjphLHpvb21WZXJ0Omh9PXRoaXMsbD1pLmF0dHJzO2wueD1vLnBsb3RMZWZ0LGwueT1vLnBsb3RUb3AsbC53aWR0aD1hPzE6by5wbG90V2lkdGgsbC5oZWlnaHQ9aD8xOm8ucGxvdEhlaWdodCxhJiYocz10LXIsbC53aWR0aD1NYXRoLmFicyhzKSxsLng9KHM+MD8wOnMpK3IpLGgmJihzPWUtbixsLmhlaWdodD1NYXRoLmFicyhzKSxsLnk9KHM+MD8wOnMpK24pfSksaX1kcmFnKHQpe2xldCBlPXRoaXMuY2hhcnQsaT1lLm9wdGlvbnMuY2hhcnQscz1lLnBsb3RMZWZ0LHI9ZS5wbG90VG9wLG49ZS5wbG90V2lkdGgsYT1lLnBsb3RIZWlnaHQsaD10aGlzLm1vdXNlRG93blh8fDAsbD10aGlzLm1vdXNlRG93bll8fDAsZD1tKGkucGFubmluZyk/aS5wYW5uaW5nJiZpLnBhbm5pbmcuZW5hYmxlZDppLnBhbm5pbmcsYz1pLnBhbktleSYmdFtpLnBhbktleStcIktleVwiXSxwPXQuY2hhcnRYLHU9dC5jaGFydFksZyxmPXRoaXMuc2VsZWN0aW9uTWFya2VyO2lmKCghZnx8IWYudG91Y2gpJiYocDxzP3A9czpwPnMrbiYmKHA9cytuKSx1PHI/dT1yOnU+cithJiYodT1yK2EpLHRoaXMuaGFzRHJhZ2dlZD1NYXRoLnNxcnQoTWF0aC5wb3coaC1wLDIpK01hdGgucG93KGwtdSwyKSksdGhpcy5oYXNEcmFnZ2VkPjEwKSl7Zz1lLmlzSW5zaWRlUGxvdChoLXMsbC1yLHt2aXNpYmxlUGxvdE9ubHk6ITB9KTtsZXR7c2hhcGVUeXBlOm4sYXR0cnM6YX09dGhpcy5nZXRTZWxlY3Rpb25NYXJrZXJBdHRycyhwLHUpOyhlLmhhc0NhcnRlc2lhblNlcmllc3x8ZS5tYXBWaWV3KSYmKHRoaXMuem9vbVh8fHRoaXMuem9vbVkpJiZnJiYhYyYmIWYmJih0aGlzLnNlbGVjdGlvbk1hcmtlcj1mPWUucmVuZGVyZXJbbl0oKSxmLmF0dHIoe2NsYXNzOlwiaGlnaGNoYXJ0cy1zZWxlY3Rpb24tbWFya2VyXCIsekluZGV4Ojd9KS5hZGQoKSxlLnN0eWxlZE1vZGV8fGYuYXR0cih7ZmlsbDppLnNlbGVjdGlvbk1hcmtlckZpbGx8fG8oXCIjMzM0ZWZmXCIpLnNldE9wYWNpdHkoLjI1KS5nZXQoKX0pKSxmJiZmLmF0dHIoYSksZyYmIWYmJmQmJmUucGFuKHQsaS5wYW5uaW5nKX19ZHJhZ1N0YXJ0KHQpe2xldCBlPXRoaXMuY2hhcnQ7ZS5tb3VzZUlzRG93bj10LnR5cGUsZS5jYW5jZWxDbGljaz0hMSxlLm1vdXNlRG93blg9dGhpcy5tb3VzZURvd25YPXQuY2hhcnRYLGUubW91c2VEb3duWT10aGlzLm1vdXNlRG93blk9dC5jaGFydFl9Z2V0U2VsZWN0aW9uQm94KHQpe2xldCBlPXthcmdzOnttYXJrZXI6dH0scmVzdWx0Ont9fTtyZXR1cm4gZyh0aGlzLFwiZ2V0U2VsZWN0aW9uQm94XCIsZSxlPT57ZS5yZXN1bHQ9e3g6dC5hdHRyPyt0LmF0dHIoXCJ4XCIpOnQueCx5OnQuYXR0cj8rdC5hdHRyKFwieVwiKTp0Lnksd2lkdGg6dC5hdHRyP3QuYXR0cihcIndpZHRoXCIpOnQud2lkdGgsaGVpZ2h0OnQuYXR0cj90LmF0dHIoXCJoZWlnaHRcIik6dC5oZWlnaHR9fSksZS5yZXN1bHR9ZHJvcCh0KXtsZXQgZT10aGlzLGk9dGhpcy5jaGFydCxzPXRoaXMuaGFzUGluY2hlZDtpZih0aGlzLnNlbGVjdGlvbk1hcmtlcil7bGV0e3g6byx5OnIsd2lkdGg6bixoZWlnaHQ6YX09dGhpcy5nZXRTZWxlY3Rpb25Cb3godGhpcy5zZWxlY3Rpb25NYXJrZXIpLGg9e29yaWdpbmFsRXZlbnQ6dCx4QXhpczpbXSx5QXhpczpbXSx4Om8seTpyLHdpZHRoOm4saGVpZ2h0OmF9LGw9ISFpLm1hcFZpZXc7KHRoaXMuaGFzRHJhZ2dlZHx8cykmJihpLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihpKXtpZihpLnpvb21FbmFibGVkJiZjKGkubWluKSYmKHN8fGVbKHt4QXhpczpcInpvb21YXCIseUF4aXM6XCJ6b29tWVwifSlbaS5jb2xsXV0pJiZmKG8pJiZmKHIpJiZmKG4pJiZmKGEpKXtsZXQgZT1pLmhvcml6LHM9XCJ0b3VjaGVuZFwiPT09dC50eXBlP2kubWluUGl4ZWxQYWRkaW5nOjAsZD1pLnRvVmFsdWUoKGU/bzpyKStzKSxjPWkudG9WYWx1ZSgoZT9vK246cithKS1zKTtoW2kuY29sbF0ucHVzaCh7YXhpczppLG1pbjpNYXRoLm1pbihkLGMpLG1heDpNYXRoLm1heChkLGMpfSksbD0hMH19KSxsJiZnKGksXCJzZWxlY3Rpb25cIixoLGZ1bmN0aW9uKHQpe2kuem9vbShwKHQscz97YW5pbWF0aW9uOiExfTpudWxsKSl9KSksZihpLmluZGV4KSYmKHRoaXMuc2VsZWN0aW9uTWFya2VyPXRoaXMuc2VsZWN0aW9uTWFya2VyLmRlc3Ryb3koKSkscyYmdGhpcy5zY2FsZUdyb3VwcygpfWkmJmYoaS5pbmRleCkmJihkKGkuY29udGFpbmVyLHtjdXJzb3I6aS5fY3Vyc29yfSksaS5jYW5jZWxDbGljaz0rdGhpcy5oYXNEcmFnZ2VkPjEwLGkubW91c2VJc0Rvd249dGhpcy5oYXNEcmFnZ2VkPXRoaXMuaGFzUGluY2hlZD0hMSx0aGlzLnBpbmNoRG93bj1bXSl9ZmluZE5lYXJlc3RLRFBvaW50KHQsZSxpKXtsZXQgcztyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldCBvPXQubm9TaGFyZWRUb29sdGlwJiZlLHI9IW8mJjA+dC5vcHRpb25zLmZpbmROZWFyZXN0UG9pbnRCeS5pbmRleE9mKFwieVwiKSxuPXQuc2VhcmNoUG9pbnQoaSxyKTttKG4sITApJiZuLnNlcmllcyYmKCFtKHMsITApfHxmdW5jdGlvbih0LGkpe2xldCBzPXQuZGlzdFgtaS5kaXN0WCxvPXQuZGlzdC1pLmRpc3Qscj0oaS5zZXJpZXMuZ3JvdXAmJmkuc2VyaWVzLmdyb3VwLnpJbmRleCktKHQuc2VyaWVzLmdyb3VwJiZ0LnNlcmllcy5ncm91cC56SW5kZXgpO3JldHVybiAwIT09cyYmZT9zOjAhPT1vP286MCE9PXI/cjp0LnNlcmllcy5pbmRleD5pLnNlcmllcy5pbmRleD8tMToxfShzLG4pPjApJiYocz1uKX0pLHN9Z2V0Q2hhcnRDb29yZGluYXRlc0Zyb21Qb2ludCh0LGUpe2xldCBpPXQuc2VyaWVzLHM9aS54QXhpcyxvPWkueUF4aXMscj10LnNoYXBlQXJncztpZihzJiZvKXtsZXQgaT1iKHQuY2xpZW50WCx0LnBsb3RYKSxuPXQucGxvdFl8fDA7cmV0dXJuIHQuaXNOb2RlJiZyJiZmKHIueCkmJmYoci55KSYmKGk9ci54LG49ci55KSxlP3tjaGFydFg6by5sZW4rby5wb3MtbixjaGFydFk6cy5sZW4rcy5wb3MtaX06e2NoYXJ0WDppK3MucG9zLGNoYXJ0WTpuK28ucG9zfX1pZihyJiZyLngmJnIueSlyZXR1cm57Y2hhcnRYOnIueCxjaGFydFk6ci55fX1nZXRDaGFydFBvc2l0aW9uKCl7aWYodGhpcy5jaGFydFBvc2l0aW9uKXJldHVybiB0aGlzLmNoYXJ0UG9zaXRpb247bGV0e2NvbnRhaW5lcjp0fT10aGlzLmNoYXJ0LGU9eSh0KTt0aGlzLmNoYXJ0UG9zaXRpb249e2xlZnQ6ZS5sZWZ0LHRvcDplLnRvcCxzY2FsZVg6MSxzY2FsZVk6MX07bGV0IGk9dC5vZmZzZXRXaWR0aCxzPXQub2Zmc2V0SGVpZ2h0O3JldHVybiBpPjImJnM+MiYmKHRoaXMuY2hhcnRQb3NpdGlvbi5zY2FsZVg9ZS53aWR0aC9pLHRoaXMuY2hhcnRQb3NpdGlvbi5zY2FsZVk9ZS5oZWlnaHQvcyksdGhpcy5jaGFydFBvc2l0aW9ufWdldENvb3JkaW5hdGVzKHQpe2xldCBlPXt4QXhpczpbXSx5QXhpczpbXX07cmV0dXJuIHRoaXMuY2hhcnQuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpe2VbaS5pc1hBeGlzP1wieEF4aXNcIjpcInlBeGlzXCJdLnB1c2goe2F4aXM6aSx2YWx1ZTppLnRvVmFsdWUodFtpLmhvcml6P1wiY2hhcnRYXCI6XCJjaGFydFlcIl0pfSl9KSxlfWdldEhvdmVyRGF0YSh0LGUsaSxzLG8scil7bGV0IG49W10sYT1mdW5jdGlvbih0KXtyZXR1cm4gdC52aXNpYmxlJiYhKCFvJiZ0LmRpcmVjdFRvdWNoKSYmYih0Lm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZywhMCl9LGg9ZSxsLGQ9e2NoYXJ0WDpyP3IuY2hhcnRYOnZvaWQgMCxjaGFydFk6cj9yLmNoYXJ0WTp2b2lkIDAsc2hhcmVkOm99O2codGhpcyxcImJlZm9yZUdldEhvdmVyRGF0YVwiLGQpO2xldCBjPWgmJiFoLnN0aWNreVRyYWNraW5nO2w9Yz9baF06aS5maWx0ZXIodD0+dC5zdGlja3lUcmFja2luZyYmKGQuZmlsdGVyfHxhKSh0KSk7bGV0IHA9cyYmdHx8IXI/dDp0aGlzLmZpbmROZWFyZXN0S0RQb2ludChsLG8scik7cmV0dXJuIGg9cCYmcC5zZXJpZXMscCYmKG8mJiFoLm5vU2hhcmVkVG9vbHRpcD8obD1pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZC5maWx0ZXI/ZC5maWx0ZXIodCk6YSh0KSYmIXQubm9TaGFyZWRUb29sdGlwfSkpLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IGU9dSh0LnBvaW50cyxmdW5jdGlvbih0KXtyZXR1cm4gdC54PT09cC54JiYhdC5pc051bGx9KTttKGUpJiYodC5ib29zdGVkJiZ0LmJvb3N0JiYoZT10LmJvb3N0LmdldFBvaW50KGUpKSxuLnB1c2goZSkpfSk6bi5wdXNoKHApKSxnKHRoaXMsXCJhZnRlckdldEhvdmVyRGF0YVwiLGQ9e2hvdmVyUG9pbnQ6cH0pLHtob3ZlclBvaW50OmQuaG92ZXJQb2ludCxob3ZlclNlcmllczpoLGhvdmVyUG9pbnRzOm59fWdldFBvaW50RnJvbUV2ZW50KHQpe2xldCBlPXQudGFyZ2V0LGk7Zm9yKDtlJiYhaTspaT1lLnBvaW50LGU9ZS5wYXJlbnROb2RlO3JldHVybiBpfW9uVHJhY2tlck1vdXNlT3V0KHQpe2xldCBlPXRoaXMuY2hhcnQsaT10LnJlbGF0ZWRUYXJnZXQscz1lLmhvdmVyU2VyaWVzO3RoaXMuaXNEaXJlY3RUb3VjaD0hMSwhc3x8IWl8fHMuc3RpY2t5VHJhY2tpbmd8fHRoaXMuaW5DbGFzcyhpLFwiaGlnaGNoYXJ0cy10b29sdGlwXCIpfHx0aGlzLmluQ2xhc3MoaSxcImhpZ2hjaGFydHMtc2VyaWVzLVwiK3MuaW5kZXgpJiZ0aGlzLmluQ2xhc3MoaSxcImhpZ2hjaGFydHMtdHJhY2tlclwiKXx8cy5vbk1vdXNlT3V0KCl9aW5DbGFzcyh0LGUpe2xldCBpPXQscztmb3IoO2k7KXtpZihzPWwoaSxcImNsYXNzXCIpKXtpZigtMSE9PXMuaW5kZXhPZihlKSlyZXR1cm4hMDtpZigtMSE9PXMuaW5kZXhPZihcImhpZ2hjaGFydHMtY29udGFpbmVyXCIpKXJldHVybiExfWk9aS5wYXJlbnRFbGVtZW50fX1jb25zdHJ1Y3Rvcih0LGUpe3RoaXMuaGFzRHJhZ2dlZD0hMSx0aGlzLmxhc3RWYWxpZFRvdWNoPXt9LHRoaXMucGluY2hEb3duPVtdLHRoaXMuZXZlbnRzVG9VbmJpbmQ9W10sdGhpcy5vcHRpb25zPWUsdGhpcy5jaGFydD10LHRoaXMucnVuQ2hhcnRDbGljaz0hIWUuY2hhcnQuZXZlbnRzPy5jbGljayx0aGlzLnBpbmNoRG93bj1bXSx0aGlzLmxhc3RWYWxpZFRvdWNoPXt9LHRoaXMuc2V0RE9NRXZlbnRzKCksZyh0aGlzLFwiYWZ0ZXJJbml0XCIpfW5vcm1hbGl6ZSh0LGUpe2xldCBpPXQudG91Y2hlcyxzPWk/aS5sZW5ndGg/aS5pdGVtKDApOmIoaS5jaGFuZ2VkVG91Y2hlcyx0LmNoYW5nZWRUb3VjaGVzKVswXTp0O2V8fChlPXRoaXMuZ2V0Q2hhcnRQb3NpdGlvbigpKTtsZXQgbz1zLnBhZ2VYLWUubGVmdCxyPXMucGFnZVktZS50b3A7cmV0dXJuIHAodCx7Y2hhcnRYOk1hdGgucm91bmQoby89ZS5zY2FsZVgpLGNoYXJ0WTpNYXRoLnJvdW5kKHIvPWUuc2NhbGVZKX0pfW9uQ29udGFpbmVyQ2xpY2sodCl7bGV0IGU9dGhpcy5jaGFydCxpPWUuaG92ZXJQb2ludCxzPXRoaXMubm9ybWFsaXplKHQpLG89ZS5wbG90TGVmdCxyPWUucGxvdFRvcDshZS5jYW5jZWxDbGljayYmKGkmJnRoaXMuaW5DbGFzcyhzLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKT8oZyhpLnNlcmllcyxcImNsaWNrXCIscChzLHtwb2ludDppfSkpLGUuaG92ZXJQb2ludCYmaS5maXJlUG9pbnRFdmVudChcImNsaWNrXCIscykpOihwKHMsdGhpcy5nZXRDb29yZGluYXRlcyhzKSksZS5pc0luc2lkZVBsb3Qocy5jaGFydFgtbyxzLmNoYXJ0WS1yLHt2aXNpYmxlUGxvdE9ubHk6ITB9KSYmZyhlLFwiY2xpY2tcIixzKSkpfW9uQ29udGFpbmVyTW91c2VEb3duKHQpe2xldCBpPSgxJih0LmJ1dHRvbnN8fHQuYnV0dG9uKSk9PTE7dD10aGlzLm5vcm1hbGl6ZSh0KSxlLmlzRmlyZWZveCYmMCE9PXQuYnV0dG9uJiZ0aGlzLm9uQ29udGFpbmVyTW91c2VNb3ZlKHQpLCh2b2lkIDA9PT10LmJ1dHRvbnx8aSkmJih0aGlzLnpvb21PcHRpb24odCksaSYmdC5wcmV2ZW50RGVmYXVsdCYmdC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuZHJhZ1N0YXJ0KHQpKX1vbkNvbnRhaW5lck1vdXNlTGVhdmUodCl7bGV0IGU9cltiKGsuaG92ZXJDaGFydEluZGV4LC0xKV07dD10aGlzLm5vcm1hbGl6ZSh0KSx0aGlzLm9uQ29udGFpbmVyTW91c2VNb3ZlKHQpLGUmJnQucmVsYXRlZFRhcmdldCYmIXRoaXMuaW5DbGFzcyh0LnJlbGF0ZWRUYXJnZXQsXCJoaWdoY2hhcnRzLXRvb2x0aXBcIikmJihlLnBvaW50ZXIucmVzZXQoKSxlLnBvaW50ZXIuY2hhcnRQb3NpdGlvbj12b2lkIDApfW9uQ29udGFpbmVyTW91c2VFbnRlcih0KXtkZWxldGUgdGhpcy5jaGFydFBvc2l0aW9ufW9uQ29udGFpbmVyTW91c2VNb3ZlKHQpe2xldCBlPXRoaXMuY2hhcnQsaT1lLnRvb2x0aXAscz10aGlzLm5vcm1hbGl6ZSh0KTt0aGlzLnNldEhvdmVyQ2hhcnRJbmRleCh0KSwoXCJtb3VzZWRvd25cIj09PWUubW91c2VJc0Rvd258fHRoaXMudG91Y2hTZWxlY3QocykpJiZ0aGlzLmRyYWcocyksIWUub3Blbk1lbnUmJih0aGlzLmluQ2xhc3Mocy50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIil8fGUuaXNJbnNpZGVQbG90KHMuY2hhcnRYLWUucGxvdExlZnQscy5jaGFydFktZS5wbG90VG9wLHt2aXNpYmxlUGxvdE9ubHk6ITB9KSkmJiEoaSYmaS5zaG91bGRTdGlja09uQ29udGFjdChzKSkmJih0aGlzLmluQ2xhc3Mocy50YXJnZXQsXCJoaWdoY2hhcnRzLW5vLXRvb2x0aXBcIik/dGhpcy5yZXNldCghMSwwKTp0aGlzLnJ1blBvaW50QWN0aW9ucyhzKSl9b25Eb2N1bWVudFRvdWNoRW5kKHQpe2xldCBlPXJbYihrLmhvdmVyQ2hhcnRJbmRleCwtMSldO2UmJmUucG9pbnRlci5kcm9wKHQpfW9uQ29udGFpbmVyVG91Y2hNb3ZlKHQpe3RoaXMudG91Y2hTZWxlY3QodCk/dGhpcy5vbkNvbnRhaW5lck1vdXNlTW92ZSh0KTp0aGlzLnRvdWNoKHQpfW9uQ29udGFpbmVyVG91Y2hTdGFydCh0KXt0aGlzLnRvdWNoU2VsZWN0KHQpP3RoaXMub25Db250YWluZXJNb3VzZURvd24odCk6KHRoaXMuem9vbU9wdGlvbih0KSx0aGlzLnRvdWNoKHQsITApKX1vbkRvY3VtZW50TW91c2VNb3ZlKHQpe2xldCBlPXRoaXMuY2hhcnQsaT1lLnRvb2x0aXAscz10aGlzLmNoYXJ0UG9zaXRpb24sbz10aGlzLm5vcm1hbGl6ZSh0LHMpOyFzfHxlLmlzSW5zaWRlUGxvdChvLmNoYXJ0WC1lLnBsb3RMZWZ0LG8uY2hhcnRZLWUucGxvdFRvcCx7dmlzaWJsZVBsb3RPbmx5OiEwfSl8fGkmJmkuc2hvdWxkU3RpY2tPbkNvbnRhY3Qobyl8fHRoaXMuaW5DbGFzcyhvLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKXx8dGhpcy5yZXNldCgpfW9uRG9jdW1lbnRNb3VzZVVwKHQpe2xldCBlPXJbYihrLmhvdmVyQ2hhcnRJbmRleCwtMSldO2UmJmUucG9pbnRlci5kcm9wKHQpfXBpbmNoKHQpe2xldCBlPXRoaXMsaT1lLmNoYXJ0LHM9ZS5waW5jaERvd24sbz10LnRvdWNoZXN8fFtdLHI9by5sZW5ndGgsbj1lLmxhc3RWYWxpZFRvdWNoLGg9ZS5oYXNab29tLGw9e30sZD0xPT09ciYmKGUuaW5DbGFzcyh0LnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKSYmaS5ydW5UcmFja2VyQ2xpY2t8fGUucnVuQ2hhcnRDbGljayksYz17fSx1PWUuY2hhcnQudG9vbHRpcCxmPTE9PT1yJiZiKHUmJnUub3B0aW9ucy5mb2xsb3dUb3VjaE1vdmUsITApLG09ZS5zZWxlY3Rpb25NYXJrZXI7cj4xP2UuaW5pdGlhdGVkPSEwOmYmJihlLmluaXRpYXRlZD0hMSksaCYmZS5pbml0aWF0ZWQmJiFkJiYhMSE9PXQuY2FuY2VsYWJsZSYmdC5wcmV2ZW50RGVmYXVsdCgpLFtdLm1hcC5jYWxsKG8sZnVuY3Rpb24odCl7cmV0dXJuIGUubm9ybWFsaXplKHQpfSksXCJ0b3VjaHN0YXJ0XCI9PT10LnR5cGU/KFtdLmZvckVhY2guY2FsbChvLGZ1bmN0aW9uKHQsZSl7c1tlXT17Y2hhcnRYOnQuY2hhcnRYLGNoYXJ0WTp0LmNoYXJ0WX19KSxuLng9W3NbMF0uY2hhcnRYLHNbMV0mJnNbMV0uY2hhcnRYXSxuLnk9W3NbMF0uY2hhcnRZLHNbMV0mJnNbMV0uY2hhcnRZXSxpLmF4ZXMuZm9yRWFjaChmdW5jdGlvbih0KXtpZih0Lnpvb21FbmFibGVkKXtsZXQgZT1pLmJvdW5kc1t0Lmhvcml6P1wiaFwiOlwidlwiXSxzPXQubWluUGl4ZWxQYWRkaW5nLG89dC50b1BpeGVscyhNYXRoLm1pbihiKHQub3B0aW9ucy5taW4sdC5kYXRhTWluKSx0LmRhdGFNaW4pKSxyPXQudG9QaXhlbHMoTWF0aC5tYXgoYih0Lm9wdGlvbnMubWF4LHQuZGF0YU1heCksdC5kYXRhTWF4KSksbj1NYXRoLm1pbihvLHIpLGE9TWF0aC5tYXgobyxyKTtlLm1pbj1NYXRoLm1pbih0LnBvcyxuLXMpLGUubWF4PU1hdGgubWF4KHQucG9zK3QubGVuLGErcyl9fSksZS5yZXM9ITApOmY/dGhpcy5ydW5Qb2ludEFjdGlvbnMoZS5ub3JtYWxpemUodCkpOnMubGVuZ3RoJiYoZyhpLFwidG91Y2hwYW5cIix7b3JpZ2luYWxFdmVudDp0fSwoKT0+e218fChlLnNlbGVjdGlvbk1hcmtlcj1tPXAoe2Rlc3Ryb3k6YSx0b3VjaDohMH0saS5wbG90Qm94KSksZS5waW5jaFRyYW5zbGF0ZShzLG8sbCxtLGMsbiksZS5oYXNQaW5jaGVkPWgsZS5zY2FsZUdyb3VwcyhsLGMpfSksZS5yZXMmJihlLnJlcz0hMSx0aGlzLnJlc2V0KCExLDApKSl9cGluY2hUcmFuc2xhdGUodCxlLGkscyxvLHIpe3RoaXMuem9vbUhvciYmdGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbighMCx0LGUsaSxzLG8sciksdGhpcy56b29tVmVydCYmdGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbighMSx0LGUsaSxzLG8scil9cGluY2hUcmFuc2xhdGVEaXJlY3Rpb24odCxlLGkscyxvLHIsbixhKXtsZXQgaD10aGlzLmNoYXJ0LGw9dD9cInhcIjpcInlcIixkPXQ/XCJYXCI6XCJZXCIsYz1cImNoYXJ0XCIrZCxwPXQ/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsdT1oW1wicGxvdFwiKyh0P1wiTGVmdFwiOlwiVG9wXCIpXSxnPWguaW52ZXJ0ZWQsZj1oLmJvdW5kc1t0P1wiaFwiOlwidlwiXSxtPTE9PT1lLmxlbmd0aCx4PWVbMF1bY10seT0hbSYmZVsxXVtjXSxiPWZ1bmN0aW9uKCl7XCJudW1iZXJcIj09dHlwZW9mIHcmJk1hdGguYWJzKHgteSk+MjAmJihNPWF8fE1hdGguYWJzKEMtdykvTWF0aC5hYnMoeC15KSksaz0odS1DKS9NK3gsdj1oW1wicGxvdFwiKyh0P1wiV2lkdGhcIjpcIkhlaWdodFwiKV0vTX0sdixTLGssTT1hfHwxLEM9aVswXVtjXSx3PSFtJiZpWzFdW2NdLFQ7YigpLChTPWspPGYubWluPyhTPWYubWluLFQ9ITApOlMrdj5mLm1heCYmKFM9Zi5tYXgtdixUPSEwKSxUPyhDLT0uOCooQy1uW2xdWzBdKSxcIm51bWJlclwiPT10eXBlb2YgdyYmKHctPS44Kih3LW5bbF1bMV0pKSxiKCkpOm5bbF09W0Msd10sZ3x8KHJbbF09ay11LHJbcF09dik7bGV0IEE9Zz90P1wic2NhbGVZXCI6XCJzY2FsZVhcIjpcInNjYWxlXCIrZCxQPWc/MS9NOk07b1twXT12LG9bbF09UyxzW0FdPU0qKGcmJiF0Py0xOjEpLHNbXCJ0cmFuc2xhdGVcIitkXT1QKnUrKEMtUCp4KX1yZXNldCh0LGUpe2xldCBpPXRoaXMuY2hhcnQscz1pLmhvdmVyU2VyaWVzLG89aS5ob3ZlclBvaW50LHI9aS5ob3ZlclBvaW50cyxuPWkudG9vbHRpcCxhPW4mJm4uc2hhcmVkP3I6bzt0JiZhJiZTKGEpLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5zZXJpZXMuaXNDYXJ0ZXNpYW4mJnZvaWQgMD09PWUucGxvdFgmJih0PSExKX0pLHQ/biYmYSYmUyhhKS5sZW5ndGgmJihuLnJlZnJlc2goYSksbi5zaGFyZWQmJnI/ci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Quc2V0U3RhdGUodC5zdGF0ZSwhMCksdC5zZXJpZXMuaXNDYXJ0ZXNpYW4mJih0LnNlcmllcy54QXhpcy5jcm9zc2hhaXImJnQuc2VyaWVzLnhBeGlzLmRyYXdDcm9zc2hhaXIobnVsbCx0KSx0LnNlcmllcy55QXhpcy5jcm9zc2hhaXImJnQuc2VyaWVzLnlBeGlzLmRyYXdDcm9zc2hhaXIobnVsbCx0KSl9KTpvJiYoby5zZXRTdGF0ZShvLnN0YXRlLCEwKSxpLmF4ZXMuZm9yRWFjaChmdW5jdGlvbih0KXt0LmNyb3NzaGFpciYmby5zZXJpZXNbdC5jb2xsXT09PXQmJnQuZHJhd0Nyb3NzaGFpcihudWxsLG8pfSkpKToobyYmby5vbk1vdXNlT3V0KCksciYmci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Quc2V0U3RhdGUoKX0pLHMmJnMub25Nb3VzZU91dCgpLG4mJm4uaGlkZShlKSx0aGlzLnVuRG9jTW91c2VNb3ZlJiYodGhpcy51bkRvY01vdXNlTW92ZT10aGlzLnVuRG9jTW91c2VNb3ZlKCkpLGkuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuaGlkZUNyb3NzaGFpcigpfSksdGhpcy5ob3Zlclg9aS5ob3ZlclBvaW50cz1pLmhvdmVyUG9pbnQ9bnVsbCl9cnVuUG9pbnRBY3Rpb25zKHQsZSxpKXtsZXQgcz10aGlzLmNoYXJ0LG89cy5zZXJpZXMsbj1zLnRvb2x0aXAmJnMudG9vbHRpcC5vcHRpb25zLmVuYWJsZWQ/cy50b29sdGlwOnZvaWQgMCxhPSEhbiYmbi5zaGFyZWQsbD1lfHxzLmhvdmVyUG9pbnQsZD1sJiZsLnNlcmllc3x8cy5ob3ZlclNlcmllcyxjPSghdHx8XCJ0b3VjaG1vdmVcIiE9PXQudHlwZSkmJighIWV8fGQmJmQuZGlyZWN0VG91Y2gmJnRoaXMuaXNEaXJlY3RUb3VjaCkscD10aGlzLmdldEhvdmVyRGF0YShsLGQsbyxjLGEsdCk7bD1wLmhvdmVyUG9pbnQsZD1wLmhvdmVyU2VyaWVzO2xldCBnPXAuaG92ZXJQb2ludHMsZj1kJiZkLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXImJiFkLnRvb2x0aXBPcHRpb25zLnNwbGl0LG09YSYmZCYmIWQubm9TaGFyZWRUb29sdGlwO2lmKGwmJihpfHxsIT09cy5ob3ZlclBvaW50fHxuJiZuLmlzSGlkZGVuKSl7aWYoKHMuaG92ZXJQb2ludHN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpey0xPT09Zy5pbmRleE9mKHQpJiZ0LnNldFN0YXRlKCl9KSxzLmhvdmVyU2VyaWVzIT09ZCYmZC5vbk1vdXNlT3ZlcigpLHRoaXMuYXBwbHlJbmFjdGl2ZVN0YXRlKGcpLChnfHxbXSkuZm9yRWFjaChmdW5jdGlvbih0KXt0LnNldFN0YXRlKFwiaG92ZXJcIil9KSxzLmhvdmVyUG9pbnQmJnMuaG92ZXJQb2ludC5maXJlUG9pbnRFdmVudChcIm1vdXNlT3V0XCIpLCFsLnNlcmllcylyZXR1cm47cy5ob3ZlclBvaW50cz1nLHMuaG92ZXJQb2ludD1sLGwuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU92ZXJcIix2b2lkIDAsKCk9PntuJiZsJiZuLnJlZnJlc2gobT9nOmwsdCl9KX1lbHNlIGlmKGYmJm4mJiFuLmlzSGlkZGVuKXtsZXQgZT1uLmdldEFuY2hvcihbe31dLHQpO3MuaXNJbnNpZGVQbG90KGVbMF0sZVsxXSx7dmlzaWJsZVBsb3RPbmx5OiEwfSkmJm4udXBkYXRlUG9zaXRpb24oe3Bsb3RYOmVbMF0scGxvdFk6ZVsxXX0pfXRoaXMudW5Eb2NNb3VzZU1vdmV8fCh0aGlzLnVuRG9jTW91c2VNb3ZlPWgocy5jb250YWluZXIub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKHQpe2xldCBlPXJbay5ob3ZlckNoYXJ0SW5kZXhdO2UmJmUucG9pbnRlci5vbkRvY3VtZW50TW91c2VNb3ZlKHQpfSksdGhpcy5ldmVudHNUb1VuYmluZC5wdXNoKHRoaXMudW5Eb2NNb3VzZU1vdmUpKSxzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihlKXtsZXQgaTtsZXQgbz1iKChlLmNyb3NzaGFpcnx8e30pLnNuYXAsITApOyFvfHwoaT1zLmhvdmVyUG9pbnQpJiZpLnNlcmllc1tlLmNvbGxdPT09ZXx8KGk9dShnLHQ9PnQuc2VyaWVzJiZ0LnNlcmllc1tlLmNvbGxdPT09ZSkpLGl8fCFvP2UuZHJhd0Nyb3NzaGFpcih0LGkpOmUuaGlkZUNyb3NzaGFpcigpfSl9c2NhbGVHcm91cHModCxlKXtsZXQgaT10aGlzLmNoYXJ0O2kuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24ocyl7bGV0IG89dHx8cy5nZXRQbG90Qm94KFwic2VyaWVzXCIpO3MuZ3JvdXAmJihzLnhBeGlzJiZzLnhBeGlzLnpvb21FbmFibGVkfHxpLm1hcFZpZXcpJiYocy5ncm91cC5hdHRyKG8pLHMubWFya2VyR3JvdXAmJihzLm1hcmtlckdyb3VwLmF0dHIodHx8cy5nZXRQbG90Qm94KFwibWFya2VyXCIpKSxzLm1hcmtlckdyb3VwLmNsaXAoZT9pLmNsaXBSZWN0Om51bGwpKSxzLmRhdGFMYWJlbHNHcm91cCYmcy5kYXRhTGFiZWxzR3JvdXAuYXR0cihvKSl9KSxpLmNsaXBSZWN0LmF0dHIoZXx8aS5jbGlwQm94KX1zZXRET01FdmVudHMoKXtsZXQgdD10aGlzLmNoYXJ0LmNvbnRhaW5lcixpPXQub3duZXJEb2N1bWVudDt0Lm9ubW91c2Vkb3duPXRoaXMub25Db250YWluZXJNb3VzZURvd24uYmluZCh0aGlzKSx0Lm9ubW91c2Vtb3ZlPXRoaXMub25Db250YWluZXJNb3VzZU1vdmUuYmluZCh0aGlzKSx0Lm9uY2xpY2s9dGhpcy5vbkNvbnRhaW5lckNsaWNrLmJpbmQodGhpcyksdGhpcy5ldmVudHNUb1VuYmluZC5wdXNoKGgodCxcIm1vdXNlZW50ZXJcIix0aGlzLm9uQ29udGFpbmVyTW91c2VFbnRlci5iaW5kKHRoaXMpKSksdGhpcy5ldmVudHNUb1VuYmluZC5wdXNoKGgodCxcIm1vdXNlbGVhdmVcIix0aGlzLm9uQ29udGFpbmVyTW91c2VMZWF2ZS5iaW5kKHRoaXMpKSksay51bmJpbmREb2N1bWVudE1vdXNlVXB8fChrLnVuYmluZERvY3VtZW50TW91c2VVcD1oKGksXCJtb3VzZXVwXCIsdGhpcy5vbkRvY3VtZW50TW91c2VVcC5iaW5kKHRoaXMpKSk7bGV0IHM9dGhpcy5jaGFydC5yZW5kZXJUby5wYXJlbnRFbGVtZW50O2Zvcig7cyYmXCJCT0RZXCIhPT1zLnRhZ05hbWU7KXRoaXMuZXZlbnRzVG9VbmJpbmQucHVzaChoKHMsXCJzY3JvbGxcIiwoKT0+e2RlbGV0ZSB0aGlzLmNoYXJ0UG9zaXRpb259KSkscz1zLnBhcmVudEVsZW1lbnQ7ZS5oYXNUb3VjaCYmKHRoaXMuZXZlbnRzVG9VbmJpbmQucHVzaChoKHQsXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vbkNvbnRhaW5lclRvdWNoU3RhcnQuYmluZCh0aGlzKSx7cGFzc2l2ZTohMX0pKSx0aGlzLmV2ZW50c1RvVW5iaW5kLnB1c2goaCh0LFwidG91Y2htb3ZlXCIsdGhpcy5vbkNvbnRhaW5lclRvdWNoTW92ZS5iaW5kKHRoaXMpLHtwYXNzaXZlOiExfSkpLGsudW5iaW5kRG9jdW1lbnRUb3VjaEVuZHx8KGsudW5iaW5kRG9jdW1lbnRUb3VjaEVuZD1oKGksXCJ0b3VjaGVuZFwiLHRoaXMub25Eb2N1bWVudFRvdWNoRW5kLmJpbmQodGhpcykse3Bhc3NpdmU6ITF9KSkpfXNldEhvdmVyQ2hhcnRJbmRleCh0KXtsZXQgaT10aGlzLmNoYXJ0LHM9ZS5jaGFydHNbYihrLmhvdmVyQ2hhcnRJbmRleCwtMSldO3MmJnMhPT1pJiZzLnBvaW50ZXIub25Db250YWluZXJNb3VzZUxlYXZlKHR8fHtyZWxhdGVkVGFyZ2V0OmkuY29udGFpbmVyfSkscyYmcy5tb3VzZUlzRG93bnx8KGsuaG92ZXJDaGFydEluZGV4PWkuaW5kZXgpfXRvdWNoKHQsZSl7bGV0IGkscztsZXQgbz10aGlzLmNoYXJ0O3RoaXMuc2V0SG92ZXJDaGFydEluZGV4KCksMT09PXQudG91Y2hlcy5sZW5ndGg/KHQ9dGhpcy5ub3JtYWxpemUodCksby5pc0luc2lkZVBsb3QodC5jaGFydFgtby5wbG90TGVmdCx0LmNoYXJ0WS1vLnBsb3RUb3Ase3Zpc2libGVQbG90T25seTohMH0pJiYhby5vcGVuTWVudT8oZSYmdGhpcy5ydW5Qb2ludEFjdGlvbnModCksXCJ0b3VjaG1vdmVcIj09PXQudHlwZSYmKGk9ISEocz10aGlzLnBpbmNoRG93bilbMF0mJk1hdGguc3FydChNYXRoLnBvdyhzWzBdLmNoYXJ0WC10LmNoYXJ0WCwyKStNYXRoLnBvdyhzWzBdLmNoYXJ0WS10LmNoYXJ0WSwyKSk+PTQpLGIoaSwhMCkmJnRoaXMucGluY2godCkpOmUmJnRoaXMucmVzZXQoKSk6Mj09PXQudG91Y2hlcy5sZW5ndGgmJnRoaXMucGluY2godCl9dG91Y2hTZWxlY3QodCl7cmV0dXJuISEodGhpcy5jaGFydC56b29taW5nLnNpbmdsZVRvdWNoJiZ0LnRvdWNoZXMmJjE9PT10LnRvdWNoZXMubGVuZ3RoKX16b29tT3B0aW9uKHQpe2xldCBlPXRoaXMuY2hhcnQsaT0oZS5vcHRpb25zLmNoYXJ0LGUuaW52ZXJ0ZWQpLHM9ZS56b29taW5nLnR5cGV8fFwiXCIsbyxyOy90b3VjaC8udGVzdCh0LnR5cGUpJiYocz1iKGUuem9vbWluZy5waW5jaFR5cGUscykpLHRoaXMuem9vbVg9bz0veC8udGVzdChzKSx0aGlzLnpvb21ZPXI9L3kvLnRlc3QocyksdGhpcy56b29tSG9yPW8mJiFpfHxyJiZpLHRoaXMuem9vbVZlcnQ9ciYmIWl8fG8mJmksdGhpcy5oYXNab29tPW98fHJ9fXJldHVybihzPWt8fChrPXt9KSkuY29tcG9zZT1mdW5jdGlvbiB0KGUpe3Yobix0KSYmaChlLFwiYmVmb3JlUmVuZGVyXCIsZnVuY3Rpb24oKXt0aGlzLnBvaW50ZXI9bmV3IHModGhpcyx0aGlzLm9wdGlvbnMpfSl9LGt9KSxpKGUsXCJDb3JlL0xlZ2VuZC9MZWdlbmQuanNcIixbZVtcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9UZW1wbGF0aW5nLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1BvaW50LmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1JlbmRlcmVyVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyxvLHIpe3ZhciBuO2xldHthbmltT2JqZWN0OmEsc2V0QW5pbWF0aW9uOmh9PXQse2Zvcm1hdDpsfT1lLHtjb21wb3NlZDpkLG1hcmdpbk5hbWVzOmN9PWkse2Rpc3RyaWJ1dGU6cH09byx7YWRkRXZlbnQ6dSxjcmVhdGVFbGVtZW50OmcsY3NzOmYsZGVmaW5lZDptLGRpc2NhcmRFbGVtZW50OngsZmluZDp5LGZpcmVFdmVudDpiLGlzTnVtYmVyOnYsbWVyZ2U6UyxwaWNrOmsscHVzaFVuaXF1ZTpNLHJlbGF0aXZlTGVuZ3RoOkMsc3RhYmxlU29ydDp3LHN5bmNUaW1lb3V0OlR9PXI7Y2xhc3MgQXtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYWxsSXRlbXM9W10sdGhpcy5pbml0aWFsSXRlbVk9MCx0aGlzLml0ZW1IZWlnaHQ9MCx0aGlzLml0ZW1NYXJnaW5Cb3R0b209MCx0aGlzLml0ZW1NYXJnaW5Ub3A9MCx0aGlzLml0ZW1YPTAsdGhpcy5pdGVtWT0wLHRoaXMubGFzdEl0ZW1ZPTAsdGhpcy5sYXN0TGluZUhlaWdodD0wLHRoaXMubGVnZW5kSGVpZ2h0PTAsdGhpcy5sZWdlbmRXaWR0aD0wLHRoaXMubWF4SXRlbVdpZHRoPTAsdGhpcy5tYXhMZWdlbmRXaWR0aD0wLHRoaXMub2Zmc2V0V2lkdGg9MCx0aGlzLnBhZGRpbmc9MCx0aGlzLnBhZ2VzPVtdLHRoaXMuc3ltYm9sSGVpZ2h0PTAsdGhpcy5zeW1ib2xXaWR0aD0wLHRoaXMudGl0bGVIZWlnaHQ9MCx0aGlzLnRvdGFsSXRlbVdpZHRoPTAsdGhpcy53aWR0aE9wdGlvbj0wLHRoaXMuY2hhcnQ9dCx0aGlzLnNldE9wdGlvbnMoZSksZS5lbmFibGVkJiYodGhpcy5yZW5kZXIoKSx1KHRoaXMuY2hhcnQsXCJlbmRSZXNpemVcIixmdW5jdGlvbigpe3RoaXMubGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpfSkpLHUodGhpcy5jaGFydCxcInJlbmRlclwiLCgpPT57dGhpcy5vcHRpb25zLmVuYWJsZWQmJnRoaXMucHJveGltYXRlJiYodGhpcy5wcm94aW1hdGVQb3NpdGlvbnMoKSx0aGlzLnBvc2l0aW9uSXRlbXMoKSl9KX1zZXRPcHRpb25zKHQpe2xldCBlPWsodC5wYWRkaW5nLDgpO3RoaXMub3B0aW9ucz10LHRoaXMuY2hhcnQuc3R5bGVkTW9kZXx8KHRoaXMuaXRlbVN0eWxlPXQuaXRlbVN0eWxlLHRoaXMuaXRlbUhpZGRlblN0eWxlPVModGhpcy5pdGVtU3R5bGUsdC5pdGVtSGlkZGVuU3R5bGUpKSx0aGlzLml0ZW1NYXJnaW5Ub3A9dC5pdGVtTWFyZ2luVG9wLHRoaXMuaXRlbU1hcmdpbkJvdHRvbT10Lml0ZW1NYXJnaW5Cb3R0b20sdGhpcy5wYWRkaW5nPWUsdGhpcy5pbml0aWFsSXRlbVk9ZS01LHRoaXMuc3ltYm9sV2lkdGg9ayh0LnN5bWJvbFdpZHRoLDE2KSx0aGlzLnBhZ2VzPVtdLHRoaXMucHJveGltYXRlPVwicHJveGltYXRlXCI9PT10LmxheW91dCYmIXRoaXMuY2hhcnQuaW52ZXJ0ZWQsdGhpcy5iYXNlbGluZT12b2lkIDB9dXBkYXRlKHQsZSl7bGV0IGk9dGhpcy5jaGFydDt0aGlzLnNldE9wdGlvbnMoUyghMCx0aGlzLm9wdGlvbnMsdCkpLHRoaXMuZGVzdHJveSgpLGkuaXNEaXJ0eUxlZ2VuZD1pLmlzRGlydHlCb3g9ITAsayhlLCEwKSYmaS5yZWRyYXcoKSxiKHRoaXMsXCJhZnRlclVwZGF0ZVwiLHtyZWRyYXc6ZX0pfWNvbG9yaXplSXRlbSh0LGUpe2xldHthcmVhOmksZ3JvdXA6cyxsYWJlbDpvLGxpbmU6cixzeW1ib2w6bn09dC5sZWdlbmRJdGVtfHx7fTtpZihzPy5bZT9cInJlbW92ZUNsYXNzXCI6XCJhZGRDbGFzc1wiXShcImhpZ2hjaGFydHMtbGVnZW5kLWl0ZW0taGlkZGVuXCIpLCF0aGlzLmNoYXJ0LnN0eWxlZE1vZGUpe2xldHtpdGVtSGlkZGVuU3R5bGU6cz17fX09dGhpcyxhPXMuY29sb3Ise2ZpbGxDb2xvcjpoLGZpbGxPcGFjaXR5OmwsbGluZUNvbG9yOmQsbWFya2VyOmN9PXQub3B0aW9ucyxwPXQ9PighZSYmKHQuZmlsbCYmKHQuZmlsbD1hKSx0LnN0cm9rZSYmKHQuc3Ryb2tlPWEpKSx0KTtvPy5jc3MoUyhlP3RoaXMuaXRlbVN0eWxlOnMpKSxyPy5hdHRyKHAoe3N0cm9rZTpkfHx0LmNvbG9yfSkpLG4mJm4uYXR0cihwKGMmJm4uaXNNYXJrZXI/dC5wb2ludEF0dHJpYnMoKTp7ZmlsbDp0LmNvbG9yfSkpLGk/LmF0dHIocCh7ZmlsbDpofHx0LmNvbG9yLFwiZmlsbC1vcGFjaXR5XCI6aD8xOmw/Py43NX0pKX1iKHRoaXMsXCJhZnRlckNvbG9yaXplSXRlbVwiLHtpdGVtOnQsdmlzaWJsZTplfSl9cG9zaXRpb25JdGVtcygpe3RoaXMuYWxsSXRlbXMuZm9yRWFjaCh0aGlzLnBvc2l0aW9uSXRlbSx0aGlzKSx0aGlzLmNoYXJ0LmlzUmVzaXppbmd8fHRoaXMucG9zaXRpb25DaGVja2JveGVzKCl9cG9zaXRpb25JdGVtKHQpe2xldHtncm91cDplLHg6aT0wLHk6cz0wfT10LmxlZ2VuZEl0ZW18fHt9LG89dGhpcy5vcHRpb25zLHI9by5zeW1ib2xQYWRkaW5nLG49IW8ucnRsLGE9dC5jaGVja2JveDtpZihlJiZlLmVsZW1lbnQpe2xldCBvPXt0cmFuc2xhdGVYOm4/aTp0aGlzLmxlZ2VuZFdpZHRoLWktMipyLTQsdHJhbnNsYXRlWTpzfTtlW20oZS50cmFuc2xhdGVZKT9cImFuaW1hdGVcIjpcImF0dHJcIl0obyx2b2lkIDAsKCk9PntiKHRoaXMsXCJhZnRlclBvc2l0aW9uSXRlbVwiLHtpdGVtOnR9KX0pfWEmJihhLng9aSxhLnk9cyl9ZGVzdHJveUl0ZW0odCl7bGV0IGU9dC5jaGVja2JveCxpPXQubGVnZW5kSXRlbXx8e307Zm9yKGxldCB0IG9mW1wiZ3JvdXBcIixcImxhYmVsXCIsXCJsaW5lXCIsXCJzeW1ib2xcIl0paVt0XSYmKGlbdF09aVt0XS5kZXN0cm95KCkpO2UmJngoZSksdC5sZWdlbmRJdGVtPXZvaWQgMH1kZXN0cm95KCl7Zm9yKGxldCB0IG9mIHRoaXMuZ2V0QWxsSXRlbXMoKSl0aGlzLmRlc3Ryb3lJdGVtKHQpO2ZvcihsZXQgdCBvZltcImNsaXBSZWN0XCIsXCJ1cFwiLFwiZG93blwiLFwicGFnZXJcIixcIm5hdlwiLFwiYm94XCIsXCJ0aXRsZVwiLFwiZ3JvdXBcIl0pdGhpc1t0XSYmKHRoaXNbdF09dGhpc1t0XS5kZXN0cm95KCkpO3RoaXMuZGlzcGxheT1udWxsfXBvc2l0aW9uQ2hlY2tib3hlcygpe2xldCB0O2xldCBlPXRoaXMuZ3JvdXAmJnRoaXMuZ3JvdXAuYWxpZ25BdHRyLGk9dGhpcy5jbGlwSGVpZ2h0fHx0aGlzLmxlZ2VuZEhlaWdodCxzPXRoaXMudGl0bGVIZWlnaHQ7ZSYmKHQ9ZS50cmFuc2xhdGVZLHRoaXMuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbihvKXtsZXQgcjtsZXQgbj1vLmNoZWNrYm94O24mJihyPXQrcytuLnkrKHRoaXMuc2Nyb2xsT2Zmc2V0fHwwKSszLGYobix7bGVmdDplLnRyYW5zbGF0ZVgrby5jaGVja2JveE9mZnNldCtuLngtMjArXCJweFwiLHRvcDpyK1wicHhcIixkaXNwbGF5OnRoaXMucHJveGltYXRlfHxyPnQtNiYmcjx0K2ktNj9cIlwiOlwibm9uZVwifSkpfSx0aGlzKSl9cmVuZGVyVGl0bGUoKXtsZXQgdD10aGlzLm9wdGlvbnMsZT10aGlzLnBhZGRpbmcsaT10LnRpdGxlLHMsbz0wO2kudGV4dCYmKHRoaXMudGl0bGV8fCh0aGlzLnRpdGxlPXRoaXMuY2hhcnQucmVuZGVyZXIubGFiZWwoaS50ZXh0LGUtMyxlLTQsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdC51c2VIVE1MLHZvaWQgMCxcImxlZ2VuZC10aXRsZVwiKS5hdHRyKHt6SW5kZXg6MX0pLHRoaXMuY2hhcnQuc3R5bGVkTW9kZXx8dGhpcy50aXRsZS5jc3MoaS5zdHlsZSksdGhpcy50aXRsZS5hZGQodGhpcy5ncm91cCkpLGkud2lkdGh8fHRoaXMudGl0bGUuY3NzKHt3aWR0aDp0aGlzLm1heExlZ2VuZFdpZHRoK1wicHhcIn0pLG89KHM9dGhpcy50aXRsZS5nZXRCQm94KCkpLmhlaWdodCx0aGlzLm9mZnNldFdpZHRoPXMud2lkdGgsdGhpcy5jb250ZW50R3JvdXAuYXR0cih7dHJhbnNsYXRlWTpvfSkpLHRoaXMudGl0bGVIZWlnaHQ9b31zZXRUZXh0KHQpe2xldCBlPXRoaXMub3B0aW9uczt0LmxlZ2VuZEl0ZW0ubGFiZWwuYXR0cih7dGV4dDplLmxhYmVsRm9ybWF0P2woZS5sYWJlbEZvcm1hdCx0LHRoaXMuY2hhcnQpOmUubGFiZWxGb3JtYXR0ZXIuY2FsbCh0KX0pfXJlbmRlckl0ZW0odCl7bGV0IGU9dC5sZWdlbmRJdGVtPXQubGVnZW5kSXRlbXx8e30saT10aGlzLmNoYXJ0LHM9aS5yZW5kZXJlcixvPXRoaXMub3B0aW9ucyxyPVwiaG9yaXpvbnRhbFwiPT09by5sYXlvdXQsbj10aGlzLnN5bWJvbFdpZHRoLGE9by5zeW1ib2xQYWRkaW5nfHwwLGg9dGhpcy5pdGVtU3R5bGUsbD10aGlzLml0ZW1IaWRkZW5TdHlsZSxkPXI/ayhvLml0ZW1EaXN0YW5jZSwyMCk6MCxjPSFvLnJ0bCxwPSF0LnNlcmllcyx1PSFwJiZ0LnNlcmllcy5kcmF3TGVnZW5kU3ltYm9sP3Quc2VyaWVzOnQsZz11Lm9wdGlvbnMsZj0hIXRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtJiZnJiZnLnNob3dDaGVja2JveCxtPW8udXNlSFRNTCx4PXQub3B0aW9ucy5jbGFzc05hbWUseT1lLmxhYmVsLGI9bithK2QrKGY/MjA6MCk7IXkmJihlLmdyb3VwPXMuZyhcImxlZ2VuZC1pdGVtXCIpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIit1LnR5cGUrXCItc2VyaWVzIGhpZ2hjaGFydHMtY29sb3ItXCIrdC5jb2xvckluZGV4Kyh4P1wiIFwiK3g6XCJcIikrKHA/XCIgaGlnaGNoYXJ0cy1zZXJpZXMtXCIrdC5pbmRleDpcIlwiKSkuYXR0cih7ekluZGV4OjF9KS5hZGQodGhpcy5zY3JvbGxHcm91cCksZS5sYWJlbD15PXMudGV4dChcIlwiLGM/bithOi1hLHRoaXMuYmFzZWxpbmV8fDAsbSksaS5zdHlsZWRNb2RlfHx5LmNzcyhTKHQudmlzaWJsZT9oOmwpKSx5LmF0dHIoe2FsaWduOmM/XCJsZWZ0XCI6XCJyaWdodFwiLHpJbmRleDoyfSkuYWRkKGUuZ3JvdXApLCF0aGlzLmJhc2VsaW5lJiYodGhpcy5mb250TWV0cmljcz1zLmZvbnRNZXRyaWNzKHkpLHRoaXMuYmFzZWxpbmU9dGhpcy5mb250TWV0cmljcy5mKzMrdGhpcy5pdGVtTWFyZ2luVG9wLHkuYXR0cihcInlcIix0aGlzLmJhc2VsaW5lKSx0aGlzLnN5bWJvbEhlaWdodD1rKG8uc3ltYm9sSGVpZ2h0LHRoaXMuZm9udE1ldHJpY3MuZiksby5zcXVhcmVTeW1ib2wmJih0aGlzLnN5bWJvbFdpZHRoPWsoby5zeW1ib2xXaWR0aCxNYXRoLm1heCh0aGlzLnN5bWJvbEhlaWdodCwxNikpLGI9dGhpcy5zeW1ib2xXaWR0aCthK2QrKGY/MjA6MCksYyYmeS5hdHRyKFwieFwiLHRoaXMuc3ltYm9sV2lkdGgrYSkpKSx1LmRyYXdMZWdlbmRTeW1ib2wodGhpcyx0KSx0aGlzLnNldEl0ZW1FdmVudHMmJnRoaXMuc2V0SXRlbUV2ZW50cyh0LHksbSkpLGYmJiF0LmNoZWNrYm94JiZ0aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSYmdGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0odCksdGhpcy5jb2xvcml6ZUl0ZW0odCx0LnZpc2libGUpLChpLnN0eWxlZE1vZGV8fCFoLndpZHRoKSYmeS5jc3Moe3dpZHRoOihvLml0ZW1XaWR0aHx8dGhpcy53aWR0aE9wdGlvbnx8aS5zcGFjaW5nQm94LndpZHRoKS1iK1wicHhcIn0pLHRoaXMuc2V0VGV4dCh0KTtsZXQgdj15LmdldEJCb3goKSxNPXRoaXMuZm9udE1ldHJpY3MmJnRoaXMuZm9udE1ldHJpY3MuaHx8MDt0Lml0ZW1XaWR0aD10LmNoZWNrYm94T2Zmc2V0PW8uaXRlbVdpZHRofHxlLmxhYmVsV2lkdGh8fHYud2lkdGgrYix0aGlzLm1heEl0ZW1XaWR0aD1NYXRoLm1heCh0aGlzLm1heEl0ZW1XaWR0aCx0Lml0ZW1XaWR0aCksdGhpcy50b3RhbEl0ZW1XaWR0aCs9dC5pdGVtV2lkdGgsdGhpcy5pdGVtSGVpZ2h0PXQuaXRlbUhlaWdodD1NYXRoLnJvdW5kKGUubGFiZWxIZWlnaHR8fCh2LmhlaWdodD4xLjUqTT92LmhlaWdodDpNKSl9bGF5b3V0SXRlbSh0KXtsZXQgZT10aGlzLm9wdGlvbnMsaT10aGlzLnBhZGRpbmcscz1cImhvcml6b250YWxcIj09PWUubGF5b3V0LG89dC5pdGVtSGVpZ2h0LHI9dGhpcy5pdGVtTWFyZ2luQm90dG9tLG49dGhpcy5pdGVtTWFyZ2luVG9wLGE9cz9rKGUuaXRlbURpc3RhbmNlLDIwKTowLGg9dGhpcy5tYXhMZWdlbmRXaWR0aCxsPWUuYWxpZ25Db2x1bW5zJiZ0aGlzLnRvdGFsSXRlbVdpZHRoPmg/dGhpcy5tYXhJdGVtV2lkdGg6dC5pdGVtV2lkdGgsZD10LmxlZ2VuZEl0ZW18fHt9O3MmJnRoaXMuaXRlbVgtaStsPmgmJih0aGlzLml0ZW1YPWksdGhpcy5sYXN0TGluZUhlaWdodCYmKHRoaXMuaXRlbVkrPW4rdGhpcy5sYXN0TGluZUhlaWdodCtyKSx0aGlzLmxhc3RMaW5lSGVpZ2h0PTApLHRoaXMubGFzdEl0ZW1ZPW4rdGhpcy5pdGVtWStyLHRoaXMubGFzdExpbmVIZWlnaHQ9TWF0aC5tYXgobyx0aGlzLmxhc3RMaW5lSGVpZ2h0KSxkLng9dGhpcy5pdGVtWCxkLnk9dGhpcy5pdGVtWSxzP3RoaXMuaXRlbVgrPWw6KHRoaXMuaXRlbVkrPW4rbytyLHRoaXMubGFzdExpbmVIZWlnaHQ9byksdGhpcy5vZmZzZXRXaWR0aD10aGlzLndpZHRoT3B0aW9ufHxNYXRoLm1heCgocz90aGlzLml0ZW1YLWktKHQuY2hlY2tib3g/MDphKTpsKStpLHRoaXMub2Zmc2V0V2lkdGgpfWdldEFsbEl0ZW1zKCl7bGV0IHQ9W107cmV0dXJuIHRoaXMuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oZSl7bGV0IGk9ZSYmZS5vcHRpb25zO2UmJmsoaS5zaG93SW5MZWdlbmQsIW0oaS5saW5rZWRUbykmJnZvaWQgMCwhMCkmJih0PXQuY29uY2F0KChlLmxlZ2VuZEl0ZW18fHt9KS5sYWJlbHN8fChcInBvaW50XCI9PT1pLmxlZ2VuZFR5cGU/ZS5kYXRhOmUpKSl9KSxiKHRoaXMsXCJhZnRlckdldEFsbEl0ZW1zXCIse2FsbEl0ZW1zOnR9KSx0fWdldEFsaWdubWVudCgpe2xldCB0PXRoaXMub3B0aW9ucztyZXR1cm4gdGhpcy5wcm94aW1hdGU/dC5hbGlnbi5jaGFyQXQoMCkrXCJ0dlwiOnQuZmxvYXRpbmc/XCJcIjp0LmFsaWduLmNoYXJBdCgwKSt0LnZlcnRpY2FsQWxpZ24uY2hhckF0KDApK3QubGF5b3V0LmNoYXJBdCgwKX1hZGp1c3RNYXJnaW5zKHQsZSl7bGV0IGk9dGhpcy5jaGFydCxzPXRoaXMub3B0aW9ucyxvPXRoaXMuZ2V0QWxpZ25tZW50KCk7byYmWy8obHRofGN0fHJ0aCkvLC8ocnR2fHJtfHJidikvLC8ocmJofGNifGxiaCkvLC8obGJ2fGxtfGx0dikvXS5mb3JFYWNoKGZ1bmN0aW9uKHIsbil7ci50ZXN0KG8pJiYhbSh0W25dKSYmKGlbY1tuXV09TWF0aC5tYXgoaVtjW25dXSxpLmxlZ2VuZFsobisxKSUyP1wibGVnZW5kSGVpZ2h0XCI6XCJsZWdlbmRXaWR0aFwiXStbMSwtMSwtMSwxXVtuXSpzW24lMj9cInhcIjpcInlcIl0rayhzLm1hcmdpbiwxMikrZVtuXSsoaS50aXRsZU9mZnNldFtuXXx8MCkpKX0pfXByb3hpbWF0ZVBvc2l0aW9ucygpe2xldCB0O2xldCBlPXRoaXMuY2hhcnQsaT1bXSxzPVwibGVmdFwiPT09dGhpcy5vcHRpb25zLmFsaWduO2ZvcihsZXQgbyBvZih0aGlzLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IG8scixuPXMsYSxoO3QueUF4aXMmJih0LnhBeGlzLm9wdGlvbnMucmV2ZXJzZWQmJihuPSFuKSx0LnBvaW50cyYmKG89eShuP3QucG9pbnRzOnQucG9pbnRzLnNsaWNlKDApLnJldmVyc2UoKSxmdW5jdGlvbih0KXtyZXR1cm4gdih0LnBsb3RZKX0pKSxyPXRoaXMuaXRlbU1hcmdpblRvcCt0LmxlZ2VuZEl0ZW0ubGFiZWwuZ2V0QkJveCgpLmhlaWdodCt0aGlzLml0ZW1NYXJnaW5Cb3R0b20saD10LnlBeGlzLnRvcC1lLnBsb3RUb3AsYT10LnZpc2libGU/KG8/by5wbG90WTp0LnlBeGlzLmhlaWdodCkrKGgtLjMqcik6aCt0LnlBeGlzLmhlaWdodCxpLnB1c2goe3RhcmdldDphLHNpemU6cixpdGVtOnR9KSl9LHRoaXMpLHAoaSxlLnBsb3RIZWlnaHQpKSl0PW8uaXRlbS5sZWdlbmRJdGVtfHx7fSx2KG8ucG9zKSYmKHQueT1lLnBsb3RUb3AtZS5zcGFjaW5nWzBdK28ucG9zKX1yZW5kZXIoKXtsZXQgdD10aGlzLmNoYXJ0LGU9dC5yZW5kZXJlcixpPXRoaXMub3B0aW9ucyxzPXRoaXMucGFkZGluZyxvPXRoaXMuZ2V0QWxsSXRlbXMoKSxyLG4sYSxoPXRoaXMuZ3JvdXAsbCxkPXRoaXMuYm94O3RoaXMuaXRlbVg9cyx0aGlzLml0ZW1ZPXRoaXMuaW5pdGlhbEl0ZW1ZLHRoaXMub2Zmc2V0V2lkdGg9MCx0aGlzLmxhc3RJdGVtWT0wLHRoaXMud2lkdGhPcHRpb249QyhpLndpZHRoLHQuc3BhY2luZ0JveC53aWR0aC1zKSxsPXQuc3BhY2luZ0JveC53aWR0aC0yKnMtaS54LFtcInJtXCIsXCJsbVwiXS5pbmRleE9mKHRoaXMuZ2V0QWxpZ25tZW50KCkuc3Vic3RyaW5nKDAsMikpPi0xJiYobC89MiksdGhpcy5tYXhMZWdlbmRXaWR0aD10aGlzLndpZHRoT3B0aW9ufHxsLGh8fCh0aGlzLmdyb3VwPWg9ZS5nKFwibGVnZW5kXCIpLmFkZENsYXNzKGkuY2xhc3NOYW1lfHxcIlwiKS5hdHRyKHt6SW5kZXg6N30pLmFkZCgpLHRoaXMuY29udGVudEdyb3VwPWUuZygpLmF0dHIoe3pJbmRleDoxfSkuYWRkKGgpLHRoaXMuc2Nyb2xsR3JvdXA9ZS5nKCkuYWRkKHRoaXMuY29udGVudEdyb3VwKSksdGhpcy5yZW5kZXJUaXRsZSgpLHcobywodCxlKT0+KHQub3B0aW9ucyYmdC5vcHRpb25zLmxlZ2VuZEluZGV4fHwwKS0oZS5vcHRpb25zJiZlLm9wdGlvbnMubGVnZW5kSW5kZXh8fDApKSxpLnJldmVyc2VkJiZvLnJldmVyc2UoKSx0aGlzLmFsbEl0ZW1zPW8sdGhpcy5kaXNwbGF5PXI9ISFvLmxlbmd0aCx0aGlzLmxhc3RMaW5lSGVpZ2h0PTAsdGhpcy5tYXhJdGVtV2lkdGg9MCx0aGlzLnRvdGFsSXRlbVdpZHRoPTAsdGhpcy5pdGVtSGVpZ2h0PTAsby5mb3JFYWNoKHRoaXMucmVuZGVySXRlbSx0aGlzKSxvLmZvckVhY2godGhpcy5sYXlvdXRJdGVtLHRoaXMpLG49KHRoaXMud2lkdGhPcHRpb258fHRoaXMub2Zmc2V0V2lkdGgpK3MsYT10aGlzLmxhc3RJdGVtWSt0aGlzLmxhc3RMaW5lSGVpZ2h0K3RoaXMudGl0bGVIZWlnaHQsYT10aGlzLmhhbmRsZU92ZXJmbG93KGEpK3MsZHx8KHRoaXMuYm94PWQ9ZS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWxlZ2VuZC1ib3hcIikuYXR0cih7cjppLmJvcmRlclJhZGl1c30pLmFkZChoKSksdC5zdHlsZWRNb2RlfHxkLmF0dHIoe3N0cm9rZTppLmJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6aS5ib3JkZXJXaWR0aHx8MCxmaWxsOmkuYmFja2dyb3VuZENvbG9yfHxcIm5vbmVcIn0pLnNoYWRvdyhpLnNoYWRvdyksbj4wJiZhPjAmJmRbZC5wbGFjZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCJdKGQuY3Jpc3AuY2FsbCh7fSx7eDowLHk6MCx3aWR0aDpuLGhlaWdodDphfSxkLnN0cm9rZVdpZHRoKCkpKSxoW3I/XCJzaG93XCI6XCJoaWRlXCJdKCksdC5zdHlsZWRNb2RlJiZcIm5vbmVcIj09PWguZ2V0U3R5bGUoXCJkaXNwbGF5XCIpJiYobj1hPTApLHRoaXMubGVnZW5kV2lkdGg9bix0aGlzLmxlZ2VuZEhlaWdodD1hLHImJnRoaXMuYWxpZ24oKSx0aGlzLnByb3hpbWF0ZXx8dGhpcy5wb3NpdGlvbkl0ZW1zKCksYih0aGlzLFwiYWZ0ZXJSZW5kZXJcIil9YWxpZ24odD10aGlzLmNoYXJ0LnNwYWNpbmdCb3gpe2xldCBlPXRoaXMuY2hhcnQsaT10aGlzLm9wdGlvbnMscz10Lnk7LyhsdGh8Y3R8cnRoKS8udGVzdCh0aGlzLmdldEFsaWdubWVudCgpKSYmZS50aXRsZU9mZnNldFswXT4wP3MrPWUudGl0bGVPZmZzZXRbMF06LyhsYmh8Y2J8cmJoKS8udGVzdCh0aGlzLmdldEFsaWdubWVudCgpKSYmZS50aXRsZU9mZnNldFsyXT4wJiYocy09ZS50aXRsZU9mZnNldFsyXSkscyE9PXQueSYmKHQ9Uyh0LHt5OnN9KSksZS5oYXNSZW5kZXJlZHx8KHRoaXMuZ3JvdXAucGxhY2VkPSExKSx0aGlzLmdyb3VwLmFsaWduKFMoaSx7d2lkdGg6dGhpcy5sZWdlbmRXaWR0aCxoZWlnaHQ6dGhpcy5sZWdlbmRIZWlnaHQsdmVydGljYWxBbGlnbjp0aGlzLnByb3hpbWF0ZT9cInRvcFwiOmkudmVydGljYWxBbGlnbn0pLCEwLHQpfWhhbmRsZU92ZXJmbG93KHQpe2xldCBlPXRoaXMsaT10aGlzLmNoYXJ0LHM9aS5yZW5kZXJlcixvPXRoaXMub3B0aW9ucyxyPW8ueSxuPVwidG9wXCI9PT1vLnZlcnRpY2FsQWxpZ24sYT10aGlzLnBhZGRpbmcsaD1vLm1heEhlaWdodCxsPW8ubmF2aWdhdGlvbixkPWsobC5hbmltYXRpb24sITApLGM9bC5hcnJvd1NpemV8fDEyLHA9dGhpcy5wYWdlcyx1PXRoaXMuYWxsSXRlbXMsZz1mdW5jdGlvbih0KXtcIm51bWJlclwiPT10eXBlb2YgdD9TLmF0dHIoe2hlaWdodDp0fSk6UyYmKGUuY2xpcFJlY3Q9Uy5kZXN0cm95KCksZS5jb250ZW50R3JvdXAuY2xpcCgpKSxlLmNvbnRlbnRHcm91cC5kaXYmJihlLmNvbnRlbnRHcm91cC5kaXYuc3R5bGUuY2xpcD10P1wicmVjdChcIithK1wicHgsOTk5OXB4LFwiKyhhK3QpK1wicHgsMClcIjpcImF1dG9cIil9LGY9ZnVuY3Rpb24odCl7cmV0dXJuIGVbdF09cy5jaXJjbGUoMCwwLDEuMypjKS50cmFuc2xhdGUoYy8yLGMvMikuYWRkKHYpLGkuc3R5bGVkTW9kZXx8ZVt0XS5hdHRyKFwiZmlsbFwiLFwicmdiYSgwLDAsMCwwLjAwMDEpXCIpLGVbdF19LG0seCx5LGI9aS5zcGFjaW5nQm94LmhlaWdodCsobj8tcjpyKS1hLHY9dGhpcy5uYXYsUz10aGlzLmNsaXBSZWN0O3JldHVyblwiaG9yaXpvbnRhbFwiIT09by5sYXlvdXR8fFwibWlkZGxlXCI9PT1vLnZlcnRpY2FsQWxpZ258fG8uZmxvYXRpbmd8fChiLz0yKSxoJiYoYj1NYXRoLm1pbihiLGgpKSxwLmxlbmd0aD0wLHQmJmI+MCYmdD5iJiYhMSE9PWwuZW5hYmxlZD8odGhpcy5jbGlwSGVpZ2h0PW09TWF0aC5tYXgoYi0yMC10aGlzLnRpdGxlSGVpZ2h0LWEsMCksdGhpcy5jdXJyZW50UGFnZT1rKHRoaXMuY3VycmVudFBhZ2UsMSksdGhpcy5mdWxsSGVpZ2h0PXQsdS5mb3JFYWNoKCh0LGUpPT57eT10LmxlZ2VuZEl0ZW18fHt9O2xldCBpPXkueXx8MCxzPU1hdGgucm91bmQoeS5sYWJlbC5nZXRCQm94KCkuaGVpZ2h0KSxvPXAubGVuZ3RoOyghb3x8aS1wW28tMV0+bSYmKHh8fGkpIT09cFtvLTFdKSYmKHAucHVzaCh4fHxpKSxvKyspLHkucGFnZUl4PW8tMSx4JiYoKHVbZS0xXS5sZWdlbmRJdGVtfHx7fSkucGFnZUl4PW8tMSksZT09PXUubGVuZ3RoLTEmJmkrcy1wW28tMV0+bSYmaT5wW28tMV0mJihwLnB1c2goaSkseS5wYWdlSXg9byksaSE9PXgmJih4PWkpfSksU3x8KFM9ZS5jbGlwUmVjdD1zLmNsaXBSZWN0KDAsYS0yLDk5OTksMCksZS5jb250ZW50R3JvdXAuY2xpcChTKSksZyhtKSx2fHwodGhpcy5uYXY9dj1zLmcoKS5hdHRyKHt6SW5kZXg6MX0pLmFkZCh0aGlzLmdyb3VwKSx0aGlzLnVwPXMuc3ltYm9sKFwidHJpYW5nbGVcIiwwLDAsYyxjKS5hZGQodiksZihcInVwVHJhY2tlclwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtlLnNjcm9sbCgtMSxkKX0pLHRoaXMucGFnZXI9cy50ZXh0KFwiXCIsMTUsMTApLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2aWdhdGlvblwiKSwhaS5zdHlsZWRNb2RlJiZsLnN0eWxlJiZ0aGlzLnBhZ2VyLmNzcyhsLnN0eWxlKSx0aGlzLnBhZ2VyLmFkZCh2KSx0aGlzLmRvd249cy5zeW1ib2woXCJ0cmlhbmdsZS1kb3duXCIsMCwwLGMsYykuYWRkKHYpLGYoXCJkb3duVHJhY2tlclwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtlLnNjcm9sbCgxLGQpfSkpLGUuc2Nyb2xsKDApLHQ9Yik6diYmKGcoKSx0aGlzLm5hdj12LmRlc3Ryb3koKSx0aGlzLnNjcm9sbEdyb3VwLmF0dHIoe3RyYW5zbGF0ZVk6MX0pLHRoaXMuY2xpcEhlaWdodD0wKSx0fXNjcm9sbCh0LGUpe2xldCBpPXRoaXMuY2hhcnQscz10aGlzLnBhZ2VzLG89cy5sZW5ndGgscj10aGlzLmNsaXBIZWlnaHQsbj10aGlzLm9wdGlvbnMubmF2aWdhdGlvbixsPXRoaXMucGFnZXIsZD10aGlzLnBhZGRpbmcsYz10aGlzLmN1cnJlbnRQYWdlK3Q7aWYoYz5vJiYoYz1vKSxjPjApe3ZvaWQgMCE9PWUmJmgoZSxpKSx0aGlzLm5hdi5hdHRyKHt0cmFuc2xhdGVYOmQsdHJhbnNsYXRlWTpyK3RoaXMucGFkZGluZys3K3RoaXMudGl0bGVIZWlnaHQsdmlzaWJpbGl0eTpcImluaGVyaXRcIn0pLFt0aGlzLnVwLHRoaXMudXBUcmFja2VyXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0cih7Y2xhc3M6MT09PWM/XCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtaW5hY3RpdmVcIjpcImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1hY3RpdmVcIn0pfSksbC5hdHRyKHt0ZXh0OmMrXCIvXCIrb30pLFt0aGlzLmRvd24sdGhpcy5kb3duVHJhY2tlcl0uZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dHIoe3g6MTgrdGhpcy5wYWdlci5nZXRCQm94KCkud2lkdGgsY2xhc3M6Yz09PW8/XCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtaW5hY3RpdmVcIjpcImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1hY3RpdmVcIn0pfSx0aGlzKSxpLnN0eWxlZE1vZGV8fCh0aGlzLnVwLmF0dHIoe2ZpbGw6MT09PWM/bi5pbmFjdGl2ZUNvbG9yOm4uYWN0aXZlQ29sb3J9KSx0aGlzLnVwVHJhY2tlci5jc3Moe2N1cnNvcjoxPT09Yz9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn0pLHRoaXMuZG93bi5hdHRyKHtmaWxsOmM9PT1vP24uaW5hY3RpdmVDb2xvcjpuLmFjdGl2ZUNvbG9yfSksdGhpcy5kb3duVHJhY2tlci5jc3Moe2N1cnNvcjpjPT09bz9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn0pKSx0aGlzLnNjcm9sbE9mZnNldD0tc1tjLTFdK3RoaXMuaW5pdGlhbEl0ZW1ZLHRoaXMuc2Nyb2xsR3JvdXAuYW5pbWF0ZSh7dHJhbnNsYXRlWTp0aGlzLnNjcm9sbE9mZnNldH0pLHRoaXMuY3VycmVudFBhZ2U9Yyx0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpO2xldCB0PWEoayhlLGkucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCEwKSk7VCgoKT0+e2IodGhpcyxcImFmdGVyU2Nyb2xsXCIse2N1cnJlbnRQYWdlOmN9KX0sdC5kdXJhdGlvbil9fXNldEl0ZW1FdmVudHModCxlLGkpe2xldCBvPXRoaXMscj10LmxlZ2VuZEl0ZW18fHt9LG49by5jaGFydC5yZW5kZXJlci5ib3hXcmFwcGVyLGE9dCBpbnN0YW5jZW9mIHMsaD1cImhpZ2hjaGFydHMtbGVnZW5kLVwiKyhhP1wicG9pbnRcIjpcInNlcmllc1wiKStcIi1hY3RpdmVcIixsPW8uY2hhcnQuc3R5bGVkTW9kZSxkPWk/W2Usci5zeW1ib2xdOltyLmdyb3VwXSxjPWU9PntvLmFsbEl0ZW1zLmZvckVhY2goaT0+e3QhPT1pJiZbaV0uY29uY2F0KGkubGlua2VkU2VyaWVzfHxbXSkuZm9yRWFjaCh0PT57dC5zZXRTdGF0ZShlLCFhKX0pfSl9O2ZvcihsZXQgaSBvZiBkKWkmJmkub24oXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe3QudmlzaWJsZSYmYyhcImluYWN0aXZlXCIpLHQuc2V0U3RhdGUoXCJob3ZlclwiKSx0LnZpc2libGUmJm4uYWRkQ2xhc3MoaCksbHx8ZS5jc3Moby5vcHRpb25zLml0ZW1Ib3ZlclN0eWxlKX0pLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbigpe28uY2hhcnQuc3R5bGVkTW9kZXx8ZS5jc3MoUyh0LnZpc2libGU/by5pdGVtU3R5bGU6by5pdGVtSGlkZGVuU3R5bGUpKSxjKFwiXCIpLG4ucmVtb3ZlQ2xhc3MoaCksdC5zZXRTdGF0ZSgpfSkub24oXCJjbGlja1wiLGZ1bmN0aW9uKGUpe2xldCBpPVwibGVnZW5kSXRlbUNsaWNrXCIscz1mdW5jdGlvbigpe3Quc2V0VmlzaWJsZSYmdC5zZXRWaXNpYmxlKCksYyh0LnZpc2libGU/XCJpbmFjdGl2ZVwiOlwiXCIpfTtuLnJlbW92ZUNsYXNzKGgpLGU9e2Jyb3dzZXJFdmVudDplfSx0LmZpcmVQb2ludEV2ZW50P3QuZmlyZVBvaW50RXZlbnQoaSxlLHMpOmIodCxpLGUscyl9KX1jcmVhdGVDaGVja2JveEZvckl0ZW0odCl7dC5jaGVja2JveD1nKFwiaW5wdXRcIix7dHlwZTpcImNoZWNrYm94XCIsY2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1sZWdlbmQtY2hlY2tib3hcIixjaGVja2VkOnQuc2VsZWN0ZWQsZGVmYXVsdENoZWNrZWQ6dC5zZWxlY3RlZH0sdGhpcy5vcHRpb25zLml0ZW1DaGVja2JveFN0eWxlLHRoaXMuY2hhcnQuY29udGFpbmVyKSx1KHQuY2hlY2tib3gsXCJjbGlja1wiLGZ1bmN0aW9uKGUpe2xldCBpPWUudGFyZ2V0O2IodC5zZXJpZXN8fHQsXCJjaGVja2JveENsaWNrXCIse2NoZWNrZWQ6aS5jaGVja2VkLGl0ZW06dH0sZnVuY3Rpb24oKXt0LnNlbGVjdCgpfSl9KX19cmV0dXJuKG49QXx8KEE9e30pKS5jb21wb3NlPWZ1bmN0aW9uIHQoZSl7TShkLHQpJiZ1KGUsXCJiZWZvcmVNYXJnaW5zXCIsZnVuY3Rpb24oKXt0aGlzLmxlZ2VuZD1uZXcgbih0aGlzLHRoaXMub3B0aW9ucy5sZWdlbmQpfSl9LEF9KSxpKGUsXCJDb3JlL0xlZ2VuZC9MZWdlbmRTeW1ib2wuanNcIixbZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0KXt2YXIgZTtsZXR7ZXh0ZW5kOmksbWVyZ2U6cyxwaWNrOm99PXQ7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLHIpe2xldCBuPXRoaXMubGVnZW5kSXRlbT10aGlzLmxlZ2VuZEl0ZW18fHt9LHtjaGFydDphLG9wdGlvbnM6aH09dGhpcyx7YmFzZWxpbmU6bD0wLHN5bWJvbFdpZHRoOmQsc3ltYm9sSGVpZ2h0OmN9PXQscD10aGlzLnN5bWJvbHx8XCJjaXJjbGVcIix1PWMvMixnPWEucmVuZGVyZXIsZj1uLmdyb3VwLG09bC1NYXRoLnJvdW5kKGMqKHI/LjQ6LjMpKSx4PXt9LHksYj1oLm1hcmtlcix2PTA7aWYoYS5zdHlsZWRNb2RlfHwoeFtcInN0cm9rZS13aWR0aFwiXT1NYXRoLm1pbihoLmxpbmVXaWR0aHx8MCwyNCksaC5kYXNoU3R5bGU/eC5kYXNoc3R5bGU9aC5kYXNoU3R5bGU6XCJzcXVhcmVcIj09PWgubGluZWNhcHx8KHhbXCJzdHJva2UtbGluZWNhcFwiXT1cInJvdW5kXCIpKSxuLmxpbmU9Zy5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWdyYXBoXCIpLmF0dHIoeCkuYWRkKGYpLHImJihuLmFyZWE9Zy5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWFyZWFcIikuYWRkKGYpKSx4W1wic3Ryb2tlLWxpbmVjYXBcIl0mJih2PU1hdGgubWluKG4ubGluZS5zdHJva2VXaWR0aCgpLGQpLzIpLGQpe2xldCB0PVtbXCJNXCIsdixtXSxbXCJMXCIsZC12LG1dXTtuLmxpbmUuYXR0cih7ZDp0fSksbi5hcmVhPy5hdHRyKHtkOlsuLi50LFtcIkxcIixkLXYsbF0sW1wiTFwiLHYsbF1dfSl9aWYoYiYmITEhPT1iLmVuYWJsZWQmJmQpe2xldCB0PU1hdGgubWluKG8oYi5yYWRpdXMsdSksdSk7MD09PXAuaW5kZXhPZihcInVybFwiKSYmKGI9cyhiLHt3aWR0aDpjLGhlaWdodDpjfSksdD0wKSxuLnN5bWJvbD15PWcuc3ltYm9sKHAsZC8yLXQsbS10LDIqdCwyKnQsaSh7Y29udGV4dDpcImxlZ2VuZFwifSxiKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmFkZChmKSx5LmlzTWFya2VyPSEwfX10LmFyZWFNYXJrZXI9ZnVuY3Rpb24odCxpKXtlLmNhbGwodGhpcyx0LGksITApfSx0LmxpbmVNYXJrZXI9ZSx0LnJlY3RhbmdsZT1mdW5jdGlvbih0LGUpe2xldCBpPWUubGVnZW5kSXRlbXx8e30scz10Lm9wdGlvbnMscj10LnN5bWJvbEhlaWdodCxuPXMuc3F1YXJlU3ltYm9sLGE9bj9yOnQuc3ltYm9sV2lkdGg7aS5zeW1ib2w9dGhpcy5jaGFydC5yZW5kZXJlci5yZWN0KG4/KHQuc3ltYm9sV2lkdGgtcikvMjowLHQuYmFzZWxpbmUtcisxLGEscixvKHQub3B0aW9ucy5zeW1ib2xSYWRpdXMsci8yKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmF0dHIoe3pJbmRleDozfSkuYWRkKGkuZ3JvdXApfX0oZXx8KGU9e30pKSxlfSksaShlLFwiQ29yZS9TZXJpZXMvU2VyaWVzRGVmYXVsdHMuanNcIixbXSxmdW5jdGlvbigpe3JldHVybntsaW5lV2lkdGg6MixhbGxvd1BvaW50U2VsZWN0OiExLGNyaXNwOiEwLHNob3dDaGVja2JveDohMSxhbmltYXRpb246e2R1cmF0aW9uOjFlM30sZW5hYmxlTW91c2VUcmFja2luZzohMCxldmVudHM6e30sbWFya2VyOntlbmFibGVkVGhyZXNob2xkOjIsbGluZUNvbG9yOlwiI2ZmZmZmZlwiLGxpbmVXaWR0aDowLHJhZGl1czo0LHN0YXRlczp7bm9ybWFsOnthbmltYXRpb246ITB9LGhvdmVyOnthbmltYXRpb246e2R1cmF0aW9uOjE1MH0sZW5hYmxlZDohMCxyYWRpdXNQbHVzOjIsbGluZVdpZHRoUGx1czoxfSxzZWxlY3Q6e2ZpbGxDb2xvcjpcIiNjY2NjY2NcIixsaW5lQ29sb3I6XCIjMDAwMDAwXCIsbGluZVdpZHRoOjJ9fX0scG9pbnQ6e2V2ZW50czp7fX0sZGF0YUxhYmVsczp7YW5pbWF0aW9uOnt9LGFsaWduOlwiY2VudGVyXCIsYm9yZGVyV2lkdGg6MCxkZWZlcjohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtsZXR7bnVtYmVyRm9ybWF0dGVyOnR9PXRoaXMuc2VyaWVzLmNoYXJ0O3JldHVyblwibnVtYmVyXCIhPXR5cGVvZiB0aGlzLnk/XCJcIjp0KHRoaXMueSwtMSl9LHBhZGRpbmc6NSxzdHlsZTp7Zm9udFNpemU6XCIwLjdlbVwiLGZvbnRXZWlnaHQ6XCJib2xkXCIsY29sb3I6XCJjb250cmFzdFwiLHRleHRPdXRsaW5lOlwiMXB4IGNvbnRyYXN0XCJ9LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowfSxjcm9wVGhyZXNob2xkOjMwMCxvcGFjaXR5OjEscG9pbnRSYW5nZTowLHNvZnRUaHJlc2hvbGQ6ITAsc3RhdGVzOntub3JtYWw6e2FuaW1hdGlvbjohMH0saG92ZXI6e2FuaW1hdGlvbjp7ZHVyYXRpb246MTUwfSxsaW5lV2lkdGhQbHVzOjEsbWFya2VyOnt9LGhhbG86e3NpemU6MTAsb3BhY2l0eTouMjV9fSxzZWxlY3Q6e2FuaW1hdGlvbjp7ZHVyYXRpb246MH19LGluYWN0aXZlOnthbmltYXRpb246e2R1cmF0aW9uOjE1MH0sb3BhY2l0eTouMn19LHN0aWNreVRyYWNraW5nOiEwLHR1cmJvVGhyZXNob2xkOjFlMyxmaW5kTmVhcmVzdFBvaW50Qnk6XCJ4XCJ9fSksaShlLFwiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIixbZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9EZWZhdWx0cy5qc1wiXSxlW1wiQ29yZS9TZXJpZXMvUG9pbnQuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSxzKXt2YXIgbztsZXR7ZGVmYXVsdE9wdGlvbnM6cn09ZSx7ZXh0ZW5kQ2xhc3M6bixtZXJnZTphfT1zO3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBzKHQscyl7bGV0IG89ci5wbG90T3B0aW9uc3x8e30sbj1zLmRlZmF1bHRPcHRpb25zLGE9cy5wcm90b3R5cGU7YS50eXBlPXQsYS5wb2ludENsYXNzfHwoYS5wb2ludENsYXNzPWkpLG4mJihvW3RdPW4pLGUuc2VyaWVzVHlwZXNbdF09c31lLnNlcmllc1R5cGVzPXQuc2VyaWVzVHlwZXMsZS5yZWdpc3RlclNlcmllc1R5cGU9cyxlLnNlcmllc1R5cGU9ZnVuY3Rpb24odCxvLGgsbCxkKXtsZXQgYz1yLnBsb3RPcHRpb25zfHx7fTtyZXR1cm4gbz1vfHxcIlwiLGNbdF09YShjW29dLGgpLHModCxuKGUuc2VyaWVzVHlwZXNbb118fGZ1bmN0aW9uKCl7fSxsKSksZS5zZXJpZXNUeXBlc1t0XS5wcm90b3R5cGUudHlwZT10LGQmJihlLnNlcmllc1R5cGVzW3RdLnByb3RvdHlwZS5wb2ludENsYXNzPW4oaSxkKSksZS5zZXJpZXNUeXBlc1t0XX19KG98fChvPXt9KSksb30pLGkoZSxcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiLFtlW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL0RlZmF1bHRzLmpzXCJdLGVbXCJDb3JlL0ZvdW5kYXRpb24uanNcIl0sZVtcIkNvcmUvR2xvYmFscy5qc1wiXSxlW1wiQ29yZS9MZWdlbmQvTGVnZW5kU3ltYm9sLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxlW1wiQ29yZS9TZXJpZXMvU2VyaWVzRGVmYXVsdHMuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1NWRy9TVkdFbGVtZW50LmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyxvLHIsbixhLGgsbCl7bGV0e2FuaW1PYmplY3Q6ZCxzZXRBbmltYXRpb246Y309dCx7ZGVmYXVsdE9wdGlvbnM6cH09ZSx7cmVnaXN0ZXJFdmVudE9wdGlvbnM6dX09aSx7aGFzVG91Y2g6Zyxzdmc6Zix3aW46bX09cyx7c2VyaWVzVHlwZXM6eH09YSx7YXJyYXlNYXg6eSxhcnJheU1pbjpiLGNsYW1wOnYsY29ycmVjdEZsb2F0OlMsZGVmaW5lZDprLGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzOk0sZGlmZk9iamVjdHM6QyxlcmFzZTp3LGVycm9yOlQsZXh0ZW5kOkEsZmluZDpQLGZpcmVFdmVudDpMLGdldENsb3Nlc3REaXN0YW5jZTpPLGdldE5lc3RlZFByb3BlcnR5OkQsaW5zZXJ0SXRlbTpFLGlzQXJyYXk6aixpc051bWJlcjpJLGlzU3RyaW5nOkIsbWVyZ2U6UixvYmplY3RFYWNoOnoscGljazpOLHJlbW92ZUV2ZW50Olcsc3BsYXQ6RyxzeW5jVGltZW91dDpIfT1sO2NsYXNzIFh7Y29uc3RydWN0b3IoKXt0aGlzLnpvbmVBeGlzPVwieVwifWluaXQodCxlKXtsZXQgaTtMKHRoaXMsXCJpbml0XCIse29wdGlvbnM6ZX0pO2xldCBzPXRoaXMsbz10LnNlcmllczt0aGlzLmV2ZW50c1RvVW5iaW5kPVtdLHMuY2hhcnQ9dCxzLm9wdGlvbnM9cy5zZXRPcHRpb25zKGUpO2xldCByPXMub3B0aW9ucyxuPSExIT09ci52aXNpYmxlO3MubGlua2VkU2VyaWVzPVtdLHMuYmluZEF4ZXMoKSxBKHMse25hbWU6ci5uYW1lLHN0YXRlOlwiXCIsdmlzaWJsZTpuLHNlbGVjdGVkOiEwPT09ci5zZWxlY3RlZH0pLHUodGhpcyxyKTtsZXQgYT1yLmV2ZW50czsoYSYmYS5jbGlja3x8ci5wb2ludCYmci5wb2ludC5ldmVudHMmJnIucG9pbnQuZXZlbnRzLmNsaWNrfHxyLmFsbG93UG9pbnRTZWxlY3QpJiYodC5ydW5UcmFja2VyQ2xpY2s9ITApLHMuZ2V0Q29sb3IoKSxzLmdldFN5bWJvbCgpLHMucGFyYWxsZWxBcnJheXMuZm9yRWFjaChmdW5jdGlvbih0KXtzW3QrXCJEYXRhXCJdfHwoc1t0K1wiRGF0YVwiXT1bXSl9KSxzLmlzQ2FydGVzaWFuJiYodC5oYXNDYXJ0ZXNpYW5TZXJpZXM9ITApLG8ubGVuZ3RoJiYoaT1vW28ubGVuZ3RoLTFdKSxzLl9pPU4oaSYmaS5faSwtMSkrMSxzLm9wYWNpdHk9cy5vcHRpb25zLm9wYWNpdHksdC5vcmRlckl0ZW1zKFwic2VyaWVzXCIsRSh0aGlzLG8pKSxyLmRhdGFTb3J0aW5nJiZyLmRhdGFTb3J0aW5nLmVuYWJsZWQ/cy5zZXREYXRhU29ydGluZ09wdGlvbnMoKTpzLnBvaW50c3x8cy5kYXRhfHxzLnNldERhdGEoci5kYXRhLCExKSxMKHRoaXMsXCJhZnRlckluaXRcIil9aXModCl7cmV0dXJuIHhbdF0mJnRoaXMgaW5zdGFuY2VvZiB4W3RdfWJpbmRBeGVzKCl7bGV0IHQ7bGV0IGU9dGhpcyxpPWUub3B0aW9ucyxzPWUuY2hhcnQ7TCh0aGlzLFwiYmluZEF4ZXNcIixudWxsLGZ1bmN0aW9uKCl7KGUuYXhpc1R5cGVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihvKXtzW29dLmZvckVhY2goZnVuY3Rpb24ocyl7dD1zLm9wdGlvbnMsKE4oaVtvXSwwKT09PXMuaW5kZXh8fHZvaWQgMCE9PWlbb10mJmlbb109PT10LmlkKSYmKEUoZSxzLnNlcmllcyksZVtvXT1zLHMuaXNEaXJ0eT0hMCl9KSxlW29dfHxlLm9wdGlvbmFsQXhpcz09PW98fFQoMTgsITAscyl9KX0pLEwodGhpcyxcImFmdGVyQmluZEF4ZXNcIil9dXBkYXRlUGFyYWxsZWxBcnJheXModCxlLGkpe2xldCBzPXQuc2VyaWVzLG89SShlKT9mdW5jdGlvbihpKXtsZXQgbz1cInlcIj09PWkmJnMudG9ZRGF0YT9zLnRvWURhdGEodCk6dFtpXTtzW2krXCJEYXRhXCJdW2VdPW99OmZ1bmN0aW9uKHQpe0FycmF5LnByb3RvdHlwZVtlXS5hcHBseShzW3QrXCJEYXRhXCJdLGkpfTtzLnBhcmFsbGVsQXJyYXlzLmZvckVhY2gobyl9aGFzRGF0YSgpe3JldHVybiB0aGlzLnZpc2libGUmJnZvaWQgMCE9PXRoaXMuZGF0YU1heCYmdm9pZCAwIT09dGhpcy5kYXRhTWlufHx0aGlzLnZpc2libGUmJnRoaXMueURhdGEmJnRoaXMueURhdGEubGVuZ3RoPjB9aGFzTWFya2VyQ2hhbmdlZCh0LGUpe2xldCBpPXQubWFya2VyLHM9ZS5tYXJrZXJ8fHt9O3JldHVybiBpJiYocy5lbmFibGVkJiYhaS5lbmFibGVkfHxzLnN5bWJvbCE9PWkuc3ltYm9sfHxzLmhlaWdodCE9PWkuaGVpZ2h0fHxzLndpZHRoIT09aS53aWR0aCl9YXV0b0luY3JlbWVudCh0KXtsZXQgZT10aGlzLm9wdGlvbnMsaT1lLnBvaW50SW50ZXJ2YWxVbml0LHM9ZS5yZWxhdGl2ZVhWYWx1ZSxvPXRoaXMuY2hhcnQudGltZSxyPXRoaXMueEluY3JlbWVudCxuLGE7cmV0dXJuKHI9TihyLGUucG9pbnRTdGFydCwwKSx0aGlzLnBvaW50SW50ZXJ2YWw9YT1OKHRoaXMucG9pbnRJbnRlcnZhbCxlLnBvaW50SW50ZXJ2YWwsMSkscyYmSSh0KSYmKGEqPXQpLGkmJihuPW5ldyBvLkRhdGUociksXCJkYXlcIj09PWk/by5zZXQoXCJEYXRlXCIsbixvLmdldChcIkRhdGVcIixuKSthKTpcIm1vbnRoXCI9PT1pP28uc2V0KFwiTW9udGhcIixuLG8uZ2V0KFwiTW9udGhcIixuKSthKTpcInllYXJcIj09PWkmJm8uc2V0KFwiRnVsbFllYXJcIixuLG8uZ2V0KFwiRnVsbFllYXJcIixuKSthKSxhPW4uZ2V0VGltZSgpLXIpLHMmJkkodCkpP3IrYToodGhpcy54SW5jcmVtZW50PXIrYSxyKX1zZXREYXRhU29ydGluZ09wdGlvbnMoKXtsZXQgdD10aGlzLm9wdGlvbnM7QSh0aGlzLHtyZXF1aXJlU29ydGluZzohMSxzb3J0ZWQ6ITEsZW5hYmxlZERhdGFTb3J0aW5nOiEwLGFsbG93REc6ITF9KSxrKHQucG9pbnRSYW5nZSl8fCh0LnBvaW50UmFuZ2U9MSl9c2V0T3B0aW9ucyh0KXtsZXQgZTtsZXQgaT10aGlzLmNoYXJ0LHM9aS5vcHRpb25zLG89cy5wbG90T3B0aW9ucyxyPWkudXNlck9wdGlvbnN8fHt9LG49Uih0KSxhPWkuc3R5bGVkTW9kZSxoPXtwbG90T3B0aW9uczpvLHVzZXJPcHRpb25zOm59O0wodGhpcyxcInNldE9wdGlvbnNcIixoKTtsZXQgbD1oLnBsb3RPcHRpb25zW3RoaXMudHlwZV0sZD1yLnBsb3RPcHRpb25zfHx7fSxjPWQuc2VyaWVzfHx7fSx1PXAucGxvdE9wdGlvbnNbdGhpcy50eXBlXXx8e30sZz1kW3RoaXMudHlwZV18fHt9O3RoaXMudXNlck9wdGlvbnM9aC51c2VyT3B0aW9ucztsZXQgZj1SKGwsby5zZXJpZXMsZyxuKTt0aGlzLnRvb2x0aXBPcHRpb25zPVIocC50b29sdGlwLHAucGxvdE9wdGlvbnMuc2VyaWVzPy50b29sdGlwLHU/LnRvb2x0aXAsaS51c2VyT3B0aW9ucy50b29sdGlwLGQuc2VyaWVzPy50b29sdGlwLGcudG9vbHRpcCxuLnRvb2x0aXApLHRoaXMuc3RpY2t5VHJhY2tpbmc9TihuLnN0aWNreVRyYWNraW5nLGcuc3RpY2t5VHJhY2tpbmcsYy5zdGlja3lUcmFja2luZywhIXRoaXMudG9vbHRpcE9wdGlvbnMuc2hhcmVkJiYhdGhpcy5ub1NoYXJlZFRvb2x0aXB8fGYuc3RpY2t5VHJhY2tpbmcpLG51bGw9PT1sLm1hcmtlciYmZGVsZXRlIGYubWFya2VyLHRoaXMuem9uZUF4aXM9Zi56b25lQXhpc3x8XCJ5XCI7bGV0IG09dGhpcy56b25lcz0oZi56b25lc3x8W10pLnNsaWNlKCk7cmV0dXJuKGYubmVnYXRpdmVDb2xvcnx8Zi5uZWdhdGl2ZUZpbGxDb2xvcikmJiFmLnpvbmVzJiYoZT17dmFsdWU6Zlt0aGlzLnpvbmVBeGlzK1wiVGhyZXNob2xkXCJdfHxmLnRocmVzaG9sZHx8MCxjbGFzc05hbWU6XCJoaWdoY2hhcnRzLW5lZ2F0aXZlXCJ9LGF8fChlLmNvbG9yPWYubmVnYXRpdmVDb2xvcixlLmZpbGxDb2xvcj1mLm5lZ2F0aXZlRmlsbENvbG9yKSxtLnB1c2goZSkpLG0ubGVuZ3RoJiZrKG1bbS5sZW5ndGgtMV0udmFsdWUpJiZtLnB1c2goYT97fTp7Y29sb3I6dGhpcy5jb2xvcixmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3J9KSxMKHRoaXMsXCJhZnRlclNldE9wdGlvbnNcIix7b3B0aW9uczpmfSksZn1nZXROYW1lKCl7cmV0dXJuIE4odGhpcy5vcHRpb25zLm5hbWUsXCJTZXJpZXMgXCIrKHRoaXMuaW5kZXgrMSkpfWdldEN5Y2xpYyh0LGUsaSl7bGV0IHMsbztsZXQgcj10aGlzLmNoYXJ0LG49YCR7dH1JbmRleGAsYT1gJHt0fUNvdW50ZXJgLGg9aT8ubGVuZ3RofHxyLm9wdGlvbnMuY2hhcnQuY29sb3JDb3VudDshZSYmKGsobz1OKFwiY29sb3JcIj09PXQ/dGhpcy5vcHRpb25zLmNvbG9ySW5kZXg6dm9pZCAwLHRoaXNbbl0pKT9zPW86KHIuc2VyaWVzLmxlbmd0aHx8KHJbYV09MCkscz1yW2FdJWgsclthXSs9MSksaSYmKGU9aVtzXSkpLHZvaWQgMCE9PXMmJih0aGlzW25dPXMpLHRoaXNbdF09ZX1nZXRDb2xvcigpe3RoaXMuY2hhcnQuc3R5bGVkTW9kZT90aGlzLmdldEN5Y2xpYyhcImNvbG9yXCIpOnRoaXMub3B0aW9ucy5jb2xvckJ5UG9pbnQ/dGhpcy5jb2xvcj1cIiNjY2NjY2NcIjp0aGlzLmdldEN5Y2xpYyhcImNvbG9yXCIsdGhpcy5vcHRpb25zLmNvbG9yfHxwLnBsb3RPcHRpb25zW3RoaXMudHlwZV0uY29sb3IsdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyl9Z2V0UG9pbnRzQ29sbGVjdGlvbigpe3JldHVybih0aGlzLmhhc0dyb3VwZWREYXRhP3RoaXMucG9pbnRzOnRoaXMuZGF0YSl8fFtdfWdldFN5bWJvbCgpe2xldCB0PXRoaXMub3B0aW9ucy5tYXJrZXI7dGhpcy5nZXRDeWNsaWMoXCJzeW1ib2xcIix0LnN5bWJvbCx0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyl9ZmluZFBvaW50SW5kZXgodCxlKXtsZXQgaSxzLG87bGV0IG49dC5pZCxhPXQueCxoPXRoaXMucG9pbnRzLGw9dGhpcy5vcHRpb25zLmRhdGFTb3J0aW5nO2lmKG4pe2xldCB0PXRoaXMuY2hhcnQuZ2V0KG4pO3QgaW5zdGFuY2VvZiByJiYoaT10KX1lbHNlIGlmKHRoaXMubGlua2VkUGFyZW50fHx0aGlzLmVuYWJsZWREYXRhU29ydGluZ3x8dGhpcy5vcHRpb25zLnJlbGF0aXZlWFZhbHVlKXtsZXQgZT1lPT4hZS50b3VjaGVkJiZlLmluZGV4PT09dC5pbmRleDtpZihsJiZsLm1hdGNoQnlOYW1lP2U9ZT0+IWUudG91Y2hlZCYmZS5uYW1lPT09dC5uYW1lOnRoaXMub3B0aW9ucy5yZWxhdGl2ZVhWYWx1ZSYmKGU9ZT0+IWUudG91Y2hlZCYmZS5vcHRpb25zLng9PT10LngpLCEoaT1QKGgsZSkpKXJldHVybn1yZXR1cm4gaSYmdm9pZCAwIT09KG89aSYmaS5pbmRleCkmJihzPSEwKSx2b2lkIDA9PT1vJiZJKGEpJiYobz10aGlzLnhEYXRhLmluZGV4T2YoYSxlKSksLTEhPT1vJiZ2b2lkIDAhPT1vJiZ0aGlzLmNyb3BwZWQmJihvPW8+PXRoaXMuY3JvcFN0YXJ0P28tdGhpcy5jcm9wU3RhcnQ6byksIXMmJkkobykmJmhbb10mJmhbb10udG91Y2hlZCYmKG89dm9pZCAwKSxvfXVwZGF0ZURhdGEodCxlKXtsZXQgaT10aGlzLm9wdGlvbnMscz1pLmRhdGFTb3J0aW5nLG89dGhpcy5wb2ludHMscj1bXSxuPXRoaXMucmVxdWlyZVNvcnRpbmcsYT10Lmxlbmd0aD09PW8ubGVuZ3RoLGgsbCxkLGMscD0hMDtpZih0aGlzLnhJbmNyZW1lbnQ9bnVsbCx0LmZvckVhY2goZnVuY3Rpb24odCxlKXtsZXQgbDtsZXQgZD1rKHQpJiZ0aGlzLnBvaW50Q2xhc3MucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHtzZXJpZXM6dGhpc30sdCl8fHt9LHA9ZC54LHU9ZC5pZDt1fHxJKHApPygtMT09PShsPXRoaXMuZmluZFBvaW50SW5kZXgoZCxjKSl8fHZvaWQgMD09PWw/ci5wdXNoKHQpOm9bbF0mJnQhPT1pLmRhdGFbbF0/KG9bbF0udXBkYXRlKHQsITEsbnVsbCwhMSksb1tsXS50b3VjaGVkPSEwLG4mJihjPWwrMSkpOm9bbF0mJihvW2xdLnRvdWNoZWQ9ITApLCghYXx8ZSE9PWx8fHMmJnMuZW5hYmxlZHx8dGhpcy5oYXNEZXJpdmVkRGF0YSkmJihoPSEwKSk6ci5wdXNoKHQpfSx0aGlzKSxoKWZvcihsPW8ubGVuZ3RoO2wtLTspKGQ9b1tsXSkmJiFkLnRvdWNoZWQmJmQucmVtb3ZlJiZkLnJlbW92ZSghMSxlKTtlbHNlIWF8fHMmJnMuZW5hYmxlZD9wPSExOih0LmZvckVhY2goZnVuY3Rpb24odCxlKXt0PT09b1tlXS55fHxvW2VdLmRlc3Ryb3llZHx8b1tlXS51cGRhdGUodCwhMSxudWxsLCExKX0pLHIubGVuZ3RoPTApO3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24odCl7dCYmKHQudG91Y2hlZD0hMSl9KSwhIXAmJihyLmZvckVhY2goZnVuY3Rpb24odCl7dGhpcy5hZGRQb2ludCh0LCExLG51bGwsbnVsbCwhMSl9LHRoaXMpLG51bGw9PT10aGlzLnhJbmNyZW1lbnQmJnRoaXMueERhdGEmJnRoaXMueERhdGEubGVuZ3RoJiYodGhpcy54SW5jcmVtZW50PXkodGhpcy54RGF0YSksdGhpcy5hdXRvSW5jcmVtZW50KCkpLCEwKX1zZXREYXRhKHQsZT0hMCxpLHMpe2xldCBvPXRoaXMscj1vLnBvaW50cyxuPXImJnIubGVuZ3RofHwwLGE9by5vcHRpb25zLGg9by5jaGFydCxsPWEuZGF0YVNvcnRpbmcsZD1vLnhBeGlzLGM9YS50dXJib1RocmVzaG9sZCxwPXRoaXMueERhdGEsdT10aGlzLnlEYXRhLGc9by5wb2ludEFycmF5TWFwLGY9ZyYmZy5sZW5ndGgsbT1hLmtleXMseCx5LGIsdj0wLFM9MSxrPW51bGwsTTtoLm9wdGlvbnMuY2hhcnQuYWxsb3dNdXRhdGluZ0RhdGF8fChhLmRhdGEmJmRlbGV0ZSBvLm9wdGlvbnMuZGF0YSxvLnVzZXJPcHRpb25zLmRhdGEmJmRlbGV0ZSBvLnVzZXJPcHRpb25zLmRhdGEsTT1SKCEwLHQpKSx0PU18fHR8fFtdO2xldCBDPXQubGVuZ3RoO2lmKGwmJmwuZW5hYmxlZCYmKHQ9dGhpcy5zb3J0RGF0YSh0KSksaC5vcHRpb25zLmNoYXJ0LmFsbG93TXV0YXRpbmdEYXRhJiYhMSE9PXMmJkMmJm4mJiFvLmNyb3BwZWQmJiFvLmhhc0dyb3VwZWREYXRhJiZvLnZpc2libGUmJiFvLmJvb3N0ZWQmJihiPXRoaXMudXBkYXRlRGF0YSh0LGkpKSwhYil7aWYoby54SW5jcmVtZW50PW51bGwsby5jb2xvckNvdW50ZXI9MCx0aGlzLnBhcmFsbGVsQXJyYXlzLmZvckVhY2goZnVuY3Rpb24odCl7b1t0K1wiRGF0YVwiXS5sZW5ndGg9MH0pLGMmJkM+Yyl7aWYoSShrPW8uZ2V0Rmlyc3RWYWxpZFBvaW50KHQpKSlmb3IoeD0wO3g8Qzt4KyspcFt4XT10aGlzLmF1dG9JbmNyZW1lbnQoKSx1W3hdPXRbeF07ZWxzZSBpZihqKGspKXtpZihmKXtpZihrLmxlbmd0aD09PWYpZm9yKHg9MDt4PEM7eCsrKXBbeF09dGhpcy5hdXRvSW5jcmVtZW50KCksdVt4XT10W3hdO2Vsc2UgZm9yKHg9MDt4PEM7eCsrKXk9dFt4XSxwW3hdPXlbMF0sdVt4XT15LnNsaWNlKDEsZisxKX1lbHNlIGlmKG0mJih2PW0uaW5kZXhPZihcInhcIiksUz1tLmluZGV4T2YoXCJ5XCIpLHY9dj49MD92OjAsUz1TPj0wP1M6MSksMT09PWsubGVuZ3RoJiYoUz0wKSx2PT09Uylmb3IoeD0wO3g8Qzt4KyspcFt4XT10aGlzLmF1dG9JbmNyZW1lbnQoKSx1W3hdPXRbeF1bU107ZWxzZSBmb3IoeD0wO3g8Qzt4KyspeT10W3hdLHBbeF09eVt2XSx1W3hdPXlbU119ZWxzZSBUKDEyLCExLGgpfWVsc2UgZm9yKHg9MDt4PEM7eCsrKXk9e3NlcmllczpvfSxvLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseSh5LFt0W3hdXSksby51cGRhdGVQYXJhbGxlbEFycmF5cyh5LHgpO2Zvcih1JiZCKHVbMF0pJiZUKDE0LCEwLGgpLG8uZGF0YT1bXSxvLm9wdGlvbnMuZGF0YT1vLnVzZXJPcHRpb25zLmRhdGE9dCx4PW47eC0tOylyW3hdPy5kZXN0cm95KCk7ZCYmKGQubWluUmFuZ2U9ZC51c2VyTWluUmFuZ2UpLG8uaXNEaXJ0eT1oLmlzRGlydHlCb3g9ITAsby5pc0RpcnR5RGF0YT0hIXIsaT0hMX1cInBvaW50XCI9PT1hLmxlZ2VuZFR5cGUmJih0aGlzLnByb2Nlc3NEYXRhKCksdGhpcy5nZW5lcmF0ZVBvaW50cygpKSxlJiZoLnJlZHJhdyhpKX1zb3J0RGF0YSh0KXtsZXQgZT10aGlzLGk9ZS5vcHRpb25zLHM9aS5kYXRhU29ydGluZyxvPXMuc29ydEtleXx8XCJ5XCIscj1mdW5jdGlvbih0LGUpe3JldHVybiBrKGUpJiZ0LnBvaW50Q2xhc3MucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHtzZXJpZXM6dH0sZSl8fHt9fTt0LmZvckVhY2goZnVuY3Rpb24oaSxzKXt0W3NdPXIoZSxpKSx0W3NdLmluZGV4PXN9LHRoaXMpO2xldCBuPXQuY29uY2F0KCkuc29ydCgodCxlKT0+e2xldCBpPUQobyx0KSxzPUQobyxlKTtyZXR1cm4gczxpPy0xOnM+aT8xOjB9KTtyZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7dC54PWV9LHRoaXMpLGUubGlua2VkU2VyaWVzJiZlLmxpbmtlZFNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2xldCBpPWUub3B0aW9ucyxzPWkuZGF0YTtpLmRhdGFTb3J0aW5nJiZpLmRhdGFTb3J0aW5nLmVuYWJsZWR8fCFzfHwocy5mb3JFYWNoKGZ1bmN0aW9uKGksbyl7c1tvXT1yKGUsaSksdFtvXSYmKHNbb10ueD10W29dLngsc1tvXS5pbmRleD1vKX0pLGUuc2V0RGF0YShzLCExKSl9KSx0fWdldFByb2Nlc3NlZERhdGEodCl7bGV0IGU9dGhpcyxpPWUueEF4aXMscz1lLm9wdGlvbnMsbz1zLmNyb3BUaHJlc2hvbGQscj10fHxlLmdldEV4dHJlbWVzRnJvbUFsbHx8cy5nZXRFeHRyZW1lc0Zyb21BbGwsbj1pPy5sb2dhcml0aG1pYyxhPWUuaXNDYXJ0ZXNpYW4saCxsLGQ9MCxjLHAsdSxnPWUueERhdGEsZj1lLnlEYXRhLG09ITEseD1nLmxlbmd0aDtpJiYocD0oYz1pLmdldEV4dHJlbWVzKCkpLm1pbix1PWMubWF4LG09ISEoaS5jYXRlZ29yaWVzJiYhaS5uYW1lcy5sZW5ndGgpKSxhJiZlLnNvcnRlZCYmIXImJighb3x8eD5vfHxlLmZvcmNlQ3JvcCkmJihnW3gtMV08cHx8Z1swXT51PyhnPVtdLGY9W10pOmUueURhdGEmJihnWzBdPHB8fGdbeC0xXT51KSYmKGc9KGg9dGhpcy5jcm9wRGF0YShlLnhEYXRhLGUueURhdGEscCx1KSkueERhdGEsZj1oLnlEYXRhLGQ9aC5zdGFydCxsPSEwKSk7bGV0IHk9Tyhbbj9nLm1hcChuLmxvZzJsaW4pOmddLCgpPT5lLnJlcXVpcmVTb3J0aW5nJiYhbSYmVCgxNSwhMSxlLmNoYXJ0KSk7cmV0dXJue3hEYXRhOmcseURhdGE6Zixjcm9wcGVkOmwsY3JvcFN0YXJ0OmQsY2xvc2VzdFBvaW50UmFuZ2U6eX19cHJvY2Vzc0RhdGEodCl7bGV0IGU9dGhpcy54QXhpcztpZih0aGlzLmlzQ2FydGVzaWFuJiYhdGhpcy5pc0RpcnR5JiYhZS5pc0RpcnR5JiYhdGhpcy55QXhpcy5pc0RpcnR5JiYhdClyZXR1cm4hMTtsZXQgaT10aGlzLmdldFByb2Nlc3NlZERhdGEoKTt0aGlzLmNyb3BwZWQ9aS5jcm9wcGVkLHRoaXMuY3JvcFN0YXJ0PWkuY3JvcFN0YXJ0LHRoaXMucHJvY2Vzc2VkWERhdGE9aS54RGF0YSx0aGlzLnByb2Nlc3NlZFlEYXRhPWkueURhdGEsdGhpcy5jbG9zZXN0UG9pbnRSYW5nZT10aGlzLmJhc2VQb2ludFJhbmdlPWkuY2xvc2VzdFBvaW50UmFuZ2UsTCh0aGlzLFwiYWZ0ZXJQcm9jZXNzRGF0YVwiKX1jcm9wRGF0YSh0LGUsaSxzKXtsZXQgbz10Lmxlbmd0aCxyLG4sYT0wLGg9bztmb3Iocj0wO3I8bztyKyspaWYodFtyXT49aSl7YT1NYXRoLm1heCgwLHItMSk7YnJlYWt9Zm9yKG49cjtuPG87bisrKWlmKHRbbl0+cyl7aD1uKzE7YnJlYWt9cmV0dXJue3hEYXRhOnQuc2xpY2UoYSxoKSx5RGF0YTplLnNsaWNlKGEsaCksc3RhcnQ6YSxlbmQ6aH19Z2VuZXJhdGVQb2ludHMoKXtsZXQgdD10aGlzLm9wdGlvbnMsZT10aGlzLnByb2Nlc3NlZERhdGF8fHQuZGF0YSxpPXRoaXMucHJvY2Vzc2VkWERhdGEscz10aGlzLnByb2Nlc3NlZFlEYXRhLG89dGhpcy5wb2ludENsYXNzLHI9aS5sZW5ndGgsbj10aGlzLmNyb3BTdGFydHx8MCxhPXRoaXMuaGFzR3JvdXBlZERhdGEsaD10LmtleXMsbD1bXSxkPXQuZGF0YUdyb3VwaW5nJiZ0LmRhdGFHcm91cGluZy5ncm91cEFsbD9uOjAsYyxwLHUsZyxmPXRoaXMuZGF0YTtpZighZiYmIWEpe2xldCB0PVtdO3QubGVuZ3RoPWUubGVuZ3RoLGY9dGhpcy5kYXRhPXR9Zm9yKGgmJmEmJih0aGlzLm9wdGlvbnMua2V5cz0hMSksZz0wO2c8cjtnKyspcD1uK2csYT8oKHU9bmV3IG8odGhpcyxbaVtnXV0uY29uY2F0KEcoc1tnXSkpKSkuZGF0YUdyb3VwPXRoaXMuZ3JvdXBNYXBbZCtnXSx1LmRhdGFHcm91cC5vcHRpb25zJiYodS5vcHRpb25zPXUuZGF0YUdyb3VwLm9wdGlvbnMsQSh1LHUuZGF0YUdyb3VwLm9wdGlvbnMpLGRlbGV0ZSB1LmRhdGFMYWJlbHMpKToodT1mW3BdKXx8dm9pZCAwPT09ZVtwXXx8KGZbcF09dT1uZXcgbyh0aGlzLGVbcF0saVtnXSkpLHUmJih1LmluZGV4PWE/ZCtnOnAsbFtnXT11KTtpZih0aGlzLm9wdGlvbnMua2V5cz1oLGYmJihyIT09KGM9Zi5sZW5ndGgpfHxhKSlmb3IoZz0wO2c8YztnKyspZyE9PW58fGF8fChnKz1yKSxmW2ddJiYoZltnXS5kZXN0cm95RWxlbWVudHMoKSxmW2ddLnBsb3RYPXZvaWQgMCk7dGhpcy5kYXRhPWYsdGhpcy5wb2ludHM9bCxMKHRoaXMsXCJhZnRlckdlbmVyYXRlUG9pbnRzXCIpfWdldFhFeHRyZW1lcyh0KXtyZXR1cm57bWluOmIodCksbWF4OnkodCl9fWdldEV4dHJlbWVzKHQsZSl7bGV0IGk9dGhpcy54QXhpcyxzPXRoaXMueUF4aXMsbz10aGlzLnByb2Nlc3NlZFhEYXRhfHx0aGlzLnhEYXRhLHI9W10sbj10aGlzLnJlcXVpcmVTb3J0aW5nJiYhdGhpcy5pcyhcImNvbHVtblwiKT8xOjAsYT0hIXMmJnMucG9zaXRpdmVWYWx1ZXNPbmx5LGgsbCxkLGMscCx1LGcsZj0wLG09MCx4PTA7dD10fHx0aGlzLnN0YWNrZWRZRGF0YXx8dGhpcy5wcm9jZXNzZWRZRGF0YXx8W107bGV0IHY9dC5sZW5ndGg7Zm9yKGkmJihmPShoPWkuZ2V0RXh0cmVtZXMoKSkubWluLG09aC5tYXgpLHU9MDt1PHY7dSsrKWlmKGM9b1t1XSxsPShJKHA9dFt1XSl8fGoocCkpJiYoKEkocCk/cD4wOnAubGVuZ3RoKXx8IWEpLGQ9ZXx8dGhpcy5nZXRFeHRyZW1lc0Zyb21BbGx8fHRoaXMub3B0aW9ucy5nZXRFeHRyZW1lc0Zyb21BbGx8fHRoaXMuY3JvcHBlZHx8IWl8fChvW3Urbl18fGMpPj1mJiYob1t1LW5dfHxjKTw9bSxsJiZkKXtpZihnPXAubGVuZ3RoKWZvcig7Zy0tOylJKHBbZ10pJiYoclt4KytdPXBbZ10pO2Vsc2Ugclt4KytdPXB9bGV0IFM9e2FjdGl2ZVlEYXRhOnIsZGF0YU1pbjpiKHIpLGRhdGFNYXg6eShyKX07cmV0dXJuIEwodGhpcyxcImFmdGVyR2V0RXh0cmVtZXNcIix7ZGF0YUV4dHJlbWVzOlN9KSxTfWFwcGx5RXh0cmVtZXMoKXtsZXQgdD10aGlzLmdldEV4dHJlbWVzKCk7cmV0dXJuIHRoaXMuZGF0YU1pbj10LmRhdGFNaW4sdGhpcy5kYXRhTWF4PXQuZGF0YU1heCx0fWdldEZpcnN0VmFsaWRQb2ludCh0KXtsZXQgZT10Lmxlbmd0aCxpPTAscz1udWxsO2Zvcig7bnVsbD09PXMmJmk8ZTspcz10W2ldLGkrKztyZXR1cm4gc310cmFuc2xhdGUoKXt0aGlzLnByb2Nlc3NlZFhEYXRhfHx0aGlzLnByb2Nlc3NEYXRhKCksdGhpcy5nZW5lcmF0ZVBvaW50cygpO2xldCB0PXRoaXMub3B0aW9ucyxlPXQuc3RhY2tpbmcsaT10aGlzLnhBeGlzLHM9aS5jYXRlZ29yaWVzLG89dGhpcy5lbmFibGVkRGF0YVNvcnRpbmcscj10aGlzLnlBeGlzLG49dGhpcy5wb2ludHMsYT1uLmxlbmd0aCxoPXRoaXMucG9pbnRQbGFjZW1lbnRUb1hWYWx1ZSgpLGw9ISFoLGQ9dC50aHJlc2hvbGQsYz10LnN0YXJ0RnJvbVRocmVzaG9sZD9kOjAscCx1LGcsZixtPU51bWJlci5NQVhfVkFMVUU7ZnVuY3Rpb24geCh0KXtyZXR1cm4gdih0LC0xZTUsMWU1KX1mb3IocD0wO3A8YTtwKyspe2xldCB0O2xldCBhPW5bcF0seT1hLngsYix2LE09YS55LEM9YS5sb3csdz1lJiZyLnN0YWNraW5nPy5zdGFja3NbKHRoaXMubmVnU3RhY2tzJiZNPChjPzA6ZCk/XCItXCI6XCJcIikrdGhpcy5zdGFja0tleV07dT1pLnRyYW5zbGF0ZSh5LCExLCExLCExLCEwLGgpLGEucGxvdFg9SSh1KT9TKHgodSkpOnZvaWQgMCxlJiZ0aGlzLnZpc2libGUmJncmJndbeV0mJihmPXRoaXMuZ2V0U3RhY2tJbmRpY2F0b3IoZix5LHRoaXMuaW5kZXgpLCFhLmlzTnVsbCYmZi5rZXkmJih2PShiPXdbeV0pLnBvaW50c1tmLmtleV0pLGImJmoodikmJihDPXZbMF0sTT12WzFdLEM9PT1jJiZmLmtleT09PXdbeV0uYmFzZSYmKEM9TihJKGQpP2Q6ci5taW4pKSxyLnBvc2l0aXZlVmFsdWVzT25seSYmayhDKSYmQzw9MCYmKEM9dm9pZCAwKSxhLnRvdGFsPWEuc3RhY2tUb3RhbD1OKGIudG90YWwpLGEucGVyY2VudGFnZT1rKGEueSkmJmIudG90YWw/YS55L2IudG90YWwqMTAwOnZvaWQgMCxhLnN0YWNrWT1NLHRoaXMuaXJyZWd1bGFyV2lkdGhzfHxiLnNldE9mZnNldCh0aGlzLnBvaW50WE9mZnNldHx8MCx0aGlzLmJhcld8fDAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdGhpcy54QXhpcykpKSxhLnlCb3R0b209ayhDKT94KHIudHJhbnNsYXRlKEMsITEsITAsITEsITApKTp2b2lkIDAsdGhpcy5kYXRhTW9kaWZ5JiYoTT10aGlzLmRhdGFNb2RpZnkubW9kaWZ5VmFsdWUoTSxwKSksSShNKSYmdm9pZCAwIT09YS5wbG90WCYmKHQ9SSh0PXIudHJhbnNsYXRlKE0sITEsITAsITEsITApKT94KHQpOnZvaWQgMCksYS5wbG90WT10LGEuaXNJbnNpZGU9dGhpcy5pc1BvaW50SW5zaWRlKGEpLGEuY2xpZW50WD1sP1MoaS50cmFuc2xhdGUoeSwhMSwhMSwhMSwhMCxoKSk6dSxhLm5lZ2F0aXZlPShhLnl8fDApPChkfHwwKSxhLmNhdGVnb3J5PU4ocyYmc1thLnhdLGEueCksYS5pc051bGx8fCExPT09YS52aXNpYmxlfHwodm9pZCAwIT09ZyYmKG09TWF0aC5taW4obSxNYXRoLmFicyh1LWcpKSksZz11KSxhLnpvbmU9dGhpcy56b25lcy5sZW5ndGg/YS5nZXRab25lKCk6dm9pZCAwLCFhLmdyYXBoaWMmJnRoaXMuZ3JvdXAmJm8mJihhLmlzTmV3PSEwKX10aGlzLmNsb3Nlc3RQb2ludFJhbmdlUHg9bSxMKHRoaXMsXCJhZnRlclRyYW5zbGF0ZVwiKX1nZXRWYWxpZFBvaW50cyh0LGUsaSl7bGV0IHM9dGhpcy5jaGFydDtyZXR1cm4odHx8dGhpcy5wb2ludHN8fFtdKS5maWx0ZXIoZnVuY3Rpb24odCl7bGV0e3Bsb3RYOm8scGxvdFk6cn09dCxuPSFpJiYodC5pc051bGx8fCFJKHIpKTtyZXR1cm4hbiYmKCFlfHwhIXMuaXNJbnNpZGVQbG90KG8scix7aW52ZXJ0ZWQ6cy5pbnZlcnRlZH0pKSYmITEhPT10LnZpc2libGV9KX1nZXRDbGlwQm94KCl7bGV0e2NoYXJ0OnQseEF4aXM6ZSx5QXhpczppfT10aGlzLHM9Uih0LmNsaXBCb3gpO3JldHVybiBlJiZlLmxlbiE9PXQucGxvdFNpemVYJiYocy53aWR0aD1lLmxlbiksaSYmaS5sZW4hPT10LnBsb3RTaXplWSYmKHMuaGVpZ2h0PWkubGVuKSxzfWdldFNoYXJlZENsaXBLZXkoKXtyZXR1cm4gdGhpcy5zaGFyZWRDbGlwS2V5PSh0aGlzLm9wdGlvbnMueEF4aXN8fDApK1wiLFwiKyh0aGlzLm9wdGlvbnMueUF4aXN8fDApLHRoaXMuc2hhcmVkQ2xpcEtleX1zZXRDbGlwKCl7bGV0e2NoYXJ0OnQsZ3JvdXA6ZSxtYXJrZXJHcm91cDppfT10aGlzLHM9dC5zaGFyZWRDbGlwcyxvPXQucmVuZGVyZXIscj10aGlzLmdldENsaXBCb3goKSxuPXRoaXMuZ2V0U2hhcmVkQ2xpcEtleSgpLGE9c1tuXTthP2EuYW5pbWF0ZShyKTpzW25dPWE9by5jbGlwUmVjdChyKSxlJiZlLmNsaXAoITE9PT10aGlzLm9wdGlvbnMuY2xpcD92b2lkIDA6YSksaSYmaS5jbGlwKCl9YW5pbWF0ZSh0KXtsZXR7Y2hhcnQ6ZSxncm91cDppLG1hcmtlckdyb3VwOnN9PXRoaXMsbz1lLmludmVydGVkLHI9ZCh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSxuPVt0aGlzLmdldFNoYXJlZENsaXBLZXkoKSxyLmR1cmF0aW9uLHIuZWFzaW5nLHIuZGVmZXJdLmpvaW4oXCIsXCIpLGE9ZS5zaGFyZWRDbGlwc1tuXSxoPWUuc2hhcmVkQ2xpcHNbbitcIm1cIl07aWYodCYmaSl7bGV0IHQ9dGhpcy5nZXRDbGlwQm94KCk7aWYoYSlhLmF0dHIoXCJoZWlnaHRcIix0LmhlaWdodCk7ZWxzZXt0LndpZHRoPTAsbyYmKHQueD1lLnBsb3RIZWlnaHQpLGE9ZS5yZW5kZXJlci5jbGlwUmVjdCh0KSxlLnNoYXJlZENsaXBzW25dPWE7bGV0IGk9e3g6LTk5LHk6LTk5LHdpZHRoOm8/ZS5wbG90V2lkdGgrMTk5Ojk5LGhlaWdodDpvPzk5OmUucGxvdEhlaWdodCsxOTl9O2g9ZS5yZW5kZXJlci5jbGlwUmVjdChpKSxlLnNoYXJlZENsaXBzW24rXCJtXCJdPWh9aS5jbGlwKGEpLHMmJnMuY2xpcChoKX1lbHNlIGlmKGEmJiFhLmhhc0NsYXNzKFwiaGlnaGNoYXJ0cy1hbmltYXRpbmdcIikpe2xldCB0PXRoaXMuZ2V0Q2xpcEJveCgpLGU9ci5zdGVwO3MmJnMuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCYmKHIuc3RlcD1mdW5jdGlvbih0LGkpe2UmJmUuYXBwbHkoaSxhcmd1bWVudHMpLFwid2lkdGhcIj09PWkucHJvcCYmaCYmaC5lbGVtZW50JiZoLmF0dHIobz9cImhlaWdodFwiOlwid2lkdGhcIix0Kzk5KX0pLGEuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWFuaW1hdGluZ1wiKS5hbmltYXRlKHQscil9fWFmdGVyQW5pbWF0ZSgpe3RoaXMuc2V0Q2xpcCgpLHoodGhpcy5jaGFydC5zaGFyZWRDbGlwcywodCxlLGkpPT57dCYmIXRoaXMuY2hhcnQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYFtjbGlwLXBhdGg9XCJ1cmwoIyR7dC5pZH0pXCJdYCkmJih0LmRlc3Ryb3koKSxkZWxldGUgaVtlXSl9KSx0aGlzLmZpbmlzaGVkQW5pbWF0aW5nPSEwLEwodGhpcyxcImFmdGVyQW5pbWF0ZVwiKX1kcmF3UG9pbnRzKHQ9dGhpcy5wb2ludHMpe2xldCBlLGkscyxvLHIsbixhO2xldCBoPXRoaXMuY2hhcnQsbD1oLnN0eWxlZE1vZGUse2NvbG9yQXhpczpkLG9wdGlvbnM6Y309dGhpcyxwPWMubWFya2VyLHU9dGhpc1t0aGlzLnNwZWNpYWxHcm91cHx8XCJtYXJrZXJHcm91cFwiXSxnPXRoaXMueEF4aXMsZj1OKHAuZW5hYmxlZCwhZ3x8ISFnLmlzUmFkaWFsfHxudWxsLHRoaXMuY2xvc2VzdFBvaW50UmFuZ2VQeD49cC5lbmFibGVkVGhyZXNob2xkKnAucmFkaXVzKTtpZighMSE9PXAuZW5hYmxlZHx8dGhpcy5faGFzUG9pbnRNYXJrZXJzKWZvcihlPTA7ZTx0Lmxlbmd0aDtlKyspe289KHM9KGk9dFtlXSkuZ3JhcGhpYyk/XCJhbmltYXRlXCI6XCJhdHRyXCIscj1pLm1hcmtlcnx8e30sbj0hIWkubWFya2VyO2xldCBjPShmJiZ2b2lkIDA9PT1yLmVuYWJsZWR8fHIuZW5hYmxlZCkmJiFpLmlzTnVsbCYmITEhPT1pLnZpc2libGU7aWYoYyl7bGV0IHQ9TihyLnN5bWJvbCx0aGlzLnN5bWJvbCxcInJlY3RcIik7YT10aGlzLm1hcmtlckF0dHJpYnMoaSxpLnNlbGVjdGVkJiZcInNlbGVjdFwiKSx0aGlzLmVuYWJsZWREYXRhU29ydGluZyYmKGkuc3RhcnRYUG9zPWcucmV2ZXJzZWQ/LShhLndpZHRofHwwKTpnLndpZHRoKTtsZXQgZT0hMSE9PWkuaXNJbnNpZGU7aWYoIXMmJmUmJigoYS53aWR0aHx8MCk+MHx8aS5oYXNJbWFnZSkmJihpLmdyYXBoaWM9cz1oLnJlbmRlcmVyLnN5bWJvbCh0LGEueCxhLnksYS53aWR0aCxhLmhlaWdodCxuP3I6cCkuYWRkKHUpLHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nJiZoLmhhc1JlbmRlcmVkJiYocy5hdHRyKHt4Omkuc3RhcnRYUG9zfSksbz1cImFuaW1hdGVcIikpLHMmJlwiYW5pbWF0ZVwiPT09byYmc1tlP1wic2hvd1wiOlwiaGlkZVwiXShlKS5hbmltYXRlKGEpLHMpe2xldCB0PXRoaXMucG9pbnRBdHRyaWJzKGksbHx8IWkuc2VsZWN0ZWQ/dm9pZCAwOlwic2VsZWN0XCIpO2w/ZCYmcy5jc3Moe2ZpbGw6dC5maWxsfSk6c1tvXSh0KX1zJiZzLmFkZENsYXNzKGkuZ2V0Q2xhc3NOYW1lKCksITApfWVsc2UgcyYmKGkuZ3JhcGhpYz1zLmRlc3Ryb3koKSl9fW1hcmtlckF0dHJpYnModCxlKXtsZXQgaT10aGlzLm9wdGlvbnMscz1pLm1hcmtlcixvPXQubWFya2VyfHx7fSxyPW8uc3ltYm9sfHxzLnN5bWJvbCxuPXt9LGEsaCxsPU4oby5yYWRpdXMscyYmcy5yYWRpdXMpO2UmJihhPXMuc3RhdGVzW2VdLGw9TigoaD1vLnN0YXRlcyYmby5zdGF0ZXNbZV0pJiZoLnJhZGl1cyxhJiZhLnJhZGl1cyxsJiZsKyhhJiZhLnJhZGl1c1BsdXN8fDApKSksdC5oYXNJbWFnZT1yJiYwPT09ci5pbmRleE9mKFwidXJsXCIpLHQuaGFzSW1hZ2UmJihsPTApO2xldCBkPXQucG9zKCk7cmV0dXJuIEkobCkmJmQmJihuLng9ZFswXS1sLG4ueT1kWzFdLWwsaS5jcmlzcCYmKG4ueD1NYXRoLmZsb29yKG4ueCkpKSxsJiYobi53aWR0aD1uLmhlaWdodD0yKmwpLG59cG9pbnRBdHRyaWJzKHQsZSl7bGV0IGk9dGhpcy5vcHRpb25zLm1hcmtlcixzPXQmJnQub3B0aW9ucyxvPXMmJnMubWFya2VyfHx7fSxyPXMmJnMuY29sb3Isbj10JiZ0LmNvbG9yLGE9dCYmdC56b25lJiZ0LnpvbmUuY29sb3IsaCxsLGQ9dGhpcy5jb2xvcixjLHAsdT1OKG8ubGluZVdpZHRoLGkubGluZVdpZHRoKSxnPTE7cmV0dXJuIGQ9cnx8YXx8bnx8ZCxjPW8uZmlsbENvbG9yfHxpLmZpbGxDb2xvcnx8ZCxwPW8ubGluZUNvbG9yfHxpLmxpbmVDb2xvcnx8ZCxlPWV8fFwibm9ybWFsXCIsaD1pLnN0YXRlc1tlXXx8e30sdT1OKChsPW8uc3RhdGVzJiZvLnN0YXRlc1tlXXx8e30pLmxpbmVXaWR0aCxoLmxpbmVXaWR0aCx1K04obC5saW5lV2lkdGhQbHVzLGgubGluZVdpZHRoUGx1cywwKSksYz1sLmZpbGxDb2xvcnx8aC5maWxsQ29sb3J8fGMse3N0cm9rZTpwPWwubGluZUNvbG9yfHxoLmxpbmVDb2xvcnx8cCxcInN0cm9rZS13aWR0aFwiOnUsZmlsbDpjLG9wYWNpdHk6Zz1OKGwub3BhY2l0eSxoLm9wYWNpdHksZyl9fWRlc3Ryb3kodCl7bGV0IGUsaSxzO2xldCBvPXRoaXMscj1vLmNoYXJ0LG49L0FwcGxlV2ViS2l0XFwvNTMzLy50ZXN0KG0ubmF2aWdhdG9yLnVzZXJBZ2VudCksYT1vLmRhdGF8fFtdO2ZvcihMKG8sXCJkZXN0cm95XCIse2tlZXBFdmVudHNGb3JVcGRhdGU6dH0pLHRoaXMucmVtb3ZlRXZlbnRzKHQpLChvLmF4aXNUeXBlc3x8W10pLmZvckVhY2goZnVuY3Rpb24odCl7KHM9b1t0XSkmJnMuc2VyaWVzJiYodyhzLnNlcmllcyxvKSxzLmlzRGlydHk9cy5mb3JjZVJlZHJhdz0hMCl9KSxvLmxlZ2VuZEl0ZW0mJm8uY2hhcnQubGVnZW5kLmRlc3Ryb3lJdGVtKG8pLGU9YS5sZW5ndGg7ZS0tOykoaT1hW2VdKSYmaS5kZXN0cm95JiZpLmRlc3Ryb3koKTtvLnpvbmVzLmZvckVhY2goTSksbC5jbGVhclRpbWVvdXQoby5hbmltYXRpb25UaW1lb3V0KSx6KG8sZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2YgaCYmIXQuc3Vydml2ZSYmdFtuJiZcImdyb3VwXCI9PT1lP1wiaGlkZVwiOlwiZGVzdHJveVwiXSgpfSksci5ob3ZlclNlcmllcz09PW8mJihyLmhvdmVyU2VyaWVzPXZvaWQgMCksdyhyLnNlcmllcyxvKSxyLm9yZGVySXRlbXMoXCJzZXJpZXNcIikseihvLGZ1bmN0aW9uKGUsaSl7dCYmXCJoY0V2ZW50c1wiPT09aXx8ZGVsZXRlIG9baV19KX1hcHBseVpvbmVzKCl7bGV0e2FyZWE6dCxjaGFydDplLGdyYXBoOmksem9uZXM6cyxwb2ludHM6byx4QXhpczpyLHlBeGlzOm4sem9uZUF4aXM6YX09dGhpcyx7aW52ZXJ0ZWQ6aCxyZW5kZXJlcjpsfT1lLGQ9dGhpc1tgJHthfUF4aXNgXSx7aXNYQXhpczpjLGxlbjpwPTB9PWR8fHt9LHU9KGk/LnN0cm9rZVdpZHRoKCl8fDApLzIrMSxnPSh0LGU9MCxpPTApPT57aCYmKGk9cC1pKTtsZXR7dHJhbnNsYXRlZDpzPTAsbGluZUNsaXA6b309dCxyPWktcztvPy5wdXNoKFtcIkxcIixlLE1hdGguYWJzKHIpPHU/aS11KihyPD0wPy0xOjEpOnNdKX07aWYocy5sZW5ndGgmJihpfHx0KSYmZCYmSShkLm1pbikpe2xldCBlPWQuZ2V0RXh0cmVtZXMoKS5tYXgsdT10PT57dC5mb3JFYWNoKChlLGkpPT57KFwiTVwiPT09ZVswXXx8XCJMXCI9PT1lWzBdKSYmKHRbaV09W2VbMF0sYz9wLWVbMV06ZVsxXSxjP2VbMl06cC1lWzJdXSl9KX07aWYocy5mb3JFYWNoKCh0LGkpPT57dC5saW5lQ2xpcD1bXSx0LnRyYW5zbGF0ZWQ9dihkLnRvUGl4ZWxzKE4odC52YWx1ZSxlKSwhMCl8fDAsMCxwKX0pLGkmJiF0aGlzLnNob3dMaW5lJiZpLmhpZGUoKSx0JiZ0LmhpZGUoKSxcInlcIj09PWEmJm8ubGVuZ3RoPHIubGVuKWZvcihsZXQgdCBvZiBvKXtsZXR7cGxvdFg6ZSxwbG90WTppLHpvbmU6b309dCxyPW8mJnNbcy5pbmRleE9mKG8pLTFdO28mJmcobyxlLGkpLHImJmcocixlLGkpfWxldCBmPVtdLG09ZC50b1BpeGVscyhkLmdldEV4dHJlbWVzKCkubWluLCEwKTtzLmZvckVhY2goZT0+e2xldCBzPWUubGluZUNsaXB8fFtdLG89TWF0aC5yb3VuZChlLnRyYW5zbGF0ZWR8fDApO3IucmV2ZXJzZWQmJnMucmV2ZXJzZSgpO2xldHtjbGlwOmEsc2ltcGxlQ2xpcDpkfT1lLHA9MCxnPTAseD1yLmxlbix5PW4ubGVuO2M/KHA9byx4PW0pOihnPW8seT1tKTtsZXQgYj1bW1wiTVwiLHAsZ10sW1wiTFwiLHgsZ10sW1wiTFwiLHgseV0sW1wiTFwiLHAseV0sW1wiWlwiXV0sdj1bYlswXSwuLi5zLGJbMV0sYlsyXSwuLi5mLGJbM10sYls0XV07Zj1zLnJldmVyc2UoKSxtPW8saCYmKHUodiksdCYmdShiKSksYT8oYS5hbmltYXRlKHtkOnZ9KSxkPy5hbmltYXRlKHtkOmJ9KSk6KGE9ZS5jbGlwPWwucGF0aCh2KSx0JiYoZD1lLnNpbXBsZUNsaXA9bC5wYXRoKGIpKSksaSYmZS5ncmFwaD8uY2xpcChhKSx0JiZlLmFyZWE/LmNsaXAoZCl9KX1lbHNlIHRoaXMudmlzaWJsZSYmKGkmJmkuc2hvdygpLHQmJnQuc2hvdygpKX1wbG90R3JvdXAodCxlLGkscyxvKXtsZXQgcj10aGlzW3RdLG49IXIsYT17dmlzaWJpbGl0eTppLHpJbmRleDpzfHwuMX07cmV0dXJuIGsodGhpcy5vcGFjaXR5KSYmIXRoaXMuY2hhcnQuc3R5bGVkTW9kZSYmXCJpbmFjdGl2ZVwiIT09dGhpcy5zdGF0ZSYmKGEub3BhY2l0eT10aGlzLm9wYWNpdHkpLHJ8fCh0aGlzW3RdPXI9dGhpcy5jaGFydC5yZW5kZXJlci5nKCkuYWRkKG8pKSxyLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIitlK1wiIGhpZ2hjaGFydHMtc2VyaWVzLVwiK3RoaXMuaW5kZXgrXCIgaGlnaGNoYXJ0cy1cIit0aGlzLnR5cGUrXCItc2VyaWVzIFwiKyhrKHRoaXMuY29sb3JJbmRleCk/XCJoaWdoY2hhcnRzLWNvbG9yLVwiK3RoaXMuY29sb3JJbmRleCtcIiBcIjpcIlwiKSsodGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIikrKHIuaGFzQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIik/XCIgaGlnaGNoYXJ0cy10cmFja2VyXCI6XCJcIiksITApLHIuYXR0cihhKVtuP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh0aGlzLmdldFBsb3RCb3goZSkpLHJ9Z2V0UGxvdEJveCh0KXtsZXQgZT10aGlzLnhBeGlzLGk9dGhpcy55QXhpcyxzPXRoaXMuY2hhcnQsbz1zLmludmVydGVkJiYhcy5wb2xhciYmZSYmITEhPT10aGlzLmludmVydGlibGUmJlwic2VyaWVzXCI9PT10O3JldHVybiBzLmludmVydGVkJiYoZT1pLGk9dGhpcy54QXhpcykse3RyYW5zbGF0ZVg6ZT9lLmxlZnQ6cy5wbG90TGVmdCx0cmFuc2xhdGVZOmk/aS50b3A6cy5wbG90VG9wLHJvdGF0aW9uOm8/OTA6MCxyb3RhdGlvbk9yaWdpblg6bz8oZS5sZW4taS5sZW4pLzI6MCxyb3RhdGlvbk9yaWdpblk6bz8oZS5sZW4raS5sZW4pLzI6MCxzY2FsZVg6bz8tMToxLHNjYWxlWToxfX1yZW1vdmVFdmVudHModCl7bGV0e2V2ZW50c1RvVW5iaW5kOmV9PXRoaXM7dHx8Vyh0aGlzKSxlLmxlbmd0aCYmKGUuZm9yRWFjaCh0PT57dCgpfSksZS5sZW5ndGg9MCl9cmVuZGVyKCl7bGV0IHQ9dGhpcyx7Y2hhcnQ6ZSxvcHRpb25zOmksaGFzUmVuZGVyZWQ6c309dCxvPWQoaS5hbmltYXRpb24pLHI9dC52aXNpYmxlP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsbj1pLnpJbmRleCxhPWUuc2VyaWVzR3JvdXAsaD10LmZpbmlzaGVkQW5pbWF0aW5nPzA6by5kdXJhdGlvbjtMKHRoaXMsXCJyZW5kZXJcIiksdC5wbG90R3JvdXAoXCJncm91cFwiLFwic2VyaWVzXCIscixuLGEpLHQubWFya2VyR3JvdXA9dC5wbG90R3JvdXAoXCJtYXJrZXJHcm91cFwiLFwibWFya2Vyc1wiLHIsbixhKSwhMSE9PWkuY2xpcCYmdC5zZXRDbGlwKCksaCYmdC5hbmltYXRlPy4oITApLHQuZHJhd0dyYXBoJiYodC5kcmF3R3JhcGgoKSx0LmFwcGx5Wm9uZXMoKSksdC52aXNpYmxlJiZ0LmRyYXdQb2ludHMoKSx0LmRyYXdEYXRhTGFiZWxzPy4oKSx0LnJlZHJhd1BvaW50cz8uKCksaS5lbmFibGVNb3VzZVRyYWNraW5nJiZ0LmRyYXdUcmFja2VyPy4oKSxoJiZ0LmFuaW1hdGU/LigpLHN8fChoJiZvLmRlZmVyJiYoaCs9by5kZWZlciksdC5hbmltYXRpb25UaW1lb3V0PUgoKCk9Pnt0LmFmdGVyQW5pbWF0ZSgpfSxofHwwKSksdC5pc0RpcnR5PSExLHQuaGFzUmVuZGVyZWQ9ITAsTCh0LFwiYWZ0ZXJSZW5kZXJcIil9cmVkcmF3KCl7bGV0IHQ9dGhpcy5pc0RpcnR5fHx0aGlzLmlzRGlydHlEYXRhO3RoaXMudHJhbnNsYXRlKCksdGhpcy5yZW5kZXIoKSx0JiZkZWxldGUgdGhpcy5rZFRyZWV9cmVzZXJ2ZVNwYWNlKCl7cmV0dXJuIHRoaXMudmlzaWJsZXx8IXRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXN9c2VhcmNoUG9pbnQodCxlKXtsZXR7eEF4aXM6aSx5QXhpczpzfT10aGlzLG89dGhpcy5jaGFydC5pbnZlcnRlZDtyZXR1cm4gdGhpcy5zZWFyY2hLRFRyZWUoe2NsaWVudFg6bz9pLmxlbi10LmNoYXJ0WStpLnBvczp0LmNoYXJ0WC1pLnBvcyxwbG90WTpvP3MubGVuLXQuY2hhcnRYK3MucG9zOnQuY2hhcnRZLXMucG9zfSxlLHQpfWJ1aWxkS0RUcmVlKHQpe3RoaXMuYnVpbGRpbmdLZFRyZWU9ITA7bGV0IGU9dGhpcyxpPWUub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik+LTE/MjoxO2RlbGV0ZSBlLmtkVHJlZSxIKGZ1bmN0aW9uKCl7ZS5rZFRyZWU9ZnVuY3Rpb24gdChpLHMsbyl7bGV0IHIsbjtsZXQgYT1pPy5sZW5ndGg7aWYoYSlyZXR1cm4gcj1lLmtkQXhpc0FycmF5W3Mlb10saS5zb3J0KCh0LGUpPT4odFtyXXx8MCktKGVbcl18fDApKSx7cG9pbnQ6aVtuPU1hdGguZmxvb3IoYS8yKV0sbGVmdDp0KGkuc2xpY2UoMCxuKSxzKzEsbykscmlnaHQ6dChpLnNsaWNlKG4rMSkscysxLG8pfX0oZS5nZXRWYWxpZFBvaW50cyh2b2lkIDAsIWUuZGlyZWN0VG91Y2gpLGksaSksZS5idWlsZGluZ0tkVHJlZT0hMX0sZS5vcHRpb25zLmtkTm93fHx0Py50eXBlPT09XCJ0b3VjaHN0YXJ0XCI/MDoxKX1zZWFyY2hLRFRyZWUodCxlLGkpe2xldCBzPXRoaXMsW28scl09dGhpcy5rZEF4aXNBcnJheSxuPWU/XCJkaXN0WFwiOlwiZGlzdFwiLGE9KHMub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50Qnl8fFwiXCIpLmluZGV4T2YoXCJ5XCIpPi0xPzI6MSxoPSEhcy5pc0J1YmJsZTtpZih0aGlzLmtkVHJlZXx8dGhpcy5idWlsZGluZ0tkVHJlZXx8dGhpcy5idWlsZEtEVHJlZShpKSx0aGlzLmtkVHJlZSlyZXR1cm4gZnVuY3Rpb24gdChlLGksYSxsKXtsZXQgZD1pLnBvaW50LGM9cy5rZEF4aXNBcnJheVthJWxdLHAsdSxnPWQ7IWZ1bmN0aW9uKHQsZSl7bGV0IGk9dFtvXSxzPWVbb10sbj1rKGkpJiZrKHMpP2ktczpudWxsLGE9dFtyXSxsPWVbcl0sZD1rKGEpJiZrKGwpP2EtbDowLGM9aCYmZS5tYXJrZXI/LnJhZGl1c3x8MDtlLmRpc3Q9TWF0aC5zcXJ0KChuJiZuKm58fDApK2QqZCktYyxlLmRpc3RYPWsobik/TWF0aC5hYnMobiktYzpOdW1iZXIuTUFYX1ZBTFVFfShlLGQpO2xldCBmPShlW2NdfHwwKS0oZFtjXXx8MCkrKGgmJmQubWFya2VyPy5yYWRpdXN8fDApLG09ZjwwP1wibGVmdFwiOlwicmlnaHRcIix4PWY8MD9cInJpZ2h0XCI6XCJsZWZ0XCI7cmV0dXJuIGlbbV0mJihnPShwPXQoZSxpW21dLGErMSxsKSlbbl08Z1tuXT9wOmQpLGlbeF0mJk1hdGguc3FydChmKmYpPGdbbl0mJihnPSh1PXQoZSxpW3hdLGErMSxsKSlbbl08Z1tuXT91OmcpLGd9KHQsdGhpcy5rZFRyZWUsYSxhKX1wb2ludFBsYWNlbWVudFRvWFZhbHVlKCl7bGV0e29wdGlvbnM6dCx4QXhpczplfT10aGlzLGk9dC5wb2ludFBsYWNlbWVudDtyZXR1cm5cImJldHdlZW5cIj09PWkmJihpPWUucmV2ZXJzZWQ/LS41Oi41KSxJKGkpP2kqKHQucG9pbnRSYW5nZXx8ZS5wb2ludFJhbmdlKTowfWlzUG9pbnRJbnNpZGUodCl7bGV0e2NoYXJ0OmUseEF4aXM6aSx5QXhpczpzfT10aGlzLHtwbG90WDpvPS0xLHBsb3RZOnI9LTF9PXQsbj1yPj0wJiZyPD0ocz9zLmxlbjplLnBsb3RIZWlnaHQpJiZvPj0wJiZvPD0oaT9pLmxlbjplLnBsb3RXaWR0aCk7cmV0dXJuIG59ZHJhd1RyYWNrZXIoKXtsZXQgdD10aGlzLGU9dC5vcHRpb25zLGk9ZS50cmFja0J5QXJlYSxzPVtdLmNvbmNhdCgoaT90LmFyZWFQYXRoOnQuZ3JhcGhQYXRoKXx8W10pLG89dC5jaGFydCxyPW8ucG9pbnRlcixuPW8ucmVuZGVyZXIsYT1vLm9wdGlvbnMudG9vbHRpcD8uc25hcHx8MCxoPSgpPT57ZS5lbmFibGVNb3VzZVRyYWNraW5nJiZvLmhvdmVyU2VyaWVzIT09dCYmdC5vbk1vdXNlT3ZlcigpfSxsPVwicmdiYSgxOTIsMTkyLDE5MixcIisoZj8xZS00Oi4wMDIpK1wiKVwiLGQ9dC50cmFja2VyO2Q/ZC5hdHRyKHtkOnN9KTp0LmdyYXBoJiYodC50cmFja2VyPWQ9bi5wYXRoKHMpLmF0dHIoe3Zpc2liaWxpdHk6dC52aXNpYmxlP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsekluZGV4OjJ9KS5hZGRDbGFzcyhpP1wiaGlnaGNoYXJ0cy10cmFja2VyLWFyZWFcIjpcImhpZ2hjaGFydHMtdHJhY2tlci1saW5lXCIpLmFkZCh0Lmdyb3VwKSxvLnN0eWxlZE1vZGV8fGQuYXR0cih7XCJzdHJva2UtbGluZWNhcFwiOlwicm91bmRcIixcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIixzdHJva2U6bCxmaWxsOmk/bDpcIm5vbmVcIixcInN0cm9rZS13aWR0aFwiOnQuZ3JhcGguc3Ryb2tlV2lkdGgoKSsoaT8wOjIqYSl9KSxbdC50cmFja2VyLHQubWFya2VyR3JvdXAsdC5kYXRhTGFiZWxzR3JvdXBdLmZvckVhY2godD0+e3QmJih0LmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIsaCkub24oXCJtb3VzZW91dFwiLHQ9PntyLm9uVHJhY2tlck1vdXNlT3V0KHQpfSksZS5jdXJzb3ImJiFvLnN0eWxlZE1vZGUmJnQuY3NzKHtjdXJzb3I6ZS5jdXJzb3J9KSxnJiZ0Lm9uKFwidG91Y2hzdGFydFwiLGgpKX0pKSxMKHRoaXMsXCJhZnRlckRyYXdUcmFja2VyXCIpfWFkZFBvaW50KHQsZSxpLHMsbyl7bGV0IHIsbjtsZXQgYT10aGlzLm9wdGlvbnMsaD10aGlzLmRhdGEsbD10aGlzLmNoYXJ0LGQ9dGhpcy54QXhpcyxjPWQmJmQuaGFzTmFtZXMmJmQubmFtZXMscD1hLmRhdGEsdT10aGlzLnhEYXRhO2U9TihlLCEwKTtsZXQgZz17c2VyaWVzOnRoaXN9O3RoaXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KGcsW3RdKTtsZXQgZj1nLng7aWYobj11Lmxlbmd0aCx0aGlzLnJlcXVpcmVTb3J0aW5nJiZmPHVbbi0xXSlmb3Iocj0hMDtuJiZ1W24tMV0+Zjspbi0tO3RoaXMudXBkYXRlUGFyYWxsZWxBcnJheXMoZyxcInNwbGljZVwiLFtuLDAsMF0pLHRoaXMudXBkYXRlUGFyYWxsZWxBcnJheXMoZyxuKSxjJiZnLm5hbWUmJihjW2ZdPWcubmFtZSkscC5zcGxpY2UobiwwLHQpLChyfHx0aGlzLnByb2Nlc3NlZERhdGEpJiYodGhpcy5kYXRhLnNwbGljZShuLDAsbnVsbCksdGhpcy5wcm9jZXNzRGF0YSgpKSxcInBvaW50XCI9PT1hLmxlZ2VuZFR5cGUmJnRoaXMuZ2VuZXJhdGVQb2ludHMoKSxpJiYoaFswXSYmaFswXS5yZW1vdmU/aFswXS5yZW1vdmUoITEpOihoLnNoaWZ0KCksdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyhnLFwic2hpZnRcIikscC5zaGlmdCgpKSksITEhPT1vJiZMKHRoaXMsXCJhZGRQb2ludFwiLHtwb2ludDpnfSksdGhpcy5pc0RpcnR5PSEwLHRoaXMuaXNEaXJ0eURhdGE9ITAsZSYmbC5yZWRyYXcocyl9cmVtb3ZlUG9pbnQodCxlLGkpe2xldCBzPXRoaXMsbz1zLmRhdGEscj1vW3RdLG49cy5wb2ludHMsYT1zLmNoYXJ0LGg9ZnVuY3Rpb24oKXtuJiZuLmxlbmd0aD09PW8ubGVuZ3RoJiZuLnNwbGljZSh0LDEpLG8uc3BsaWNlKHQsMSkscy5vcHRpb25zLmRhdGEuc3BsaWNlKHQsMSkscy51cGRhdGVQYXJhbGxlbEFycmF5cyhyfHx7c2VyaWVzOnN9LFwic3BsaWNlXCIsW3QsMV0pLHImJnIuZGVzdHJveSgpLHMuaXNEaXJ0eT0hMCxzLmlzRGlydHlEYXRhPSEwLGUmJmEucmVkcmF3KCl9O2MoaSxhKSxlPU4oZSwhMCkscj9yLmZpcmVQb2ludEV2ZW50KFwicmVtb3ZlXCIsbnVsbCxoKTpoKCl9cmVtb3ZlKHQsZSxpLHMpe2xldCBvPXRoaXMscj1vLmNoYXJ0O2Z1bmN0aW9uIG4oKXtvLmRlc3Ryb3kocyksci5pc0RpcnR5TGVnZW5kPXIuaXNEaXJ0eUJveD0hMCxyLmxpbmtTZXJpZXMocyksTih0LCEwKSYmci5yZWRyYXcoZSl9ITEhPT1pP0wobyxcInJlbW92ZVwiLG51bGwsbik6bigpfXVwZGF0ZSh0LGUpe0wodGhpcyxcInVwZGF0ZVwiLHtvcHRpb25zOnQ9Qyh0LHRoaXMudXNlck9wdGlvbnMpfSk7bGV0IGk9dGhpcyxzPWkuY2hhcnQsbz1pLnVzZXJPcHRpb25zLHI9aS5pbml0aWFsVHlwZXx8aS50eXBlLG49cy5vcHRpb25zLnBsb3RPcHRpb25zLGE9eFtyXS5wcm90b3R5cGUsaD1pLmZpbmlzaGVkQW5pbWF0aW5nJiZ7YW5pbWF0aW9uOiExfSxsPXt9LGQsYyxwPVtcImNvbG9ySW5kZXhcIixcImV2ZW50T3B0aW9uc1wiLFwibmF2aWdhdG9yU2VyaWVzXCIsXCJzeW1ib2xJbmRleFwiLFwiYmFzZVNlcmllc1wiXSx1PXQudHlwZXx8by50eXBlfHxzLm9wdGlvbnMuY2hhcnQudHlwZSxnPSEodGhpcy5oYXNEZXJpdmVkRGF0YXx8dSYmdSE9PXRoaXMudHlwZXx8dm9pZCAwIT09dC5wb2ludFN0YXJ0fHx2b2lkIDAhPT10LnBvaW50SW50ZXJ2YWx8fHZvaWQgMCE9PXQucmVsYXRpdmVYVmFsdWV8fHQuam9pbkJ5fHx0Lm1hcERhdGF8fFtcImRhdGFHcm91cGluZ1wiLFwicG9pbnRTdGFydFwiLFwicG9pbnRJbnRlcnZhbFwiLFwicG9pbnRJbnRlcnZhbFVuaXRcIixcImtleXNcIl0uc29tZSh0PT5pLmhhc09wdGlvbkNoYW5nZWQodCkpKTt1PXV8fHIsZyYmKHAucHVzaChcImRhdGFcIixcImlzRGlydHlEYXRhXCIsXCJpc0RpcnR5Q2FudmFzXCIsXCJwb2ludHNcIixcInByb2Nlc3NlZERhdGFcIixcInByb2Nlc3NlZFhEYXRhXCIsXCJwcm9jZXNzZWRZRGF0YVwiLFwieEluY3JlbWVudFwiLFwiY3JvcHBlZFwiLFwiX2hhc1BvaW50TWFya2Vyc1wiLFwiaGFzRGF0YUxhYmVsc1wiLFwibm9kZXNcIixcImxheW91dFwiLFwibGV2ZWxcIixcIm1hcE1hcFwiLFwibWFwRGF0YVwiLFwibWluWVwiLFwibWF4WVwiLFwibWluWFwiLFwibWF4WFwiKSwhMSE9PXQudmlzaWJsZSYmcC5wdXNoKFwiYXJlYVwiLFwiZ3JhcGhcIiksaS5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3AucHVzaCh0K1wiRGF0YVwiKX0pLHQuZGF0YSYmKHQuZGF0YVNvcnRpbmcmJkEoaS5vcHRpb25zLmRhdGFTb3J0aW5nLHQuZGF0YVNvcnRpbmcpLHRoaXMuc2V0RGF0YSh0LmRhdGEsITEpKSksdD1SKG8se2luZGV4OnZvaWQgMD09PW8uaW5kZXg/aS5pbmRleDpvLmluZGV4LHBvaW50U3RhcnQ6bj8uc2VyaWVzPy5wb2ludFN0YXJ0Pz9vLnBvaW50U3RhcnQ/P2kueERhdGE/LlswXX0sIWcmJntkYXRhOmkub3B0aW9ucy5kYXRhfSx0LGgpLGcmJnQuZGF0YSYmKHQuZGF0YT1pLm9wdGlvbnMuZGF0YSksKHA9W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIixcInRyYW5zZm9ybUdyb3VwXCJdLmNvbmNhdChwKSkuZm9yRWFjaChmdW5jdGlvbih0KXtwW3RdPWlbdF0sZGVsZXRlIGlbdF19KTtsZXQgZj0hMTtpZih4W3VdKXtpZihmPXUhPT1pLnR5cGUsaS5yZW1vdmUoITEsITEsITEsITApLGYpe2lmKE9iamVjdC5zZXRQcm90b3R5cGVPZilPYmplY3Quc2V0UHJvdG90eXBlT2YoaSx4W3VdLnByb3RvdHlwZSk7ZWxzZXtsZXQgdD1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChpLFwiaGNFdmVudHNcIikmJmkuaGNFdmVudHM7Zm9yKGMgaW4gYSlpW2NdPXZvaWQgMDtBKGkseFt1XS5wcm90b3R5cGUpLHQ/aS5oY0V2ZW50cz10OmRlbGV0ZSBpLmhjRXZlbnRzfX19ZWxzZSBUKDE3LCEwLHMse21pc3NpbmdNb2R1bGVGb3I6dX0pO2lmKHAuZm9yRWFjaChmdW5jdGlvbih0KXtpW3RdPXBbdF19KSxpLmluaXQocyx0KSxnJiZ0aGlzLnBvaW50cylmb3IobGV0IHQgb2YoITE9PT0oZD1pLm9wdGlvbnMpLnZpc2libGU/KGwuZ3JhcGhpYz0xLGwuZGF0YUxhYmVsPTEpOih0aGlzLmhhc01hcmtlckNoYW5nZWQoZCxvKSYmKGwuZ3JhcGhpYz0xKSxpLmhhc0RhdGFMYWJlbHM/LigpfHwobC5kYXRhTGFiZWw9MSkpLHRoaXMucG9pbnRzKSl0JiZ0LnNlcmllcyYmKHQucmVzb2x2ZUNvbG9yKCksT2JqZWN0LmtleXMobCkubGVuZ3RoJiZ0LmRlc3Ryb3lFbGVtZW50cyhsKSwhMT09PWQuc2hvd0luTGVnZW5kJiZ0LmxlZ2VuZEl0ZW0mJnMubGVnZW5kLmRlc3Ryb3lJdGVtKHQpKTtpLmluaXRpYWxUeXBlPXIscy5saW5rU2VyaWVzKCkscy5zZXRTb3J0ZWREYXRhKCksZiYmaS5saW5rZWRTZXJpZXMubGVuZ3RoJiYoaS5pc0RpcnR5RGF0YT0hMCksTCh0aGlzLFwiYWZ0ZXJVcGRhdGVcIiksTihlLCEwKSYmcy5yZWRyYXcoISFnJiZ2b2lkIDApfXNldE5hbWUodCl7dGhpcy5uYW1lPXRoaXMub3B0aW9ucy5uYW1lPXRoaXMudXNlck9wdGlvbnMubmFtZT10LHRoaXMuY2hhcnQuaXNEaXJ0eUxlZ2VuZD0hMH1oYXNPcHRpb25DaGFuZ2VkKHQpe2xldCBlPXRoaXMuY2hhcnQsaT10aGlzLm9wdGlvbnNbdF0scz1lLm9wdGlvbnMucGxvdE9wdGlvbnMsbz10aGlzLnVzZXJPcHRpb25zW3RdLHI9TihzPy5bdGhpcy50eXBlXT8uW3RdLHM/LnNlcmllcz8uW3RdKTtyZXR1cm4gbyYmIWsocik/aSE9PW86aSE9PU4ocixpKX1vbk1vdXNlT3Zlcigpe2xldCB0PXRoaXMuY2hhcnQsZT10LmhvdmVyU2VyaWVzLGk9dC5wb2ludGVyO2kuc2V0SG92ZXJDaGFydEluZGV4KCksZSYmZSE9PXRoaXMmJmUub25Nb3VzZU91dCgpLHRoaXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyJiZMKHRoaXMsXCJtb3VzZU92ZXJcIiksdGhpcy5zZXRTdGF0ZShcImhvdmVyXCIpLHQuaG92ZXJTZXJpZXM9dGhpc31vbk1vdXNlT3V0KCl7bGV0IHQ9dGhpcy5vcHRpb25zLGU9dGhpcy5jaGFydCxpPWUudG9vbHRpcCxzPWUuaG92ZXJQb2ludDtlLmhvdmVyU2VyaWVzPW51bGwscyYmcy5vbk1vdXNlT3V0KCksdGhpcyYmdC5ldmVudHMubW91c2VPdXQmJkwodGhpcyxcIm1vdXNlT3V0XCIpLGkmJiF0aGlzLnN0aWNreVRyYWNraW5nJiYoIWkuc2hhcmVkfHx0aGlzLm5vU2hhcmVkVG9vbHRpcCkmJmkuaGlkZSgpLGUuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24odCl7dC5zZXRTdGF0ZShcIlwiLCEwKX0pfXNldFN0YXRlKHQsZSl7bGV0IGk9dGhpcyxzPWkub3B0aW9ucyxvPWkuZ3JhcGgscj1zLmluYWN0aXZlT3RoZXJQb2ludHMsbj1zLnN0YXRlcyxhPU4oblt0fHxcIm5vcm1hbFwiXSYmblt0fHxcIm5vcm1hbFwiXS5hbmltYXRpb24saS5jaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiksaD1zLmxpbmVXaWR0aCxsPXMub3BhY2l0eTtpZih0PXR8fFwiXCIsaS5zdGF0ZSE9PXQmJihbaS5ncm91cCxpLm1hcmtlckdyb3VwLGkuZGF0YUxhYmVsc0dyb3VwXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UmJihpLnN0YXRlJiZlLnJlbW92ZUNsYXNzKFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIraS5zdGF0ZSksdCYmZS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2VyaWVzLVwiK3QpKX0pLGkuc3RhdGU9dCwhaS5jaGFydC5zdHlsZWRNb2RlKSl7aWYoblt0XSYmITE9PT1uW3RdLmVuYWJsZWQpcmV0dXJuO2lmKHQmJihoPW5bdF0ubGluZVdpZHRofHxoKyhuW3RdLmxpbmVXaWR0aFBsdXN8fDApLGw9TihuW3RdLm9wYWNpdHksbCkpLG8mJiFvLmRhc2hzdHlsZSYmSShoKSlmb3IobGV0IHQgb2ZbbywuLi50aGlzLnpvbmVzLm1hcCh0PT50LmdyYXBoKV0pdD8uYW5pbWF0ZSh7XCJzdHJva2Utd2lkdGhcIjpofSxhKTtyfHxbaS5ncm91cCxpLm1hcmtlckdyb3VwLGkuZGF0YUxhYmVsc0dyb3VwLGkubGFiZWxCeVNlcmllc10uZm9yRWFjaChmdW5jdGlvbih0KXt0JiZ0LmFuaW1hdGUoe29wYWNpdHk6bH0sYSl9KX1lJiZyJiZpLnBvaW50cyYmaS5zZXRBbGxQb2ludHNUb1N0YXRlKHR8fHZvaWQgMCl9c2V0QWxsUG9pbnRzVG9TdGF0ZSh0KXt0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc2V0U3RhdGUmJmUuc2V0U3RhdGUodCl9KX1zZXRWaXNpYmxlKHQsZSl7bGV0IGk9dGhpcyxzPWkuY2hhcnQsbz1zLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLHI9aS52aXNpYmxlO2kudmlzaWJsZT10PWkub3B0aW9ucy52aXNpYmxlPWkudXNlck9wdGlvbnMudmlzaWJsZT12b2lkIDA9PT10PyFyOnQ7bGV0IG49dD9cInNob3dcIjpcImhpZGVcIjtbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCIsXCJtYXJrZXJHcm91cFwiLFwidHJhY2tlclwiLFwidHRcIl0uZm9yRWFjaCh0PT57aVt0XT8uW25dKCl9KSwocy5ob3ZlclNlcmllcz09PWl8fHMuaG92ZXJQb2ludD8uc2VyaWVzPT09aSkmJmkub25Nb3VzZU91dCgpLGkubGVnZW5kSXRlbSYmcy5sZWdlbmQuY29sb3JpemVJdGVtKGksdCksaS5pc0RpcnR5PSEwLGkub3B0aW9ucy5zdGFja2luZyYmcy5zZXJpZXMuZm9yRWFjaCh0PT57dC5vcHRpb25zLnN0YWNraW5nJiZ0LnZpc2libGUmJih0LmlzRGlydHk9ITApfSksaS5saW5rZWRTZXJpZXMuZm9yRWFjaChlPT57ZS5zZXRWaXNpYmxlKHQsITEpfSksbyYmKHMuaXNEaXJ0eUJveD0hMCksTChpLG4pLCExIT09ZSYmcy5yZWRyYXcoKX1zaG93KCl7dGhpcy5zZXRWaXNpYmxlKCEwKX1oaWRlKCl7dGhpcy5zZXRWaXNpYmxlKCExKX1zZWxlY3QodCl7dGhpcy5zZWxlY3RlZD10PXRoaXMub3B0aW9ucy5zZWxlY3RlZD12b2lkIDA9PT10PyF0aGlzLnNlbGVjdGVkOnQsdGhpcy5jaGVja2JveCYmKHRoaXMuY2hlY2tib3guY2hlY2tlZD10KSxMKHRoaXMsdD9cInNlbGVjdFwiOlwidW5zZWxlY3RcIil9c2hvdWxkU2hvd1Rvb2x0aXAodCxlLGk9e30pe3JldHVybiBpLnNlcmllcz10aGlzLGkudmlzaWJsZVBsb3RPbmx5PSEwLHRoaXMuY2hhcnQuaXNJbnNpZGVQbG90KHQsZSxpKX1kcmF3TGVnZW5kU3ltYm9sKHQsZSl7b1t0aGlzLm9wdGlvbnMubGVnZW5kU3ltYm9sfHxcInJlY3RhbmdsZVwiXT8uY2FsbCh0aGlzLHQsZSl9fXJldHVybiBYLmRlZmF1bHRPcHRpb25zPW4sWC50eXBlcz1hLnNlcmllc1R5cGVzLFgucmVnaXN0ZXJUeXBlPWEucmVnaXN0ZXJTZXJpZXNUeXBlLEEoWC5wcm90b3R5cGUse2F4aXNUeXBlczpbXCJ4QXhpc1wiLFwieUF4aXNcIl0sY29sbDpcInNlcmllc1wiLGNvbG9yQ291bnRlcjowLGRpcmVjdFRvdWNoOiExLGlzQ2FydGVzaWFuOiEwLGtkQXhpc0FycmF5OltcImNsaWVudFhcIixcInBsb3RZXCJdLHBhcmFsbGVsQXJyYXlzOltcInhcIixcInlcIl0scG9pbnRDbGFzczpyLHJlcXVpcmVTb3J0aW5nOiEwLHNvcnRlZDohMH0pLGEuc2VyaWVzPVgsWH0pLGkoZSxcIkNvcmUvQ2hhcnQvQ2hhcnQuanNcIixbZVtcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9BeGlzL0F4aXMuanNcIl0sZVtcIkNvcmUvRGVmYXVsdHMuanNcIl0sZVtcIkNvcmUvVGVtcGxhdGluZy5qc1wiXSxlW1wiQ29yZS9Gb3VuZGF0aW9uLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvUmVuZGVyZXJSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9TZXJpZXMvU2VyaWVzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHUmVuZGVyZXIuanNcIl0sZVtcIkNvcmUvVGltZS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvSFRNTC9BU1QuanNcIl0sZVtcIkNvcmUvQXhpcy9UaWNrLmpzXCJdXSxmdW5jdGlvbih0LGUsaSxzLG8scixuLGEsaCxsLGQsYyxwLHUpe2xldHthbmltYXRlOmcsYW5pbU9iamVjdDpmLHNldEFuaW1hdGlvbjptfT10LHtkZWZhdWx0T3B0aW9uczp4LGRlZmF1bHRUaW1lOnl9PWkse251bWJlckZvcm1hdDpifT1zLHtyZWdpc3RlckV2ZW50T3B0aW9uczp2fT1vLHtjaGFydHM6Uyxkb2M6ayxtYXJnaW5OYW1lczpNLHN2ZzpDLHdpbjp3fT1yLHtzZXJpZXNUeXBlczpUfT1oLHthZGRFdmVudDpBLGF0dHI6UCxjcmVhdGVFbGVtZW50OkwsY2xhbXA6Tyxjc3M6RCxkZWZpbmVkOkUsZGlmZk9iamVjdHM6aixkaXNjYXJkRWxlbWVudDpJLGVyYXNlOkIsZXJyb3I6UixleHRlbmQ6eixmaW5kOk4sZmlyZUV2ZW50OlcsZ2V0U3R5bGU6Ryxpc0FycmF5OkgsaXNOdW1iZXI6WCxpc09iamVjdDpGLGlzU3RyaW5nOlksbWVyZ2U6VSxvYmplY3RFYWNoOlYscGljazokLHBJbnQ6WixyZWxhdGl2ZUxlbmd0aDpfLHJlbW92ZUV2ZW50OnEsc3BsYXQ6SyxzeW5jVGltZW91dDpKLHVuaXF1ZUtleTpRfT1jO2NsYXNzIHR0e3N0YXRpYyBjaGFydCh0LGUsaSl7cmV0dXJuIG5ldyB0dCh0LGUsaSl9Y29uc3RydWN0b3IodCxlLGkpe3RoaXMuc2hhcmVkQ2xpcHM9e307bGV0IHM9Wy4uLmFyZ3VtZW50c107KFkodCl8fHQubm9kZU5hbWUpJiYodGhpcy5yZW5kZXJUbz1zLnNoaWZ0KCkpLHRoaXMuaW5pdChzWzBdLHNbMV0pfXNldFpvb21PcHRpb25zKCl7bGV0IHQ9dGhpcy5vcHRpb25zLmNoYXJ0LGU9dC56b29taW5nO3RoaXMuem9vbWluZz17Li4uZSx0eXBlOiQodC56b29tVHlwZSxlLnR5cGUpLGtleTokKHQuem9vbUtleSxlLmtleSkscGluY2hUeXBlOiQodC5waW5jaFR5cGUsZS5waW5jaFR5cGUpLHNpbmdsZVRvdWNoOiQodC56b29tQnlTaW5nbGVUb3VjaCxlLnNpbmdsZVRvdWNoLCExKSxyZXNldEJ1dHRvbjpVKGUucmVzZXRCdXR0b24sdC5yZXNldFpvb21CdXR0b24pfX1pbml0KHQsZSl7Vyh0aGlzLFwiaW5pdFwiLHthcmdzOmFyZ3VtZW50c30sZnVuY3Rpb24oKXtsZXQgaT1VKHgsdCkscz1pLmNoYXJ0O3RoaXMudXNlck9wdGlvbnM9eih7fSx0KSx0aGlzLm1hcmdpbj1bXSx0aGlzLnNwYWNpbmc9W10sdGhpcy5ib3VuZHM9e2g6e30sdjp7fX0sdGhpcy5sYWJlbENvbGxlY3RvcnM9W10sdGhpcy5jYWxsYmFjaz1lLHRoaXMuaXNSZXNpemluZz0wLHRoaXMub3B0aW9ucz1pLHRoaXMuYXhlcz1bXSx0aGlzLnNlcmllcz1bXSx0aGlzLnRpbWU9dC50aW1lJiZPYmplY3Qua2V5cyh0LnRpbWUpLmxlbmd0aD9uZXcgZCh0LnRpbWUpOnIudGltZSx0aGlzLm51bWJlckZvcm1hdHRlcj1zLm51bWJlckZvcm1hdHRlcnx8Yix0aGlzLnN0eWxlZE1vZGU9cy5zdHlsZWRNb2RlLHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzPXMuc2hvd0F4ZXMsdGhpcy5pbmRleD1TLmxlbmd0aCxTLnB1c2godGhpcyksci5jaGFydENvdW50Kyssdih0aGlzLHMpLHRoaXMueEF4aXM9W10sdGhpcy55QXhpcz1bXSx0aGlzLnBvaW50Q291bnQ9dGhpcy5jb2xvckNvdW50ZXI9dGhpcy5zeW1ib2xDb3VudGVyPTAsdGhpcy5zZXRab29tT3B0aW9ucygpLFcodGhpcyxcImFmdGVySW5pdFwiKSx0aGlzLmZpcnN0UmVuZGVyKCl9KX1pbml0U2VyaWVzKHQpe2xldCBlPXRoaXMub3B0aW9ucy5jaGFydCxpPXQudHlwZXx8ZS50eXBlLHM9VFtpXTtzfHxSKDE3LCEwLHRoaXMse21pc3NpbmdNb2R1bGVGb3I6aX0pO2xldCBvPW5ldyBzO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG8uaW5pdCYmby5pbml0KHRoaXMsdCksb31zZXRTb3J0ZWREYXRhKCl7dGhpcy5nZXRTZXJpZXNPcmRlckJ5TGlua3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucG9pbnRzfHx0LmRhdGF8fCF0LmVuYWJsZWREYXRhU29ydGluZ3x8dC5zZXREYXRhKHQub3B0aW9ucy5kYXRhLCExKX0pfWdldFNlcmllc09yZGVyQnlMaW5rcygpe3JldHVybiB0aGlzLnNlcmllcy5jb25jYXQoKS5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQubGlua2VkU2VyaWVzLmxlbmd0aHx8ZS5saW5rZWRTZXJpZXMubGVuZ3RoP2UubGlua2VkU2VyaWVzLmxlbmd0aC10LmxpbmtlZFNlcmllcy5sZW5ndGg6MH0pfW9yZGVySXRlbXModCxlPTApe2xldCBpPXRoaXNbdF0scz10aGlzLm9wdGlvbnNbdF09Syh0aGlzLm9wdGlvbnNbdF0pLnNsaWNlKCksbz10aGlzLnVzZXJPcHRpb25zW3RdPXRoaXMudXNlck9wdGlvbnNbdF0/Syh0aGlzLnVzZXJPcHRpb25zW3RdKS5zbGljZSgpOltdO2lmKHRoaXMuaGFzUmVuZGVyZWQmJihzLnNwbGljZShlKSxvLnNwbGljZShlKSksaSlmb3IobGV0IHQ9ZSxyPWkubGVuZ3RoO3Q8cjsrK3Qpe2xldCBlPWlbdF07ZSYmKGUuaW5kZXg9dCxlIGluc3RhbmNlb2YgYSYmKGUubmFtZT1lLmdldE5hbWUoKSksZS5vcHRpb25zLmlzSW50ZXJuYWx8fChzW3RdPWUub3B0aW9ucyxvW3RdPWUudXNlck9wdGlvbnMpKX19aXNJbnNpZGVQbG90KHQsZSxpPXt9KXtsZXR7aW52ZXJ0ZWQ6cyxwbG90Qm94Om8scGxvdExlZnQ6cixwbG90VG9wOm4sc2Nyb2xsYWJsZVBsb3RCb3g6YX09dGhpcyxoPTAsbD0wO2kudmlzaWJsZVBsb3RPbmx5JiZ0aGlzLnNjcm9sbGluZ0NvbnRhaW5lciYmKHtzY3JvbGxMZWZ0Omgsc2Nyb2xsVG9wOmx9PXRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyKTtsZXQgZD1pLnNlcmllcyxjPWkudmlzaWJsZVBsb3RPbmx5JiZhfHxvLHA9aS5pbnZlcnRlZD9lOnQsdT1pLmludmVydGVkP3Q6ZSxnPXt4OnAseTp1LGlzSW5zaWRlUGxvdDohMCxvcHRpb25zOml9O2lmKCFpLmlnbm9yZVgpe2xldCB0PWQmJihzJiYhdGhpcy5wb2xhcj9kLnlBeGlzOmQueEF4aXMpfHx7cG9zOnIsbGVuOjEvMH0sZT1pLnBhbmVDb29yZGluYXRlcz90LnBvcytwOnIrcDtlPj1NYXRoLm1heChoK3IsdC5wb3MpJiZlPD1NYXRoLm1pbihoK3IrYy53aWR0aCx0LnBvcyt0Lmxlbil8fChnLmlzSW5zaWRlUGxvdD0hMSl9aWYoIWkuaWdub3JlWSYmZy5pc0luc2lkZVBsb3Qpe2xldCB0PSFzJiZpLmF4aXMmJiFpLmF4aXMuaXNYQXhpcyYmaS5heGlzfHxkJiYocz9kLnhBeGlzOmQueUF4aXMpfHx7cG9zOm4sbGVuOjEvMH0sZT1pLnBhbmVDb29yZGluYXRlcz90LnBvcyt1Om4rdTtlPj1NYXRoLm1heChsK24sdC5wb3MpJiZlPD1NYXRoLm1pbihsK24rYy5oZWlnaHQsdC5wb3MrdC5sZW4pfHwoZy5pc0luc2lkZVBsb3Q9ITEpfXJldHVybiBXKHRoaXMsXCJhZnRlcklzSW5zaWRlUGxvdFwiLGcpLGcuaXNJbnNpZGVQbG90fXJlZHJhdyh0KXtXKHRoaXMsXCJiZWZvcmVSZWRyYXdcIik7bGV0IGU9dGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXM/dGhpcy5heGVzOnRoaXMuY29sb3JBeGlzfHxbXSxpPXRoaXMuc2VyaWVzLHM9dGhpcy5wb2ludGVyLG89dGhpcy5sZWdlbmQscj10aGlzLnVzZXJPcHRpb25zLmxlZ2VuZCxuPXRoaXMucmVuZGVyZXIsYT1uLmlzSGlkZGVuKCksaD1bXSxsLGQsYyxwPXRoaXMuaXNEaXJ0eUJveCx1PXRoaXMuaXNEaXJ0eUxlZ2VuZCxnO2ZvcihuLnJvb3RGb250U2l6ZT1uLmJveFdyYXBwZXIuZ2V0U3R5bGUoXCJmb250LXNpemVcIiksdGhpcy5zZXRSZXNwb25zaXZlJiZ0aGlzLnNldFJlc3BvbnNpdmUoITEpLG0oISF0aGlzLmhhc1JlbmRlcmVkJiZ0LHRoaXMpLGEmJnRoaXMudGVtcG9yYXJ5RGlzcGxheSgpLHRoaXMubGF5T3V0VGl0bGVzKCExKSxjPWkubGVuZ3RoO2MtLTspaWYoKChnPWlbY10pLm9wdGlvbnMuc3RhY2tpbmd8fGcub3B0aW9ucy5jZW50ZXJJbkNhdGVnb3J5KSYmKGQ9ITAsZy5pc0RpcnR5KSl7bD0hMDticmVha31pZihsKWZvcihjPWkubGVuZ3RoO2MtLTspKGc9aVtjXSkub3B0aW9ucy5zdGFja2luZyYmKGcuaXNEaXJ0eT0hMCk7aS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuaXNEaXJ0eSYmKFwicG9pbnRcIj09PXQub3B0aW9ucy5sZWdlbmRUeXBlPyhcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnVwZGF0ZVRvdGFscyYmdC51cGRhdGVUb3RhbHMoKSx1PSEwKTpyJiYoci5sYWJlbEZvcm1hdHRlcnx8ci5sYWJlbEZvcm1hdCkmJih1PSEwKSksdC5pc0RpcnR5RGF0YSYmVyh0LFwidXBkYXRlZERhdGFcIil9KSx1JiZvJiZvLm9wdGlvbnMuZW5hYmxlZCYmKG8ucmVuZGVyKCksdGhpcy5pc0RpcnR5TGVnZW5kPSExKSxkJiZ0aGlzLmdldFN0YWNrcygpLGUuZm9yRWFjaChmdW5jdGlvbih0KXt0LnVwZGF0ZU5hbWVzKCksdC5zZXRTY2FsZSgpfSksdGhpcy5nZXRNYXJnaW5zKCksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuaXNEaXJ0eSYmKHA9ITApfSksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldCBlPXQubWluK1wiLFwiK3QubWF4O3QuZXh0S2V5IT09ZSYmKHQuZXh0S2V5PWUsaC5wdXNoKGZ1bmN0aW9uKCl7Vyh0LFwiYWZ0ZXJTZXRFeHRyZW1lc1wiLHoodC5ldmVudEFyZ3MsdC5nZXRFeHRyZW1lcygpKSksZGVsZXRlIHQuZXZlbnRBcmdzfSkpLChwfHxkKSYmdC5yZWRyYXcoKX0pLHAmJnRoaXMuZHJhd0NoYXJ0Qm94KCksVyh0aGlzLFwicHJlZHJhd1wiKSxpLmZvckVhY2goZnVuY3Rpb24odCl7KHB8fHQuaXNEaXJ0eSkmJnQudmlzaWJsZSYmdC5yZWRyYXcoKSx0LmlzRGlydHlEYXRhPSExfSkscyYmcy5yZXNldCghMCksbi5kcmF3KCksVyh0aGlzLFwicmVkcmF3XCIpLFcodGhpcyxcInJlbmRlclwiKSxhJiZ0aGlzLnRlbXBvcmFyeURpc3BsYXkoITApLGguZm9yRWFjaChmdW5jdGlvbih0KXt0LmNhbGwoKX0pfWdldCh0KXtsZXQgZT10aGlzLnNlcmllcztmdW5jdGlvbiBpKGUpe3JldHVybiBlLmlkPT09dHx8ZS5vcHRpb25zJiZlLm9wdGlvbnMuaWQ9PT10fWxldCBzPU4odGhpcy5heGVzLGkpfHxOKHRoaXMuc2VyaWVzLGkpO2ZvcihsZXQgdD0wOyFzJiZ0PGUubGVuZ3RoO3QrKylzPU4oZVt0XS5wb2ludHN8fFtdLGkpO3JldHVybiBzfWdldEF4ZXMoKXtsZXQgdD10aGlzLnVzZXJPcHRpb25zO2ZvcihsZXQgaSBvZihXKHRoaXMsXCJnZXRBeGVzXCIpLFtcInhBeGlzXCIsXCJ5QXhpc1wiXSkpe2xldCBzPXRbaV09Syh0W2ldfHx7fSk7Zm9yKGxldCB0IG9mIHMpbmV3IGUodGhpcyx0LGkpfVcodGhpcyxcImFmdGVyR2V0QXhlc1wiKX1nZXRTZWxlY3RlZFBvaW50cygpe3JldHVybiB0aGlzLnNlcmllcy5yZWR1Y2UoKHQsZSk9PihlLmdldFBvaW50c0NvbGxlY3Rpb24oKS5mb3JFYWNoKGU9PnskKGUuc2VsZWN0ZWRTdGFnaW5nLGUuc2VsZWN0ZWQpJiZ0LnB1c2goZSl9KSx0KSxbXSl9Z2V0U2VsZWN0ZWRTZXJpZXMoKXtyZXR1cm4gdGhpcy5zZXJpZXMuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNlbGVjdGVkfSl9c2V0VGl0bGUodCxlLGkpe3RoaXMuYXBwbHlEZXNjcmlwdGlvbihcInRpdGxlXCIsdCksdGhpcy5hcHBseURlc2NyaXB0aW9uKFwic3VidGl0bGVcIixlKSx0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJjYXB0aW9uXCIsdm9pZCAwKSx0aGlzLmxheU91dFRpdGxlcyhpKX1hcHBseURlc2NyaXB0aW9uKHQsZSl7bGV0IGk9dGhpcyxzPXRoaXMub3B0aW9uc1t0XT1VKHRoaXMub3B0aW9uc1t0XSxlKSxvPXRoaXNbdF07byYmZSYmKHRoaXNbdF09bz1vLmRlc3Ryb3koKSkscyYmIW8mJigobz10aGlzLnJlbmRlcmVyLnRleHQocy50ZXh0LDAsMCxzLnVzZUhUTUwpLmF0dHIoe2FsaWduOnMuYWxpZ24sY2xhc3M6XCJoaWdoY2hhcnRzLVwiK3QsekluZGV4OnMuekluZGV4fHw0fSkuYWRkKCkpLnVwZGF0ZT1mdW5jdGlvbihlLHMpe2kuYXBwbHlEZXNjcmlwdGlvbih0LGUpLGkubGF5T3V0VGl0bGVzKHMpfSx0aGlzLnN0eWxlZE1vZGV8fG8uY3NzKHooXCJ0aXRsZVwiPT09dD97Zm9udFNpemU6dGhpcy5vcHRpb25zLmlzU3RvY2s/XCIxZW1cIjpcIjEuMmVtXCJ9Ont9LHMuc3R5bGUpKSx0aGlzW3RdPW8pfWxheU91dFRpdGxlcyh0PSEwKXtsZXQgZT1bMCwwLDBdLGk9dGhpcy5yZW5kZXJlcixzPXRoaXMuc3BhY2luZ0JveDtbXCJ0aXRsZVwiLFwic3VidGl0bGVcIixcImNhcHRpb25cIl0uZm9yRWFjaChmdW5jdGlvbih0KXtsZXQgbz10aGlzW3RdLHI9dGhpcy5vcHRpb25zW3RdLG49ci52ZXJ0aWNhbEFsaWdufHxcInRvcFwiLGE9XCJ0aXRsZVwiPT09dD9cInRvcFwiPT09bj8tMzowOlwidG9wXCI9PT1uP2VbMF0rMjowO2lmKG8pe28uY3NzKHt3aWR0aDooci53aWR0aHx8cy53aWR0aCsoci53aWR0aEFkanVzdHx8MCkpK1wicHhcIn0pO2xldCB0PWkuZm9udE1ldHJpY3MobykuYixoPU1hdGgucm91bmQoby5nZXRCQm94KHIudXNlSFRNTCkuaGVpZ2h0KTtvLmFsaWduKHooe3k6XCJib3R0b21cIj09PW4/dDphK3QsaGVpZ2h0Omh9LHIpLCExLFwic3BhY2luZ0JveFwiKSxyLmZsb2F0aW5nfHwoXCJ0b3BcIj09PW4/ZVswXT1NYXRoLmNlaWwoZVswXStoKTpcImJvdHRvbVwiPT09biYmKGVbMl09TWF0aC5jZWlsKGVbMl0raCkpKX19LHRoaXMpLGVbMF0mJlwidG9wXCI9PT0odGhpcy5vcHRpb25zLnRpdGxlLnZlcnRpY2FsQWxpZ258fFwidG9wXCIpJiYoZVswXSs9dGhpcy5vcHRpb25zLnRpdGxlLm1hcmdpbiksZVsyXSYmXCJib3R0b21cIj09PXRoaXMub3B0aW9ucy5jYXB0aW9uLnZlcnRpY2FsQWxpZ24mJihlWzJdKz10aGlzLm9wdGlvbnMuY2FwdGlvbi5tYXJnaW4pO2xldCBvPSF0aGlzLnRpdGxlT2Zmc2V0fHx0aGlzLnRpdGxlT2Zmc2V0LmpvaW4oXCIsXCIpIT09ZS5qb2luKFwiLFwiKTt0aGlzLnRpdGxlT2Zmc2V0PWUsVyh0aGlzLFwiYWZ0ZXJMYXlPdXRUaXRsZXNcIiksIXRoaXMuaXNEaXJ0eUJveCYmbyYmKHRoaXMuaXNEaXJ0eUJveD10aGlzLmlzRGlydHlMZWdlbmQ9byx0aGlzLmhhc1JlbmRlcmVkJiZ0JiZ0aGlzLmlzRGlydHlCb3gmJnRoaXMucmVkcmF3KCkpfWdldENvbnRhaW5lckJveCgpe3JldHVybnt3aWR0aDpHKHRoaXMucmVuZGVyVG8sXCJ3aWR0aFwiLCEwKXx8MCxoZWlnaHQ6Ryh0aGlzLnJlbmRlclRvLFwiaGVpZ2h0XCIsITApfHwwfX1nZXRDaGFydFNpemUoKXtsZXQgdD10aGlzLm9wdGlvbnMuY2hhcnQsZT10LndpZHRoLGk9dC5oZWlnaHQscz10aGlzLmdldENvbnRhaW5lckJveCgpO3RoaXMuY2hhcnRXaWR0aD1NYXRoLm1heCgwLGV8fHMud2lkdGh8fDYwMCksdGhpcy5jaGFydEhlaWdodD1NYXRoLm1heCgwLF8oaSx0aGlzLmNoYXJ0V2lkdGgpfHwocy5oZWlnaHQ+MT9zLmhlaWdodDo0MDApKSx0aGlzLmNvbnRhaW5lckJveD1zfXRlbXBvcmFyeURpc3BsYXkodCl7bGV0IGU9dGhpcy5yZW5kZXJUbyxpO2lmKHQpZm9yKDtlJiZlLnN0eWxlOyllLmhjT3JpZ1N0eWxlJiYoRChlLGUuaGNPcmlnU3R5bGUpLGRlbGV0ZSBlLmhjT3JpZ1N0eWxlKSxlLmhjT3JpZ0RldGFjaGVkJiYoay5ib2R5LnJlbW92ZUNoaWxkKGUpLGUuaGNPcmlnRGV0YWNoZWQ9ITEpLGU9ZS5wYXJlbnROb2RlO2Vsc2UgZm9yKDtlJiZlLnN0eWxlJiYoay5ib2R5LmNvbnRhaW5zKGUpfHxlLnBhcmVudE5vZGV8fChlLmhjT3JpZ0RldGFjaGVkPSEwLGsuYm9keS5hcHBlbmRDaGlsZChlKSksKFwibm9uZVwiPT09RyhlLFwiZGlzcGxheVwiLCExKXx8ZS5oY09yaWNEZXRhY2hlZCkmJihlLmhjT3JpZ1N0eWxlPXtkaXNwbGF5OmUuc3R5bGUuZGlzcGxheSxoZWlnaHQ6ZS5zdHlsZS5oZWlnaHQsb3ZlcmZsb3c6ZS5zdHlsZS5vdmVyZmxvd30saT17ZGlzcGxheTpcImJsb2NrXCIsb3ZlcmZsb3c6XCJoaWRkZW5cIn0sZSE9PXRoaXMucmVuZGVyVG8mJihpLmhlaWdodD0wKSxEKGUsaSksZS5vZmZzZXRXaWR0aHx8ZS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcImJsb2NrXCIsXCJpbXBvcnRhbnRcIikpLChlPWUucGFyZW50Tm9kZSkhPT1rLmJvZHkpOyk7fXNldENsYXNzTmFtZSh0KXt0aGlzLmNvbnRhaW5lci5jbGFzc05hbWU9XCJoaWdoY2hhcnRzLWNvbnRhaW5lciBcIisodHx8XCJcIil9Z2V0Q29udGFpbmVyKCl7bGV0IHQ9dGhpcy5vcHRpb25zLGU9dC5jaGFydCxpPVwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIscz1RKCksbyxyPXRoaXMucmVuZGVyVG87cnx8KHRoaXMucmVuZGVyVG89cj1lLnJlbmRlclRvKSxZKHIpJiYodGhpcy5yZW5kZXJUbz1yPWsuZ2V0RWxlbWVudEJ5SWQocikpLHJ8fFIoMTMsITAsdGhpcyk7bGV0IGE9WihQKHIsaSkpO1goYSkmJlNbYV0mJlNbYV0uaGFzUmVuZGVyZWQmJlNbYV0uZGVzdHJveSgpLFAocixpLHRoaXMuaW5kZXgpLHIuaW5uZXJIVE1MPXAuZW1wdHlIVE1MLGUuc2tpcENsb25lfHxyLm9mZnNldFdpZHRofHx0aGlzLnRlbXBvcmFyeURpc3BsYXkoKSx0aGlzLmdldENoYXJ0U2l6ZSgpO2xldCBoPXRoaXMuY2hhcnRXaWR0aCxkPXRoaXMuY2hhcnRIZWlnaHQ7RChyLHtvdmVyZmxvdzpcImhpZGRlblwifSksdGhpcy5zdHlsZWRNb2RlfHwobz16KHtwb3NpdGlvbjpcInJlbGF0aXZlXCIsb3ZlcmZsb3c6XCJoaWRkZW5cIix3aWR0aDpoK1wicHhcIixoZWlnaHQ6ZCtcInB4XCIsdGV4dEFsaWduOlwibGVmdFwiLGxpbmVIZWlnaHQ6XCJub3JtYWxcIix6SW5kZXg6MCxcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiOlwicmdiYSgwLDAsMCwwKVwiLHVzZXJTZWxlY3Q6XCJub25lXCIsXCJ0b3VjaC1hY3Rpb25cIjpcIm1hbmlwdWxhdGlvblwiLG91dGxpbmU6XCJub25lXCJ9LGUuc3R5bGV8fHt9KSk7bGV0IGM9TChcImRpdlwiLHtpZDpzfSxvLHIpO3RoaXMuY29udGFpbmVyPWMsdGhpcy5fY3Vyc29yPWMuc3R5bGUuY3Vyc29yO2xldCB1PWUucmVuZGVyZXJ8fCFDP24uZ2V0UmVuZGVyZXJUeXBlKGUucmVuZGVyZXIpOmw7aWYodGhpcy5yZW5kZXJlcj1uZXcgdShjLGgsZCx2b2lkIDAsZS5mb3JFeHBvcnQsdC5leHBvcnRpbmcmJnQuZXhwb3J0aW5nLmFsbG93SFRNTCx0aGlzLnN0eWxlZE1vZGUpLHRoaXMuY29udGFpbmVyQm94PXRoaXMuZ2V0Q29udGFpbmVyQm94KCksbSh2b2lkIDAsdGhpcyksdGhpcy5zZXRDbGFzc05hbWUoZS5jbGFzc05hbWUpLHRoaXMuc3R5bGVkTW9kZSlmb3IobGV0IGUgaW4gdC5kZWZzKXRoaXMucmVuZGVyZXIuZGVmaW5pdGlvbih0LmRlZnNbZV0pO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlLnN0eWxlKTt0aGlzLnJlbmRlcmVyLmNoYXJ0SW5kZXg9dGhpcy5pbmRleCxXKHRoaXMsXCJhZnRlckdldENvbnRhaW5lclwiKX1nZXRNYXJnaW5zKHQpe2xldHtzcGFjaW5nOmUsbWFyZ2luOmksdGl0bGVPZmZzZXQ6c309dGhpczt0aGlzLnJlc2V0TWFyZ2lucygpLHNbMF0mJiFFKGlbMF0pJiYodGhpcy5wbG90VG9wPU1hdGgubWF4KHRoaXMucGxvdFRvcCxzWzBdK2VbMF0pKSxzWzJdJiYhRShpWzJdKSYmKHRoaXMubWFyZ2luQm90dG9tPU1hdGgubWF4KHRoaXMubWFyZ2luQm90dG9tLHNbMl0rZVsyXSkpLHRoaXMubGVnZW5kJiZ0aGlzLmxlZ2VuZC5kaXNwbGF5JiZ0aGlzLmxlZ2VuZC5hZGp1c3RNYXJnaW5zKGksZSksVyh0aGlzLFwiZ2V0TWFyZ2luc1wiKSx0fHx0aGlzLmdldEF4aXNNYXJnaW5zKCl9Z2V0QXhpc01hcmdpbnMoKXtsZXQgdD10aGlzLGU9dC5heGlzT2Zmc2V0PVswLDAsMCwwXSxpPXQuY29sb3JBeGlzLHM9dC5tYXJnaW4sbz1mdW5jdGlvbih0KXt0LmZvckVhY2goZnVuY3Rpb24odCl7dC52aXNpYmxlJiZ0LmdldE9mZnNldCgpfSl9O3QuaGFzQ2FydGVzaWFuU2VyaWVzP28odC5heGVzKTppJiZpLmxlbmd0aCYmbyhpKSxNLmZvckVhY2goZnVuY3Rpb24oaSxvKXtFKHNbb10pfHwodFtpXSs9ZVtvXSl9KSx0LnNldENoYXJ0U2l6ZSgpfWdldE9wdGlvbnMoKXtyZXR1cm4gaih0aGlzLnVzZXJPcHRpb25zLHgpfXJlZmxvdyh0KXtsZXQgZT10aGlzLGk9ZS5jb250YWluZXJCb3gscz1lLmdldENvbnRhaW5lckJveCgpO2RlbGV0ZSBlLnBvaW50ZXIuY2hhcnRQb3NpdGlvbiwhZS5pc1ByaW50aW5nJiYhZS5pc1Jlc2l6aW5nJiZpJiZzLndpZHRoJiYoKHMud2lkdGghPT1pLndpZHRofHxzLmhlaWdodCE9PWkuaGVpZ2h0KSYmKGMuY2xlYXJUaW1lb3V0KGUucmVmbG93VGltZW91dCksZS5yZWZsb3dUaW1lb3V0PUooZnVuY3Rpb24oKXtlLmNvbnRhaW5lciYmZS5zZXRTaXplKHZvaWQgMCx2b2lkIDAsITEpfSx0PzEwMDowKSksZS5jb250YWluZXJCb3g9cyl9c2V0UmVmbG93KCl7bGV0IHQ9dGhpcyxlPWU9Pnt0Lm9wdGlvbnM/LmNoYXJ0LnJlZmxvdyYmdC5oYXNMb2FkZWQmJnQucmVmbG93KGUpfTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZXNpemVPYnNlcnZlciluZXcgUmVzaXplT2JzZXJ2ZXIoZSkub2JzZXJ2ZSh0LnJlbmRlclRvKTtlbHNle2xldCB0PUEodyxcInJlc2l6ZVwiLGUpO0EodGhpcyxcImRlc3Ryb3lcIix0KX19c2V0U2l6ZSh0LGUsaSl7bGV0IHM9dGhpcyxvPXMucmVuZGVyZXI7cy5pc1Jlc2l6aW5nKz0xLG0oaSxzKTtsZXQgcj1vLmdsb2JhbEFuaW1hdGlvbjtzLm9sZENoYXJ0SGVpZ2h0PXMuY2hhcnRIZWlnaHQscy5vbGRDaGFydFdpZHRoPXMuY2hhcnRXaWR0aCx2b2lkIDAhPT10JiYocy5vcHRpb25zLmNoYXJ0LndpZHRoPXQpLHZvaWQgMCE9PWUmJihzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0PWUpLHMuZ2V0Q2hhcnRTaXplKCk7bGV0e2NoYXJ0V2lkdGg6bixjaGFydEhlaWdodDphLHNjcm9sbGFibGVQaXhlbHNYOmg9MCxzY3JvbGxhYmxlUGl4ZWxzWTpsPTB9PXM7KHMuaXNEaXJ0eUJveHx8biE9PXMub2xkQ2hhcnRXaWR0aHx8YSE9PXMub2xkQ2hhcnRIZWlnaHQpJiYocy5zdHlsZWRNb2RlfHwocj9nOkQpKHMuY29udGFpbmVyLHt3aWR0aDpgJHtuK2h9cHhgLGhlaWdodDpgJHthK2x9cHhgfSxyKSxzLnNldENoYXJ0U2l6ZSghMCksby5zZXRTaXplKG4sYSxyKSxzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbih0KXt0LmlzRGlydHk9ITAsdC5zZXRTY2FsZSgpfSkscy5pc0RpcnR5TGVnZW5kPSEwLHMuaXNEaXJ0eUJveD0hMCxzLmxheU91dFRpdGxlcygpLHMuZ2V0TWFyZ2lucygpLHMucmVkcmF3KHIpLHMub2xkQ2hhcnRIZWlnaHQ9dm9pZCAwLFcocyxcInJlc2l6ZVwiKSxzZXRUaW1lb3V0KCgpPT57cyYmVyhzLFwiZW5kUmVzaXplXCIsdm9pZCAwLCgpPT57cy5pc1Jlc2l6aW5nLT0xfSl9LGYocikuZHVyYXRpb24pKX1zZXRDaGFydFNpemUodCl7bGV0IGUsaSxzLG87bGV0IHI9dGhpcy5pbnZlcnRlZCxuPXRoaXMucmVuZGVyZXIsYT10aGlzLmNoYXJ0V2lkdGgsaD10aGlzLmNoYXJ0SGVpZ2h0LGw9dGhpcy5vcHRpb25zLmNoYXJ0LGQ9dGhpcy5zcGFjaW5nLGM9dGhpcy5jbGlwT2Zmc2V0O3RoaXMucGxvdExlZnQ9ZT1NYXRoLnJvdW5kKHRoaXMucGxvdExlZnQpLHRoaXMucGxvdFRvcD1pPU1hdGgucm91bmQodGhpcy5wbG90VG9wKSx0aGlzLnBsb3RXaWR0aD1zPU1hdGgubWF4KDAsTWF0aC5yb3VuZChhLWUtdGhpcy5tYXJnaW5SaWdodCkpLHRoaXMucGxvdEhlaWdodD1vPU1hdGgubWF4KDAsTWF0aC5yb3VuZChoLWktdGhpcy5tYXJnaW5Cb3R0b20pKSx0aGlzLnBsb3RTaXplWD1yP286cyx0aGlzLnBsb3RTaXplWT1yP3M6byx0aGlzLnBsb3RCb3JkZXJXaWR0aD1sLnBsb3RCb3JkZXJXaWR0aHx8MCx0aGlzLnNwYWNpbmdCb3g9bi5zcGFjaW5nQm94PXt4OmRbM10seTpkWzBdLHdpZHRoOmEtZFszXS1kWzFdLGhlaWdodDpoLWRbMF0tZFsyXX0sdGhpcy5wbG90Qm94PW4ucGxvdEJveD17eDplLHk6aSx3aWR0aDpzLGhlaWdodDpvfTtsZXQgcD0yKk1hdGguZmxvb3IodGhpcy5wbG90Qm9yZGVyV2lkdGgvMiksdT1NYXRoLmNlaWwoTWF0aC5tYXgocCxjWzNdKS8yKSxnPU1hdGguY2VpbChNYXRoLm1heChwLGNbMF0pLzIpO3RoaXMuY2xpcEJveD17eDp1LHk6Zyx3aWR0aDpNYXRoLmZsb29yKHRoaXMucGxvdFNpemVYLU1hdGgubWF4KHAsY1sxXSkvMi11KSxoZWlnaHQ6TWF0aC5tYXgoMCxNYXRoLmZsb29yKHRoaXMucGxvdFNpemVZLU1hdGgubWF4KHAsY1syXSkvMi1nKSl9LHR8fCh0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbih0KXt0LnNldEF4aXNTaXplKCksdC5zZXRBeGlzVHJhbnNsYXRpb24oKX0pLG4uYWxpZ25FbGVtZW50cygpKSxXKHRoaXMsXCJhZnRlclNldENoYXJ0U2l6ZVwiLHtza2lwQXhlczp0fSl9cmVzZXRNYXJnaW5zKCl7Vyh0aGlzLFwicmVzZXRNYXJnaW5zXCIpO2xldCB0PXRoaXMsZT10Lm9wdGlvbnMuY2hhcnQ7W1wibWFyZ2luXCIsXCJzcGFjaW5nXCJdLmZvckVhY2goZnVuY3Rpb24oaSl7bGV0IHM9ZVtpXSxvPUYocyk/czpbcyxzLHMsc107W1wiVG9wXCIsXCJSaWdodFwiLFwiQm90dG9tXCIsXCJMZWZ0XCJdLmZvckVhY2goZnVuY3Rpb24ocyxyKXt0W2ldW3JdPSQoZVtpK3NdLG9bcl0pfSl9KSxNLmZvckVhY2goZnVuY3Rpb24oZSxpKXt0W2VdPSQodC5tYXJnaW5baV0sdC5zcGFjaW5nW2ldKX0pLHQuYXhpc09mZnNldD1bMCwwLDAsMF0sdC5jbGlwT2Zmc2V0PVswLDAsMCwwXX1kcmF3Q2hhcnRCb3goKXtsZXQgdD10aGlzLm9wdGlvbnMuY2hhcnQsZT10aGlzLnJlbmRlcmVyLGk9dGhpcy5jaGFydFdpZHRoLHM9dGhpcy5jaGFydEhlaWdodCxvPXRoaXMuc3R5bGVkTW9kZSxyPXRoaXMucGxvdEJHSW1hZ2Usbj10LmJhY2tncm91bmRDb2xvcixhPXQucGxvdEJhY2tncm91bmRDb2xvcixoPXQucGxvdEJhY2tncm91bmRJbWFnZSxsPXRoaXMucGxvdExlZnQsZD10aGlzLnBsb3RUb3AsYz10aGlzLnBsb3RXaWR0aCxwPXRoaXMucGxvdEhlaWdodCx1PXRoaXMucGxvdEJveCxnPXRoaXMuY2xpcFJlY3QsZj10aGlzLmNsaXBCb3gsbT10aGlzLmNoYXJ0QmFja2dyb3VuZCx4PXRoaXMucGxvdEJhY2tncm91bmQseT10aGlzLnBsb3RCb3JkZXIsYix2LFMsaz1cImFuaW1hdGVcIjttfHwodGhpcy5jaGFydEJhY2tncm91bmQ9bT1lLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYmFja2dyb3VuZFwiKS5hZGQoKSxrPVwiYXR0clwiKSxvP2I9dj1tLnN0cm9rZVdpZHRoKCk6KHY9KGI9dC5ib3JkZXJXaWR0aHx8MCkrKHQuc2hhZG93Pzg6MCksUz17ZmlsbDpufHxcIm5vbmVcIn0sKGJ8fG1bXCJzdHJva2Utd2lkdGhcIl0pJiYoUy5zdHJva2U9dC5ib3JkZXJDb2xvcixTW1wic3Ryb2tlLXdpZHRoXCJdPWIpLG0uYXR0cihTKS5zaGFkb3codC5zaGFkb3cpKSxtW2tdKHt4OnYvMix5OnYvMix3aWR0aDppLXYtYiUyLGhlaWdodDpzLXYtYiUyLHI6dC5ib3JkZXJSYWRpdXN9KSxrPVwiYW5pbWF0ZVwiLHh8fChrPVwiYXR0clwiLHRoaXMucGxvdEJhY2tncm91bmQ9eD1lLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1iYWNrZ3JvdW5kXCIpLmFkZCgpKSx4W2tdKHUpLCFvJiYoeC5hdHRyKHtmaWxsOmF8fFwibm9uZVwifSkuc2hhZG93KHQucGxvdFNoYWRvdyksaCYmKHI/KGghPT1yLmF0dHIoXCJocmVmXCIpJiZyLmF0dHIoXCJocmVmXCIsaCksci5hbmltYXRlKHUpKTp0aGlzLnBsb3RCR0ltYWdlPWUuaW1hZ2UoaCxsLGQsYyxwKS5hZGQoKSkpLGc/Zy5hbmltYXRlKHt3aWR0aDpmLndpZHRoLGhlaWdodDpmLmhlaWdodH0pOnRoaXMuY2xpcFJlY3Q9ZS5jbGlwUmVjdChmKSxrPVwiYW5pbWF0ZVwiLHl8fChrPVwiYXR0clwiLHRoaXMucGxvdEJvcmRlcj15PWUucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wbG90LWJvcmRlclwiKS5hdHRyKHt6SW5kZXg6MX0pLmFkZCgpKSxvfHx5LmF0dHIoe3N0cm9rZTp0LnBsb3RCb3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOnQucGxvdEJvcmRlcldpZHRofHwwLGZpbGw6XCJub25lXCJ9KSx5W2tdKHkuY3Jpc3Aoe3g6bCx5OmQsd2lkdGg6YyxoZWlnaHQ6cH0sLXkuc3Ryb2tlV2lkdGgoKSkpLHRoaXMuaXNEaXJ0eUJveD0hMSxXKHRoaXMsXCJhZnRlckRyYXdDaGFydEJveFwiKX1wcm9wRnJvbVNlcmllcygpe2xldCB0LGUsaTtsZXQgcz10aGlzLG89cy5vcHRpb25zLmNoYXJ0LHI9cy5vcHRpb25zLnNlcmllcztbXCJpbnZlcnRlZFwiLFwiYW5ndWxhclwiLFwicG9sYXJcIl0uZm9yRWFjaChmdW5jdGlvbihuKXtmb3IoZT1UW28udHlwZV0saT1vW25dfHxlJiZlLnByb3RvdHlwZVtuXSx0PXImJnIubGVuZ3RoOyFpJiZ0LS07KShlPVRbclt0XS50eXBlXSkmJmUucHJvdG90eXBlW25dJiYoaT0hMCk7c1tuXT1pfSl9bGlua1Nlcmllcyh0KXtsZXQgZT10aGlzLGk9ZS5zZXJpZXM7aS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QubGlua2VkU2VyaWVzLmxlbmd0aD0wfSksaS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldHtsaW5rZWRUbzppfT10Lm9wdGlvbnM7aWYoWShpKSl7bGV0IHM7KHM9XCI6cHJldmlvdXNcIj09PWk/ZS5zZXJpZXNbdC5pbmRleC0xXTplLmdldChpKSkmJnMubGlua2VkUGFyZW50IT09dCYmKHMubGlua2VkU2VyaWVzLnB1c2godCksdC5saW5rZWRQYXJlbnQ9cyxzLmVuYWJsZWREYXRhU29ydGluZyYmdC5zZXREYXRhU29ydGluZ09wdGlvbnMoKSx0LnZpc2libGU9JCh0Lm9wdGlvbnMudmlzaWJsZSxzLm9wdGlvbnMudmlzaWJsZSx0LnZpc2libGUpKX19KSxXKHRoaXMsXCJhZnRlckxpbmtTZXJpZXNcIix7aXNVcGRhdGluZzp0fSl9cmVuZGVyU2VyaWVzKCl7dGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbih0KXt0LnRyYW5zbGF0ZSgpLHQucmVuZGVyKCl9KX1yZW5kZXIoKXtsZXQgdD10aGlzLmF4ZXMsZT10aGlzLmNvbG9yQXhpcyxpPXRoaXMucmVuZGVyZXIscz10aGlzLm9wdGlvbnMuY2hhcnQuYXhpc0xheW91dFJ1bnN8fDIsbz10PT57dC5mb3JFYWNoKHQ9Pnt0LnZpc2libGUmJnQucmVuZGVyKCl9KX0scj0wLG49ITAsYSxoPTA7Zm9yKGxldCBlIG9mKHRoaXMuc2V0VGl0bGUoKSxXKHRoaXMsXCJiZWZvcmVNYXJnaW5zXCIpLHRoaXMuZ2V0U3RhY2tzPy4oKSx0aGlzLmdldE1hcmdpbnMoITApLHRoaXMuc2V0Q2hhcnRTaXplKCksdCkpe2xldHtvcHRpb25zOnR9PWUse2xhYmVsczppfT10O2lmKGUuaG9yaXomJmUudmlzaWJsZSYmaS5lbmFibGVkJiZlLnNlcmllcy5sZW5ndGgmJlwiY29sb3JBeGlzXCIhPT1lLmNvbGwmJiF0aGlzLnBvbGFyKXtyPXQudGlja0xlbmd0aCxlLmNyZWF0ZUdyb3VwcygpO2xldCBzPW5ldyB1KGUsMCxcIlwiLCEwKSxvPXMuY3JlYXRlTGFiZWwoXCJ4XCIsaSk7aWYocy5kZXN0cm95KCksbyYmJChpLnJlc2VydmVTcGFjZSwhWCh0LmNyb3NzaW5nKSkmJihyPW8uZ2V0QkJveCgpLmhlaWdodCtpLmRpc3RhbmNlK01hdGgubWF4KHQub2Zmc2V0fHwwLDApKSxyKXtvPy5kZXN0cm95KCk7YnJlYWt9fX1mb3IodGhpcy5wbG90SGVpZ2h0PU1hdGgubWF4KHRoaXMucGxvdEhlaWdodC1yLDApOyhufHxhfHxzPjEpJiZoPHM7KXtsZXQgZT10aGlzLnBsb3RXaWR0aCxpPXRoaXMucGxvdEhlaWdodDtmb3IobGV0IGUgb2YgdCkwPT09aD9lLnNldFNjYWxlKCk6KGUuaG9yaXomJm58fCFlLmhvcml6JiZhKSYmZS5zZXRUaWNrSW50ZXJ2YWwoITApOzA9PT1oP3RoaXMuZ2V0QXhpc01hcmdpbnMoKTp0aGlzLmdldE1hcmdpbnMoKSxuPWUvdGhpcy5wbG90V2lkdGg+KGg/MToxLjEpLGE9aS90aGlzLnBsb3RIZWlnaHQ+KGg/MToxLjA1KSxoKyt9dGhpcy5kcmF3Q2hhcnRCb3goKSx0aGlzLmhhc0NhcnRlc2lhblNlcmllcz9vKHQpOmUmJmUubGVuZ3RoJiZvKGUpLHRoaXMuc2VyaWVzR3JvdXB8fCh0aGlzLnNlcmllc0dyb3VwPWkuZyhcInNlcmllcy1ncm91cFwiKS5hdHRyKHt6SW5kZXg6M30pLnNoYWRvdyh0aGlzLm9wdGlvbnMuY2hhcnQuc2VyaWVzR3JvdXBTaGFkb3cpLmFkZCgpKSx0aGlzLnJlbmRlclNlcmllcygpLHRoaXMuYWRkQ3JlZGl0cygpLHRoaXMuc2V0UmVzcG9uc2l2ZSYmdGhpcy5zZXRSZXNwb25zaXZlKCksdGhpcy5oYXNSZW5kZXJlZD0hMH1hZGRDcmVkaXRzKHQpe2xldCBlPXRoaXMsaT1VKCEwLHRoaXMub3B0aW9ucy5jcmVkaXRzLHQpO2kuZW5hYmxlZCYmIXRoaXMuY3JlZGl0cyYmKHRoaXMuY3JlZGl0cz10aGlzLnJlbmRlcmVyLnRleHQoaS50ZXh0Kyh0aGlzLm1hcENyZWRpdHN8fFwiXCIpLDAsMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyZWRpdHNcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7aS5ocmVmJiYody5sb2NhdGlvbi5ocmVmPWkuaHJlZil9KS5hdHRyKHthbGlnbjppLnBvc2l0aW9uLmFsaWduLHpJbmRleDo4fSksZS5zdHlsZWRNb2RlfHx0aGlzLmNyZWRpdHMuY3NzKGkuc3R5bGUpLHRoaXMuY3JlZGl0cy5hZGQoKS5hbGlnbihpLnBvc2l0aW9uKSx0aGlzLmNyZWRpdHMudXBkYXRlPWZ1bmN0aW9uKHQpe2UuY3JlZGl0cz1lLmNyZWRpdHMuZGVzdHJveSgpLGUuYWRkQ3JlZGl0cyh0KX0pfWRlc3Ryb3koKXtsZXQgdDtsZXQgZT10aGlzLGk9ZS5heGVzLHM9ZS5zZXJpZXMsbz1lLmNvbnRhaW5lcixuPW8mJm8ucGFyZW50Tm9kZTtmb3IoVyhlLFwiZGVzdHJveVwiKSxlLnJlbmRlcmVyLmZvckV4cG9ydD9CKFMsZSk6U1tlLmluZGV4XT12b2lkIDAsci5jaGFydENvdW50LS0sZS5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIikscShlKSx0PWkubGVuZ3RoO3QtLTspaVt0XT1pW3RdLmRlc3Ryb3koKTtmb3IodGhpcy5zY3JvbGxlciYmdGhpcy5zY3JvbGxlci5kZXN0cm95JiZ0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKSx0PXMubGVuZ3RoO3QtLTspc1t0XT1zW3RdLmRlc3Ryb3koKTtbXCJ0aXRsZVwiLFwic3VidGl0bGVcIixcImNoYXJ0QmFja2dyb3VuZFwiLFwicGxvdEJhY2tncm91bmRcIixcInBsb3RCR0ltYWdlXCIsXCJwbG90Qm9yZGVyXCIsXCJzZXJpZXNHcm91cFwiLFwiY2xpcFJlY3RcIixcImNyZWRpdHNcIixcInBvaW50ZXJcIixcInJhbmdlU2VsZWN0b3JcIixcImxlZ2VuZFwiLFwicmVzZXRab29tQnV0dG9uXCIsXCJ0b29sdGlwXCIsXCJyZW5kZXJlclwiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldCBpPWVbdF07aSYmaS5kZXN0cm95JiYoZVt0XT1pLmRlc3Ryb3koKSl9KSxvJiYoby5pbm5lckhUTUw9cC5lbXB0eUhUTUwscShvKSxuJiZJKG8pKSxWKGUsZnVuY3Rpb24odCxpKXtkZWxldGUgZVtpXX0pfWZpcnN0UmVuZGVyKCl7bGV0IHQ9dGhpcyxlPXQub3B0aW9uczt0LmdldENvbnRhaW5lcigpLHQucmVzZXRNYXJnaW5zKCksdC5zZXRDaGFydFNpemUoKSx0LnByb3BGcm9tU2VyaWVzKCksdC5nZXRBeGVzKCk7bGV0IGk9SChlLnNlcmllcyk/ZS5zZXJpZXM6W107ZS5zZXJpZXM9W10saS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuaW5pdFNlcmllcyhlKX0pLHQubGlua1NlcmllcygpLHQuc2V0U29ydGVkRGF0YSgpLFcodCxcImJlZm9yZVJlbmRlclwiKSx0LnJlbmRlcigpLHQucG9pbnRlci5nZXRDaGFydFBvc2l0aW9uKCksdC5yZW5kZXJlci5pbWdDb3VudHx8dC5oYXNMb2FkZWR8fHQub25sb2FkKCksdC50ZW1wb3JhcnlEaXNwbGF5KCEwKX1vbmxvYWQoKXt0aGlzLmNhbGxiYWNrcy5jb25jYXQoW3RoaXMuY2FsbGJhY2tdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QmJnZvaWQgMCE9PXRoaXMuaW5kZXgmJnQuYXBwbHkodGhpcyxbdGhpc10pfSx0aGlzKSxXKHRoaXMsXCJsb2FkXCIpLFcodGhpcyxcInJlbmRlclwiKSxFKHRoaXMuaW5kZXgpJiZ0aGlzLnNldFJlZmxvdygpLHRoaXMud2FybklmQTExeU1vZHVsZU5vdExvYWRlZCgpLHRoaXMuaGFzTG9hZGVkPSEwfXdhcm5JZkExMXlNb2R1bGVOb3RMb2FkZWQoKXtsZXR7b3B0aW9uczp0LHRpdGxlOmV9PXRoaXM7IXR8fHRoaXMuYWNjZXNzaWJpbGl0eXx8KHRoaXMucmVuZGVyZXIuYm94V3JhcHBlci5hdHRyKHtyb2xlOlwiaW1nXCIsXCJhcmlhLWxhYmVsXCI6KGUmJmUuZWxlbWVudC50ZXh0Q29udGVudHx8XCJcIikucmVwbGFjZSgvPC9nLFwiJmx0O1wiKX0pLHQuYWNjZXNzaWJpbGl0eSYmITE9PT10LmFjY2Vzc2liaWxpdHkuZW5hYmxlZHx8UignSGlnaGNoYXJ0cyB3YXJuaW5nOiBDb25zaWRlciBpbmNsdWRpbmcgdGhlIFwiYWNjZXNzaWJpbGl0eS5qc1wiIG1vZHVsZSB0byBtYWtlIHlvdXIgY2hhcnQgbW9yZSB1c2FibGUgZm9yIHBlb3BsZSB3aXRoIGRpc2FiaWxpdGllcy4gU2V0IHRoZSBcImFjY2Vzc2liaWxpdHkuZW5hYmxlZFwiIG9wdGlvbiB0byBmYWxzZSB0byByZW1vdmUgdGhpcyB3YXJuaW5nLiBTZWUgaHR0cHM6Ly93d3cuaGlnaGNoYXJ0cy5jb20vZG9jcy9hY2Nlc3NpYmlsaXR5L2FjY2Vzc2liaWxpdHktbW9kdWxlLicsITEsdGhpcykpfWFkZFNlcmllcyh0LGUsaSl7bGV0IHM7bGV0IG89dGhpcztyZXR1cm4gdCYmKGU9JChlLCEwKSxXKG8sXCJhZGRTZXJpZXNcIix7b3B0aW9uczp0fSxmdW5jdGlvbigpe3M9by5pbml0U2VyaWVzKHQpLG8uaXNEaXJ0eUxlZ2VuZD0hMCxvLmxpbmtTZXJpZXMoKSxzLmVuYWJsZWREYXRhU29ydGluZyYmcy5zZXREYXRhKHQuZGF0YSwhMSksVyhvLFwiYWZ0ZXJBZGRTZXJpZXNcIix7c2VyaWVzOnN9KSxlJiZvLnJlZHJhdyhpKX0pKSxzfWFkZEF4aXModCxlLGkscyl7cmV0dXJuIHRoaXMuY3JlYXRlQXhpcyhlP1wieEF4aXNcIjpcInlBeGlzXCIse2F4aXM6dCxyZWRyYXc6aSxhbmltYXRpb246c30pfWFkZENvbG9yQXhpcyh0LGUsaSl7cmV0dXJuIHRoaXMuY3JlYXRlQXhpcyhcImNvbG9yQXhpc1wiLHtheGlzOnQscmVkcmF3OmUsYW5pbWF0aW9uOml9KX1jcmVhdGVBeGlzKHQsaSl7bGV0IHM9bmV3IGUodGhpcyxpLmF4aXMsdCk7cmV0dXJuICQoaS5yZWRyYXcsITApJiZ0aGlzLnJlZHJhdyhpLmFuaW1hdGlvbiksc31zaG93TG9hZGluZyh0KXtsZXQgZT10aGlzLGk9ZS5vcHRpb25zLHM9aS5sb2FkaW5nLG89ZnVuY3Rpb24oKXtyJiZEKHIse2xlZnQ6ZS5wbG90TGVmdCtcInB4XCIsdG9wOmUucGxvdFRvcCtcInB4XCIsd2lkdGg6ZS5wbG90V2lkdGgrXCJweFwiLGhlaWdodDplLnBsb3RIZWlnaHQrXCJweFwifSl9LHI9ZS5sb2FkaW5nRGl2LG49ZS5sb2FkaW5nU3BhbjtyfHwoZS5sb2FkaW5nRGl2PXI9TChcImRpdlwiLHtjbGFzc05hbWU6XCJoaWdoY2hhcnRzLWxvYWRpbmcgaGlnaGNoYXJ0cy1sb2FkaW5nLWhpZGRlblwifSxudWxsLGUuY29udGFpbmVyKSksbnx8KGUubG9hZGluZ1NwYW49bj1MKFwic3BhblwiLHtjbGFzc05hbWU6XCJoaWdoY2hhcnRzLWxvYWRpbmctaW5uZXJcIn0sbnVsbCxyKSxBKGUsXCJyZWRyYXdcIixvKSksci5jbGFzc05hbWU9XCJoaWdoY2hhcnRzLWxvYWRpbmdcIixwLnNldEVsZW1lbnRIVE1MKG4sJCh0LGkubGFuZy5sb2FkaW5nLFwiXCIpKSxlLnN0eWxlZE1vZGV8fChEKHIseihzLnN0eWxlLHt6SW5kZXg6MTB9KSksRChuLHMubGFiZWxTdHlsZSksZS5sb2FkaW5nU2hvd258fChEKHIse29wYWNpdHk6MCxkaXNwbGF5OlwiXCJ9KSxnKHIse29wYWNpdHk6cy5zdHlsZS5vcGFjaXR5fHwuNX0se2R1cmF0aW9uOnMuc2hvd0R1cmF0aW9ufHwwfSkpKSxlLmxvYWRpbmdTaG93bj0hMCxvKCl9aGlkZUxvYWRpbmcoKXtsZXQgdD10aGlzLm9wdGlvbnMsZT10aGlzLmxvYWRpbmdEaXY7ZSYmKGUuY2xhc3NOYW1lPVwiaGlnaGNoYXJ0cy1sb2FkaW5nIGhpZ2hjaGFydHMtbG9hZGluZy1oaWRkZW5cIix0aGlzLnN0eWxlZE1vZGV8fGcoZSx7b3BhY2l0eTowfSx7ZHVyYXRpb246dC5sb2FkaW5nLmhpZGVEdXJhdGlvbnx8MTAwLGNvbXBsZXRlOmZ1bmN0aW9uKCl7RChlLHtkaXNwbGF5Olwibm9uZVwifSl9fSkpLHRoaXMubG9hZGluZ1Nob3duPSExfXVwZGF0ZSh0LGUsaSxzKXtsZXQgbyxyLG47bGV0IGE9dGhpcyxoPXtjcmVkaXRzOlwiYWRkQ3JlZGl0c1wiLHRpdGxlOlwic2V0VGl0bGVcIixzdWJ0aXRsZTpcInNldFN1YnRpdGxlXCIsY2FwdGlvbjpcInNldENhcHRpb25cIn0sbD10LmlzUmVzcG9uc2l2ZU9wdGlvbnMsYz1bXTtXKGEsXCJ1cGRhdGVcIix7b3B0aW9uczp0fSksbHx8YS5zZXRSZXNwb25zaXZlKCExLCEwKSx0PWoodCxhLm9wdGlvbnMpLGEudXNlck9wdGlvbnM9VShhLnVzZXJPcHRpb25zLHQpO2xldCBwPXQuY2hhcnQ7cCYmKFUoITAsYS5vcHRpb25zLmNoYXJ0LHApLHRoaXMuc2V0Wm9vbU9wdGlvbnMoKSxcImNsYXNzTmFtZVwiaW4gcCYmYS5zZXRDbGFzc05hbWUocC5jbGFzc05hbWUpLChcImludmVydGVkXCJpbiBwfHxcInBvbGFyXCJpbiBwfHxcInR5cGVcImluIHApJiYoYS5wcm9wRnJvbVNlcmllcygpLG89ITApLFwiYWxpZ25UaWNrc1wiaW4gcCYmKG89ITApLFwiZXZlbnRzXCJpbiBwJiZ2KHRoaXMscCksVihwLGZ1bmN0aW9uKHQsZSl7LTEhPT1hLnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllcy5pbmRleE9mKFwiY2hhcnQuXCIrZSkmJihyPSEwKSwtMSE9PWEucHJvcHNSZXF1aXJlRGlydHlCb3guaW5kZXhPZihlKSYmKGEuaXNEaXJ0eUJveD0hMCksLTE9PT1hLnByb3BzUmVxdWlyZVJlZmxvdy5pbmRleE9mKGUpfHwoYS5pc0RpcnR5Qm94PSEwLGx8fChuPSEwKSl9KSwhYS5zdHlsZWRNb2RlJiZwLnN0eWxlJiZhLnJlbmRlcmVyLnNldFN0eWxlKGEub3B0aW9ucy5jaGFydC5zdHlsZXx8e30pKSwhYS5zdHlsZWRNb2RlJiZ0LmNvbG9ycyYmKHRoaXMub3B0aW9ucy5jb2xvcnM9dC5jb2xvcnMpLHQudGltZSYmKHRoaXMudGltZT09PXkmJih0aGlzLnRpbWU9bmV3IGQodC50aW1lKSksVSghMCxhLm9wdGlvbnMudGltZSx0LnRpbWUpKSxWKHQsZnVuY3Rpb24oZSxpKXthW2ldJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhW2ldLnVwZGF0ZT9hW2ldLnVwZGF0ZShlLCExKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBhW2hbaV1dP2FbaFtpXV0oZSk6XCJjb2xvcnNcIiE9PWkmJi0xPT09YS5jb2xsZWN0aW9uc1dpdGhVcGRhdGUuaW5kZXhPZihpKSYmVSghMCxhLm9wdGlvbnNbaV0sdFtpXSksXCJjaGFydFwiIT09aSYmLTEhPT1hLnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllcy5pbmRleE9mKGkpJiYocj0hMCl9KSx0aGlzLmNvbGxlY3Rpb25zV2l0aFVwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV0mJihLKHRbZV0pLmZvckVhY2goZnVuY3Rpb24odCxzKXtsZXQgbztsZXQgcj1FKHQuaWQpO3ImJihvPWEuZ2V0KHQuaWQpKSwhbyYmYVtlXSYmKG89YVtlXVskKHQuaW5kZXgscyldKSYmKHImJkUoby5vcHRpb25zLmlkKXx8by5vcHRpb25zLmlzSW50ZXJuYWwpJiYobz12b2lkIDApLG8mJm8uY29sbD09PWUmJihvLnVwZGF0ZSh0LCExKSxpJiYoby50b3VjaGVkPSEwKSksIW8mJmkmJmEuY29sbGVjdGlvbnNXaXRoSW5pdFtlXSYmKGEuY29sbGVjdGlvbnNXaXRoSW5pdFtlXVswXS5hcHBseShhLFt0XS5jb25jYXQoYS5jb2xsZWN0aW9uc1dpdGhJbml0W2VdWzFdfHxbXSkuY29uY2F0KFshMV0pKS50b3VjaGVkPSEwKX0pLGkmJmFbZV0uZm9yRWFjaChmdW5jdGlvbih0KXt0LnRvdWNoZWR8fHQub3B0aW9ucy5pc0ludGVybmFsP2RlbGV0ZSB0LnRvdWNoZWQ6Yy5wdXNoKHQpfSkpfSksYy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuY2hhcnQmJnQucmVtb3ZlJiZ0LnJlbW92ZSghMSl9KSxvJiZhLmF4ZXMuZm9yRWFjaChmdW5jdGlvbih0KXt0LnVwZGF0ZSh7fSwhMSl9KSxyJiZhLmdldFNlcmllc09yZGVyQnlMaW5rcygpLmZvckVhY2goZnVuY3Rpb24odCl7dC5jaGFydCYmdC51cGRhdGUoe30sITEpfSx0aGlzKTtsZXQgdT1wJiZwLndpZHRoLGc9cCYmKFkocC5oZWlnaHQpP18ocC5oZWlnaHQsdXx8YS5jaGFydFdpZHRoKTpwLmhlaWdodCk7bnx8WCh1KSYmdSE9PWEuY2hhcnRXaWR0aHx8WChnKSYmZyE9PWEuY2hhcnRIZWlnaHQ/YS5zZXRTaXplKHUsZyxzKTokKGUsITApJiZhLnJlZHJhdyhzKSxXKGEsXCJhZnRlclVwZGF0ZVwiLHtvcHRpb25zOnQscmVkcmF3OmUsYW5pbWF0aW9uOnN9KX1zZXRTdWJ0aXRsZSh0LGUpe3RoaXMuYXBwbHlEZXNjcmlwdGlvbihcInN1YnRpdGxlXCIsdCksdGhpcy5sYXlPdXRUaXRsZXMoZSl9c2V0Q2FwdGlvbih0LGUpe3RoaXMuYXBwbHlEZXNjcmlwdGlvbihcImNhcHRpb25cIix0KSx0aGlzLmxheU91dFRpdGxlcyhlKX1zaG93UmVzZXRab29tKCl7bGV0IHQ9dGhpcyxlPXgubGFuZyxpPXQuem9vbWluZy5yZXNldEJ1dHRvbixzPWkudGhlbWUsbz1cImNoYXJ0XCI9PT1pLnJlbGF0aXZlVG98fFwic3BhY2luZ0JveFwiPT09aS5yZWxhdGl2ZVRvP251bGw6XCJzY3JvbGxhYmxlUGxvdEJveFwiO2Z1bmN0aW9uIHIoKXt0Lnpvb21PdXQoKX1XKHRoaXMsXCJiZWZvcmVTaG93UmVzZXRab29tXCIsbnVsbCxmdW5jdGlvbigpe3QucmVzZXRab29tQnV0dG9uPXQucmVuZGVyZXIuYnV0dG9uKGUucmVzZXRab29tLG51bGwsbnVsbCxyLHMpLmF0dHIoe2FsaWduOmkucG9zaXRpb24uYWxpZ24sdGl0bGU6ZS5yZXNldFpvb21UaXRsZX0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1yZXNldC16b29tXCIpLmFkZCgpLmFsaWduKGkucG9zaXRpb24sITEsbyl9KSxXKHRoaXMsXCJhZnRlclNob3dSZXNldFpvb21cIil9em9vbU91dCgpe1codGhpcyxcInNlbGVjdGlvblwiLHtyZXNldFNlbGVjdGlvbjohMH0sdGhpcy56b29tKX16b29tKHQpe2xldCBlPXRoaXMsaT1lLnBvaW50ZXIscz0hMSxvOyF0fHx0LnJlc2V0U2VsZWN0aW9uPyhlLmF4ZXMuZm9yRWFjaChmdW5jdGlvbih0KXtvPXQuem9vbSgpfSksaS5pbml0aWF0ZWQ9ITEpOnQueEF4aXMuY29uY2F0KHQueUF4aXMpLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IHI9dC5heGlzLG49ci5pc1hBeGlzLHtoYXNQaW5jaGVkOmEsbW91c2VEb3duWDpoLG1vdXNlRG93blk6bH09aTsoaVtuP1wiem9vbVhcIjpcInpvb21ZXCJdJiZFKGgpJiZFKGwpJiZlLmlzSW5zaWRlUGxvdChoLWUucGxvdExlZnQsbC1lLnBsb3RUb3Ase2F4aXM6cixpZ25vcmVYOmEsaWdub3JlWTphfSl8fCFFKGUuaW52ZXJ0ZWQ/aDpsKSkmJihvPXIuem9vbSh0Lm1pbix0Lm1heCksci5kaXNwbGF5QnRuJiYocz0hMCkpfSk7bGV0IHI9ZS5yZXNldFpvb21CdXR0b247cyYmIXI/ZS5zaG93UmVzZXRab29tKCk6IXMmJkYocikmJihlLnJlc2V0Wm9vbUJ1dHRvbj1yLmRlc3Ryb3koKSksbyYmZS5yZWRyYXcoJChlLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLHQmJnQuYW5pbWF0aW9uLGUucG9pbnRDb3VudDwxMDApKX1wYW4odCxlKXtsZXQgaTtsZXQgcz10aGlzLG89cy5ob3ZlclBvaW50cyxyPVwib2JqZWN0XCI9PXR5cGVvZiBlP2U6e2VuYWJsZWQ6ZSx0eXBlOlwieFwifSxuPXMub3B0aW9ucy5jaGFydDtuJiZuLnBhbm5pbmcmJihuLnBhbm5pbmc9cik7bGV0IGE9ci50eXBlO1codGhpcyxcInBhblwiLHtvcmlnaW5hbEV2ZW50OnR9LGZ1bmN0aW9uKCl7byYmby5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Quc2V0U3RhdGUoKX0pO2xldCBlPXMueEF4aXM7XCJ4eVwiPT09YT9lPWUuY29uY2F0KHMueUF4aXMpOlwieVwiPT09YSYmKGU9cy55QXhpcyk7bGV0IHI9e307ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKCFlLm9wdGlvbnMucGFubmluZ0VuYWJsZWR8fGUub3B0aW9ucy5pc0ludGVybmFsKXJldHVybjtsZXQgbz1lLmhvcml6LG49dFtvP1wiY2hhcnRYXCI6XCJjaGFydFlcIl0saD1vP1wibW91c2VEb3duWFwiOlwibW91c2VEb3duWVwiLGw9c1toXSxkPWUubWluUG9pbnRPZmZzZXR8fDAsYz1lLnJldmVyc2VkJiYhcy5pbnZlcnRlZHx8IWUucmV2ZXJzZWQmJnMuaW52ZXJ0ZWQ/LTE6MSxwPWUuZ2V0RXh0cmVtZXMoKSx1PWUudG9WYWx1ZShsLW4sITApK2QqYyxnPWUudG9WYWx1ZShsK2UubGVuLW4sITApLShkKmN8fGUuaXNYQXhpcyYmZS5wb2ludFJhbmdlUGFkZGluZ3x8MCksZj1nPHUsbT1lLmhhc1ZlcnRpY2FsUGFubmluZygpLHg9Zj9nOnUseT1mP3U6ZyxiPWUucGFubmluZ1N0YXRlLHY7bSYmIWUuaXNYQXhpcyYmKCFifHxiLmlzRGlydHkpJiZlLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldCBlPXQuZ2V0UHJvY2Vzc2VkRGF0YSghMCksaT10LmdldEV4dHJlbWVzKGUueURhdGEsITApO2J8fChiPXtzdGFydE1pbjpOdW1iZXIuTUFYX1ZBTFVFLHN0YXJ0TWF4Oi1OdW1iZXIuTUFYX1ZBTFVFfSksWChpLmRhdGFNaW4pJiZYKGkuZGF0YU1heCkmJihiLnN0YXJ0TWluPU1hdGgubWluKCQodC5vcHRpb25zLnRocmVzaG9sZCwxLzApLGkuZGF0YU1pbixiLnN0YXJ0TWluKSxiLnN0YXJ0TWF4PU1hdGgubWF4KCQodC5vcHRpb25zLnRocmVzaG9sZCwtMS8wKSxpLmRhdGFNYXgsYi5zdGFydE1heCkpfSk7bGV0IFM9TWF0aC5taW4oJChiJiZiLnN0YXJ0TWluLHAuZGF0YU1pbiksZD9wLm1pbjplLnRvVmFsdWUoZS50b1BpeGVscyhwLm1pbiktZS5taW5QaXhlbFBhZGRpbmcpKSxrPU1hdGgubWF4KCQoYiYmYi5zdGFydE1heCxwLmRhdGFNYXgpLGQ/cC5tYXg6ZS50b1ZhbHVlKGUudG9QaXhlbHMocC5tYXgpK2UubWluUGl4ZWxQYWRkaW5nKSk7ZS5wYW5uaW5nU3RhdGU9YixlLmlzT3JkaW5hbHx8KCh2PVMteCk+MCYmKHkrPXYseD1TKSwodj15LWspPjAmJih5PWsseC09diksZS5zZXJpZXMubGVuZ3RoJiZ4IT09cC5taW4mJnkhPT1wLm1heCYmeD49UyYmeTw9ayYmKGUuc2V0RXh0cmVtZXMoeCx5LCExLCExLHt0cmlnZ2VyOlwicGFuXCJ9KSwhcy5yZXNldFpvb21CdXR0b24mJnghPT1TJiZ5IT09ayYmYS5tYXRjaChcInlcIikmJihzLnNob3dSZXNldFpvb20oKSxlLmRpc3BsYXlCdG49ITEpLGk9ITApLHJbaF09bil9KSxWKHIsKHQsZSk9PntzW2VdPXR9KSxpJiZzLnJlZHJhdyghMSksRChzLmNvbnRhaW5lcix7Y3Vyc29yOlwibW92ZVwifSl9KX19cmV0dXJuIHoodHQucHJvdG90eXBlLHtjYWxsYmFja3M6W10sY29sbGVjdGlvbnNXaXRoSW5pdDp7eEF4aXM6W3R0LnByb3RvdHlwZS5hZGRBeGlzLFshMF1dLHlBeGlzOlt0dC5wcm90b3R5cGUuYWRkQXhpcyxbITFdXSxzZXJpZXM6W3R0LnByb3RvdHlwZS5hZGRTZXJpZXNdfSxjb2xsZWN0aW9uc1dpdGhVcGRhdGU6W1wieEF4aXNcIixcInlBeGlzXCIsXCJzZXJpZXNcIl0scHJvcHNSZXF1aXJlRGlydHlCb3g6W1wiYmFja2dyb3VuZENvbG9yXCIsXCJib3JkZXJDb2xvclwiLFwiYm9yZGVyV2lkdGhcIixcImJvcmRlclJhZGl1c1wiLFwicGxvdEJhY2tncm91bmRDb2xvclwiLFwicGxvdEJhY2tncm91bmRJbWFnZVwiLFwicGxvdEJvcmRlckNvbG9yXCIsXCJwbG90Qm9yZGVyV2lkdGhcIixcInBsb3RTaGFkb3dcIixcInNoYWRvd1wiXSxwcm9wc1JlcXVpcmVSZWZsb3c6W1wibWFyZ2luXCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcIm1hcmdpbkxlZnRcIixcInNwYWNpbmdcIixcInNwYWNpbmdUb3BcIixcInNwYWNpbmdSaWdodFwiLFwic3BhY2luZ0JvdHRvbVwiLFwic3BhY2luZ0xlZnRcIl0scHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzOltcImNoYXJ0LmludmVydGVkXCIsXCJjaGFydC5wb2xhclwiLFwiY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzXCIsXCJjaGFydC50eXBlXCIsXCJjb2xvcnNcIixcInBsb3RPcHRpb25zXCIsXCJ0aW1lXCIsXCJ0b29sdGlwXCJdfSksdHR9KSxpKGUsXCJFeHRlbnNpb25zL1Njcm9sbGFibGVQbG90QXJlYS5qc1wiLFtlW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvUmVuZGVyZXIvUmVuZGVyZXJSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpLHMpe2xldHtzdG9wOm99PXQse2NvbXBvc2VkOnJ9PWUse2FkZEV2ZW50Om4sY3JlYXRlRWxlbWVudDphLGNzczpoLGRlZmluZWQ6bCxleHRlbmQ6ZCxtZXJnZTpjLHBpY2s6cCxwdXNoVW5pcXVlOnV9PXM7ZnVuY3Rpb24gZygpe2xldCB0O2xldHtheGlzT2Zmc2V0OmUsY2hhcnRXaWR0aDpzLGNoYXJ0SGVpZ2h0OnIsY29udGFpbmVyOmwscGxvdEhlaWdodDpkLHBsb3RMZWZ0OmMscGxvdFRvcDp1LHBsb3RXaWR0aDpnLHNjcm9sbGFibGVQaXhlbHNYOmY9MCxzY3JvbGxhYmxlUGl4ZWxzWTptPTAsc2Nyb2xsaW5nQ29udGFpbmVyOnh9PXRoaXMseT0hdGhpcy5maXhlZERpdixiPXRoaXMub3B0aW9ucy5jaGFydCx2PWIuc2Nyb2xsYWJsZVBsb3RBcmVhLHtzY3JvbGxQb3NpdGlvblg6UyxzY3JvbGxQb3NpdGlvblk6a309dixNPWkuZ2V0UmVuZGVyZXJUeXBlKCkse2ZpeGVkUmVuZGVyZXI6Q309dGhpcztDP0Muc2V0U2l6ZShzLHIpOih0aGlzLmZpeGVkRGl2PWEoXCJkaXZcIix7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1maXhlZFwifSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLG92ZXJmbG93OlwiaGlkZGVuXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIix6SW5kZXg6KGIuc3R5bGU/LnpJbmRleHx8MCkrMix0b3A6MH0sdm9pZCAwLCEwKSx4Py5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmZpeGVkRGl2LHgpLGgodGhpcy5yZW5kZXJUbyx7b3ZlcmZsb3c6XCJ2aXNpYmxlXCJ9KSx0aGlzLmZpeGVkUmVuZGVyZXI9Qz1uZXcgTSh0aGlzLmZpeGVkRGl2LHMscixiLnN0eWxlKSx0aGlzLnNjcm9sbGFibGVNYXNrPUMucGF0aCgpLmF0dHIoe2ZpbGw6Yi5iYWNrZ3JvdW5kQ29sb3J8fFwiI2ZmZlwiLFwiZmlsbC1vcGFjaXR5XCI6cCh2Lm9wYWNpdHksLjg1KSx6SW5kZXg6LTF9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYWJsZS1tYXNrXCIpLmFkZCgpLG4odGhpcyxcImFmdGVyU2hvd1Jlc2V0Wm9vbVwiLHRoaXMubW92ZUZpeGVkRWxlbWVudHMpLG4odGhpcyxcImFmdGVyQXBwbHlEcmlsbGRvd25cIix0aGlzLm1vdmVGaXhlZEVsZW1lbnRzKSxuKHRoaXMsXCJhZnRlckxheU91dFRpdGxlc1wiLHRoaXMubW92ZUZpeGVkRWxlbWVudHMpKSwodGhpcy5zY3JvbGxhYmxlRGlydHl8fHkpJiYodGhpcy5zY3JvbGxhYmxlRGlydHk9ITEsdGhpcy5tb3ZlRml4ZWRFbGVtZW50cygpKTtsZXQgdz1zK2YsVD1yK207byh0aGlzLmNvbnRhaW5lciksaChsLHt3aWR0aDpgJHt3fXB4YCxoZWlnaHQ6YCR7VH1weGB9KSx0aGlzLnJlbmRlcmVyLmJveFdyYXBwZXIuYXR0cih7d2lkdGg6dyxoZWlnaHQ6VCx2aWV3Qm94OlswLDAsdyxUXS5qb2luKFwiIFwiKX0pLHRoaXMuY2hhcnRCYWNrZ3JvdW5kPy5hdHRyKHt3aWR0aDp3LGhlaWdodDpUfSkseCYmKGgoeCx7d2lkdGg6YCR7dGhpcy5jaGFydFdpZHRofXB4YCxoZWlnaHQ6YCR7dGhpcy5jaGFydEhlaWdodH1weGB9KSx5JiYoUyYmKHguc2Nyb2xsTGVmdD1mKlMpLGsmJih4LnNjcm9sbFRvcD1tKmspKSk7bGV0IEE9dS1lWzBdLTEsUD1jLWVbM10tMSxMPXUrZCtlWzJdKzEsTz1jK2crZVsxXSsxLEQ9YytnLWYsRT11K2QtbTt0PWY/W1tcIk1cIiwwLEFdLFtcIkxcIixjLTEsQV0sW1wiTFwiLGMtMSxMXSxbXCJMXCIsMCxMXSxbXCJaXCJdLFtcIk1cIixELEFdLFtcIkxcIixzLEFdLFtcIkxcIixzLExdLFtcIkxcIixELExdLFtcIlpcIl1dOm0/W1tcIk1cIixQLDBdLFtcIkxcIixQLHUtMV0sW1wiTFwiLE8sdS0xXSxbXCJMXCIsTywwXSxbXCJaXCJdLFtcIk1cIixQLEVdLFtcIkxcIixQLHJdLFtcIkxcIixPLHJdLFtcIkxcIixPLEVdLFtcIlpcIl1dOltbXCJNXCIsMCwwXV0sXCJhZGp1c3RIZWlnaHRcIiE9PXRoaXMucmVkcmF3VHJpZ2dlciYmdGhpcy5zY3JvbGxhYmxlTWFzaz8uYXR0cih7ZDp0fSl9ZnVuY3Rpb24gZigpe2xldCB0O2xldCBlPXRoaXMuY29udGFpbmVyLGk9dGhpcy5maXhlZFJlbmRlcmVyLHM9W1wiLmhpZ2hjaGFydHMtYnJlYWRjcnVtYnMtZ3JvdXBcIixcIi5oaWdoY2hhcnRzLWNvbnRleHRidXR0b25cIixcIi5oaWdoY2hhcnRzLWNhcHRpb25cIixcIi5oaWdoY2hhcnRzLWNyZWRpdHNcIixcIi5oaWdoY2hhcnRzLWxlZ2VuZFwiLFwiLmhpZ2hjaGFydHMtbGVnZW5kLWNoZWNrYm94XCIsXCIuaGlnaGNoYXJ0cy1uYXZpZ2F0b3Itc2VyaWVzXCIsXCIuaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteGF4aXNcIixcIi5oaWdoY2hhcnRzLW5hdmlnYXRvci15YXhpc1wiLFwiLmhpZ2hjaGFydHMtbmF2aWdhdG9yXCIsXCIuaGlnaGNoYXJ0cy1yZXNldC16b29tXCIsXCIuaGlnaGNoYXJ0cy1kcmlsbHVwLWJ1dHRvblwiLFwiLmhpZ2hjaGFydHMtc2Nyb2xsYmFyXCIsXCIuaGlnaGNoYXJ0cy1zdWJ0aXRsZVwiLFwiLmhpZ2hjaGFydHMtdGl0bGVcIl07Zm9yKGxldCBvIG9mKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1gmJiF0aGlzLmludmVydGVkP3Q9XCIuaGlnaGNoYXJ0cy15YXhpc1wiOnRoaXMuc2Nyb2xsYWJsZVBpeGVsc1gmJnRoaXMuaW52ZXJ0ZWQ/dD1cIi5oaWdoY2hhcnRzLXhheGlzXCI6dGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSYmIXRoaXMuaW52ZXJ0ZWQ/dD1cIi5oaWdoY2hhcnRzLXhheGlzXCI6dGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSYmdGhpcy5pbnZlcnRlZCYmKHQ9XCIuaGlnaGNoYXJ0cy15YXhpc1wiKSx0JiZzLnB1c2goYCR7dH06bm90KC5oaWdoY2hhcnRzLXJhZGlhbC1heGlzKWAsYCR7dH0tbGFiZWxzOm5vdCguaGlnaGNoYXJ0cy1yYWRpYWwtYXhpcy1sYWJlbHMpYCkscykpW10uZm9yRWFjaC5jYWxsKGUucXVlcnlTZWxlY3RvckFsbChvKSx0PT57KHQubmFtZXNwYWNlVVJJPT09aS5TVkdfTlM/aS5ib3g6aS5ib3gucGFyZW50Tm9kZSkuYXBwZW5kQ2hpbGQodCksdC5zdHlsZS5wb2ludGVyRXZlbnRzPVwiYXV0b1wifSl9ZnVuY3Rpb24gbSgpe2xldCB0O2xldCBlPXtXZWJraXRPdmVyZmxvd1Njcm9sbGluZzpcInRvdWNoXCIsb3ZlcmZsb3dYOlwiaGlkZGVuXCIsb3ZlcmZsb3dZOlwiaGlkZGVuXCJ9O3RoaXMuc2Nyb2xsYWJsZVBpeGVsc1gmJihlLm92ZXJmbG93WD1cImF1dG9cIiksdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSYmKGUub3ZlcmZsb3dZPVwiYXV0b1wiKSx0aGlzLnNjcm9sbGluZ1BhcmVudD1hKFwiZGl2XCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtc2Nyb2xsaW5nLXBhcmVudFwifSx7cG9zaXRpb246XCJyZWxhdGl2ZVwifSx0aGlzLnJlbmRlclRvKSx0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcj1hKFwiZGl2XCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtc2Nyb2xsaW5nXCJ9LGUsdGhpcy5zY3JvbGxpbmdQYXJlbnQpLG4odGhpcy5zY3JvbGxpbmdDb250YWluZXIsXCJzY3JvbGxcIiwoKT0+e3RoaXMucG9pbnRlciYmKGRlbGV0ZSB0aGlzLnBvaW50ZXIuY2hhcnRQb3NpdGlvbix0aGlzLmhvdmVyUG9pbnQmJih0PXRoaXMuaG92ZXJQb2ludCksdGhpcy5wb2ludGVyLnJ1blBvaW50QWN0aW9ucyh2b2lkIDAsdCwhMCkpfSksdGhpcy5pbm5lckNvbnRhaW5lcj1hKFwiZGl2XCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtaW5uZXItY29udGFpbmVyXCJ9LG51bGwsdGhpcy5zY3JvbGxpbmdDb250YWluZXIpLHRoaXMuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpLHRoaXMuc2V0VXBTY3JvbGxpbmc9bnVsbH1mdW5jdGlvbiB4KCl7dGhpcy5jaGFydC5zY3JvbGxhYmxlRGlydHk9ITB9ZnVuY3Rpb24geSh0KXtsZXQgZSxpLHM7bGV0IG89dGhpcy5vcHRpb25zLmNoYXJ0LnNjcm9sbGFibGVQbG90QXJlYSxyPW8mJm8ubWluV2lkdGgsbj1vJiZvLm1pbkhlaWdodDtpZighdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQmJihyPyh0aGlzLnNjcm9sbGFibGVQaXhlbHNYPWU9TWF0aC5tYXgoMCxyLXRoaXMuY2hhcnRXaWR0aCksZSYmKHRoaXMuc2Nyb2xsYWJsZVBsb3RCb3g9dGhpcy5yZW5kZXJlci5zY3JvbGxhYmxlUGxvdEJveD1jKHRoaXMucGxvdEJveCksdGhpcy5wbG90Qm94LndpZHRoPXRoaXMucGxvdFdpZHRoKz1lLHRoaXMuaW52ZXJ0ZWQ/dGhpcy5jbGlwQm94LmhlaWdodCs9ZTp0aGlzLmNsaXBCb3gud2lkdGgrPWUscz17MTp7bmFtZTpcInJpZ2h0XCIsdmFsdWU6ZX19KSk6biYmKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1k9aT1NYXRoLm1heCgwLG4tdGhpcy5jaGFydEhlaWdodCksbChpKSYmKHRoaXMuc2Nyb2xsYWJsZVBsb3RCb3g9dGhpcy5yZW5kZXJlci5zY3JvbGxhYmxlUGxvdEJveD1jKHRoaXMucGxvdEJveCksdGhpcy5wbG90Qm94LmhlaWdodD10aGlzLnBsb3RIZWlnaHQrPWksdGhpcy5pbnZlcnRlZD90aGlzLmNsaXBCb3gud2lkdGgrPWk6dGhpcy5jbGlwQm94LmhlaWdodCs9aSxzPXsyOntuYW1lOlwiYm90dG9tXCIsdmFsdWU6aX19KSkscyYmIXQuc2tpcEF4ZXMpKWZvcihsZXQgdCBvZiB0aGlzLmF4ZXMpaWYoc1t0LnNpZGVdKXtsZXQgZT10LmdldFBsb3RMaW5lUGF0aDt0LmdldFBsb3RMaW5lUGF0aD1mdW5jdGlvbigpe2xldCBpPXNbdC5zaWRlXS5uYW1lLG89c1t0LnNpZGVdLnZhbHVlLHI9dGhpc1tpXTt0aGlzW2ldPXItbztsZXQgbj1lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gdGhpc1tpXT1yLG59fWVsc2UgdC5zZXRBeGlzU2l6ZSgpLHQuc2V0QXhpc1RyYW5zbGF0aW9uKCl9ZnVuY3Rpb24gYigpe3RoaXMuc2Nyb2xsYWJsZVBpeGVsc1h8fHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1k/KHRoaXMuc2V0VXBTY3JvbGxpbmcmJnRoaXMuc2V0VXBTY3JvbGxpbmcoKSx0aGlzLmFwcGx5Rml4ZWQoKSk6dGhpcy5maXhlZERpdiYmdGhpcy5hcHBseUZpeGVkKCl9ZnVuY3Rpb24gdigpe3RoaXMuY2hhcnQuc2Nyb2xsYWJsZURpcnR5PSEwfXJldHVybntjb21wb3NlOmZ1bmN0aW9uIHQoZSxpLHMpe3Uocix0KSYmKG4oZSxcImFmdGVySW5pdFwiLHgpLGQoaS5wcm90b3R5cGUse2FwcGx5Rml4ZWQ6Zyxtb3ZlRml4ZWRFbGVtZW50czpmLHNldFVwU2Nyb2xsaW5nOm19KSxuKGksXCJhZnRlclNldENoYXJ0U2l6ZVwiLHkpLG4oaSxcInJlbmRlclwiLGIpLG4ocyxcInNob3dcIix2KSl9fX0pLGkoZSxcIkNvcmUvQXhpcy9TdGFja2luZy9TdGFja0l0ZW0uanNcIixbZVtcIkNvcmUvVGVtcGxhdGluZy5qc1wiXSxlW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7bGV0e2Zvcm1hdDpzfT10LHtzZXJpZXM6b309ZSx7ZGVzdHJveU9iamVjdFByb3BlcnRpZXM6cixmaXJlRXZlbnQ6bixpc051bWJlcjphLHBpY2s6aH09aTtyZXR1cm4gY2xhc3N7Y29uc3RydWN0b3IodCxlLGkscyxvKXtsZXQgcj10LmNoYXJ0LmludmVydGVkLG49dC5yZXZlcnNlZDt0aGlzLmF4aXM9dDtsZXQgYT10aGlzLmlzTmVnYXRpdmU9ISFpIT0hIW47dGhpcy5vcHRpb25zPWU9ZXx8e30sdGhpcy54PXMsdGhpcy50b3RhbD1udWxsLHRoaXMuY3VtdWxhdGl2ZT1udWxsLHRoaXMucG9pbnRzPXt9LHRoaXMuaGFzVmFsaWRQb2ludHM9ITEsdGhpcy5zdGFjaz1vLHRoaXMubGVmdENsaWZmPTAsdGhpcy5yaWdodENsaWZmPTAsdGhpcy5hbGlnbk9wdGlvbnM9e2FsaWduOmUuYWxpZ258fChyP2E/XCJsZWZ0XCI6XCJyaWdodFwiOlwiY2VudGVyXCIpLHZlcnRpY2FsQWxpZ246ZS52ZXJ0aWNhbEFsaWdufHwocj9cIm1pZGRsZVwiOmE/XCJib3R0b21cIjpcInRvcFwiKSx5OmUueSx4OmUueH0sdGhpcy50ZXh0QWxpZ249ZS50ZXh0QWxpZ258fChyP2E/XCJyaWdodFwiOlwibGVmdFwiOlwiY2VudGVyXCIpfWRlc3Ryb3koKXtyKHRoaXMsdGhpcy5heGlzKX1yZW5kZXIodCl7bGV0IGU9dGhpcy5heGlzLmNoYXJ0LGk9dGhpcy5vcHRpb25zLG89aS5mb3JtYXQscj1vP3Mobyx0aGlzLGUpOmkuZm9ybWF0dGVyLmNhbGwodGhpcyk7aWYodGhpcy5sYWJlbCl0aGlzLmxhYmVsLmF0dHIoe3RleHQ6cix2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KTtlbHNle3RoaXMubGFiZWw9ZS5yZW5kZXJlci5sYWJlbChyLG51bGwsdm9pZCAwLGkuc2hhcGUsdm9pZCAwLHZvaWQgMCxpLnVzZUhUTUwsITEsXCJzdGFjay1sYWJlbHNcIik7bGV0IHM9e3I6aS5ib3JkZXJSYWRpdXN8fDAsdGV4dDpyLHBhZGRpbmc6aChpLnBhZGRpbmcsNSksdmlzaWJpbGl0eTpcImhpZGRlblwifTtlLnN0eWxlZE1vZGV8fChzLmZpbGw9aS5iYWNrZ3JvdW5kQ29sb3Iscy5zdHJva2U9aS5ib3JkZXJDb2xvcixzW1wic3Ryb2tlLXdpZHRoXCJdPWkuYm9yZGVyV2lkdGgsdGhpcy5sYWJlbC5jc3MoaS5zdHlsZXx8e30pKSx0aGlzLmxhYmVsLmF0dHIocyksdGhpcy5sYWJlbC5hZGRlZHx8dGhpcy5sYWJlbC5hZGQodCl9dGhpcy5sYWJlbC5sYWJlbHJhbms9ZS5wbG90U2l6ZVksbih0aGlzLFwiYWZ0ZXJSZW5kZXJcIil9c2V0T2Zmc2V0KHQsZSxpLHMscixsKXtsZXR7YWxpZ25PcHRpb25zOmQsYXhpczpjLGxhYmVsOnAsb3B0aW9uczp1LHRleHRBbGlnbjpnfT10aGlzLGY9Yy5jaGFydCxtPXRoaXMuZ2V0U3RhY2tCb3goe3hPZmZzZXQ6dCx3aWR0aDplLGJveEJvdHRvbTppLGJveFRvcDpzLGRlZmF1bHRYOnIseEF4aXM6bH0pLHt2ZXJ0aWNhbEFsaWduOnh9PWQ7aWYocCYmbSl7bGV0IHQ9cC5nZXRCQm94KCksZT1wLnBhZGRpbmcsaT1cImp1c3RpZnlcIj09PWgodS5vdmVyZmxvdyxcImp1c3RpZnlcIikscztkLng9dS54fHwwLGQueT11Lnl8fDA7bGV0e3g6cix5Om59PXRoaXMuYWRqdXN0U3RhY2tQb3NpdGlvbih7bGFiZWxCb3g6dCx2ZXJ0aWNhbEFsaWduOngsdGV4dEFsaWduOmd9KTttLngtPXIsbS55LT1uLHAuYWxpZ24oZCwhMSxtKSwocz1mLmlzSW5zaWRlUGxvdChwLmFsaWduQXR0ci54K2QueCtyLHAuYWxpZ25BdHRyLnkrZC55K24pKXx8KGk9ITEpLGkmJm8ucHJvdG90eXBlLmp1c3RpZnlEYXRhTGFiZWwuY2FsbChjLHAsZCxwLmFsaWduQXR0cix0LG0pLHAuYXR0cih7eDpwLmFsaWduQXR0ci54LHk6cC5hbGlnbkF0dHIueSxyb3RhdGlvbjp1LnJvdGF0aW9uLHJvdGF0aW9uT3JpZ2luWDp0LndpZHRoLzIscm90YXRpb25PcmlnaW5ZOnQuaGVpZ2h0LzJ9KSxoKCFpJiZ1LmNyb3AsITApJiYocz1hKHAueCkmJmEocC55KSYmZi5pc0luc2lkZVBsb3QocC54LWUrKHAud2lkdGh8fDApLHAueSkmJmYuaXNJbnNpZGVQbG90KHAueCtlLHAueSkpLHBbcz9cInNob3dcIjpcImhpZGVcIl0oKX1uKHRoaXMsXCJhZnRlclNldE9mZnNldFwiLHt4T2Zmc2V0OnQsd2lkdGg6ZX0pfWFkanVzdFN0YWNrUG9zaXRpb24oe2xhYmVsQm94OnQsdmVydGljYWxBbGlnbjplLHRleHRBbGlnbjppfSl7bGV0IHM9e2JvdHRvbTowLG1pZGRsZToxLHRvcDoyLHJpZ2h0OjEsY2VudGVyOjAsbGVmdDotMX0sbz1zW2VdLHI9c1tpXTtyZXR1cm57eDp0LndpZHRoLzIrdC53aWR0aC8yKnIseTp0LmhlaWdodC8yKm99fWdldFN0YWNrQm94KHQpe2xldCBlPXRoaXMuYXhpcyxpPWUuY2hhcnQse2JveFRvcDpzLGRlZmF1bHRYOm8seE9mZnNldDpyLHdpZHRoOm4sYm94Qm90dG9tOmx9PXQsZD1lLnN0YWNraW5nLnVzZVBlcmNlbnRhZ2U/MTAwOmgocyx0aGlzLnRvdGFsLDApLGM9ZS50b1BpeGVscyhkKSxwPXQueEF4aXN8fGkueEF4aXNbMF0sdT1oKG8scC50cmFuc2xhdGUodGhpcy54KSkrcixnPWUudG9QaXhlbHMobHx8YShlLm1pbikmJmUubG9nYXJpdGhtaWMmJmUubG9nYXJpdGhtaWMubGluMmxvZyhlLm1pbil8fDApLGY9TWF0aC5hYnMoYy1nKSxtPWkuaW52ZXJ0ZWQseD10aGlzLmlzTmVnYXRpdmU7cmV0dXJuIG0/e3g6KHg/YzpjLWYpLWkucGxvdExlZnQseTpwLmhlaWdodC11LW4sd2lkdGg6ZixoZWlnaHQ6bn06e3g6dStwLnRyYW5zQi1pLnBsb3RMZWZ0LHk6KHg/Yy1mOmMpLWkucGxvdFRvcCx3aWR0aDpuLGhlaWdodDpmfX19fSksaShlLFwiQ29yZS9BeGlzL1N0YWNraW5nL1N0YWNraW5nQXhpcy5qc1wiLFtlW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL0F4aXMvQXhpcy5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9BeGlzL1N0YWNraW5nL1N0YWNrSXRlbS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpLHMsbyxyKXt2YXIgbjtsZXR7Z2V0RGVmZXJyZWRBbmltYXRpb246YX09dCx7Y29tcG9zZWQ6aH09aSx7c2VyaWVzOntwcm90b3R5cGU6bH19PXMse2FkZEV2ZW50OmQsY29ycmVjdEZsb2F0OmMsZGVmaW5lZDpwLGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzOnUsZmlyZUV2ZW50OmcsaXNBcnJheTpmLGlzTnVtYmVyOm0sb2JqZWN0RWFjaDp4LHBpY2s6eSxwdXNoVW5pcXVlOmJ9PXI7ZnVuY3Rpb24gdigpe2xldCB0PXRoaXMuaW52ZXJ0ZWQ7dGhpcy5heGVzLmZvckVhY2godD0+e3Quc3RhY2tpbmcmJnQuc3RhY2tpbmcuc3RhY2tzJiZ0Lmhhc1Zpc2libGVTZXJpZXMmJih0LnN0YWNraW5nLm9sZFN0YWNrcz10LnN0YWNraW5nLnN0YWNrcyl9KSx0aGlzLnNlcmllcy5mb3JFYWNoKGU9PntsZXQgaT1lLnhBeGlzJiZlLnhBeGlzLm9wdGlvbnN8fHt9O2Uub3B0aW9ucy5zdGFja2luZyYmZS5yZXNlcnZlU3BhY2UoKSYmKGUuc3RhY2tLZXk9W2UudHlwZSx5KGUub3B0aW9ucy5zdGFjayxcIlwiKSx0P2kudG9wOmkubGVmdCx0P2kuaGVpZ2h0Omkud2lkdGhdLmpvaW4oXCIsXCIpKX0pfWZ1bmN0aW9uIFMoKXtsZXQgdD10aGlzLnN0YWNraW5nO2lmKHQpe2xldCBlPXQuc3RhY2tzO3goZSwodCxpKT0+e3UodCksZGVsZXRlIGVbaV19KSx0LnN0YWNrVG90YWxHcm91cD8uZGVzdHJveSgpfX1mdW5jdGlvbiBrKCl7dGhpcy5zdGFja2luZ3x8KHRoaXMuc3RhY2tpbmc9bmV3IFAodGhpcykpfWZ1bmN0aW9uIE0odCxlLGkscyl7cmV0dXJuIXAodCl8fHQueCE9PWV8fHMmJnQuc3RhY2tLZXkhPT1zP3Q9e3g6ZSxpbmRleDowLGtleTpzLHN0YWNrS2V5OnN9OnQuaW5kZXgrKyx0LmtleT1baSxlLHQuaW5kZXhdLmpvaW4oXCIsXCIpLHR9ZnVuY3Rpb24gQygpe2xldCB0O2xldCBlPXRoaXMsaT1lLnlBeGlzLHM9ZS5zdGFja0tleXx8XCJcIixvPWkuc3RhY2tpbmcuc3RhY2tzLHI9ZS5wcm9jZXNzZWRYRGF0YSxuPWUub3B0aW9ucy5zdGFja2luZyxhPWVbbitcIlN0YWNrZXJcIl07YSYmW3MsXCItXCIrc10uZm9yRWFjaChpPT57bGV0IHM9ci5sZW5ndGgsbixoLGw7Zm9yKDtzLS07KW49cltzXSx0PWUuZ2V0U3RhY2tJbmRpY2F0b3IodCxuLGUuaW5kZXgsaSksaD1vW2ldPy5bbl0sKGw9aD8ucG9pbnRzW3Qua2V5fHxcIlwiXSkmJmEuY2FsbChlLGwsaCxzKX0pfWZ1bmN0aW9uIHcodCxlLGkpe2xldCBzPWUudG90YWw/MTAwL2UudG90YWw6MDt0WzBdPWModFswXSpzKSx0WzFdPWModFsxXSpzKSx0aGlzLnN0YWNrZWRZRGF0YVtpXT10WzFdfWZ1bmN0aW9uIFQodCl7KHRoaXMuaXMoXCJjb2x1bW5cIil8fHRoaXMuaXMoXCJjb2x1bW5yYW5nZVwiKSkmJih0aGlzLm9wdGlvbnMuY2VudGVySW5DYXRlZ29yeSYmIXRoaXMub3B0aW9ucy5zdGFja2luZyYmdGhpcy5jaGFydC5zZXJpZXMubGVuZ3RoPjE/bC5zZXRTdGFja2VkUG9pbnRzLmNhbGwodGhpcyx0LFwiZ3JvdXBcIik6dC5zdGFja2luZy5yZXNldFN0YWNrcygpKX1mdW5jdGlvbiBBKHQsZSl7bGV0IGkscyxyLG4sYSxoLGwsZCx1O2xldCBnPWV8fHRoaXMub3B0aW9ucy5zdGFja2luZztpZighZ3x8IXRoaXMucmVzZXJ2ZVNwYWNlKCl8fCgoe2dyb3VwOlwieEF4aXNcIn0pW2ddfHxcInlBeGlzXCIpIT09dC5jb2xsKXJldHVybjtsZXQgbT10aGlzLnByb2Nlc3NlZFhEYXRhLHg9dGhpcy5wcm9jZXNzZWRZRGF0YSxiPVtdLHY9eC5sZW5ndGgsUz10aGlzLm9wdGlvbnMsaz1TLnRocmVzaG9sZHx8MCxNPVMuc3RhcnRGcm9tVGhyZXNob2xkP2s6MCxDPVMuc3RhY2ssdz1lP2Ake3RoaXMudHlwZX0sJHtnfWA6dGhpcy5zdGFja0tleXx8XCJcIixUPVwiLVwiK3csQT10aGlzLm5lZ1N0YWNrcyxQPXQuc3RhY2tpbmcsTD1QLnN0YWNrcyxPPVAub2xkU3RhY2tzO2ZvcihQLnN0YWNrc1RvdWNoZWQrPTEsbD0wO2w8djtsKyspe2Q9bVtsXSx1PXhbbF0saD0oaT10aGlzLmdldFN0YWNrSW5kaWNhdG9yKGksZCx0aGlzLmluZGV4KSkua2V5fHxcIlwiLExbYT0ocz1BJiZ1PChNPzA6aykpP1Q6d118fChMW2FdPXt9KSxMW2FdW2RdfHwoT1thXT8uW2RdPyhMW2FdW2RdPU9bYV1bZF0sTFthXVtkXS50b3RhbD1udWxsKTpMW2FdW2RdPW5ldyBvKHQsdC5vcHRpb25zLnN0YWNrTGFiZWxzLCEhcyxkLEMpKSxyPUxbYV1bZF0sbnVsbCE9PXU/KHIucG9pbnRzW2hdPXIucG9pbnRzW3RoaXMuaW5kZXhdPVt5KHIuY3VtdWxhdGl2ZSxNKV0scChyLmN1bXVsYXRpdmUpfHwoci5iYXNlPWgpLHIudG91Y2hlZD1QLnN0YWNrc1RvdWNoZWQsaS5pbmRleD4wJiYhMT09PXRoaXMuc2luZ2xlU3RhY2tzJiYoci5wb2ludHNbaF1bMF09ci5wb2ludHNbdGhpcy5pbmRleCtcIixcIitkK1wiLDBcIl1bMF0pKTooZGVsZXRlIHIucG9pbnRzW2hdLGRlbGV0ZSByLnBvaW50c1t0aGlzLmluZGV4XSk7bGV0IGU9ci50b3RhbHx8MDtcInBlcmNlbnRcIj09PWc/KG49cz93OlQsZT1BJiZMW25dPy5bZF0/KG49TFtuXVtkXSkudG90YWw9TWF0aC5tYXgobi50b3RhbHx8MCxlKStNYXRoLmFicyh1KXx8MDpjKGUrKE1hdGguYWJzKHUpfHwwKSkpOlwiZ3JvdXBcIj09PWc/KGYodSkmJih1PXVbMF0pLG51bGwhPT11JiZlKyspOmU9YyhlKyh1fHwwKSksXCJncm91cFwiPT09Zz9yLmN1bXVsYXRpdmU9KGV8fDEpLTE6ci5jdW11bGF0aXZlPWMoeShyLmN1bXVsYXRpdmUsTSkrKHV8fDApKSxyLnRvdGFsPWUsbnVsbCE9PXUmJihyLnBvaW50c1toXS5wdXNoKHIuY3VtdWxhdGl2ZSksYltsXT1yLmN1bXVsYXRpdmUsci5oYXNWYWxpZFBvaW50cz0hMCl9XCJwZXJjZW50XCI9PT1nJiYoUC51c2VQZXJjZW50YWdlPSEwKSxcImdyb3VwXCIhPT1nJiYodGhpcy5zdGFja2VkWURhdGE9YiksUC5vbGRTdGFja3M9e319Y2xhc3MgUHtjb25zdHJ1Y3Rvcih0KXt0aGlzLm9sZFN0YWNrcz17fSx0aGlzLnN0YWNrcz17fSx0aGlzLnN0YWNrc1RvdWNoZWQ9MCx0aGlzLmF4aXM9dH1idWlsZFN0YWNrcygpe2xldCB0LGU7bGV0IGk9dGhpcy5heGlzLHM9aS5zZXJpZXMsbz1cInhBeGlzXCI9PT1pLmNvbGwscj1pLm9wdGlvbnMucmV2ZXJzZWRTdGFja3Msbj1zLmxlbmd0aDtmb3IodGhpcy5yZXNldFN0YWNrcygpLHRoaXMudXNlUGVyY2VudGFnZT0hMSxlPW47ZS0tOyl0PXNbcj9lOm4tZS0xXSxvJiZ0LnNldEdyb3VwZWRQb2ludHMoaSksdC5zZXRTdGFja2VkUG9pbnRzKGkpO2lmKCFvKWZvcihlPTA7ZTxuO2UrKylzW2VdLm1vZGlmeVN0YWNrcygpO2coaSxcImFmdGVyQnVpbGRTdGFja3NcIil9Y2xlYW5TdGFja3MoKXt0aGlzLm9sZFN0YWNrcyYmKHRoaXMuc3RhY2tzPXRoaXMub2xkU3RhY2tzLHgodGhpcy5zdGFja3MsdD0+e3godCx0PT57dC5jdW11bGF0aXZlPXQudG90YWx9KX0pKX1yZXNldFN0YWNrcygpe3godGhpcy5zdGFja3MsdD0+e3godCwoZSxpKT0+e20oZS50b3VjaGVkKSYmZS50b3VjaGVkPHRoaXMuc3RhY2tzVG91Y2hlZD8oZS5kZXN0cm95KCksZGVsZXRlIHRbaV0pOihlLnRvdGFsPW51bGwsZS5jdW11bGF0aXZlPW51bGwpfSl9KX1yZW5kZXJTdGFja1RvdGFscygpe2xldCB0PXRoaXMuYXhpcyxlPXQuY2hhcnQsaT1lLnJlbmRlcmVyLHM9dGhpcy5zdGFja3Msbz10Lm9wdGlvbnMuc3RhY2tMYWJlbHM/LmFuaW1hdGlvbixyPWEoZSxvfHwhMSksbj10aGlzLnN0YWNrVG90YWxHcm91cD10aGlzLnN0YWNrVG90YWxHcm91cHx8aS5nKFwic3RhY2stbGFiZWxzXCIpLmF0dHIoe3pJbmRleDo2LG9wYWNpdHk6MH0pLmFkZCgpO24udHJhbnNsYXRlKGUucGxvdExlZnQsZS5wbG90VG9wKSx4KHMsdD0+e3godCx0PT57dC5yZW5kZXIobil9KX0pLG4uYW5pbWF0ZSh7b3BhY2l0eToxfSxyKX19cmV0dXJuKG58fChuPXt9KSkuY29tcG9zZT1mdW5jdGlvbiB0KGUsaSxzKXtpZihiKGgsdCkpe2xldCB0PWkucHJvdG90eXBlLG89cy5wcm90b3R5cGU7ZChlLFwiaW5pdFwiLGspLGQoZSxcImRlc3Ryb3lcIixTKSx0LmdldFN0YWNrcz12LG8uZ2V0U3RhY2tJbmRpY2F0b3I9TSxvLm1vZGlmeVN0YWNrcz1DLG8ucGVyY2VudFN0YWNrZXI9dyxvLnNldEdyb3VwZWRQb2ludHM9VCxvLnNldFN0YWNrZWRQb2ludHM9QX19LG59KSxpKGUsXCJTZXJpZXMvTGluZS9MaW5lU2VyaWVzLmpzXCIsW2VbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkpe2xldHtkZWZpbmVkOnMsbWVyZ2U6byxpc09iamVjdDpyfT1pO2NsYXNzIG4gZXh0ZW5kcyB0e2RyYXdHcmFwaCgpe2xldCB0PXRoaXMub3B0aW9ucyxlPSh0aGlzLmdhcHBlZFBhdGh8fHRoaXMuZ2V0R3JhcGhQYXRoKS5jYWxsKHRoaXMpLGk9dGhpcy5jaGFydC5zdHlsZWRNb2RlO1t0aGlzLC4uLnRoaXMuem9uZXNdLmZvckVhY2goKHMsbik9PntsZXQgYSxoPXMuZ3JhcGgsbD1oP1wiYW5pbWF0ZVwiOlwiYXR0clwiLGQ9cy5kYXNoU3R5bGV8fHQuZGFzaFN0eWxlO2g/KGguZW5kWD10aGlzLnByZXZlbnRHcmFwaEFuaW1hdGlvbj9udWxsOmUueE1hcCxoLmFuaW1hdGUoe2Q6ZX0pKTplLmxlbmd0aCYmKHMuZ3JhcGg9aD10aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoZSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWdyYXBoXCIrKG4/YCBoaWdoY2hhcnRzLXpvbmUtZ3JhcGgtJHtuLTF9IGA6XCIgXCIpKyhuJiZzLmNsYXNzTmFtZXx8XCJcIikpLmF0dHIoe3pJbmRleDoxfSkuYWRkKHRoaXMuZ3JvdXApKSxoJiYhaSYmKGE9e3N0cm9rZTohbiYmdC5saW5lQ29sb3J8fHMuY29sb3J8fHRoaXMuY29sb3J8fFwiI2NjY2NjY1wiLFwic3Ryb2tlLXdpZHRoXCI6dC5saW5lV2lkdGh8fDAsZmlsbDp0aGlzLmZpbGxHcmFwaCYmdGhpcy5jb2xvcnx8XCJub25lXCJ9LGQ/YS5kYXNoc3R5bGU9ZDpcInNxdWFyZVwiIT09dC5saW5lY2FwJiYoYVtcInN0cm9rZS1saW5lY2FwXCJdPWFbXCJzdHJva2UtbGluZWpvaW5cIl09XCJyb3VuZFwiKSxoW2xdKGEpLnNoYWRvdyhuPDImJnQuc2hhZG93JiZvKHtmaWx0ZXJVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9LHIodC5zaGFkb3cpP3Quc2hhZG93Ont9KSkpLGgmJihoLnN0YXJ0WD1lLnhNYXAsaC5pc0FyZWE9ZS5pc0FyZWEpfSl9Z2V0R3JhcGhQYXRoKHQsZSxpKXtsZXQgbz10aGlzLHI9by5vcHRpb25zLG49W10sYT1bXSxoLGw9ci5zdGVwO3Q9dHx8by5wb2ludHM7bGV0IGQ9dC5yZXZlcnNlZDtyZXR1cm4gZCYmdC5yZXZlcnNlKCksKGw9KHtyaWdodDoxLGNlbnRlcjoyfSlbbF18fGwmJjMpJiZkJiYobD00LWwpLCh0PXRoaXMuZ2V0VmFsaWRQb2ludHModCwhMSwhKHIuY29ubmVjdE51bGxzJiYhZSYmIWkpKSkuZm9yRWFjaChmdW5jdGlvbihkLGMpe2xldCBwO2xldCB1PWQucGxvdFgsZz1kLnBsb3RZLGY9dFtjLTFdLG09ZC5pc051bGx8fFwibnVtYmVyXCIhPXR5cGVvZiBnOyhkLmxlZnRDbGlmZnx8ZiYmZi5yaWdodENsaWZmKSYmIWkmJihoPSEwKSxtJiYhcyhlKSYmYz4wP2g9IXIuY29ubmVjdE51bGxzOm0mJiFlP2g9ITA6KDA9PT1jfHxoP3A9W1tcIk1cIixkLnBsb3RYLGQucGxvdFldXTpvLmdldFBvaW50U3BsaW5lP3A9W28uZ2V0UG9pbnRTcGxpbmUodCxkLGMpXTpsPyhwPTE9PT1sP1tbXCJMXCIsZi5wbG90WCxnXV06Mj09PWw/W1tcIkxcIiwoZi5wbG90WCt1KS8yLGYucGxvdFldLFtcIkxcIiwoZi5wbG90WCt1KS8yLGddXTpbW1wiTFwiLHUsZi5wbG90WV1dKS5wdXNoKFtcIkxcIix1LGddKTpwPVtbXCJMXCIsdSxnXV0sYS5wdXNoKGQueCksbCYmKGEucHVzaChkLngpLDI9PT1sJiZhLnB1c2goZC54KSksbi5wdXNoLmFwcGx5KG4scCksaD0hMSl9KSxuLnhNYXA9YSxvLmdyYXBoUGF0aD1uLG59fXJldHVybiBuLmRlZmF1bHRPcHRpb25zPW8odC5kZWZhdWx0T3B0aW9ucyx7bGVnZW5kU3ltYm9sOlwibGluZU1hcmtlclwifSksZS5yZWdpc3RlclNlcmllc1R5cGUoXCJsaW5lXCIsbiksbn0pLGkoZSxcIlNlcmllcy9BcmVhL0FyZWFTZXJpZXMuanNcIixbZVtcIkNvcmUvQ29sb3IvQ29sb3IuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkpe2xldHtwYXJzZTpzfT10LHtzZXJpZXNUeXBlczp7bGluZTpvfX09ZSx7ZXh0ZW5kOnIsbWVyZ2U6bixvYmplY3RFYWNoOmEscGljazpofT1pO2NsYXNzIGwgZXh0ZW5kcyBve2RyYXdHcmFwaCgpe3RoaXMuYXJlYVBhdGg9W10sc3VwZXIuZHJhd0dyYXBoLmFwcGx5KHRoaXMpO2xldHthcmVhUGF0aDp0LG9wdGlvbnM6ZX09dGhpcztbdGhpcywuLi50aGlzLnpvbmVzXS5mb3JFYWNoKChpLHMpPT57bGV0IG89e30scj1pLmZpbGxDb2xvcnx8ZS5maWxsQ29sb3Isbj1pLmFyZWEsYT1uP1wiYW5pbWF0ZVwiOlwiYXR0clwiO24/KG4uZW5kWD10aGlzLnByZXZlbnRHcmFwaEFuaW1hdGlvbj9udWxsOnQueE1hcCxuLmFuaW1hdGUoe2Q6dH0pKTooby56SW5kZXg9MCwobj1pLmFyZWE9dGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKHQpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1hcmVhXCIrKHM/YCBoaWdoY2hhcnRzLXpvbmUtYXJlYS0ke3MtMX0gYDpcIiBcIikrKHMmJmkuY2xhc3NOYW1lfHxcIlwiKSkuYWRkKHRoaXMuZ3JvdXApKS5pc0FyZWE9ITApLHRoaXMuY2hhcnQuc3R5bGVkTW9kZXx8KG8uZmlsbD1yfHxpLmNvbG9yfHx0aGlzLmNvbG9yLG9bXCJmaWxsLW9wYWNpdHlcIl09cj8xOmUuZmlsbE9wYWNpdHk/Py43NSxuLmNzcyh7cG9pbnRlckV2ZW50czp0aGlzLnN0aWNreVRyYWNraW5nP1wibm9uZVwiOlwiYXV0b1wifSkpLG5bYV0obyksbi5zdGFydFg9dC54TWFwLG4uc2hpZnRVbml0PWUuc3RlcD8yOjF9KX1nZXRHcmFwaFBhdGgodCl7bGV0IGUsaSxzO2xldCByPW8ucHJvdG90eXBlLmdldEdyYXBoUGF0aCxuPXRoaXMub3B0aW9ucyxhPW4uc3RhY2tpbmcsbD10aGlzLnlBeGlzLGQ9W10sYz1bXSxwPXRoaXMuaW5kZXgsdT1sLnN0YWNraW5nLnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxnPW4udGhyZXNob2xkLGY9TWF0aC5yb3VuZChsLmdldFRocmVzaG9sZChuLnRocmVzaG9sZCkpLG09aChuLmNvbm5lY3ROdWxscyxcInBlcmNlbnRcIj09PWEpLHg9ZnVuY3Rpb24oaSxzLG8pe2xldCByPXRbaV0sbj1hJiZ1W3IueF0ucG9pbnRzW3BdLGg9cltvK1wiTnVsbFwiXXx8MCxtPXJbbytcIkNsaWZmXCJdfHwwLHgseSxiPSEwO218fGg/KHg9KGg/blswXTpuWzFdKSttLHk9blswXSttLGI9ISFoKTohYSYmdFtzXSYmdFtzXS5pc051bGwmJih4PXk9Zyksdm9pZCAwIT09eCYmKGMucHVzaCh7cGxvdFg6ZSxwbG90WTpudWxsPT09eD9mOmwuZ2V0VGhyZXNob2xkKHgpLGlzTnVsbDpiLGlzQ2xpZmY6ITB9KSxkLnB1c2goe3Bsb3RYOmUscGxvdFk6bnVsbD09PXk/ZjpsLmdldFRocmVzaG9sZCh5KSxkb0N1cnZlOiExfSkpfTt0PXR8fHRoaXMucG9pbnRzLGEmJih0PXRoaXMuZ2V0U3RhY2tQb2ludHModCkpO2ZvcihsZXQgbz0wLHI9dC5sZW5ndGg7bzxyOysrbylhfHwodFtvXS5sZWZ0Q2xpZmY9dFtvXS5yaWdodENsaWZmPXRbb10ubGVmdE51bGw9dFtvXS5yaWdodE51bGw9dm9pZCAwKSxpPXRbb10uaXNOdWxsLGU9aCh0W29dLnJlY3RQbG90WCx0W29dLnBsb3RYKSxzPWE/aCh0W29dLnlCb3R0b20sZik6ZixpJiYhbXx8KG18fHgobyxvLTEsXCJsZWZ0XCIpLGkmJiFhJiZtfHwoYy5wdXNoKHRbb10pLGQucHVzaCh7eDpvLHBsb3RYOmUscGxvdFk6c30pKSxtfHx4KG8sbysxLFwicmlnaHRcIikpO2xldCB5PXIuY2FsbCh0aGlzLGMsITAsITApO2QucmV2ZXJzZWQ9ITA7bGV0IGI9ci5jYWxsKHRoaXMsZCwhMCwhMCksdj1iWzBdO3YmJlwiTVwiPT09dlswXSYmKGJbMF09W1wiTFwiLHZbMV0sdlsyXV0pO2xldCBTPXkuY29uY2F0KGIpO1MubGVuZ3RoJiZTLnB1c2goW1wiWlwiXSk7bGV0IGs9ci5jYWxsKHRoaXMsYywhMSxtKTtyZXR1cm4gUy54TWFwPXkueE1hcCx0aGlzLmFyZWFQYXRoPVMsa31nZXRTdGFja1BvaW50cyh0KXtsZXQgZT10aGlzLGk9W10scz1bXSxvPXRoaXMueEF4aXMscj10aGlzLnlBeGlzLG49ci5zdGFja2luZy5zdGFja3NbdGhpcy5zdGFja0tleV0sbD17fSxkPXIuc2VyaWVzLGM9ZC5sZW5ndGgscD1yLm9wdGlvbnMucmV2ZXJzZWRTdGFja3M/MTotMSx1PWQuaW5kZXhPZihlKTtpZih0PXR8fHRoaXMucG9pbnRzLHRoaXMub3B0aW9ucy5zdGFja2luZyl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXS5sZWZ0TnVsbD10W2VdLnJpZ2h0TnVsbD12b2lkIDAsbFt0W2VdLnhdPXRbZV07YShuLGZ1bmN0aW9uKHQsZSl7bnVsbCE9PXQudG90YWwmJnMucHVzaChlKX0pLHMuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9KTtsZXQgZz1kLm1hcCh0PT50LnZpc2libGUpO3MuZm9yRWFjaChmdW5jdGlvbih0LGEpe2xldCBmPTAsbSx4O2lmKGxbdF0mJiFsW3RdLmlzTnVsbClpLnB1c2gobFt0XSksWy0xLDFdLmZvckVhY2goZnVuY3Rpb24oaSl7bGV0IG89MT09PWk/XCJyaWdodE51bGxcIjpcImxlZnROdWxsXCIscj1uW3NbYStpXV0saD0wO2lmKHIpe2xldCBpPXU7Zm9yKDtpPj0wJiZpPGM7KXtsZXQgcz1kW2ldLmluZGV4OyEobT1yLnBvaW50c1tzXSkmJihzPT09ZS5pbmRleD9sW3RdW29dPSEwOmdbaV0mJih4PW5bdF0ucG9pbnRzW3NdKSYmKGgtPXhbMV0teFswXSkpLGkrPXB9fWxbdF1bMT09PWk/XCJyaWdodENsaWZmXCI6XCJsZWZ0Q2xpZmZcIl09aH0pO2Vsc2V7bGV0IGU9dTtmb3IoO2U+PTAmJmU8Yzspe2xldCBpPWRbZV0uaW5kZXg7aWYobT1uW3RdLnBvaW50c1tpXSl7Zj1tWzFdO2JyZWFrfWUrPXB9Zj1oKGYsMCksZj1yLnRyYW5zbGF0ZShmLDAsMSwwLDEpLGkucHVzaCh7aXNOdWxsOiEwLHBsb3RYOm8udHJhbnNsYXRlKHQsMCwwLDAsMSkseDp0LHBsb3RZOmYseUJvdHRvbTpmfSl9fSl9cmV0dXJuIGl9fXJldHVybiBsLmRlZmF1bHRPcHRpb25zPW4oby5kZWZhdWx0T3B0aW9ucyx7dGhyZXNob2xkOjAsbGVnZW5kU3ltYm9sOlwiYXJlYU1hcmtlclwifSkscihsLnByb3RvdHlwZSx7c2luZ2xlU3RhY2tzOiExfSksZS5yZWdpc3RlclNlcmllc1R5cGUoXCJhcmVhXCIsbCksbH0pLGkoZSxcIlNlcmllcy9TcGxpbmUvU3BsaW5lU2VyaWVzLmpzXCIsW2VbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSl7bGV0e2xpbmU6aX09dC5zZXJpZXNUeXBlcyx7bWVyZ2U6cyxwaWNrOm99PWU7Y2xhc3MgciBleHRlbmRzIGl7Z2V0UG9pbnRTcGxpbmUodCxlLGkpe2xldCBzLHIsbixhO2xldCBoPWUucGxvdFh8fDAsbD1lLnBsb3RZfHwwLGQ9dFtpLTFdLGM9dFtpKzFdO2Z1bmN0aW9uIHAodCl7cmV0dXJuIHQmJiF0LmlzTnVsbCYmITEhPT10LmRvQ3VydmUmJiFlLmlzQ2xpZmZ9aWYocChkKSYmcChjKSl7bGV0IHQ9ZC5wbG90WHx8MCxpPWQucGxvdFl8fDAsbz1jLnBsb3RYfHwwLHA9Yy5wbG90WXx8MCx1PTA7cz0oMS41KmgrdCkvMi41LHI9KDEuNSpsK2kpLzIuNSxuPSgxLjUqaCtvKS8yLjUsYT0oMS41KmwrcCkvMi41LG4hPT1zJiYodT0oYS1yKSoobi1oKS8obi1zKStsLWEpLHIrPXUsYSs9dSxyPmkmJnI+bD8ocj1NYXRoLm1heChpLGwpLGE9MipsLXIpOnI8aSYmcjxsJiYocj1NYXRoLm1pbihpLGwpLGE9MipsLXIpLGE+cCYmYT5sPyhhPU1hdGgubWF4KHAsbCkscj0yKmwtYSk6YTxwJiZhPGwmJihhPU1hdGgubWluKHAsbCkscj0yKmwtYSksZS5yaWdodENvbnRYPW4sZS5yaWdodENvbnRZPWEsZS5jb250cm9sUG9pbnRzPXtsb3c6W3Mscl0saGlnaDpbbixhXX19bGV0IHU9W1wiQ1wiLG8oZC5yaWdodENvbnRYLGQucGxvdFgsMCksbyhkLnJpZ2h0Q29udFksZC5wbG90WSwwKSxvKHMsaCwwKSxvKHIsbCwwKSxoLGxdO3JldHVybiBkLnJpZ2h0Q29udFg9ZC5yaWdodENvbnRZPXZvaWQgMCx1fX1yZXR1cm4gci5kZWZhdWx0T3B0aW9ucz1zKGkuZGVmYXVsdE9wdGlvbnMpLHQucmVnaXN0ZXJTZXJpZXNUeXBlKFwic3BsaW5lXCIscikscn0pLGkoZSxcIlNlcmllcy9BcmVhU3BsaW5lL0FyZWFTcGxpbmVTZXJpZXMuanNcIixbZVtcIlNlcmllcy9TcGxpbmUvU3BsaW5lU2VyaWVzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpKXtsZXR7YXJlYTpzLGFyZWE6e3Byb3RvdHlwZTpvfX09ZS5zZXJpZXNUeXBlcyx7ZXh0ZW5kOnIsbWVyZ2U6bn09aTtjbGFzcyBhIGV4dGVuZHMgdHt9cmV0dXJuIGEuZGVmYXVsdE9wdGlvbnM9bih0LmRlZmF1bHRPcHRpb25zLHMuZGVmYXVsdE9wdGlvbnMpLHIoYS5wcm90b3R5cGUse2dldEdyYXBoUGF0aDpvLmdldEdyYXBoUGF0aCxnZXRTdGFja1BvaW50czpvLmdldFN0YWNrUG9pbnRzLGRyYXdHcmFwaDpvLmRyYXdHcmFwaH0pLGUucmVnaXN0ZXJTZXJpZXNUeXBlKFwiYXJlYXNwbGluZVwiLGEpLGF9KSxpKGUsXCJTZXJpZXMvQ29sdW1uL0NvbHVtblNlcmllc0RlZmF1bHRzLmpzXCIsW10sZnVuY3Rpb24oKXtyZXR1cm57Ym9yZGVyUmFkaXVzOjMsY2VudGVySW5DYXRlZ29yeTohMSxncm91cFBhZGRpbmc6LjIsbWFya2VyOm51bGwscG9pbnRQYWRkaW5nOi4xLG1pblBvaW50TGVuZ3RoOjAsY3JvcFRocmVzaG9sZDo1MCxwb2ludFJhbmdlOm51bGwsc3RhdGVzOntob3Zlcjp7aGFsbzohMSxicmlnaHRuZXNzOi4xfSxzZWxlY3Q6e2NvbG9yOlwiI2NjY2NjY1wiLGJvcmRlckNvbG9yOlwiIzAwMDAwMFwifX0sZGF0YUxhYmVsczp7YWxpZ246dm9pZCAwLHZlcnRpY2FsQWxpZ246dm9pZCAwLHk6dm9pZCAwfSxzdGFydEZyb21UaHJlc2hvbGQ6ITAsc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7ZGlzdGFuY2U6Nn0sdGhyZXNob2xkOjAsYm9yZGVyQ29sb3I6XCIjZmZmZmZmXCJ9fSksaShlLFwiU2VyaWVzL0NvbHVtbi9Db2x1bW5TZXJpZXMuanNcIixbZVtcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxlW1wiU2VyaWVzL0NvbHVtbi9Db2x1bW5TZXJpZXNEZWZhdWx0cy5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyxvLHIsbil7bGV0e2FuaW1PYmplY3Q6YX09dCx7cGFyc2U6aH09ZSx7aGFzVG91Y2g6bCxub29wOmR9PXMse2NsYW1wOmMsZGVmaW5lZDpwLGV4dGVuZDp1LGZpcmVFdmVudDpnLGlzQXJyYXk6Zixpc051bWJlcjptLG1lcmdlOngscGljazp5LG9iamVjdEVhY2g6YixyZWxhdGl2ZUxlbmd0aDp2fT1uO2NsYXNzIFMgZXh0ZW5kcyBve2FuaW1hdGUodCl7bGV0IGUsaTtsZXQgcz10aGlzLG89dGhpcy55QXhpcyxyPW8ucG9zLG49cy5vcHRpb25zLGg9dGhpcy5jaGFydC5pbnZlcnRlZCxsPXt9LGQ9aD9cInRyYW5zbGF0ZVhcIjpcInRyYW5zbGF0ZVlcIjt0PyhsLnNjYWxlWT0uMDAxLGk9YyhvLnRvUGl4ZWxzKG4udGhyZXNob2xkKSxyLHIrby5sZW4pLGg/bC50cmFuc2xhdGVYPWktby5sZW46bC50cmFuc2xhdGVZPWkscy5jbGlwQm94JiZzLnNldENsaXAoKSxzLmdyb3VwLmF0dHIobCkpOihlPU51bWJlcihzLmdyb3VwLmF0dHIoZCkpLHMuZ3JvdXAuYW5pbWF0ZSh7c2NhbGVZOjF9LHUoYShzLm9wdGlvbnMuYW5pbWF0aW9uKSx7c3RlcDpmdW5jdGlvbih0LGkpe3MuZ3JvdXAmJihsW2RdPWUraS5wb3MqKHItZSkscy5ncm91cC5hdHRyKGwpKX19KSkpfWluaXQodCxlKXtzdXBlci5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtsZXQgaT10aGlzOyh0PWkuY2hhcnQpLmhhc1JlbmRlcmVkJiZ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QudHlwZT09PWkudHlwZSYmKHQuaXNEaXJ0eT0hMCl9KX1nZXRDb2x1bW5NZXRyaWNzKCl7bGV0IHQ9dGhpcyxlPXQub3B0aW9ucyxpPXQueEF4aXMscz10LnlBeGlzLG89aS5vcHRpb25zLnJldmVyc2VkU3RhY2tzLHI9aS5yZXZlcnNlZCYmIW98fCFpLnJldmVyc2VkJiZvLG49e30sYSxoPTA7ITE9PT1lLmdyb3VwaW5nP2g9MTp0LmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2xldCBpO2xldCBvPWUueUF4aXMscj1lLm9wdGlvbnM7ZS50eXBlPT09dC50eXBlJiZlLnJlc2VydmVTcGFjZSgpJiZzLmxlbj09PW8ubGVuJiZzLnBvcz09PW8ucG9zJiYoci5zdGFja2luZyYmXCJncm91cFwiIT09ci5zdGFja2luZz8odm9pZCAwPT09blthPWUuc3RhY2tLZXldJiYoblthXT1oKyspLGk9blthXSk6ITEhPT1yLmdyb3VwaW5nJiYoaT1oKyspLGUuY29sdW1uSW5kZXg9aSl9KTtsZXQgbD1NYXRoLm1pbihNYXRoLmFicyhpLnRyYW5zQSkqKCFpLmJyb2tlbkF4aXM/Lmhhc0JyZWFrcyYmaS5vcmRpbmFsPy5zbG9wZXx8ZS5wb2ludFJhbmdlfHxpLmNsb3Nlc3RQb2ludFJhbmdlfHxpLnRpY2tJbnRlcnZhbHx8MSksaS5sZW4pLGQ9bCplLmdyb3VwUGFkZGluZyxjPShsLTIqZCkvKGh8fDEpLHA9TWF0aC5taW4oZS5tYXhQb2ludFdpZHRofHxpLmxlbix5KGUucG9pbnRXaWR0aCxjKigxLTIqZS5wb2ludFBhZGRpbmcpKSksdT0oYy1wKS8yLGc9KHQuY29sdW1uSW5kZXh8fDApKyhyPzE6MCksZj11KyhkK2cqYy1sLzIpKihyPy0xOjEpO3JldHVybiB0LmNvbHVtbk1ldHJpY3M9e3dpZHRoOnAsb2Zmc2V0OmYscGFkZGVkV2lkdGg6Yyxjb2x1bW5Db3VudDpofSx0LmNvbHVtbk1ldHJpY3N9Y3Jpc3BDb2wodCxlLGkscyl7dGhpcy5jaGFydDtsZXQgbz10aGlzLmJvcmRlcldpZHRoLHI9LShvJTI/LjU6MCksbj1vJTI/LjU6MTt0aGlzLm9wdGlvbnMuY3Jpc3AmJihpPU1hdGgucm91bmQodCtpKStyLSh0PU1hdGgucm91bmQodCkrcikpO2xldCBhPU1hdGgucm91bmQoZStzKStuLGg9LjU+PU1hdGguYWJzKGUpJiZhPi41O3JldHVybiBzPWEtKGU9TWF0aC5yb3VuZChlKStuKSxoJiZzJiYoZS09MSxzKz0xKSx7eDp0LHk6ZSx3aWR0aDppLGhlaWdodDpzfX1hZGp1c3RGb3JNaXNzaW5nQ29sdW1ucyh0LGUsaSxzKXtpZighaS5pc051bGwmJnMuY29sdW1uQ291bnQ+MSl7bGV0IG89dGhpcy54QXhpcy5zZXJpZXMuZmlsdGVyKHQ9PnQudmlzaWJsZSkubWFwKHQ9PnQuaW5kZXgpLHI9MCxuPTA7Yih0aGlzLnhBeGlzLnN0YWNraW5nPy5zdGFja3MsdD0+e2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpLngpe2xldCBlPXRbaS54LnRvU3RyaW5nKCldO2lmKGUpe2xldCB0PWUucG9pbnRzW3RoaXMuaW5kZXhdO2lmKGYodCkpe2xldCB0PU9iamVjdC5rZXlzKGUucG9pbnRzKS5maWx0ZXIodD0+IXQubWF0Y2goXCIsXCIpJiZlLnBvaW50c1t0XSYmZS5wb2ludHNbdF0ubGVuZ3RoPjEpLm1hcChwYXJzZUZsb2F0KS5maWx0ZXIodD0+LTEhPT1vLmluZGV4T2YodCkpLnNvcnQoKHQsZSk9PmUtdCk7cj10LmluZGV4T2YodGhpcy5pbmRleCksbj10Lmxlbmd0aH19fX0pO2xldCBhPShuLTEpKnMucGFkZGVkV2lkdGgrZTt0PShpLnBsb3RYfHwwKSthLzItZS1yKnMucGFkZGVkV2lkdGh9cmV0dXJuIHR9dHJhbnNsYXRlKCl7bGV0IHQ9dGhpcyxlPXQuY2hhcnQsaT10Lm9wdGlvbnMscz10LmRlbnNlPXQuY2xvc2VzdFBvaW50UmFuZ2UqdC54QXhpcy50cmFuc0E8MixyPXQuYm9yZGVyV2lkdGg9eShpLmJvcmRlcldpZHRoLHM/MDoxKSxuPXQueEF4aXMsYT10LnlBeGlzLGg9aS50aHJlc2hvbGQsbD15KGkubWluUG9pbnRMZW5ndGgsNSksZD10LmdldENvbHVtbk1ldHJpY3MoKSx1PWQud2lkdGgsZj10LnBvaW50WE9mZnNldD1kLm9mZnNldCx4PXQuZGF0YU1pbixiPXQuZGF0YU1heCx2PXQuYmFyVz1NYXRoLm1heCh1LDErMipyKSxTPXQudHJhbnNsYXRlZFRocmVzaG9sZD1hLmdldFRocmVzaG9sZChoKTtlLmludmVydGVkJiYoUy09LjUpLGkucG9pbnRQYWRkaW5nJiYodj1NYXRoLmNlaWwodikpLG8ucHJvdG90eXBlLnRyYW5zbGF0ZS5hcHBseSh0KSx0LnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHMpe2xldCBvPXkocy55Qm90dG9tLFMpLHI9OTk5K01hdGguYWJzKG8pLGc9cy5wbG90WHx8MCxrPWMocy5wbG90WSwtcixhLmxlbityKTtzLnN0YWNrQm94O2xldCBNLEM9TWF0aC5taW4oayxvKSx3PU1hdGgubWF4KGssbyktQyxUPXUsQT1nK2YsUD12O2wmJk1hdGguYWJzKHcpPGwmJih3PWwsTT0hYS5yZXZlcnNlZCYmIXMubmVnYXRpdmV8fGEucmV2ZXJzZWQmJnMubmVnYXRpdmUsbShoKSYmbShiKSYmcy55PT09aCYmYjw9aCYmKGEubWlufHwwKTxoJiYoeCE9PWJ8fChhLm1heHx8MCk8PWgpJiYoTT0hTSxzLm5lZ2F0aXZlPSFzLm5lZ2F0aXZlKSxDPU1hdGguYWJzKEMtUyk+bD9vLWw6Uy0oTT9sOjApKSxwKHMub3B0aW9ucy5wb2ludFdpZHRoKSYmKEEtPU1hdGgucm91bmQoKChUPVA9TWF0aC5jZWlsKHMub3B0aW9ucy5wb2ludFdpZHRoKSktdSkvMikpLGkuY2VudGVySW5DYXRlZ29yeSYmIWkuc3RhY2tpbmcmJihBPXQuYWRqdXN0Rm9yTWlzc2luZ0NvbHVtbnMoQSxULHMsZCkpLHMuYmFyWD1BLHMucG9pbnRXaWR0aD1ULHMudG9vbHRpcFBvcz1lLmludmVydGVkP1tjKGEubGVuK2EucG9zLWUucGxvdExlZnQtayxhLnBvcy1lLnBsb3RMZWZ0LGEubGVuK2EucG9zLWUucGxvdExlZnQpLG4ubGVuK24ucG9zLWUucGxvdFRvcC1BLVAvMix3XTpbbi5sZWZ0LWUucGxvdExlZnQrQStQLzIsYyhrK2EucG9zLWUucGxvdFRvcCxhLnBvcy1lLnBsb3RUb3AsYS5sZW4rYS5wb3MtZS5wbG90VG9wKSx3XSxzLnNoYXBlVHlwZT10LnBvaW50Q2xhc3MucHJvdG90eXBlLnNoYXBlVHlwZXx8XCJyb3VuZGVkUmVjdFwiLHMuc2hhcGVBcmdzPXQuY3Jpc3BDb2woQSxzLmlzTnVsbD9TOkMsUCxzLmlzTnVsbD8wOncpfSksZyh0aGlzLFwiYWZ0ZXJDb2x1bW5UcmFuc2xhdGVcIil9ZHJhd0dyYXBoKCl7dGhpcy5ncm91cFt0aGlzLmRlbnNlP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKFwiaGlnaGNoYXJ0cy1kZW5zZS1kYXRhXCIpfXBvaW50QXR0cmlicyh0LGUpe2xldCBpPXRoaXMub3B0aW9ucyxzPXRoaXMucG9pbnRBdHRyVG9PcHRpb25zfHx7fSxvPXMuc3Ryb2tlfHxcImJvcmRlckNvbG9yXCIscj1zW1wic3Ryb2tlLXdpZHRoXCJdfHxcImJvcmRlcldpZHRoXCIsbixhLGwsZD10JiZ0LmNvbG9yfHx0aGlzLmNvbG9yLGM9dCYmdFtvXXx8aVtvXXx8ZCxwPXQmJnQub3B0aW9ucy5kYXNoU3R5bGV8fGkuZGFzaFN0eWxlLHU9dCYmdFtyXXx8aVtyXXx8dGhpc1tyXXx8MCxnPXkodCYmdC5vcGFjaXR5LGkub3BhY2l0eSwxKTt0JiZ0aGlzLnpvbmVzLmxlbmd0aCYmKGE9dC5nZXRab25lKCksZD10Lm9wdGlvbnMuY29sb3J8fGEmJihhLmNvbG9yfHx0Lm5vblpvbmVkQ29sb3IpfHx0aGlzLmNvbG9yLGEmJihjPWEuYm9yZGVyQ29sb3J8fGMscD1hLmRhc2hTdHlsZXx8cCx1PWEuYm9yZGVyV2lkdGh8fHUpKSxlJiZ0JiYobD0obj14KGkuc3RhdGVzW2VdLHQub3B0aW9ucy5zdGF0ZXMmJnQub3B0aW9ucy5zdGF0ZXNbZV18fHt9KSkuYnJpZ2h0bmVzcyxkPW4uY29sb3J8fHZvaWQgMCE9PWwmJmgoZCkuYnJpZ2h0ZW4obi5icmlnaHRuZXNzKS5nZXQoKXx8ZCxjPW5bb118fGMsdT1uW3JdfHx1LHA9bi5kYXNoU3R5bGV8fHAsZz15KG4ub3BhY2l0eSxnKSk7bGV0IGY9e2ZpbGw6ZCxzdHJva2U6YyxcInN0cm9rZS13aWR0aFwiOnUsb3BhY2l0eTpnfTtyZXR1cm4gcCYmKGYuZGFzaHN0eWxlPXApLGZ9ZHJhd1BvaW50cyh0PXRoaXMucG9pbnRzKXtsZXQgZTtsZXQgaT10aGlzLHM9dGhpcy5jaGFydCxvPWkub3B0aW9ucyxyPXMucmVuZGVyZXIsbj1vLmFuaW1hdGlvbkxpbWl0fHwyNTA7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2xldCBhPXQucGxvdFksaD10LmdyYXBoaWMsbD0hIWgsZD1oJiZzLnBvaW50Q291bnQ8bj9cImFuaW1hdGVcIjpcImF0dHJcIjttKGEpJiZudWxsIT09dC55PyhlPXQuc2hhcGVBcmdzLGgmJnQuaGFzTmV3U2hhcGVUeXBlKCkmJihoPWguZGVzdHJveSgpKSxpLmVuYWJsZWREYXRhU29ydGluZyYmKHQuc3RhcnRYUG9zPWkueEF4aXMucmV2ZXJzZWQ/LShlJiZlLndpZHRofHwwKTppLnhBeGlzLndpZHRoKSwhaCYmKHQuZ3JhcGhpYz1oPXJbdC5zaGFwZVR5cGVdKGUpLmFkZCh0Lmdyb3VwfHxpLmdyb3VwKSxoJiZpLmVuYWJsZWREYXRhU29ydGluZyYmcy5oYXNSZW5kZXJlZCYmcy5wb2ludENvdW50PG4mJihoLmF0dHIoe3g6dC5zdGFydFhQb3N9KSxsPSEwLGQ9XCJhbmltYXRlXCIpKSxoJiZsJiZoW2RdKHgoZSkpLHMuc3R5bGVkTW9kZXx8aFtkXShpLnBvaW50QXR0cmlicyh0LHQuc2VsZWN0ZWQmJlwic2VsZWN0XCIpKS5zaGFkb3coITEhPT10LmFsbG93U2hhZG93JiZvLnNoYWRvdyksaCYmKGguYWRkQ2xhc3ModC5nZXRDbGFzc05hbWUoKSwhMCksaC5hdHRyKHt2aXNpYmlsaXR5OnQudmlzaWJsZT9cImluaGVyaXRcIjpcImhpZGRlblwifSkpKTpoJiYodC5ncmFwaGljPWguZGVzdHJveSgpKX0pfWRyYXdUcmFja2VyKHQ9dGhpcy5wb2ludHMpe2xldCBlO2xldCBpPXRoaXMscz1pLmNoYXJ0LG89cy5wb2ludGVyLHI9ZnVuY3Rpb24odCl7bGV0IGU9by5nZXRQb2ludEZyb21FdmVudCh0KTt2b2lkIDAhPT1lJiZpLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZyYmKG8uaXNEaXJlY3RUb3VjaD0hMCxlLm9uTW91c2VPdmVyKHQpKX07dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2U9Zih0LmRhdGFMYWJlbHMpP3QuZGF0YUxhYmVsczp0LmRhdGFMYWJlbD9bdC5kYXRhTGFiZWxdOltdLHQuZ3JhcGhpYyYmKHQuZ3JhcGhpYy5lbGVtZW50LnBvaW50PXQpLGUuZm9yRWFjaChmdW5jdGlvbihlKXtlLmRpdj9lLmRpdi5wb2ludD10OmUuZWxlbWVudC5wb2ludD10fSl9KSxpLl9oYXNUcmFja2luZ3x8KGkudHJhY2tlckdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lbdF0mJihpW3RdLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIscikub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKHQpe28ub25UcmFja2VyTW91c2VPdXQodCl9KSxsJiZpW3RdLm9uKFwidG91Y2hzdGFydFwiLHIpLCFzLnN0eWxlZE1vZGUmJmkub3B0aW9ucy5jdXJzb3ImJmlbdF0uY3NzKHtjdXJzb3I6aS5vcHRpb25zLmN1cnNvcn0pKX0pLGkuX2hhc1RyYWNraW5nPSEwKSxnKHRoaXMsXCJhZnRlckRyYXdUcmFja2VyXCIpfXJlbW92ZSgpe2xldCB0PXRoaXMsZT10LmNoYXJ0O2UuaGFzUmVuZGVyZWQmJmUuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS50eXBlPT09dC50eXBlJiYoZS5pc0RpcnR5PSEwKX0pLG8ucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0LGFyZ3VtZW50cyl9fXJldHVybiBTLmRlZmF1bHRPcHRpb25zPXgoby5kZWZhdWx0T3B0aW9ucyxpKSx1KFMucHJvdG90eXBlLHtkaXJlY3RUb3VjaDohMCxnZXRTeW1ib2w6ZCxuZWdTdGFja3M6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdfSksci5yZWdpc3RlclNlcmllc1R5cGUoXCJjb2x1bW5cIixTKSxTfSksaShlLFwiQ29yZS9TZXJpZXMvRGF0YUxhYmVsLmpzXCIsW2VbXCJDb3JlL0FuaW1hdGlvbi9BbmltYXRpb25VdGlsaXRpZXMuanNcIl0sZVtcIkNvcmUvVGVtcGxhdGluZy5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyl7dmFyIG87bGV0e2dldERlZmVycmVkQW5pbWF0aW9uOnJ9PXQse2Zvcm1hdDpufT1lLHtjb21wb3NlZDphfT1pLHtkZWZpbmVkOmgsZXh0ZW5kOmwsZmlyZUV2ZW50OmQsaXNBcnJheTpjLGlzU3RyaW5nOnAsbWVyZ2U6dSxvYmplY3RFYWNoOmcscGljazpmLHBJbnQ6bSxwdXNoVW5pcXVlOngsc3BsYXQ6eX09cztyZXR1cm4gZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBrKHRoaXMpLnNvbWUodD0+dD8uZW5hYmxlZCl9ZnVuY3Rpb24gaSh0LGUsaSxzLG8pe2xldCByPXRoaXMsbj10aGlzLmNoYXJ0LGE9dGhpcy5pc0NhcnRlc2lhbiYmbi5pbnZlcnRlZCxkPXRoaXMuZW5hYmxlZERhdGFTb3J0aW5nLGM9dC5wbG90WCxwPXQucGxvdFksdT1pLnJvdGF0aW9uLGc9aS5hbGlnbixtPWgoYykmJmgocCkmJm4uaXNJbnNpZGVQbG90KGMsTWF0aC5yb3VuZChwKSx7aW52ZXJ0ZWQ6YSxwYW5lQ29vcmRpbmF0ZXM6ITAsc2VyaWVzOnJ9KSx4PWk9PntkJiZyLnhBeGlzJiYhUyYmci5zZXREYXRhTGFiZWxTdGFydFBvcyh0LGUsbyxtLGkpfSx5LGIsdixTPVwianVzdGlmeVwiPT09ZihpLm92ZXJmbG93LGQ/XCJub25lXCI6XCJqdXN0aWZ5XCIpLGs9dGhpcy52aXNpYmxlJiYhMSE9PXQudmlzaWJsZSYmaChjKSYmKHQuc2VyaWVzLmZvcmNlREx8fGQmJiFTfHxtfHxmKGkuaW5zaWRlLCEhdGhpcy5vcHRpb25zLnN0YWNraW5nKSYmcyYmbi5pc0luc2lkZVBsb3QoYyxhP3MueCsxOnMueStzLmhlaWdodC0xLHtpbnZlcnRlZDphLHBhbmVDb29yZGluYXRlczohMCxzZXJpZXM6cn0pKSxNPXQucG9zKCk7aWYoayYmTSl7dSYmZS5hdHRyKHthbGlnbjpnfSk7bGV0IHQ9ZS5nZXRCQm94KCEwKSxhPVswLDBdO2lmKHk9bi5yZW5kZXJlci5mb250TWV0cmljcyhlKS5iLHM9bCh7eDpNWzBdLHk6TWF0aC5yb3VuZChNWzFdKSx3aWR0aDowLGhlaWdodDowfSxzKSxsKGkse3dpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fSksdT8oUz0hMSxiPW4ucmVuZGVyZXIucm90Q29ycih5LHUpLHY9e3g6cy54KyhpLnh8fDApK3Mud2lkdGgvMitiLngseTpzLnkrKGkueXx8MCkrKHt0b3A6MCxtaWRkbGU6LjUsYm90dG9tOjF9KVtpLnZlcnRpY2FsQWxpZ25dKnMuaGVpZ2h0fSxhPVt0LngtTnVtYmVyKGUuYXR0cihcInhcIikpLHQueS1OdW1iZXIoZS5hdHRyKFwieVwiKSldLHgodiksZVtvP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh2KSk6KHgocyksZS5hbGlnbihpLHZvaWQgMCxzKSx2PWUuYWxpZ25BdHRyKSxTJiZzLmhlaWdodD49MCl0aGlzLmp1c3RpZnlEYXRhTGFiZWwoZSxpLHYsdCxzLG8pO2Vsc2UgaWYoZihpLmNyb3AsITApKXtsZXR7eDplLHk6aX09djtlKz1hWzBdLGkrPWFbMV0saz1uLmlzSW5zaWRlUGxvdChlLGkse3BhbmVDb29yZGluYXRlczohMCxzZXJpZXM6cn0pJiZuLmlzSW5zaWRlUGxvdChlK3Qud2lkdGgsaSt0LmhlaWdodCx7cGFuZUNvb3JkaW5hdGVzOiEwLHNlcmllczpyfSl9aS5zaGFwZSYmIXUmJmVbbz9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2FuY2hvclg6TVswXSxhbmNob3JZOk1bMV19KX1vJiZkJiYoZS5wbGFjZWQ9ITEpLGt8fGQmJiFTP2Uuc2hvdygpOihlLmhpZGUoKSxlLnBsYWNlZD0hMSl9ZnVuY3Rpb24gcygpe3JldHVybiB0aGlzLnBsb3RHcm91cChcImRhdGFMYWJlbHNHcm91cFwiLFwiZGF0YS1sYWJlbHNcIix0aGlzLmhhc1JlbmRlcmVkP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsdGhpcy5vcHRpb25zLmRhdGFMYWJlbHMuekluZGV4fHw2KX1mdW5jdGlvbiBvKHQpe2xldCBlPXRoaXMuaGFzUmVuZGVyZWR8fDAsaT10aGlzLmluaXREYXRhTGFiZWxzR3JvdXAoKS5hdHRyKHtvcGFjaXR5OitlfSk7cmV0dXJuIWUmJmkmJih0aGlzLnZpc2libGUmJmkuc2hvdygpLHRoaXMub3B0aW9ucy5hbmltYXRpb24/aS5hbmltYXRlKHtvcGFjaXR5OjF9LHQpOmkuYXR0cih7b3BhY2l0eToxfSkpLGl9ZnVuY3Rpb24gYih0KXtsZXQgZTt0PXR8fHRoaXMucG9pbnRzO2xldCBpPXRoaXMscz1pLmNoYXJ0LG89aS5vcHRpb25zLGE9cy5yZW5kZXJlcix7YmFja2dyb3VuZENvbG9yOmwscGxvdEJhY2tncm91bmRDb2xvcjpjfT1zLm9wdGlvbnMuY2hhcnQsdT1hLmdldENvbnRyYXN0KHAoYykmJmN8fHAobCkmJmx8fFwiIzAwMDAwMFwiKSx4PWsoaSkse2FuaW1hdGlvbjpiLGRlZmVyOnZ9PXhbMF0sTT12P3IocyxiLGkpOntkZWZlcjowLGR1cmF0aW9uOjB9O2QodGhpcyxcImRyYXdEYXRhTGFiZWxzXCIpLGkuaGFzRGF0YUxhYmVscz8uKCkmJihlPXRoaXMuaW5pdERhdGFMYWJlbHMoTSksdC5mb3JFYWNoKHQ9PntsZXQgcj10LmRhdGFMYWJlbHN8fFtdO3koUyh4LHQuZGxPcHRpb25zfHx0Lm9wdGlvbnM/LmRhdGFMYWJlbHMpKS5mb3JFYWNoKChsLGQpPT57bGV0IGM9bC5lbmFibGVkJiZ0LnZpc2libGUmJighdC5pc051bGx8fHQuZGF0YUxhYmVsT25OdWxsKSYmZnVuY3Rpb24odCxlKXtsZXQgaT1lLmZpbHRlcjtpZihpKXtsZXQgZT1pLm9wZXJhdG9yLHM9dFtpLnByb3BlcnR5XSxvPWkudmFsdWU7cmV0dXJuXCI+XCI9PT1lJiZzPm98fFwiPFwiPT09ZSYmczxvfHxcIj49XCI9PT1lJiZzPj1vfHxcIjw9XCI9PT1lJiZzPD1vfHxcIj09XCI9PT1lJiZzPT1vfHxcIj09PVwiPT09ZSYmcz09PW98fFwiIT1cIj09PWUmJnMhPW98fFwiIT09XCI9PT1lJiZzIT09b31yZXR1cm4hMH0odCxsKSx7YmFja2dyb3VuZENvbG9yOngsYm9yZGVyQ29sb3I6eSxkaXN0YW5jZTpiLHN0eWxlOnY9e319PWwsUyxrLE0sQyx3PXt9LFQ9cltkXSxBPSFULFA7aWYoYyYmKGs9ZihsW3QuZm9ybWF0UHJlZml4K1wiRm9ybWF0XCJdLGwuZm9ybWF0KSxTPXQuZ2V0TGFiZWxDb25maWcoKSxNPWgoayk/bihrLFMscyk6KGxbdC5mb3JtYXRQcmVmaXgrXCJGb3JtYXR0ZXJcIl18fGwuZm9ybWF0dGVyKS5jYWxsKFMsbCksQz1sLnJvdGF0aW9uLCFzLnN0eWxlZE1vZGUmJih2LmNvbG9yPWYobC5jb2xvcix2LmNvbG9yLHAoaS5jb2xvcik/aS5jb2xvcjp2b2lkIDAsXCIjMDAwMDAwXCIpLFwiY29udHJhc3RcIj09PXYuY29sb3I/KFwibm9uZVwiIT09eCYmKFA9eCksdC5jb250cmFzdENvbG9yPWEuZ2V0Q29udHJhc3QoXCJhdXRvXCIhPT1QJiZQfHx0LmNvbG9yfHxpLmNvbG9yKSx2LmNvbG9yPVB8fCFoKGIpJiZsLmluc2lkZXx8MD5tKGJ8fDApfHxvLnN0YWNraW5nP3QuY29udHJhc3RDb2xvcjp1KTpkZWxldGUgdC5jb250cmFzdENvbG9yLG8uY3Vyc29yJiYodi5jdXJzb3I9by5jdXJzb3IpKSx3PXtyOmwuYm9yZGVyUmFkaXVzfHwwLHJvdGF0aW9uOkMscGFkZGluZzpsLnBhZGRpbmcsekluZGV4OjF9LHMuc3R5bGVkTW9kZXx8KHcuZmlsbD1cImF1dG9cIj09PXg/dC5jb2xvcjp4LHcuc3Ryb2tlPVwiYXV0b1wiPT09eT90LmNvbG9yOnksd1tcInN0cm9rZS13aWR0aFwiXT1sLmJvcmRlcldpZHRoKSxnKHcsKHQsZSk9Pnt2b2lkIDA9PT10JiZkZWxldGUgd1tlXX0pKSwhVHx8YyYmaChNKSYmISFULmRpdj09ISFsLnVzZUhUTUwmJihULnJvdGF0aW9uJiZsLnJvdGF0aW9ufHxULnJvdGF0aW9uPT09bC5yb3RhdGlvbil8fChUPXZvaWQgMCxBPSEwKSxjJiZoKE0pJiYoVD93LnRleHQ9TTooVD1DP2EudGV4dChNLDAsMCxsLnVzZUhUTUwpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1kYXRhLWxhYmVsXCIpOmEubGFiZWwoTSwwLDAsbC5zaGFwZSx2b2lkIDAsdm9pZCAwLGwudXNlSFRNTCx2b2lkIDAsXCJkYXRhLWxhYmVsXCIpKSYmVC5hZGRDbGFzcyhcIiBoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29sb3ItXCIrdC5jb2xvckluZGV4K1wiIFwiKyhsLmNsYXNzTmFtZXx8XCJcIikrKGwudXNlSFRNTD9cIiBoaWdoY2hhcnRzLXRyYWNrZXJcIjpcIlwiKSksVCkpe1Qub3B0aW9ucz1sLFQuYXR0cih3KSxzLnN0eWxlZE1vZGV8fFQuY3NzKHYpLnNoYWRvdyhsLnNoYWRvdyk7bGV0IG89bFt0LmZvcm1hdFByZWZpeCtcIlRleHRQYXRoXCJdfHxsLnRleHRQYXRoO28mJiFsLnVzZUhUTUwmJihULnNldFRleHRQYXRoKHQuZ2V0RGF0YUxhYmVsUGF0aD8uKFQpfHx0LmdyYXBoaWMsbyksdC5kYXRhTGFiZWxQYXRoJiYhby5lbmFibGVkJiYodC5kYXRhTGFiZWxQYXRoPXQuZGF0YUxhYmVsUGF0aC5kZXN0cm95KCkpKSxULmFkZGVkfHxULmFkZChlKSxpLmFsaWduRGF0YUxhYmVsKHQsVCxsLHZvaWQgMCxBKSxULmlzQWN0aXZlPSEwLHJbZF0mJnJbZF0hPT1UJiZyW2RdLmRlc3Ryb3koKSxyW2RdPVR9fSk7bGV0IGw9ci5sZW5ndGg7Zm9yKDtsLS07KXJbbF0mJnJbbF0uaXNBY3RpdmU/cltsXS5pc0FjdGl2ZT0hMToocltsXT8uZGVzdHJveSgpLHIuc3BsaWNlKGwsMSkpO3QuZGF0YUxhYmVsPXJbMF0sdC5kYXRhTGFiZWxzPXJ9KSksZCh0aGlzLFwiYWZ0ZXJEcmF3RGF0YUxhYmVsc1wiKX1mdW5jdGlvbiB2KHQsZSxpLHMsbyxyKXtsZXQgbj10aGlzLmNoYXJ0LGE9ZS5hbGlnbixoPWUudmVydGljYWxBbGlnbixsPXQuYm94PzA6dC5wYWRkaW5nfHwwLHt4OmQ9MCx5OmM9MH09ZSxwLHU7cmV0dXJuKHA9KGkueHx8MCkrbCk8MCYmKFwicmlnaHRcIj09PWEmJmQ+PTA/KGUuYWxpZ249XCJsZWZ0XCIsZS5pbnNpZGU9ITApOmQtPXAsdT0hMCksKHA9KGkueHx8MCkrcy53aWR0aC1sKT5uLnBsb3RXaWR0aCYmKFwibGVmdFwiPT09YSYmZDw9MD8oZS5hbGlnbj1cInJpZ2h0XCIsZS5pbnNpZGU9ITApOmQrPW4ucGxvdFdpZHRoLXAsdT0hMCksKHA9aS55K2wpPDAmJihcImJvdHRvbVwiPT09aCYmYz49MD8oZS52ZXJ0aWNhbEFsaWduPVwidG9wXCIsZS5pbnNpZGU9ITApOmMtPXAsdT0hMCksKHA9KGkueXx8MCkrcy5oZWlnaHQtbCk+bi5wbG90SGVpZ2h0JiYoXCJ0b3BcIj09PWgmJmM8PTA/KGUudmVydGljYWxBbGlnbj1cImJvdHRvbVwiLGUuaW5zaWRlPSEwKTpjKz1uLnBsb3RIZWlnaHQtcCx1PSEwKSx1JiYoZS54PWQsZS55PWMsdC5wbGFjZWQ9IXIsdC5hbGlnbihlLHZvaWQgMCxvKSksdX1mdW5jdGlvbiBTKHQsZSl7bGV0IGk9W10scztpZihjKHQpJiYhYyhlKSlpPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB1KHQsZSl9KTtlbHNlIGlmKGMoZSkmJiFjKHQpKWk9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHUodCxlKX0pO2Vsc2UgaWYoYyh0KXx8YyhlKSl7aWYoYyh0KSYmYyhlKSlmb3Iocz1NYXRoLm1heCh0Lmxlbmd0aCxlLmxlbmd0aCk7cy0tOylpW3NdPXUodFtzXSxlW3NdKX1lbHNlIGk9dSh0LGUpO3JldHVybiBpfWZ1bmN0aW9uIGsodCl7bGV0IGU9dC5jaGFydC5vcHRpb25zLnBsb3RPcHRpb25zO3JldHVybiB5KFMoUyhlPy5zZXJpZXM/LmRhdGFMYWJlbHMsZT8uW3QudHlwZV0/LmRhdGFMYWJlbHMpLHQub3B0aW9ucy5kYXRhTGFiZWxzKSl9ZnVuY3Rpb24gTSh0LGUsaSxzLG8pe2xldCByPXRoaXMuY2hhcnQsbj1yLmludmVydGVkLGE9dGhpcy54QXhpcyxoPWEucmV2ZXJzZWQsbD0oKG4/ZS5oZWlnaHQ6ZS53aWR0aCl8fDApLzIsZD10LnBvaW50V2lkdGgsYz1kP2QvMjowO2Uuc3RhcnRYUG9zPW4/by54Omg/LWwtYzphLndpZHRoLWwrYyxlLnN0YXJ0WVBvcz1uP2g/dGhpcy55QXhpcy5oZWlnaHQtbCtjOi1sLWM6by55LHM/XCJoaWRkZW5cIj09PWUudmlzaWJpbGl0eSYmKGUuc2hvdygpLGUuYXR0cih7b3BhY2l0eTowfSkuYW5pbWF0ZSh7b3BhY2l0eToxfSkpOmUuYXR0cih7b3BhY2l0eToxfSkuYW5pbWF0ZSh7b3BhY2l0eTowfSx2b2lkIDAsZS5oaWRlKSxyLmhhc1JlbmRlcmVkJiYoaSYmZS5hdHRyKHt4OmUuc3RhcnRYUG9zLHk6ZS5zdGFydFlQb3N9KSxlLnBsYWNlZD0hMCl9dC5jb21wb3NlPWZ1bmN0aW9uIHQocil7aWYoeChhLHQpKXtsZXQgdD1yLnByb3RvdHlwZTt0LmluaXREYXRhTGFiZWxzR3JvdXA9cyx0LmluaXREYXRhTGFiZWxzPW8sdC5hbGlnbkRhdGFMYWJlbD1pLHQuZHJhd0RhdGFMYWJlbHM9Yix0Lmp1c3RpZnlEYXRhTGFiZWw9dix0LnNldERhdGFMYWJlbFN0YXJ0UG9zPU0sdC5oYXNEYXRhTGFiZWxzPWV9fX0ob3x8KG89e30pKSxvfSksaShlLFwiU2VyaWVzL0NvbHVtbi9Db2x1bW5EYXRhTGFiZWwuanNcIixbZVtcIkNvcmUvU2VyaWVzL0RhdGFMYWJlbC5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpLHMpe3ZhciBvO2xldHtjb21wb3NlZDpyfT1lLHtzZXJpZXM6bn09aSx7bWVyZ2U6YSxwaWNrOmgscHVzaFVuaXF1ZTpsfT1zO3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBpKHQsZSxpLHMsbyl7bGV0IHI9dGhpcy5jaGFydC5pbnZlcnRlZCxsPXQuc2VyaWVzLGQ9KGwueEF4aXM/bC54QXhpcy5sZW46dGhpcy5jaGFydC5wbG90U2l6ZVgpfHwwLGM9KGwueUF4aXM/bC55QXhpcy5sZW46dGhpcy5jaGFydC5wbG90U2l6ZVkpfHwwLHA9dC5kbEJveHx8dC5zaGFwZUFyZ3MsdT1oKHQuYmVsb3csdC5wbG90WT5oKHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCxjKSksZz1oKGkuaW5zaWRlLCEhdGhpcy5vcHRpb25zLnN0YWNraW5nKTtpZihwKXtpZihzPWEocCksIShcImFsbG93XCI9PT1pLm92ZXJmbG93JiYhMT09PWkuY3JvcCkpe3MueTwwJiYocy5oZWlnaHQrPXMueSxzLnk9MCk7bGV0IHQ9cy55K3MuaGVpZ2h0LWM7dD4wJiZ0PHMuaGVpZ2h0JiYocy5oZWlnaHQtPXQpfXImJihzPXt4OmMtcy55LXMuaGVpZ2h0LHk6ZC1zLngtcy53aWR0aCx3aWR0aDpzLmhlaWdodCxoZWlnaHQ6cy53aWR0aH0pLGd8fChyPyhzLngrPXU/MDpzLndpZHRoLHMud2lkdGg9MCk6KHMueSs9dT9zLmhlaWdodDowLHMuaGVpZ2h0PTApKX1pLmFsaWduPWgoaS5hbGlnbiwhcnx8Zz9cImNlbnRlclwiOnU/XCJyaWdodFwiOlwibGVmdFwiKSxpLnZlcnRpY2FsQWxpZ249aChpLnZlcnRpY2FsQWxpZ24scnx8Zz9cIm1pZGRsZVwiOnU/XCJ0b3BcIjpcImJvdHRvbVwiKSxuLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsdCxlLGkscyxvKSxpLmluc2lkZSYmdC5jb250cmFzdENvbG9yJiZlLmNzcyh7Y29sb3I6dC5jb250cmFzdENvbG9yfSl9ZS5jb21wb3NlPWZ1bmN0aW9uIGUocyl7dC5jb21wb3NlKG4pLGwocixlKSYmKHMucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsPWkpfX0ob3x8KG89e30pKSxvfSksaShlLFwiU2VyaWVzL0Jhci9CYXJTZXJpZXMuanNcIixbZVtcIlNlcmllcy9Db2x1bW4vQ29sdW1uU2VyaWVzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpKXtsZXR7ZXh0ZW5kOnMsbWVyZ2U6b309aTtjbGFzcyByIGV4dGVuZHMgdHt9cmV0dXJuIHIuZGVmYXVsdE9wdGlvbnM9byh0LmRlZmF1bHRPcHRpb25zLHt9KSxzKHIucHJvdG90eXBlLHtpbnZlcnRlZDohMH0pLGUucmVnaXN0ZXJTZXJpZXNUeXBlKFwiYmFyXCIscikscn0pLGkoZSxcIlNlcmllcy9TY2F0dGVyL1NjYXR0ZXJTZXJpZXNEZWZhdWx0cy5qc1wiLFtdLGZ1bmN0aW9uKCl7cmV0dXJue2xpbmVXaWR0aDowLGZpbmROZWFyZXN0UG9pbnRCeTpcInh5XCIsaml0dGVyOnt4OjAseTowfSxtYXJrZXI6e2VuYWJsZWQ6ITB9LHRvb2x0aXA6e2hlYWRlckZvcm1hdDonPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+4pePPC9zcGFuPiA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMC44ZW1cIj4ge3Nlcmllcy5uYW1lfTwvc3Bhbj48YnIvPicscG9pbnRGb3JtYXQ6XCJ4OiA8Yj57cG9pbnQueH08L2I+PGJyLz55OiA8Yj57cG9pbnQueX08L2I+PGJyLz5cIn19fSksaShlLFwiU2VyaWVzL1NjYXR0ZXIvU2NhdHRlclNlcmllcy5qc1wiLFtlW1wiU2VyaWVzL1NjYXR0ZXIvU2NhdHRlclNlcmllc0RlZmF1bHRzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpKXtsZXR7Y29sdW1uOnMsbGluZTpvfT1lLnNlcmllc1R5cGVzLHthZGRFdmVudDpyLGV4dGVuZDpuLG1lcmdlOmF9PWk7Y2xhc3MgaCBleHRlbmRzIG97YXBwbHlKaXR0ZXIoKXtsZXQgdD10aGlzLGU9dGhpcy5vcHRpb25zLmppdHRlcixpPXRoaXMucG9pbnRzLmxlbmd0aDtlJiZ0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHMsbyl7W1wieFwiLFwieVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHIsbil7bGV0IGEsaD1cInBsb3RcIityLnRvVXBwZXJDYXNlKCksbCxkLGM7ZVtyXSYmIXMuaXNOdWxsJiYoYT10W3IrXCJBeGlzXCJdLGM9ZVtyXSphLnRyYW5zQSxhJiYhYS5pc0xvZyYmKGw9TWF0aC5tYXgoMCxzW2hdLWMpLGQ9TWF0aC5taW4oYS5sZW4sc1toXStjKSxzW2hdPWwrKGQtbCkqZnVuY3Rpb24odCl7bGV0IGU9MWU0Kk1hdGguc2luKHQpO3JldHVybiBlLU1hdGguZmxvb3IoZSl9KG8rbippKSxcInhcIj09PXImJihzLmNsaWVudFg9cy5wbG90WCkpKX0pfSl9ZHJhd0dyYXBoKCl7dGhpcy5vcHRpb25zLmxpbmVXaWR0aD9zdXBlci5kcmF3R3JhcGgoKTp0aGlzLmdyYXBoJiYodGhpcy5ncmFwaD10aGlzLmdyYXBoLmRlc3Ryb3koKSl9fXJldHVybiBoLmRlZmF1bHRPcHRpb25zPWEoby5kZWZhdWx0T3B0aW9ucyx0KSxuKGgucHJvdG90eXBlLHtkcmF3VHJhY2tlcjpzLnByb3RvdHlwZS5kcmF3VHJhY2tlcixzb3J0ZWQ6ITEscmVxdWlyZVNvcnRpbmc6ITEsbm9TaGFyZWRUb29sdGlwOiEwLHRyYWNrZXJHcm91cHM6W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl19KSxyKGgsXCJhZnRlclRyYW5zbGF0ZVwiLGZ1bmN0aW9uKCl7dGhpcy5hcHBseUppdHRlcigpfSksZS5yZWdpc3RlclNlcmllc1R5cGUoXCJzY2F0dGVyXCIsaCksaH0pLGkoZSxcIlNlcmllcy9DZW50ZXJlZFV0aWxpdGllcy5qc1wiLFtlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7dmFyIHMsbztsZXR7ZGVnMnJhZDpyfT10LHtmaXJlRXZlbnQ6bixpc051bWJlcjphLHBpY2s6aCxyZWxhdGl2ZUxlbmd0aDpsfT1pO3JldHVybihvPXN8fChzPXt9KSkuZ2V0Q2VudGVyPWZ1bmN0aW9uKCl7bGV0IHQ9dGhpcy5vcHRpb25zLGk9dGhpcy5jaGFydCxzPTIqKHQuc2xpY2VkT2Zmc2V0fHwwKSxvPWkucGxvdFdpZHRoLTIqcyxyPWkucGxvdEhlaWdodC0yKnMsZD10LmNlbnRlcixjPU1hdGgubWluKG8scikscD10LnRoaWNrbmVzcyx1LGc9dC5zaXplLGY9dC5pbm5lclNpemV8fDAsbSx4O1wic3RyaW5nXCI9PXR5cGVvZiBnJiYoZz1wYXJzZUZsb2F0KGcpKSxcInN0cmluZ1wiPT10eXBlb2YgZiYmKGY9cGFyc2VGbG9hdChmKSk7bGV0IHk9W2goZFswXSxcIjUwJVwiKSxoKGRbMV0sXCI1MCVcIiksaChnJiZnPDA/dm9pZCAwOnQuc2l6ZSxcIjEwMCVcIiksaChmJiZmPDA/dm9pZCAwOnQuaW5uZXJTaXplfHwwLFwiMCVcIildO2ZvcighaS5hbmd1bGFyfHx0aGlzIGluc3RhbmNlb2YgZXx8KHlbM109MCksbT0wO208NDsrK20peD15W21dLHU9bTwyfHwyPT09bSYmLyUkLy50ZXN0KHgpLHlbbV09bCh4LFtvLHIsYyx5WzJdXVttXSkrKHU/czowKTtyZXR1cm4geVszXT55WzJdJiYoeVszXT15WzJdKSxhKHApJiYyKnA8eVsyXSYmcD4wJiYoeVszXT15WzJdLTIqcCksbih0aGlzLFwiYWZ0ZXJHZXRDZW50ZXJcIix7cG9zaXRpb25zOnl9KSx5fSxvLmdldFN0YXJ0QW5kRW5kUmFkaWFucz1mdW5jdGlvbih0LGUpe2xldCBpPWEodCk/dDowLHM9YShlKSYmZT5pJiZlLWk8MzYwP2U6aSszNjA7cmV0dXJue3N0YXJ0OnIqKGkrLTkwKSxlbmQ6cioocystOTApfX0sc30pLGkoZSxcIlNlcmllcy9QaWUvUGllUG9pbnQuanNcIixbZVtcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9TZXJpZXMvUG9pbnQuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7bGV0e3NldEFuaW1hdGlvbjpzfT10LHthZGRFdmVudDpvLGRlZmluZWQ6cixleHRlbmQ6bixpc051bWJlcjphLGlzU3RyaW5nOmgscGljazpsLHJlbGF0aXZlTGVuZ3RoOmR9PWk7Y2xhc3MgYyBleHRlbmRzIGV7Z2V0Q29ubmVjdG9yUGF0aCh0KXtsZXQgZT10LmRhdGFMYWJlbFBvc2l0aW9uLGk9dC5vcHRpb25zfHx7fSxzPWkuY29ubmVjdG9yU2hhcGUsbz10aGlzLmNvbm5lY3RvclNoYXBlc1tzXXx8cztyZXR1cm4gZSYmby5jYWxsKHRoaXMsey4uLmUuY29tcHV0ZWQsYWxpZ25tZW50OmUuYWxpZ25tZW50fSxlLmNvbm5lY3RvclBvc2l0aW9uLGkpfHxbXX1nZXRUcmFuc2xhdGUoKXtyZXR1cm4gdGhpcy5zbGljZWQmJnRoaXMuc2xpY2VkVHJhbnNsYXRpb258fHt0cmFuc2xhdGVYOjAsdHJhbnNsYXRlWTowfX1oYWxvUGF0aCh0KXtsZXQgZT10aGlzLnNoYXBlQXJncztyZXR1cm4gdGhpcy5zbGljZWR8fCF0aGlzLnZpc2libGU/W106dGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5hcmMoZS54LGUueSxlLnIrdCxlLnIrdCx7aW5uZXJSOmUuci0xLHN0YXJ0OmUuc3RhcnQsZW5kOmUuZW5kLGJvcmRlclJhZGl1czplLmJvcmRlclJhZGl1c30pfWNvbnN0cnVjdG9yKHQsZSxpKXtzdXBlcih0LGUsaSksdGhpcy5oYWxmPTAsdGhpcy5uYW1lPz8odGhpcy5uYW1lPVwiU2xpY2VcIik7bGV0IHM9dD0+e3RoaXMuc2xpY2UoXCJzZWxlY3RcIj09PXQudHlwZSl9O28odGhpcyxcInNlbGVjdFwiLHMpLG8odGhpcyxcInVuc2VsZWN0XCIscyl9aXNWYWxpZCgpe3JldHVybiBhKHRoaXMueSkmJnRoaXMueT49MH1zZXRWaXNpYmxlKHQsZT0hMCl7dCE9PXRoaXMudmlzaWJsZSYmdGhpcy51cGRhdGUoe3Zpc2libGU6dD8/IXRoaXMudmlzaWJsZX0sZSx2b2lkIDAsITEpfXNsaWNlKHQsZSxpKXtsZXQgbz10aGlzLnNlcmllcyxuPW8uY2hhcnQ7cyhpLG4pLGU9bChlLCEwKSx0aGlzLnNsaWNlZD10aGlzLm9wdGlvbnMuc2xpY2VkPXQ9cih0KT90OiF0aGlzLnNsaWNlZCxvLm9wdGlvbnMuZGF0YVtvLmRhdGEuaW5kZXhPZih0aGlzKV09dGhpcy5vcHRpb25zLHRoaXMuZ3JhcGhpYyYmdGhpcy5ncmFwaGljLmFuaW1hdGUodGhpcy5nZXRUcmFuc2xhdGUoKSl9fXJldHVybiBuKGMucHJvdG90eXBlLHtjb25uZWN0b3JTaGFwZXM6e2ZpeGVkT2Zmc2V0OmZ1bmN0aW9uKHQsZSxpKXtsZXQgcz1lLmJyZWFrQXQsbz1lLnRvdWNoaW5nU2xpY2VBdCxyPWkuc29mdENvbm5lY3Rvcj9bXCJDXCIsdC54KyhcImxlZnRcIj09PXQuYWxpZ25tZW50Py01OjUpLHQueSwyKnMueC1vLngsMipzLnktby55LHMueCxzLnldOltcIkxcIixzLngscy55XTtyZXR1cm5bW1wiTVwiLHQueCx0LnldLHIsW1wiTFwiLG8ueCxvLnldXX0sc3RyYWlnaHQ6ZnVuY3Rpb24odCxlKXtsZXQgaT1lLnRvdWNoaW5nU2xpY2VBdDtyZXR1cm5bW1wiTVwiLHQueCx0LnldLFtcIkxcIixpLngsaS55XV19LGNyb29rZWRMaW5lOmZ1bmN0aW9uKHQsZSxpKXtsZXR7YnJlYWtBdDpzLHRvdWNoaW5nU2xpY2VBdDpvfT1lLHtzZXJpZXM6cn09dGhpcyxbbixhLGhdPXIuY2VudGVyLGw9aC8yLHtwbG90TGVmdDpjLHBsb3RXaWR0aDpwfT1yLmNoYXJ0LHU9XCJsZWZ0XCI9PT10LmFsaWdubWVudCx7eDpnLHk6Zn09dCxtPXMueDtpZihpLmNyb29rRGlzdGFuY2Upe2xldCB0PWQoaS5jcm9va0Rpc3RhbmNlLDEpO209dT9uK2wrKHArYy1uLWwpKigxLXQpOmMrKG4tbCkqdH1lbHNlIG09bisoYS1mKSpNYXRoLnRhbigodGhpcy5hbmdsZXx8MCktTWF0aC5QSS8yKTtsZXQgeD1bW1wiTVwiLGcsZl1dO3JldHVybih1P208PWcmJm0+PXMueDptPj1nJiZtPD1zLngpJiZ4LnB1c2goW1wiTFwiLG0sZl0pLHgucHVzaChbXCJMXCIscy54LHMueV0sW1wiTFwiLG8ueCxvLnldKSx4fX19KSxjfSksaShlLFwiU2VyaWVzL1BpZS9QaWVTZXJpZXNEZWZhdWx0cy5qc1wiLFtdLGZ1bmN0aW9uKCl7cmV0dXJue2JvcmRlclJhZGl1czozLGNlbnRlcjpbbnVsbCxudWxsXSxjbGlwOiExLGNvbG9yQnlQb2ludDohMCxkYXRhTGFiZWxzOntjb25uZWN0b3JQYWRkaW5nOjUsY29ubmVjdG9yU2hhcGU6XCJjcm9va2VkTGluZVwiLGNyb29rRGlzdGFuY2U6dm9pZCAwLGRpc3RhbmNlOjMwLGVuYWJsZWQ6ITAsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnQuaXNOdWxsP3ZvaWQgMDp0aGlzLnBvaW50Lm5hbWV9LHNvZnRDb25uZWN0b3I6ITAseDowfSxmaWxsQ29sb3I6dm9pZCAwLGlnbm9yZUhpZGRlblBvaW50OiEwLGluYWN0aXZlT3RoZXJQb2ludHM6ITAsbGVnZW5kVHlwZTpcInBvaW50XCIsbWFya2VyOm51bGwsc2l6ZTpudWxsLHNob3dJbkxlZ2VuZDohMSxzbGljZWRPZmZzZXQ6MTAsc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7Zm9sbG93UG9pbnRlcjohMH0sYm9yZGVyQ29sb3I6XCIjZmZmZmZmXCIsYm9yZGVyV2lkdGg6MSxsaW5lV2lkdGg6dm9pZCAwLHN0YXRlczp7aG92ZXI6e2JyaWdodG5lc3M6LjF9fX19KSxpKGUsXCJTZXJpZXMvUGllL1BpZVNlcmllcy5qc1wiLFtlW1wiU2VyaWVzL0NlbnRlcmVkVXRpbGl0aWVzLmpzXCJdLGVbXCJTZXJpZXMvQ29sdW1uL0NvbHVtblNlcmllcy5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJTZXJpZXMvUGllL1BpZVBvaW50LmpzXCJdLGVbXCJTZXJpZXMvUGllL1BpZVNlcmllc0RlZmF1bHRzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1NWRy9TeW1ib2xzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlLGkscyxvLHIsbixhLGgpe2xldHtnZXRTdGFydEFuZEVuZFJhZGlhbnM6bH09dCx7bm9vcDpkfT1pLHtjbGFtcDpjLGV4dGVuZDpwLGZpcmVFdmVudDp1LG1lcmdlOmcscGljazpmLHJlbGF0aXZlTGVuZ3RoOm0sc3BsYXQ6eH09aDtjbGFzcyB5IGV4dGVuZHMgcnthbmltYXRlKHQpe2xldCBlPXRoaXMsaT1lLnBvaW50cyxzPWUuc3RhcnRBbmdsZVJhZDt0fHxpLmZvckVhY2goZnVuY3Rpb24odCl7bGV0IGk9dC5ncmFwaGljLG89dC5zaGFwZUFyZ3M7aSYmbyYmKGkuYXR0cih7cjpmKHQuc3RhcnRSLGUuY2VudGVyJiZlLmNlbnRlclszXS8yKSxzdGFydDpzLGVuZDpzfSksaS5hbmltYXRlKHtyOm8ucixzdGFydDpvLnN0YXJ0LGVuZDpvLmVuZH0sZS5vcHRpb25zLmFuaW1hdGlvbikpfSl9ZHJhd0VtcHR5KCl7bGV0IHQsZTtsZXQgaT10aGlzLnN0YXJ0QW5nbGVSYWQscz10aGlzLmVuZEFuZ2xlUmFkLG89dGhpcy5vcHRpb25zOzA9PT10aGlzLnRvdGFsJiZ0aGlzLmNlbnRlcj8odD10aGlzLmNlbnRlclswXSxlPXRoaXMuY2VudGVyWzFdLHRoaXMuZ3JhcGh8fCh0aGlzLmdyYXBoPXRoaXMuY2hhcnQucmVuZGVyZXIuYXJjKHQsZSx0aGlzLmNlbnRlclsxXS8yLDAsaSxzKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZW1wdHktc2VyaWVzXCIpLmFkZCh0aGlzLmdyb3VwKSksdGhpcy5ncmFwaC5hdHRyKHtkOmEuYXJjKHQsZSx0aGlzLmNlbnRlclsyXS8yLDAse3N0YXJ0OmksZW5kOnMsaW5uZXJSOnRoaXMuY2VudGVyWzNdLzJ9KX0pLHRoaXMuY2hhcnQuc3R5bGVkTW9kZXx8dGhpcy5ncmFwaC5hdHRyKHtcInN0cm9rZS13aWR0aFwiOm8uYm9yZGVyV2lkdGgsZmlsbDpvLmZpbGxDb2xvcnx8XCJub25lXCIsc3Ryb2tlOm8uY29sb3J8fFwiI2NjY2NjY1wifSkpOnRoaXMuZ3JhcGgmJih0aGlzLmdyYXBoPXRoaXMuZ3JhcGguZGVzdHJveSgpKX1kcmF3UG9pbnRzKCl7bGV0IHQ9dGhpcy5jaGFydC5yZW5kZXJlcjt0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZ3JhcGhpYyYmZS5oYXNOZXdTaGFwZVR5cGUoKSYmKGUuZ3JhcGhpYz1lLmdyYXBoaWMuZGVzdHJveSgpKSxlLmdyYXBoaWN8fChlLmdyYXBoaWM9dFtlLnNoYXBlVHlwZV0oZS5zaGFwZUFyZ3MpLmFkZChlLnNlcmllcy5ncm91cCksZS5kZWxheWVkUmVuZGVyaW5nPSEwKX0pfWdlbmVyYXRlUG9pbnRzKCl7c3VwZXIuZ2VuZXJhdGVQb2ludHMoKSx0aGlzLnVwZGF0ZVRvdGFscygpfWdldFgodCxlLGkscyl7bGV0IG89dGhpcy5jZW50ZXIscj10aGlzLnJhZGlpP3RoaXMucmFkaWlbaS5pbmRleF18fDA6b1syXS8yLG49cy5kYXRhTGFiZWxQb3NpdGlvbixhPW4/LmRpc3RhbmNlfHwwLGg9TWF0aC5hc2luKGMoKHQtb1sxXSkvKHIrYSksLTEsMSkpLGw9b1swXSsoZT8tMToxKSooTWF0aC5jb3MoaCkqKHIrYSkpKyhhPjA/KGU/LTE6MSkqKHMucGFkZGluZ3x8MCk6MCk7cmV0dXJuIGx9aGFzRGF0YSgpe3JldHVybiEhdGhpcy5wcm9jZXNzZWRYRGF0YS5sZW5ndGh9cmVkcmF3UG9pbnRzKCl7bGV0IHQsZSxpLHM7bGV0IG89dGhpcyxyPW8uY2hhcnQ7dGhpcy5kcmF3RW1wdHkoKSxvLmdyb3VwJiYhci5zdHlsZWRNb2RlJiZvLmdyb3VwLnNoYWRvdyhvLm9wdGlvbnMuc2hhZG93KSxvLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKG4pe2xldCBhPXt9O2U9bi5ncmFwaGljLCFuLmlzTnVsbCYmZT8ocz1uLnNoYXBlQXJncyx0PW4uZ2V0VHJhbnNsYXRlKCksci5zdHlsZWRNb2RlfHwoaT1vLnBvaW50QXR0cmlicyhuLG4uc2VsZWN0ZWQmJlwic2VsZWN0XCIpKSxuLmRlbGF5ZWRSZW5kZXJpbmc/KGUuc2V0UmFkaWFsUmVmZXJlbmNlKG8uY2VudGVyKS5hdHRyKHMpLmF0dHIodCksci5zdHlsZWRNb2RlfHxlLmF0dHIoaSkuYXR0cih7XCJzdHJva2UtbGluZWpvaW5cIjpcInJvdW5kXCJ9KSxuLmRlbGF5ZWRSZW5kZXJpbmc9ITEpOihlLnNldFJhZGlhbFJlZmVyZW5jZShvLmNlbnRlciksci5zdHlsZWRNb2RlfHxnKCEwLGEsaSksZyghMCxhLHMsdCksZS5hbmltYXRlKGEpKSxlLmF0dHIoe3Zpc2liaWxpdHk6bi52aXNpYmxlP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCJ9KSxlLmFkZENsYXNzKG4uZ2V0Q2xhc3NOYW1lKCksITApKTplJiYobi5ncmFwaGljPWUuZGVzdHJveSgpKX0pfXNvcnRCeUFuZ2xlKHQsZSl7dC5zb3J0KGZ1bmN0aW9uKHQsaSl7cmV0dXJuIHZvaWQgMCE9PXQuYW5nbGUmJihpLmFuZ2xlLXQuYW5nbGUpKmV9KX10cmFuc2xhdGUodCl7dSh0aGlzLFwidHJhbnNsYXRlXCIpLHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtsZXQgZT10aGlzLm9wdGlvbnMsaT1lLnNsaWNlZE9mZnNldCxzPWwoZS5zdGFydEFuZ2xlLGUuZW5kQW5nbGUpLG89dGhpcy5zdGFydEFuZ2xlUmFkPXMuc3RhcnQscj10aGlzLmVuZEFuZ2xlUmFkPXMuZW5kLG49ci1vLGE9dGhpcy5wb2ludHMsaD1lLmlnbm9yZUhpZGRlblBvaW50LGQ9YS5sZW5ndGgsYyxwLGcsZixtLHgseSxiPTA7Zm9yKHR8fCh0aGlzLmNlbnRlcj10PXRoaXMuZ2V0Q2VudGVyKCkpLHg9MDt4PGQ7eCsrKXt5PWFbeF0sYz1vK2Iqbix5LmlzVmFsaWQoKSYmKCFofHx5LnZpc2libGUpJiYoYis9eS5wZXJjZW50YWdlLzEwMCkscD1vK2IqbjtsZXQgZT17eDp0WzBdLHk6dFsxXSxyOnRbMl0vMixpbm5lclI6dFszXS8yLHN0YXJ0Ok1hdGgucm91bmQoMWUzKmMpLzFlMyxlbmQ6TWF0aC5yb3VuZCgxZTMqcCkvMWUzfTt5LnNoYXBlVHlwZT1cImFyY1wiLHkuc2hhcGVBcmdzPWUsKGc9KHArYykvMik+MS41Kk1hdGguUEk/Zy09MipNYXRoLlBJOmc8LU1hdGguUEkvMiYmKGcrPTIqTWF0aC5QSSkseS5zbGljZWRUcmFuc2xhdGlvbj17dHJhbnNsYXRlWDpNYXRoLnJvdW5kKE1hdGguY29zKGcpKmkpLHRyYW5zbGF0ZVk6TWF0aC5yb3VuZChNYXRoLnNpbihnKSppKX0sZj1NYXRoLmNvcyhnKSp0WzJdLzIsbT1NYXRoLnNpbihnKSp0WzJdLzIseS50b29sdGlwUG9zPVt0WzBdKy43KmYsdFsxXSsuNyptXSx5LmhhbGY9ZzwtTWF0aC5QSS8yfHxnPk1hdGguUEkvMj8xOjAseS5hbmdsZT1nfXUodGhpcyxcImFmdGVyVHJhbnNsYXRlXCIpfXVwZGF0ZVRvdGFscygpe2xldCB0PXRoaXMucG9pbnRzLGU9dC5sZW5ndGgsaT10aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQscyxvLHI9MDtmb3Iocz0wO3M8ZTtzKyspKG89dFtzXSkuaXNWYWxpZCgpJiYoIWl8fG8udmlzaWJsZSkmJihyKz1vLnkpO2ZvcihzPTAsdGhpcy50b3RhbD1yO3M8ZTtzKyspKG89dFtzXSkucGVyY2VudGFnZT1yPjAmJihvLnZpc2libGV8fCFpKT9vLnkvcioxMDA6MCxvLnRvdGFsPXJ9fXJldHVybiB5LmRlZmF1bHRPcHRpb25zPWcoci5kZWZhdWx0T3B0aW9ucyxvKSxwKHkucHJvdG90eXBlLHtheGlzVHlwZXM6W10sZGlyZWN0VG91Y2g6ITAsZHJhd0dyYXBoOnZvaWQgMCxkcmF3VHJhY2tlcjplLnByb3RvdHlwZS5kcmF3VHJhY2tlcixnZXRDZW50ZXI6dC5nZXRDZW50ZXIsZ2V0U3ltYm9sOmQsaXNDYXJ0ZXNpYW46ITEsbm9TaGFyZWRUb29sdGlwOiEwLHBvaW50QXR0cmliczplLnByb3RvdHlwZS5wb2ludEF0dHJpYnMscG9pbnRDbGFzczpzLHJlcXVpcmVTb3J0aW5nOiExLHNlYXJjaFBvaW50OmQsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdfSksbi5yZWdpc3RlclNlcmllc1R5cGUoXCJwaWVcIix5KSx5fSksaShlLFwiU2VyaWVzL1BpZS9QaWVEYXRhTGFiZWwuanNcIixbZVtcIkNvcmUvU2VyaWVzL0RhdGFMYWJlbC5qc1wiXSxlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1JlbmRlcmVyVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxlW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKHQsZSxpLHMsbyl7dmFyIHI7bGV0e2NvbXBvc2VkOm4sbm9vcDphfT1lLHtkaXN0cmlidXRlOmh9PWkse3NlcmllczpsfT1zLHthcnJheU1heDpkLGNsYW1wOmMsZGVmaW5lZDpwLHBpY2s6dSxwdXNoVW5pcXVlOmcscmVsYXRpdmVMZW5ndGg6Zn09bztyZXR1cm4gZnVuY3Rpb24oZSl7bGV0IGk9e3JhZGlhbERpc3RyaWJ1dGlvblk6ZnVuY3Rpb24odCxlKXtyZXR1cm4oZS5kYXRhTGFiZWxQb3NpdGlvbj8udG9wfHwwKSt0LmRpc3RyaWJ1dGVCb3gucG9zfSxyYWRpYWxEaXN0cmlidXRpb25YOmZ1bmN0aW9uKHQsZSxpLHMsbyl7bGV0IHI9by5kYXRhTGFiZWxQb3NpdGlvbjtyZXR1cm4gdC5nZXRYKGk8KHI/LnRvcHx8MCkrMnx8aT4ocj8uYm90dG9tfHwwKS0yP3M6aSxlLmhhbGYsZSxvKX0sanVzdGlmeTpmdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gc1swXSsodC5oYWxmPy0xOjEpKihpKyhlLmRhdGFMYWJlbFBvc2l0aW9uPy5kaXN0YW5jZXx8MCkpfSxhbGlnblRvUGxvdEVkZ2VzOmZ1bmN0aW9uKHQsZSxpLHMpe2xldCBvPXQuZ2V0QkJveCgpLndpZHRoO3JldHVybiBlP28rczppLW8tc30sYWxpZ25Ub0Nvbm5lY3RvcnM6ZnVuY3Rpb24odCxlLGkscyl7bGV0IG89MCxyO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7KHI9dC5kYXRhTGFiZWwuZ2V0QkJveCgpLndpZHRoKT5vJiYobz1yKX0pLGU/bytzOmktby1zfX07ZnVuY3Rpb24gcyh0LGUpe2xldHtjZW50ZXI6aSxvcHRpb25zOnN9PXRoaXMsbz1pWzJdLzIscj10LmFuZ2xlfHwwLG49TWF0aC5jb3MociksYT1NYXRoLnNpbihyKSxoPWlbMF0rbipvLGw9aVsxXSthKm8sZD1NYXRoLm1pbigocy5zbGljZWRPZmZzZXR8fDApKyhzLmJvcmRlcldpZHRofHwwKSxlLzUpO3JldHVybntuYXR1cmFsOnt4OmgrbiplLHk6bCthKmV9LGNvbXB1dGVkOnt9LGFsaWdubWVudDplPDA/XCJjZW50ZXJcIjp0LmhhbGY/XCJyaWdodFwiOlwibGVmdFwiLGNvbm5lY3RvclBvc2l0aW9uOnticmVha0F0Ont4OmgrbipkLHk6bCthKmR9LHRvdWNoaW5nU2xpY2VBdDp7eDpoLHk6bH19LGRpc3RhbmNlOmV9fWZ1bmN0aW9uIG8oKXtsZXQgdD10aGlzLGU9dC5wb2ludHMsaT10LmNoYXJ0LHM9aS5wbG90V2lkdGgsbz1pLnBsb3RIZWlnaHQscj1pLnBsb3RMZWZ0LG49TWF0aC5yb3VuZChpLmNoYXJ0V2lkdGgvMyksYT10LmNlbnRlcixjPWFbMl0vMixnPWFbMV0sbT1bW10sW11dLHg9WzAsMCwwLDBdLHk9dC5kYXRhTGFiZWxQb3NpdGlvbmVycyxiLHYsUyxrPTA7dC52aXNpYmxlJiZ0Lmhhc0RhdGFMYWJlbHM/LigpJiYoZS5mb3JFYWNoKHQ9PnsodC5kYXRhTGFiZWxzfHxbXSkuZm9yRWFjaCh0PT57dC5zaG9ydGVuZWQmJih0LmF0dHIoe3dpZHRoOlwiYXV0b1wifSkuY3NzKHt3aWR0aDpcImF1dG9cIix0ZXh0T3ZlcmZsb3c6XCJjbGlwXCJ9KSx0LnNob3J0ZW5lZD0hMSl9KX0pLGwucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzLmFwcGx5KHQpLGUuZm9yRWFjaCh0PT57KHQuZGF0YUxhYmVsc3x8W10pLmZvckVhY2goKGUsaSk9PntsZXQgcz1hWzJdLzIsbz1lLm9wdGlvbnMscj1mKG8/LmRpc3RhbmNlfHwwLHMpOzA9PT1pJiZtW3QuaGFsZl0ucHVzaCh0KSwhcChvPy5zdHlsZT8ud2lkdGgpJiZlLmdldEJCb3goKS53aWR0aD5uJiYoZS5jc3Moe3dpZHRoOk1hdGgucm91bmQoLjcqbikrXCJweFwifSksZS5zaG9ydGVuZWQ9ITApLGUuZGF0YUxhYmVsUG9zaXRpb249dGhpcy5nZXREYXRhTGFiZWxQb3NpdGlvbih0LHIpLGs9TWF0aC5tYXgoayxyKX0pfSksbS5mb3JFYWNoKChlLG4pPT57bGV0IGw9ZS5sZW5ndGgsZD1bXSxmLG0sYj0wLE07bCYmKHQuc29ydEJ5QW5nbGUoZSxuLS41KSxrPjAmJihmPU1hdGgubWF4KDAsZy1jLWspLG09TWF0aC5taW4oZytjK2ssaS5wbG90SGVpZ2h0KSxlLmZvckVhY2godD0+eyh0LmRhdGFMYWJlbHN8fFtdKS5mb3JFYWNoKChlLHMpPT57bGV0IG89ZS5kYXRhTGFiZWxQb3NpdGlvbjtvJiZvLmRpc3RhbmNlPjAmJihvLnRvcD1NYXRoLm1heCgwLGctYy1vLmRpc3RhbmNlKSxvLmJvdHRvbT1NYXRoLm1pbihnK2Mrby5kaXN0YW5jZSxpLnBsb3RIZWlnaHQpLGI9ZS5nZXRCQm94KCkuaGVpZ2h0fHwyMSx0LmRpc3RyaWJ1dGVCb3g9e3RhcmdldDooZS5kYXRhTGFiZWxQb3NpdGlvbj8ubmF0dXJhbC55fHwwKS1vLnRvcCtiLzIsc2l6ZTpiLHJhbms6dC55fSxkLnB1c2godC5kaXN0cmlidXRlQm94KSl9KX0pLGgoZCxNPW0rYi1mLE0vNSkpLGUuZm9yRWFjaChpPT57KGkuZGF0YUxhYmVsc3x8W10pLmZvckVhY2goaD0+e2xldCBsPWgub3B0aW9uc3x8e30sZz1pLmRpc3RyaWJ1dGVCb3gsZj1oLmRhdGFMYWJlbFBvc2l0aW9uLG09Zj8ubmF0dXJhbC55fHwwLGI9bC5jb25uZWN0b3JQYWRkaW5nfHwwLGs9MCxNPW0sQz1cImluaGVyaXRcIjtpZihmKXtpZihkJiZwKGcpJiZmLmRpc3RhbmNlPjAmJih2b2lkIDA9PT1nLnBvcz9DPVwiaGlkZGVuXCI6KFM9Zy5zaXplLE09eS5yYWRpYWxEaXN0cmlidXRpb25ZKGksaCkpKSxsLmp1c3RpZnkpaz15Lmp1c3RpZnkoaSxoLGMsYSk7ZWxzZSBzd2l0Y2gobC5hbGlnblRvKXtjYXNlXCJjb25uZWN0b3JzXCI6az15LmFsaWduVG9Db25uZWN0b3JzKGUsbixzLHIpO2JyZWFrO2Nhc2VcInBsb3RFZGdlc1wiOms9eS5hbGlnblRvUGxvdEVkZ2VzKGgsbixzLHIpO2JyZWFrO2RlZmF1bHQ6az15LnJhZGlhbERpc3RyaWJ1dGlvblgodCxpLE0sbSxoKX1pZihmLmF0dHJpYnM9e3Zpc2liaWxpdHk6QyxhbGlnbjpmLmFsaWdubWVudH0sZi5wb3NBdHRyaWJzPXt4OmsrKGwueHx8MCkrKCh7bGVmdDpiLHJpZ2h0Oi1ifSlbZi5hbGlnbm1lbnRdfHwwKSx5Ok0rKGwueXx8MCktaC5nZXRCQm94KCkuaGVpZ2h0LzJ9LGYuY29tcHV0ZWQueD1rLGYuY29tcHV0ZWQueT1NLHUobC5jcm9wLCEwKSl7bGV0IHQ7ay0odj1oLmdldEJCb3goKS53aWR0aCk8YiYmMT09PW4/KHQ9TWF0aC5yb3VuZCh2LWsrYikseFszXT1NYXRoLm1heCh0LHhbM10pKTprK3Y+cy1iJiYwPT09biYmKHQ9TWF0aC5yb3VuZChrK3YtcytiKSx4WzFdPU1hdGgubWF4KHQseFsxXSkpLE0tUy8yPDA/eFswXT1NYXRoLm1heChNYXRoLnJvdW5kKC1NK1MvMikseFswXSk6TStTLzI+byYmKHhbMl09TWF0aC5tYXgoTWF0aC5yb3VuZChNK1MvMi1vKSx4WzJdKSksZi5zaWRlT3ZlcmZsb3c9dH19fSl9KSl9KSwoMD09PWQoeCl8fHRoaXMudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3coeCkpJiYodGhpcy5wbGFjZURhdGFMYWJlbHMoKSx0aGlzLnBvaW50cy5mb3JFYWNoKGU9PnsoZS5kYXRhTGFiZWxzfHxbXSkuZm9yRWFjaChzPT57bGV0e2Nvbm5lY3RvckNvbG9yOm8sY29ubmVjdG9yV2lkdGg6cj0xfT1zLm9wdGlvbnN8fHt9LG49cy5kYXRhTGFiZWxQb3NpdGlvbjtpZihyKXtsZXQgYTtiPXMuY29ubmVjdG9yLG4mJm4uZGlzdGFuY2U+MD8oYT0hYixifHwocy5jb25uZWN0b3I9Yj1pLnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbC1jb25uZWN0b3IgIGhpZ2hjaGFydHMtY29sb3ItXCIrZS5jb2xvckluZGV4KyhlLmNsYXNzTmFtZT9cIiBcIitlLmNsYXNzTmFtZTpcIlwiKSkuYWRkKHQuZGF0YUxhYmVsc0dyb3VwKSksaS5zdHlsZWRNb2RlfHxiLmF0dHIoe1wic3Ryb2tlLXdpZHRoXCI6cixzdHJva2U6b3x8ZS5jb2xvcnx8XCIjNjY2NjY2XCJ9KSxiW2E/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHtkOmUuZ2V0Q29ubmVjdG9yUGF0aChzKX0pLGIuYXR0cih7dmlzaWJpbGl0eTpuLmF0dHJpYnM/LnZpc2liaWxpdHl9KSk6YiYmKHMuY29ubmVjdG9yPWIuZGVzdHJveSgpKX19KX0pKSl9ZnVuY3Rpb24gcigpe3RoaXMucG9pbnRzLmZvckVhY2godD0+eyh0LmRhdGFMYWJlbHN8fFtdKS5mb3JFYWNoKHQ9PntsZXQgZT10LmRhdGFMYWJlbFBvc2l0aW9uO2U/KGUuc2lkZU92ZXJmbG93JiYodC5jc3Moe3dpZHRoOk1hdGgubWF4KHQuZ2V0QkJveCgpLndpZHRoLWUuc2lkZU92ZXJmbG93LDApK1wicHhcIix0ZXh0T3ZlcmZsb3c6KHQub3B0aW9ucz8uc3R5bGV8fHt9KS50ZXh0T3ZlcmZsb3d8fFwiZWxsaXBzaXNcIn0pLHQuc2hvcnRlbmVkPSEwKSx0LmF0dHIoZS5hdHRyaWJzKSx0W3QubW92ZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCJdKGUucG9zQXR0cmlicyksdC5tb3ZlZD0hMCk6dCYmdC5hdHRyKHt5Oi05OTk5fSl9KSxkZWxldGUgdC5kaXN0cmlidXRlQm94fSx0aGlzKX1mdW5jdGlvbiBtKHQpe2xldCBlPXRoaXMuY2VudGVyLGk9dGhpcy5vcHRpb25zLHM9aS5jZW50ZXIsbz1pLm1pblNpemV8fDgwLHI9byxuPW51bGwhPT1pLnNpemU7cmV0dXJuIW4mJihudWxsIT09c1swXT9yPU1hdGgubWF4KGVbMl0tTWF0aC5tYXgodFsxXSx0WzNdKSxvKToocj1NYXRoLm1heChlWzJdLXRbMV0tdFszXSxvKSxlWzBdKz0odFszXS10WzFdKS8yKSxudWxsIT09c1sxXT9yPWMocixvLGVbMl0tTWF0aC5tYXgodFswXSx0WzJdKSk6KHI9YyhyLG8sZVsyXS10WzBdLXRbMl0pLGVbMV0rPSh0WzBdLXRbMl0pLzIpLHI8ZVsyXT8oZVsyXT1yLGVbM109TWF0aC5taW4oaS50aGlja25lc3M/TWF0aC5tYXgoMCxyLTIqaS50aGlja25lc3MpOk1hdGgubWF4KDAsZihpLmlubmVyU2l6ZXx8MCxyKSksciksdGhpcy50cmFuc2xhdGUoZSksdGhpcy5kcmF3RGF0YUxhYmVscyYmdGhpcy5kcmF3RGF0YUxhYmVscygpKTpuPSEwKSxufWUuY29tcG9zZT1mdW5jdGlvbiBlKGgpe2lmKHQuY29tcG9zZShsKSxnKG4sZSkpe2xldCB0PWgucHJvdG90eXBlO3QuZGF0YUxhYmVsUG9zaXRpb25lcnM9aSx0LmFsaWduRGF0YUxhYmVsPWEsdC5kcmF3RGF0YUxhYmVscz1vLHQuZ2V0RGF0YUxhYmVsUG9zaXRpb249cyx0LnBsYWNlRGF0YUxhYmVscz1yLHQudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3c9bX19fShyfHwocj17fSkpLHJ9KSxpKGUsXCJFeHRlbnNpb25zL092ZXJsYXBwaW5nRGF0YUxhYmVscy5qc1wiLFtlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlKXtsZXR7Y29tcG9zZWQ6aX09dCx7YWRkRXZlbnQ6cyxmaXJlRXZlbnQ6byxpc051bWJlcjpyLG9iamVjdEVhY2g6bixwaWNrOmEscHVzaFVuaXF1ZTpofT1lO2Z1bmN0aW9uIGwodCl7bGV0IGU9dC5sZW5ndGgsaT10aGlzLnJlbmRlcmVyLHM9KHQsZSk9PiEoZS54Pj10LngrdC53aWR0aHx8ZS54K2Uud2lkdGg8PXQueHx8ZS55Pj10LnkrdC5oZWlnaHR8fGUueStlLmhlaWdodDw9dC55KSxuPXQ9PntsZXQgZT10LmJveD8wOnQucGFkZGluZ3x8MCxzLG8sbixhPTAsaD0wLGwsZDtpZih0JiYoIXQuYWxpZ25BdHRyfHx0LnBsYWNlZCkpcmV0dXJuIHM9dC5hbGlnbkF0dHJ8fHt4OnQuYXR0cihcInhcIikseTp0LmF0dHIoXCJ5XCIpfSxvPXQucGFyZW50R3JvdXAsdC53aWR0aHx8KG49dC5nZXRCQm94KCksdC53aWR0aD1uLndpZHRoLHQuaGVpZ2h0PW4uaGVpZ2h0LGE9aS5mb250TWV0cmljcyh0LmVsZW1lbnQpLmgpLGw9dC53aWR0aC0yKmUsKGQ9KHtsZWZ0OlwiMFwiLGNlbnRlcjpcIjAuNVwiLHJpZ2h0OlwiMVwifSlbdC5hbGlnblZhbHVlXSk/aD0rZCpsOnIodC54KSYmTWF0aC5yb3VuZCh0LngpIT09dC50cmFuc2xhdGVYJiYoaD10LngtKHQudHJhbnNsYXRlWHx8MCkpLHt4OnMueCsoby50cmFuc2xhdGVYfHwwKStlLShofHwwKSx5OnMueSsoby50cmFuc2xhdGVZfHwwKStlLWEsd2lkdGg6dC53aWR0aC0yKmUsaGVpZ2h0Oih0LmhlaWdodHx8MCktMiplfX0sYSxoLGwsYyxwLHU9ITE7Zm9yKGxldCBpPTA7aTxlO2krKykoYT10W2ldKSYmKGEub2xkT3BhY2l0eT1hLm9wYWNpdHksYS5uZXdPcGFjaXR5PTEsYS5hYnNvbHV0ZUJveD1uKGEpKTt0LnNvcnQoKHQsZSk9PihlLmxhYmVscmFua3x8MCktKHQubGFiZWxyYW5rfHwwKSk7Zm9yKGxldCBpPTA7aTxlOysraSl7Yz0oaD10W2ldKSYmaC5hYnNvbHV0ZUJveDtmb3IobGV0IG89aSsxO288ZTsrK28pcD0obD10W29dKSYmbC5hYnNvbHV0ZUJveCxjJiZwJiZoIT09bCYmMCE9PWgubmV3T3BhY2l0eSYmMCE9PWwubmV3T3BhY2l0eSYmXCJoaWRkZW5cIiE9PWgudmlzaWJpbGl0eSYmXCJoaWRkZW5cIiE9PWwudmlzaWJpbGl0eSYmcyhjLHApJiYoKGgubGFiZWxyYW5rPGwubGFiZWxyYW5rP2g6bCkubmV3T3BhY2l0eT0wKX1mb3IobGV0IGUgb2YgdClkKGUsdGhpcykmJih1PSEwKTt1JiZvKHRoaXMsXCJhZnRlckhpZGVBbGxPdmVybGFwcGluZ0xhYmVsc1wiKX1mdW5jdGlvbiBkKHQsZSl7bGV0IGkscz0hMTtyZXR1cm4gdCYmKGk9dC5uZXdPcGFjaXR5LHQub2xkT3BhY2l0eSE9PWkmJih0Lmhhc0NsYXNzKFwiaGlnaGNoYXJ0cy1kYXRhLWxhYmVsXCIpPyh0W2k/XCJyZW1vdmVDbGFzc1wiOlwiYWRkQ2xhc3NcIl0oXCJoaWdoY2hhcnRzLWRhdGEtbGFiZWwtaGlkZGVuXCIpLHM9ITAsdFt0LmlzT2xkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7b3BhY2l0eTppfSx2b2lkIDAsZnVuY3Rpb24oKXtlLnN0eWxlZE1vZGV8fHQuY3NzKHtwb2ludGVyRXZlbnRzOmk/XCJhdXRvXCI6XCJub25lXCJ9KX0pLG8oZSxcImFmdGVySGlkZU92ZXJsYXBwaW5nTGFiZWxcIikpOnQuYXR0cih7b3BhY2l0eTppfSkpLHQuaXNPbGQ9ITApLHN9ZnVuY3Rpb24gYygpe2xldCB0PXRoaXMsZT1bXTtmb3IobGV0IGkgb2YgdC5sYWJlbENvbGxlY3RvcnN8fFtdKWU9ZS5jb25jYXQoaSgpKTtmb3IobGV0IGkgb2YgdC55QXhpc3x8W10paS5zdGFja2luZyYmaS5vcHRpb25zLnN0YWNrTGFiZWxzJiYhaS5vcHRpb25zLnN0YWNrTGFiZWxzLmFsbG93T3ZlcmxhcCYmbihpLnN0YWNraW5nLnN0YWNrcyx0PT57bih0LHQ9Pnt0LmxhYmVsJiZlLnB1c2godC5sYWJlbCl9KX0pO2ZvcihsZXQgaSBvZiB0LnNlcmllc3x8W10paWYoaS52aXNpYmxlJiZpLmhhc0RhdGFMYWJlbHM/LigpKXtsZXQgcz1pPT57Zm9yKGxldCBzIG9mIGkpcy52aXNpYmxlJiYocy5kYXRhTGFiZWxzfHxbXSkuZm9yRWFjaChpPT57bGV0IG89aS5vcHRpb25zfHx7fTtpLmxhYmVscmFuaz1hKG8ubGFiZWxyYW5rLHMubGFiZWxyYW5rLHMuc2hhcGVBcmdzPy5oZWlnaHQpLG8uYWxsb3dPdmVybGFwPz9OdW1iZXIoby5kaXN0YW5jZSk+MD8oaS5vbGRPcGFjaXR5PWkub3BhY2l0eSxpLm5ld09wYWNpdHk9MSxkKGksdCkpOmUucHVzaChpKX0pfTtzKGkubm9kZXN8fFtdKSxzKGkucG9pbnRzKX10aGlzLmhpZGVPdmVybGFwcGluZ0xhYmVscyhlKX1yZXR1cm57Y29tcG9zZTpmdW5jdGlvbiB0KGUpe2lmKGgoaSx0KSl7bGV0IHQ9ZS5wcm90b3R5cGU7dC5oaWRlT3ZlcmxhcHBpbmdMYWJlbHM9bCxzKGUsXCJyZW5kZXJcIixjKX19fX0pLGkoZSxcIkV4dGVuc2lvbnMvQm9yZGVyUmFkaXVzLmpzXCIsW2VbXCJDb3JlL0RlZmF1bHRzLmpzXCJdLGVbXCJDb3JlL0dsb2JhbHMuanNcIl0sZVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbih0LGUsaSl7bGV0e2RlZmF1bHRPcHRpb25zOnN9PXQse2NvbXBvc2VkOm8sbm9vcDpyfT1lLHthZGRFdmVudDpuLGV4dGVuZDphLGlzT2JqZWN0OmgsbWVyZ2U6bCxwdXNoVW5pcXVlOmQscmVsYXRpdmVMZW5ndGg6Y309aSxwPXtyYWRpdXM6MCxzY29wZTpcInN0YWNrXCIsd2hlcmU6dm9pZCAwfSx1PXIsZz1yO2Z1bmN0aW9uIGYodCxlLGkscyxvPXt9KXtsZXQgcj11KHQsZSxpLHMsbykse2lubmVyUjpuPTAscjphPWksc3RhcnQ6aD0wLGVuZDpsPTB9PW87aWYoby5vcGVufHwhby5ib3JkZXJSYWRpdXMpcmV0dXJuIHI7bGV0IGQ9bC1oLHA9TWF0aC5zaW4oZC8yKSxnPU1hdGgubWF4KE1hdGgubWluKGMoby5ib3JkZXJSYWRpdXN8fDAsYS1uKSwoYS1uKS8yLGEqcC8oMStwKSksMCksZj1NYXRoLm1pbihnLDIqKGQvTWF0aC5QSSkqbiksbT1yLmxlbmd0aC0xO2Zvcig7bS0tOykhZnVuY3Rpb24odCxlLGkpe2xldCBzLG8scjtsZXQgbj10W2VdLGE9dFtlKzFdO2lmKFwiWlwiPT09YVswXSYmKGE9dFswXSksKFwiTVwiPT09blswXXx8XCJMXCI9PT1uWzBdKSYmXCJBXCI9PT1hWzBdPyhzPW4sbz1hLHI9ITApOlwiQVwiPT09blswXSYmKFwiTVwiPT09YVswXXx8XCJMXCI9PT1hWzBdKSYmKHM9YSxvPW4pLHMmJm8mJm8ucGFyYW1zKXtsZXQgbj1vWzFdLGE9b1s1XSxoPW8ucGFyYW1zLHtzdGFydDpsLGVuZDpkLGN4OmMsY3k6cH09aCx1PWE/bi1pOm4raSxnPXU/TWF0aC5hc2luKGkvdSk6MCxmPWE/ZzotZyxtPU1hdGguY29zKGcpKnU7cj8oaC5zdGFydD1sK2Ysc1sxXT1jK20qTWF0aC5jb3MobCksc1syXT1wK20qTWF0aC5zaW4obCksdC5zcGxpY2UoZSsxLDAsW1wiQVwiLGksaSwwLDAsMSxjK24qTWF0aC5jb3MoaC5zdGFydCkscCtuKk1hdGguc2luKGguc3RhcnQpXSkpOihoLmVuZD1kLWYsb1s2XT1jK24qTWF0aC5jb3MoaC5lbmQpLG9bN109cCtuKk1hdGguc2luKGguZW5kKSx0LnNwbGljZShlKzEsMCxbXCJBXCIsaSxpLDAsMCwxLGMrbSpNYXRoLmNvcyhkKSxwK20qTWF0aC5zaW4oZCldKSksb1s0XT1NYXRoLmFicyhoLmVuZC1oLnN0YXJ0KTxNYXRoLlBJPzA6MX19KHIsbSxtPjE/ZjpnKTtyZXR1cm4gcn1mdW5jdGlvbiBtKCl7aWYodGhpcy5vcHRpb25zLmJvcmRlclJhZGl1cyYmISh0aGlzLmNoYXJ0LmlzM2QmJnRoaXMuY2hhcnQuaXMzZCgpKSl7bGV0e29wdGlvbnM6dCx5QXhpczplfT10aGlzLGk9XCJwZXJjZW50XCI9PT10LnN0YWNraW5nLG89cy5wbG90T3B0aW9ucz8uW3RoaXMudHlwZV0/LmJvcmRlclJhZGl1cyxyPXgodC5ib3JkZXJSYWRpdXMsaChvKT9vOnt9KSxuPWUub3B0aW9ucy5yZXZlcnNlZDtmb3IobGV0IHMgb2YgdGhpcy5wb2ludHMpe2xldHtzaGFwZUFyZ3M6b309cztpZihcInJvdW5kZWRSZWN0XCI9PT1zLnNoYXBlVHlwZSYmbyl7bGV0e3dpZHRoOmg9MCxoZWlnaHQ6bD0wLHk6ZD0wfT1vLHA9ZCx1PWw7aWYoXCJzdGFja1wiPT09ci5zY29wZSYmcy5zdGFja1RvdGFsKXtsZXQgbz1lLnRyYW5zbGF0ZShpPzEwMDpzLnN0YWNrVG90YWwsITEsITAsITEsITApLHI9ZS50cmFuc2xhdGUodC50aHJlc2hvbGR8fDAsITEsITAsITEsITApLG49dGhpcy5jcmlzcENvbCgwLE1hdGgubWluKG8sciksMCxNYXRoLmFicyhvLXIpKTtwPW4ueSx1PW4uaGVpZ2h0fWxldCBnPShzLm5lZ2F0aXZlPy0xOjEpKihuPy0xOjEpPT0tMSxmPXIud2hlcmU7IWYmJnRoaXMuaXMoXCJ3YXRlcmZhbGxcIikmJk1hdGguYWJzKChzLnlCb3R0b218fDApLSh0aGlzLnRyYW5zbGF0ZWRUaHJlc2hvbGR8fDApKT50aGlzLmJvcmRlcldpZHRoJiYoZj1cImFsbFwiKSxmfHwoZj1cImVuZFwiKTtsZXQgbT1NYXRoLm1pbihjKHIucmFkaXVzLGgpLGgvMixcImFsbFwiPT09Zj9sLzI6MS8wKXx8MDtcImVuZFwiPT09ZiYmKGcmJihwLT1tKSx1Kz1tKSxhKG8se2JyQm94SGVpZ2h0OnUsYnJCb3hZOnAscjptfSl9fX19ZnVuY3Rpb24geCh0LGUpe3JldHVybiBoKHQpfHwodD17cmFkaXVzOnR8fDB9KSxsKHAsZSx0KX1mdW5jdGlvbiB5KCl7bGV0IHQ9eCh0aGlzLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtmb3IobGV0IGUgb2YgdGhpcy5wb2ludHMpe2xldCBpPWUuc2hhcGVBcmdzO2kmJihpLmJvcmRlclJhZGl1cz1jKHQucmFkaXVzLChpLnJ8fDApLShpLmlubmVyUnx8MCkpKX19ZnVuY3Rpb24gYih0LGUsaSxzLG89e30pe2xldCByPWcodCxlLGkscyxvKSx7cjpuPTAsYnJCb3hIZWlnaHQ6YT1zLGJyQm94WTpoPWV9PW8sbD1lLWgsZD1oK2EtKGUrcyksYz1sLW4+LS4xPzA6bixwPWQtbj4tLjE/MDpuLHU9TWF0aC5tYXgoYyYmbCwwKSxmPU1hdGgubWF4KHAmJmQsMCksbT1bdCtjLGVdLHg9W3QraS1jLGVdLHk9W3QraSxlK2NdLGI9W3QraSxlK3MtcF0sdj1bdCtpLXAsZStzXSxTPVt0K3AsZStzXSxrPVt0LGUrcy1wXSxNPVt0LGUrY10sQz0odCxlKT0+TWF0aC5zcXJ0KE1hdGgucG93KHQsMiktTWF0aC5wb3coZSwyKSk7aWYodSl7bGV0IHQ9QyhjLGMtdSk7bVswXS09dCx4WzBdKz10LHlbMV09TVsxXT1lK2MtdX1pZihzPGMtdSl7bGV0IG89QyhjLGMtdS1zKTt5WzBdPWJbMF09dCtpLWMrbyx2WzBdPU1hdGgubWluKHlbMF0sdlswXSksU1swXT1NYXRoLm1heChiWzBdLFNbMF0pLGtbMF09TVswXT10K2Mtbyx5WzFdPU1bMV09ZStzfWlmKGYpe2xldCB0PUMocCxwLWYpO3ZbMF0rPXQsU1swXS09dCxiWzFdPWtbMV09ZStzLXArZn1pZihzPHAtZil7bGV0IG89QyhwLHAtZi1zKTt5WzBdPWJbMF09dCtpLXArbyx4WzBdPU1hdGgubWluKHlbMF0seFswXSksbVswXT1NYXRoLm1heChiWzBdLG1bMF0pLGtbMF09TVswXT10K3AtbyxiWzFdPWtbMV09ZX1yZXR1cm4gci5sZW5ndGg9MCxyLnB1c2goW1wiTVwiLC4uLm1dLFtcIkxcIiwuLi54XSxbXCJBXCIsYyxjLDAsMCwxLC4uLnldLFtcIkxcIiwuLi5iXSxbXCJBXCIscCxwLDAsMCwxLC4uLnZdLFtcIkxcIiwuLi5TXSxbXCJBXCIscCxwLDAsMCwxLC4uLmtdLFtcIkxcIiwuLi5NXSxbXCJBXCIsYyxjLDAsMCwxLC4uLm1dLFtcIlpcIl0pLHJ9cmV0dXJue2NvbXBvc2U6ZnVuY3Rpb24gdChlLGkscyxyKXtpZihkKG8sdCkpe2xldCB0PXIucHJvdG90eXBlLnN5bWJvbHM7bihlLFwiYWZ0ZXJDb2x1bW5UcmFuc2xhdGVcIixtLHtvcmRlcjo5fSksbihpLFwiYWZ0ZXJUcmFuc2xhdGVcIix5KSxzLnN5bWJvbEN1c3RvbUF0dHJpYnMucHVzaChcImJvcmRlclJhZGl1c1wiLFwiYnJCb3hIZWlnaHRcIixcImJyQm94WVwiKSx1PXQuYXJjLGc9dC5yb3VuZGVkUmVjdCx0LmFyYz1mLHQucm91bmRlZFJlY3Q9Yn19LG9wdGlvbnNUb09iamVjdDp4fX0pLGkoZSxcIkNvcmUvUmVzcG9uc2l2ZS5qc1wiLFtlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24odCxlKXt2YXIgaTtsZXR7Y29tcG9zZWQ6c309dCx7ZGlmZk9iamVjdHM6byxleHRlbmQ6cixmaW5kOm4sbWVyZ2U6YSxwaWNrOmgscHVzaFVuaXF1ZTpsLHVuaXF1ZUtleTpkfT1lO3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7bGV0IGk9dC5jb25kaXRpb24scz1pLmNhbGxiYWNrfHxmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoYXJ0V2lkdGg8PWgoaS5tYXhXaWR0aCxOdW1iZXIuTUFYX1ZBTFVFKSYmdGhpcy5jaGFydEhlaWdodDw9aChpLm1heEhlaWdodCxOdW1iZXIuTUFYX1ZBTFVFKSYmdGhpcy5jaGFydFdpZHRoPj1oKGkubWluV2lkdGgsMCkmJnRoaXMuY2hhcnRIZWlnaHQ+PWgoaS5taW5IZWlnaHQsMCl9O3MuY2FsbCh0aGlzKSYmZS5wdXNoKHQuX2lkKX1mdW5jdGlvbiBpKHQsZSl7bGV0IGk9dGhpcy5vcHRpb25zLnJlc3BvbnNpdmUscz10aGlzLmN1cnJlbnRSZXNwb25zaXZlLHI9W10saDshZSYmaSYmaS5ydWxlcyYmaS5ydWxlcy5mb3JFYWNoKHQ9Pnt2b2lkIDA9PT10Ll9pZCYmKHQuX2lkPWQoKSksdGhpcy5tYXRjaFJlc3BvbnNpdmVSdWxlKHQscil9LHRoaXMpO2xldCBsPWEoLi4uci5tYXAodD0+bigoaXx8e30pLnJ1bGVzfHxbXSxlPT5lLl9pZD09PXQpKS5tYXAodD0+dCYmdC5jaGFydE9wdGlvbnMpKTtsLmlzUmVzcG9uc2l2ZU9wdGlvbnM9ITAscj1yLnRvU3RyaW5nKCl8fHZvaWQgMDtsZXQgYz1zJiZzLnJ1bGVJZHM7ciE9PWMmJihzJiZ0aGlzLnVwZGF0ZShzLnVuZG9PcHRpb25zLHQsITApLHI/KChoPW8obCx0aGlzLm9wdGlvbnMsITAsdGhpcy5jb2xsZWN0aW9uc1dpdGhVcGRhdGUpKS5pc1Jlc3BvbnNpdmVPcHRpb25zPSEwLHRoaXMuY3VycmVudFJlc3BvbnNpdmU9e3J1bGVJZHM6cixtZXJnZWRPcHRpb25zOmwsdW5kb09wdGlvbnM6aH0sdGhpcy51cGRhdGUobCx0LCEwKSk6dGhpcy5jdXJyZW50UmVzcG9uc2l2ZT12b2lkIDApfXQuY29tcG9zZT1mdW5jdGlvbiB0KG8pe3JldHVybiBsKHMsdCkmJnIoby5wcm90b3R5cGUse21hdGNoUmVzcG9uc2l2ZVJ1bGU6ZSxzZXRSZXNwb25zaXZlOml9KSxvfX0oaXx8KGk9e30pKSxpfSksaShlLFwibWFzdGVycy9oaWdoY2hhcnRzLnNyYy5qc1wiLFtlW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGVbXCJDb3JlL1V0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9EZWZhdWx0cy5qc1wiXSxlW1wiQ29yZS9BbmltYXRpb24vRnguanNcIl0sZVtcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxlW1wiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiXSxlW1wiQ29yZS9UZW1wbGF0aW5nLmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1JlbmRlcmVyVXRpbGl0aWVzLmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1NWRy9TVkdFbGVtZW50LmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL1NWRy9TVkdSZW5kZXJlci5qc1wiXSxlW1wiQ29yZS9SZW5kZXJlci9IVE1ML0hUTUxFbGVtZW50LmpzXCJdLGVbXCJDb3JlL1JlbmRlcmVyL0hUTUwvSFRNTFJlbmRlcmVyLmpzXCJdLGVbXCJDb3JlL0F4aXMvQXhpcy5qc1wiXSxlW1wiQ29yZS9BeGlzL0RhdGVUaW1lQXhpcy5qc1wiXSxlW1wiQ29yZS9BeGlzL0xvZ2FyaXRobWljQXhpcy5qc1wiXSxlW1wiQ29yZS9BeGlzL1Bsb3RMaW5lT3JCYW5kL1Bsb3RMaW5lT3JCYW5kLmpzXCJdLGVbXCJDb3JlL0F4aXMvVGljay5qc1wiXSxlW1wiQ29yZS9Ub29sdGlwLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxlW1wiQ29yZS9Qb2ludGVyLmpzXCJdLGVbXCJDb3JlL0xlZ2VuZC9MZWdlbmQuanNcIl0sZVtcIkNvcmUvQ2hhcnQvQ2hhcnQuanNcIl0sZVtcIkV4dGVuc2lvbnMvU2Nyb2xsYWJsZVBsb3RBcmVhLmpzXCJdLGVbXCJDb3JlL0F4aXMvU3RhY2tpbmcvU3RhY2tpbmdBeGlzLmpzXCJdLGVbXCJDb3JlL0F4aXMvU3RhY2tpbmcvU3RhY2tJdGVtLmpzXCJdLGVbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sZVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGVbXCJTZXJpZXMvQ29sdW1uL0NvbHVtblNlcmllcy5qc1wiXSxlW1wiU2VyaWVzL0NvbHVtbi9Db2x1bW5EYXRhTGFiZWwuanNcIl0sZVtcIlNlcmllcy9QaWUvUGllU2VyaWVzLmpzXCJdLGVbXCJTZXJpZXMvUGllL1BpZURhdGFMYWJlbC5qc1wiXSxlW1wiQ29yZS9TZXJpZXMvRGF0YUxhYmVsLmpzXCJdLGVbXCJFeHRlbnNpb25zL092ZXJsYXBwaW5nRGF0YUxhYmVscy5qc1wiXSxlW1wiRXh0ZW5zaW9ucy9Cb3JkZXJSYWRpdXMuanNcIl0sZVtcIkNvcmUvUmVzcG9uc2l2ZS5qc1wiXSxlW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxlW1wiQ29yZS9UaW1lLmpzXCJdXSxmdW5jdGlvbih0LGUsaSxzLG8scixuLGEsaCxsLGQsYyxwLHUsZyxmLG0seCx5LGIsdixTLGssTSxDLHcsVCxBLFAsTCxPLEQsRSxqLEksQixSKXtyZXR1cm4gdC5hbmltYXRlPW8uYW5pbWF0ZSx0LmFuaW1PYmplY3Q9by5hbmltT2JqZWN0LHQuZ2V0RGVmZXJyZWRBbmltYXRpb249by5nZXREZWZlcnJlZEFuaW1hdGlvbix0LnNldEFuaW1hdGlvbj1vLnNldEFuaW1hdGlvbix0LnN0b3A9by5zdG9wLHQudGltZXJzPXMudGltZXJzLHQuQVNUPXIsdC5BeGlzPXAsdC5DaGFydD1TLHQuY2hhcnQ9Uy5jaGFydCx0LkZ4PXMsdC5MZWdlbmQ9dix0LlBsb3RMaW5lT3JCYW5kPWYsdC5Qb2ludD15LHQuUG9pbnRlcj1iLHQuU2VyaWVzPXcsdC5TdGFja0l0ZW09Qyx0LlNWR0VsZW1lbnQ9aCx0LlNWR1JlbmRlcmVyPWwsdC5UZW1wbGF0aW5nPW4sdC5UaWNrPW0sdC5UaW1lPVIsdC5Ub29sdGlwPXgsdC5Db2xvcj1CLHQuY29sb3I9Qi5wYXJzZSxjLmNvbXBvc2UobCksZC5jb21wb3NlKGgpLGIuY29tcG9zZShTKSx2LmNvbXBvc2UoUyksdC5kZWZhdWx0T3B0aW9ucz1pLmRlZmF1bHRPcHRpb25zLHQuZ2V0T3B0aW9ucz1pLmdldE9wdGlvbnMsdC50aW1lPWkuZGVmYXVsdFRpbWUsdC5zZXRPcHRpb25zPWkuc2V0T3B0aW9ucyx0LmRhdGVGb3JtYXQ9bi5kYXRlRm9ybWF0LHQuZm9ybWF0PW4uZm9ybWF0LHQubnVtYmVyRm9ybWF0PW4ubnVtYmVyRm9ybWF0LGUuZXh0ZW5kKHQsZSksdC5kaXN0cmlidXRlPWEuZGlzdHJpYnV0ZSx0LnNlcmllc1R5cGU9VC5zZXJpZXNUeXBlLFAuY29tcG9zZShBKSxqLmNvbXBvc2UodyxMLGgsbCksRC5jb21wb3NlKHcpLHUuY29tcG9zZShwKSxnLmNvbXBvc2UocCksRS5jb21wb3NlKFMpLE8uY29tcG9zZShMKSxmLmNvbXBvc2UocCksSS5jb21wb3NlKFMpLGsuY29tcG9zZShwLFMsdyksTS5jb21wb3NlKHAsUyx3KSx4LmNvbXBvc2UoYiksdH0pLGVbXCJtYXN0ZXJzL2hpZ2hjaGFydHMuc3JjLmpzXCJdLl9tb2R1bGVzPWUsZVtcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIl19KTsiXSwibmFtZXMiOlsidCIsImUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmYXVsdCIsImRvY3VtZW50IiwiZGVmaW5lIiwiYW1kIiwiSGlnaGNoYXJ0cyIsImVycm9yIiwid2luZG93IiwiaSIsInMiLCJvIiwiaGFzT3duUHJvcGVydHkiLCJhcHBseSIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImRldGFpbCIsInBhdGgiLCJTVkdfTlMiLCJwcm9kdWN0IiwidmVyc2lvbiIsIndpbiIsImRvYyIsInN2ZyIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVNWR1JlY3QiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJpc0Nocm9tZSIsImluZGV4T2YiLCJpc0ZpcmVmb3giLCJpc01TIiwidGVzdCIsIm9wZXJhIiwiaXNTYWZhcmkiLCJpc1RvdWNoRGV2aWNlIiwiaXNXZWJLaXQiLCJkZWcycmFkIiwiTWF0aCIsIlBJIiwiaGFzQmlkaUJ1ZyIsInBhcnNlSW50Iiwic3BsaXQiLCJoYXNUb3VjaCIsIlRvdWNoRXZlbnQiLCJtYXJnaW5OYW1lcyIsIm5vb3AiLCJzdXBwb3J0c1Bhc3NpdmVFdmVudHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2hhcnRzIiwiY29tcG9zZWQiLCJkYXRlRm9ybWF0cyIsInNlcmllc1R5cGVzIiwic3ltYm9sU2l6ZXMiLCJjaGFydENvdW50IiwiciIsIm4iLCJhIiwiaCIsInAiLCJsIiwidG9TdHJpbmciLCJrIiwiZW5jb2RlVVJJIiwiQyIsImNoYXJ0IiwiY29kZSIsIm1lc3NhZ2UiLCJwYXJhbXMiLCJFcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlcyIsIndhcm4iLCJwdXNoIiwicHJvdG90eXBlIiwiY2FsbCIsImQiLCJub2RlVHlwZSIsImMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJpc05hTiIsInUiLCJnIiwic2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZiIsIm0iLCJ4IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwieSIsIm9wYWNpdHkiLCJmaWx0ZXIiLCJzdHlsZSIsImIiLCJwb3ciLCJmbG9vciIsImxvZyIsIkxOMTAiLCJ2IiwicGFyc2VGbG9hdCIsInRvUHJlY2lzaW9uIiwiZWFzZUluT3V0U2luZSIsImNvcyIsIlMiLCJBcnJheSIsImZpbmQiLCJNIiwibm9kZU5hbWUiLCJmbiIsImhjRXZlbnRzIiwiY3JlYXRlRXZlbnQiLCJmaXJlRXZlbnQiLCJpbml0RXZlbnQiLCJ0YXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ0eXBlIiwidW5zaGlmdCIsImdldFByb3RvdHlwZU9mIiwic29ydCIsIm9yZGVyIiwiZm9yRWFjaCIsIm1hcCIsImVhY2giLCJncmVwIiwicmVkdWNlIiwic29tZSIsInNsaWNlIiwidyIsInJhbmRvbSIsInN1YnN0cmluZyIsImpRdWVyeSIsImhpZ2hjaGFydHMiLCJzaGlmdCIsIlQiLCJhZGRFdmVudCIsIlBvaW50Iiwic2VyaWVzIiwicnVuVHJhY2tlckNsaWNrIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJhcnJheU1heCIsImFycmF5TWluIiwiYXR0ciIsImNsYW1wIiwiY2xlYXJUaW1lb3V0IiwiY29ycmVjdEZsb2F0IiwiY3JlYXRlRWxlbWVudCIsInBhZGRpbmciLCJib3JkZXIiLCJtYXJnaW4iLCJhcHBlbmRDaGlsZCIsImNzcyIsImRlZmluZWQiLCJkZXN0cm95T2JqZWN0UHJvcGVydGllcyIsImRlc3Ryb3kiLCJkaWZmT2JqZWN0cyIsIm1heCIsImtleXMiLCJkaXNjYXJkRWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsImVyYXNlIiwic3BsaWNlIiwiZXh0ZW5kIiwiZXh0ZW5kQ2xhc3MiLCJnZXRDbG9zZXN0RGlzdGFuY2UiLCJnZXRNYWduaXR1ZGUiLCJnZXROZXN0ZWRQcm9wZXJ0eSIsImdldFN0eWxlIiwibWluIiwib2Zmc2V0V2lkdGgiLCJzY3JvbGxXaWR0aCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJpbkFycmF5IiwiaW5zZXJ0SXRlbSIsIm9wdGlvbnMiLCJpbmRleCIsImlzSW50ZXJuYWwiLCJfaSIsImlzQXJyYXkiLCJpc0NsYXNzIiwiaXNET01FbGVtZW50IiwiaXNGdW5jdGlvbiIsImlzTnVtYmVyIiwiaXNPYmplY3QiLCJpc1N0cmluZyIsIm1lcmdlIiwibm9ybWFsaXplVGlja0ludGVydmFsIiwicm91bmQiLCJvYmplY3RFYWNoIiwib2Zmc2V0IiwiZG9jdW1lbnRFbGVtZW50IiwicGFyZW50Tm9kZSIsInRvcCIsImxlZnQiLCJoZWlnaHQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImNsaWVudFRvcCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsImNsaWVudExlZnQiLCJwYWQiLCJTdHJpbmciLCJyZXBsYWNlIiwiam9pbiIsInBpY2siLCJwSW50IiwicHVzaFVuaXF1ZSIsInJlbGF0aXZlTGVuZ3RoIiwicmVtb3ZlRXZlbnQiLCJzcGxhdCIsInN0YWJsZVNvcnQiLCJzYWZlSSIsInN5bmNUaW1lb3V0Iiwic2V0VGltZW91dCIsInRpbWVVbml0cyIsIm1pbGxpc2Vjb25kIiwic2Vjb25kIiwibWludXRlIiwiaG91ciIsImRheSIsIndlZWsiLCJtb250aCIsInllYXIiLCJ1bmlxdWVLZXkiLCJ1c2VTZXJpYWxJZHMiLCJ3cmFwIiwiY29uY2F0IiwiYWxpZ25UaHJlc2hvbGRzIiwicGFubmluZyIsImVuYWJsZWQiLCJzdHlsZWRNb2RlIiwiYm9yZGVyUmFkaXVzIiwiY29sb3JDb3VudCIsImFsbG93TXV0YXRpbmdEYXRhIiwiaWdub3JlSGlkZGVuU2VyaWVzIiwic3BhY2luZyIsInJlc2V0Wm9vbUJ1dHRvbiIsInRoZW1lIiwicG9zaXRpb24iLCJyZWZsb3ciLCJ6b29taW5nIiwic2luZ2xlVG91Y2giLCJyZXNldEJ1dHRvbiIsInpJbmRleCIsImFsaWduIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwbG90Qm9yZGVyQ29sb3IiLCJjb2xvcnMiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJmb3JtYXRSYW5nZSIsInZhcmlhYmxlVGltZXpvbmUiLCJ0aW1lem9uZU9mZnNldCIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNldFRpbWUiLCJ1c2VVVEMiLCJzZXQiLCJ1cGRhdGUiLCJEYXRlIiwidGltZXpvbmVPZmZzZXRGdW5jdGlvbiIsInRpbWV6b25lIiwibWFrZVRpbWUiLCJVVEMiLCJ0aW1lWm9uZSIsInRpbWVab25lTmFtZSIsImZvcm1hdCIsIk51bWJlciIsInZhbHVlT2YiLCJkYXRlRm9ybWF0IiwiZGVmYXVsdE9wdGlvbnMiLCJsYW5nIiwiaW52YWxpZERhdGUiLCJ3ZWVrZGF5cyIsInNob3J0V2Vla2RheXMiLCJzdWJzdHIiLCJBIiwic2hvcnRNb250aHMiLCJCIiwibW9udGhzIiwiWSIsIkgiLCJJIiwiUCIsIkwiLCJ0b1VwcGVyQ2FzZSIsInJlc29sdmVEVExGb3JtYXQiLCJtYWluIiwiZnJvbSIsInRvIiwiZ2V0VGltZVRpY2tzIiwidW5pdFJhbmdlIiwiY291bnQiLCJpbmZvIiwiaGlnaGVyUmFua3MiLCJ0b3RhbFJhbmdlIiwiZ2V0RGF0ZUZvcm1hdCIsInN5bWJvbHMiLCJsb2FkaW5nIiwiZGVjaW1hbFBvaW50IiwibnVtZXJpY1N5bWJvbHMiLCJyZXNldFpvb20iLCJyZXNldFpvb21UaXRsZSIsInRob3VzYW5kc1NlcCIsImdsb2JhbCIsInRpbWUiLCJ0aXRsZSIsImNvbG9yIiwiZm9udFdlaWdodCIsInRleHQiLCJ3aWR0aEFkanVzdCIsInN1YnRpdGxlIiwiZm9udFNpemUiLCJjYXB0aW9uIiwidmVydGljYWxBbGlnbiIsInBsb3RPcHRpb25zIiwibGVnZW5kIiwiYWxpZ25Db2x1bW5zIiwiY2xhc3NOYW1lIiwibGF5b3V0IiwiaXRlbU1hcmdpbkJvdHRvbSIsIml0ZW1NYXJnaW5Ub3AiLCJsYWJlbEZvcm1hdHRlciIsIm5hdmlnYXRpb24iLCJhY3RpdmVDb2xvciIsImluYWN0aXZlQ29sb3IiLCJpdGVtU3R5bGUiLCJjdXJzb3IiLCJ0ZXh0RGVjb3JhdGlvbiIsInRleHRPdmVyZmxvdyIsIml0ZW1Ib3ZlclN0eWxlIiwiaXRlbUhpZGRlblN0eWxlIiwic2hhZG93IiwiaXRlbUNoZWNrYm94U3R5bGUiLCJzcXVhcmVTeW1ib2wiLCJzeW1ib2xQYWRkaW5nIiwibGFiZWxTdHlsZSIsInRleHRBbGlnbiIsInRvb2x0aXAiLCJhbmltYXRpb24iLCJkYXRlVGltZUxhYmVsRm9ybWF0cyIsImZvb3RlckZvcm1hdCIsImhlYWRlclNoYXBlIiwiaGlkZURlbGF5Iiwic2hhcGUiLCJzaGFyZWQiLCJzbmFwIiwiaGVhZGVyRm9ybWF0IiwicG9pbnRGb3JtYXQiLCJib3JkZXJXaWR0aCIsInN0aWNrT25Db250YWN0IiwidXNlSFRNTCIsImNyZWRpdHMiLCJocmVmIiwiZGVmYXVsdFRpbWUiLCJnZXRPcHRpb25zIiwic2V0T3B0aW9ucyIsInBhcnNlIiwiTm9uZSIsImlucHV0IiwicmdiYSIsInN0b3BzIiwiYnJpZ2h0ZW4iLCJzZXRPcGFjaXR5IiwidHdlZW5UbyIsIk5hTiIsIkNvbG9yIiwibmFtZXMiLCJ0b0xvd2VyQ2FzZSIsImNoYXJBdCIsInBhcnNlcnMiLCJyZWdleCIsImV4ZWMiLCJ3aGl0ZSIsImJsYWNrIiwiZFNldHRlciIsInBhdGhzIiwibm93IiwidG9EIiwiZWxlbSIsInByb3AiLCJzdGVwIiwiZWxlbWVudCIsInVuaXQiLCJydW4iLCJzdG9wcGVkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGltZXJzIiwic3RhcnRUaW1lIiwic3RhcnQiLCJlbmQiLCJwb3MiLCJjdXJBbmltIiwiY29tcGxldGUiLCJkdXJhdGlvbiIsImVhc2luZyIsImluaXRQYXRoIiwic3RhcnRYIiwiZW5kWCIsImlzQXJlYSIsInBvcCIsImZpbGxTZXR0ZXIiLCJzdHJva2VTZXR0ZXIiLCJkZWZlciIsImFuaW1hdGUiLCJwYXRoQXJyYXkiLCJtYXRjaCIsImFuaW1PYmplY3QiLCJnZXREZWZlcnJlZEFuaW1hdGlvbiIsInJlbmRlcmVyIiwiZm9yRXhwb3J0Iiwic2V0QW5pbWF0aW9uIiwiZ2xvYmFsQW5pbWF0aW9uIiwic3RvcCIsInRydXN0ZWRUeXBlcyIsImNyZWF0ZVBvbGljeSIsImNyZWF0ZUhUTUwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJmaWx0ZXJVc2VyQXR0cmlidXRlcyIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiYWxsb3dlZFJlZmVyZW5jZXMiLCJwYXJzZVN0eWxlIiwidHJpbSIsInNldEVsZW1lbnRIVE1MIiwiaW5uZXJIVE1MIiwiZW1wdHlIVE1MIiwiYWRkVG9ET00iLCJ0YWdOYW1lIiwidGV4dENvbnRlbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImJ5cGFzc0hUTUxGaWx0ZXJpbmciLCJhbGxvd2VkVGFncyIsIm5hbWVzcGFjZVVSSSIsImF0dHJpYnV0ZXMiLCJjaGlsZHJlbiIsIm5vZGVzIiwicGFyc2VNYXJrdXAiLCJib2R5IiwidmFsdWUiLCJjaGlsZE5vZGVzIiwiYWRkIiwiZGl2aWRlIiwiZXEiLCJnZSIsImd0IiwiaWYiLCJsZSIsImx0IiwibXVsdGlwbHkiLCJuZSIsInN1YnRyYWN0IiwidW5sZXNzIiwibnVtYmVyRm9ybWF0dGVyIiwiaXNCbG9jayIsImN0eCIsImV4cHJlc3Npb24iLCJzdGFydElubmVyIiwiZWxzZUJvZHkiLCJ0b0V4cG9uZW50aWFsIiwidG9GaXhlZCIsImFicyIsImhlbHBlcnMiLCJudW1iZXJGb3JtYXQiLCJkaXN0cmlidXRlIiwicmVkdWNlZExlbiIsInNpemUiLCJyYW5rIiwidGFyZ2V0cyIsIk8iLCJEIiwiX2RlZmF1bHRHZXR0ZXIiLCJfZGVmYXVsdFNldHRlciIsInBhcmVudEdyb3VwIiwidGV4dFN0ciIsImJ1aWxkVGV4dCIsImFkZGVkIiwiaGFuZGxlWiIsInpJbmRleFNldHRlciIsImJveCIsIm9uQWRkIiwiYWRkQ2xhc3MiLCJhZnRlclNldHRlcnMiLCJkb1RyYW5zZm9ybSIsInVwZGF0ZVRyYW5zZm9ybSIsImFsaWduZWRPYmplY3RzIiwiYWxpZ25PcHRpb25zIiwiYWxpZ25CeVRyYW5zbGF0ZSIsImFsaWduVG8iLCJwbG90Qm94IiwicGxhY2VkIiwiYWxpZ25BdHRyIiwiYWxpZ25TZXR0ZXIiLCJjZW50ZXIiLCJyaWdodCIsImFsaWduVmFsdWUiLCJoaWRkZW4iLCJhcHBseVRleHRPdXRsaW5lIiwiZ2V0Q29udHJhc3QiLCJmaWxsIiwiZmFrZVRTIiwicmVtb3ZlVGV4dE91dGxpbmUiLCJjbGFzcyIsInN0cm9rZSIsInF1ZXJ5U2VsZWN0b3IiLCJjbG9uZU5vZGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZHkiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwic3ltYm9sQ3VzdG9tQXR0cmlicyIsInN5bWJvbE5hbWUiLCJzeW1ib2xBdHRyIiwicm90YXRpb24iLCJjbGlwIiwiY2xpcFBhdGgiLCJpZCIsImRlZnMiLCJ1cmwiLCJjcmlzcCIsInN0cm9rZVdpZHRoIiwiY29tcGxleENvbG9yIiwiYXJncyIsInJhZGlhbEdyYWRpZW50IiwibGluZWFyR3JhZGllbnQiLCJncmFkaWVudHMiLCJyYWRpYWxSZWZlcmVuY2UiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImdyYWRpZW50VW5pdHMiLCJnZXRSYWRpYWxBdHRyIiwicmFkQXR0ciIsImdyYWRpZW50Iiwic3R5bGVzIiwidGV4dFdpZHRoIiwidGV4dE91dGxpbmUiLCJkYXNoc3R5bGVTZXR0ZXIiLCJvd25lclNWR0VsZW1lbnQiLCJvbmNsaWNrIiwib25tb3VzZW91dCIsIm9ubW91c2VvdmVyIiwib25tb3VzZW1vdmUiLCJwb2ludCIsImNvbm5lY3RvciIsInNhZmVSZW1vdmVDaGlsZCIsImRpdiIsInBhdGhUb1NlZ21lbnRzIiwiaHJlZlNldHRlciIsInNldEF0dHJpYnV0ZU5TIiwiZ2V0QkJveCIsImNhY2hlIiwiY2FjaGVLZXlzIiwicm9vdEZvbnRTaXplIiwiZGlzcGxheSIsImh0bWxHZXRCQm94Iiwic2luIiwiaGFzQ2xhc3MiLCJoaWRlIiwidmlzaWJpbGl0eSIsIm9uIiwib25FdmVudHMiLCJvcGFjaXR5U2V0dGVyIiwicmVtb3ZlQ2xhc3MiLCJSZWdFeHAiLCJzZXRSYWRpYWxSZWZlcmVuY2UiLCJzZXRUZXh0UGF0aCIsInN0YXJ0T2Zmc2V0IiwidGV4dEFuY2hvciIsInRleHRQYXRoIiwidW5kbyIsImR4IiwidHJhbnNmb3JtIiwidGV4dENhY2hlIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJzaGFkb3dEZWZpbml0aW9uIiwic2hvdyIsInRleHRTZXR0ZXIiLCJ0ZXh0UHhMZW5ndGgiLCJ0aXRsZVNldHRlciIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwidG9Gcm9udCIsInRyYW5zbGF0ZSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwibWF0cml4Iiwic2NhbGVYIiwic2NhbGVZIiwicm90YXRpb25PcmlnaW5YIiwicm90YXRpb25PcmlnaW5ZIiwidmlzaWJpbGl0eVNldHRlciIsInhHZXR0ZXIiLCJ5R2V0dGVyIiwibWF0cml4U2V0dGVyIiwicm90YXRpb25PcmlnaW5YU2V0dGVyIiwicm90YXRpb25PcmlnaW5ZU2V0dGVyIiwicm90YXRpb25TZXR0ZXIiLCJzY2FsZVhTZXR0ZXIiLCJzY2FsZVlTZXR0ZXIiLCJ0cmFuc2xhdGVYU2V0dGVyIiwidHJhbnNsYXRlWVNldHRlciIsInZlcnRpY2FsQWxpZ25TZXR0ZXIiLCJyZW5kZXJlclR5cGVzIiwiZ2V0UmVuZGVyZXJUeXBlIiwicmVnaXN0ZXJSZW5kZXJlclR5cGUiLCJSZW5kZXJlciIsImFsaWduRmFjdG9yIiwiYkJveCIsInhTZXR0aW5nIiwiYW5jaG9yWFNldHRlciIsImFuY2hvclgiLCJib3hBdHRyIiwiZ2V0Q3Jpc3BBZGp1c3QiLCJhbmNob3JZU2V0dGVyIiwiYW5jaG9yWSIsInlTZXR0aW5nIiwiZGVmZXJyZWRBdHRyIiwidGV4dFByb3BzIiwidXBkYXRlVGV4dFBhZGRpbmciLCJ1cGRhdGVCb3hTaXplIiwibmVlZHNCb3giLCJwYWRkaW5nTGVmdCIsImhlaWdodFNldHRlciIsImhlaWdodFNldHRpbmciLCJwYWRkaW5nU2V0dGVyIiwiclNldHRlciIsIndpZHRoU2V0dGluZyIsImVtcHR5QkJveCIsImdldFBhZGRlZFdpZHRoIiwiZm9udE1ldHJpY3MiLCJiYXNlbGluZU9mZnNldCIsImZpcnN0TGluZU1ldHJpY3MiLCJzeW1ib2xLZXkiLCJzeW1ib2wiLCJyZWN0IiwiYmFzZWxpbmUiLCJoYXNCb3hXaWR0aENoYW5nZWQiLCJ3aWR0aFNldHRlciIsInBhZGRpbmdSaWdodCIsInhTZXR0ZXIiLCJ5U2V0dGVyIiwicGFkZGluZ0xlZnRTZXR0ZXIiLCJwYWRkaW5nUmlnaHRTZXR0ZXIiLCJpbm5lclIiLCJvcGVuIiwibG9uZ0FyYyIsImNsb2Nrd2lzZSIsImN4IiwiY3kiLCJhcmMiLCJjYWxsb3V0IiwiY2lyY2xlIiwiZGlhbW9uZCIsInJvdW5kZWRSZWN0Iiwic3F1YXJlIiwidHJpYW5nbGUiLCJidWlsZFNWRyIsInN2Z0VsZW1lbnQiLCJlbGxpcHNpcyIsIm5vV3JhcCIsInRleHRMaW5lSGVpZ2h0IiwiYWN0dWFsV2lkdGgiLCJtb2RpZnlUcmVlIiwibW9kaWZ5RE9NIiwidW5lc2NhcGVFbnRpdGllcyIsIm5leHRTaWJsaW5nIiwicHJldmlvdXNTaWJsaW5nIiwiZ2V0TGluZUhlaWdodCIsInRydW5jYXRlIiwiTm9kZSIsIlRFWFRfTk9ERSIsImJhc2VWYWwiLCJmb250U3R5bGUiLCJnZXRTdWJTdHJpbmdMZW5ndGgiLCJjZWlsIiwiZXNjYXBlcyIsImxpbmVIZWlnaHQiLCJ3aGl0ZVNwYWNlIiwiRSIsImoiLCJkZWZpbml0aW9uIiwiZ2V0UmVmZXJlbmNlVVJMIiwiZWxlbWVudEZyb21Qb2ludCIsImxvY2F0aW9uIiwiZm9udEZhbWlseSIsInNldFN0eWxlIiwiYm94V3JhcHBlciIsImlzSGlkZGVuIiwidW5TdWJQaXhlbEZpeCIsIkVsZW1lbnQiLCJjaGFydEluZGV4IiwiZmlsdGVyVW5pdHMiLCJzdGREZXZpYXRpb24iLCJidXR0b24iLCJsYWJlbCIsInN0YXRlcyIsImhvdmVyIiwic2VsZWN0IiwiZGlzYWJsZWQiLCJzZXRTdGF0ZSIsInN0YXRlIiwicG9pbnRlckV2ZW50cyIsInN0b3BQcm9wYWdhdGlvbiIsImNyaXNwTGluZSIsInJ4IiwicnkiLCJyR2V0dGVyIiwic2V0U2l6ZSIsInZpZXdCb3giLCJhbGlnbkVsZW1lbnRzIiwiaW1hZ2UiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiSW1hZ2UiLCJzcmMiLCJpbWd3aWR0aCIsImltZ2hlaWdodCIsImJhY2tncm91bmRTaXplIiwiaXNJbWciLCJvbmxvYWQiLCJpbWdDb3VudCIsImhhc0xvYWRlZCIsImNsaXBSZWN0IiwiYWxsb3dIVE1MIiwiaHRtbCIsInJvdENvcnIiLCJRIiwiViIsImRyYXciLCJjb21wb3NlIiwiZ2V0U3BhbkNvcnJlY3Rpb24iLCJodG1sQ3NzIiwiaHRtbFVwZGF0ZVRyYW5zZm9ybSIsInNldFNwYW5Sb3RhdGlvbiIsInhDb3JyIiwieUNvcnIiLCJvdmVyZmxvdyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJhbGlnbk9uQWRkIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsIm9sZFRleHRXaWR0aCIsImlubmVyVGV4dCIsImNUVCIsIm9sZFJvdGF0aW9uIiwib2xkQWxpZ24iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJhZGRlZFNldHRlcnMiLCJyZXZlcnNlIiwiY2xhc3NTZXR0ZXIiLCJ4QXhpcyIsImFsaWduVGlja3MiLCJhbGxvd0RlY2ltYWxzIiwicGFubmluZ0VuYWJsZWQiLCJ6b29tRW5hYmxlZCIsInJhbmdlIiwiZW5kT25UaWNrIiwiZ3JpZExpbmVEYXNoU3R5bGUiLCJncmlkWkluZGV4IiwibGFiZWxzIiwiYXV0b1JvdGF0aW9uTGltaXQiLCJkaXN0YW5jZSIsImluZGVudGF0aW9uIiwicmVzZXJ2ZVNwYWNlIiwic3RhZ2dlckxpbmVzIiwibWF4UGFkZGluZyIsIm1pbm9yR3JpZExpbmVEYXNoU3R5bGUiLCJtaW5vclRpY2tMZW5ndGgiLCJtaW5vclRpY2tQb3NpdGlvbiIsIm1pbm9yVGlja3NQZXJNYWpvciIsIm1pblBhZGRpbmciLCJyZXZlcnNlZCIsInJldmVyc2VkU3RhY2tzIiwic2hvd0VtcHR5Iiwic2hvd0ZpcnN0TGFiZWwiLCJzaG93TGFzdExhYmVsIiwic3RhcnRPZldlZWsiLCJzdGFydE9uVGljayIsInRpY2tMZW5ndGgiLCJ0aWNrUGl4ZWxJbnRlcnZhbCIsInRpY2ttYXJrUGxhY2VtZW50IiwidGlja1Bvc2l0aW9uIiwidW5pcXVlTmFtZXMiLCJ2aXNpYmxlIiwibWlub3JHcmlkTGluZUNvbG9yIiwibWlub3JHcmlkTGluZVdpZHRoIiwibWlub3JUaWNrQ29sb3IiLCJsaW5lQ29sb3IiLCJsaW5lV2lkdGgiLCJncmlkTGluZUNvbG9yIiwiZ3JpZExpbmVXaWR0aCIsInRpY2tDb2xvciIsInlBeGlzIiwic3RhY2tMYWJlbHMiLCJhbGxvd092ZXJsYXAiLCJjcm9wIiwiZm9ybWF0dGVyIiwiYXhpcyIsInRvdGFsIiwicmVnaXN0ZXJFdmVudE9wdGlvbnMiLCJldmVudE9wdGlvbnMiLCJldmVudHMiLCJhZGRMYWJlbCIsImNhdGVnb3JpZXMiLCJsb2dhcml0aG1pYyIsInRpY2tQb3NpdGlvbnMiLCJ0aWNrSW50ZXJ2YWwiLCJwYXJhbWV0ZXJzIiwiY2F0ZWdvcnkiLCJsaW4ybG9nIiwiZGF0ZVRpbWUiLCJncmlkIiwidW5pdE5hbWUiLCJnZXRYRGF0ZUZvcm1hdCIsImlzRmlyc3QiLCJpc0xhc3QiLCJkYXRlVGltZUxhYmVsRm9ybWF0IiwidGljayIsInRpY2tQb3NpdGlvbkluZm8iLCJkZWZhdWx0TGFiZWxGb3JtYXR0ZXIiLCJsaXN0Iiwic2hvcnRlbkxhYmVsIiwiZ2V0U2xvdFdpZHRoIiwiX2FkZGVkUGxvdExCIiwibW92ZUxhYmVsIiwibW92ZWRMYWJlbCIsImNyZWF0ZUxhYmVsIiwibGFiZWxHcm91cCIsImdldFBvc2l0aW9uIiwib2xkQ2hhcnRIZWlnaHQiLCJjaGFydEhlaWdodCIsInRyYW5zQiIsIm9wcG9zaXRlIiwib2xkQ2hhcnRXaWR0aCIsImNoYXJ0V2lkdGgiLCJib3R0b20iLCJnZXRMYWJlbFBvc2l0aW9uIiwidHJhbnNBIiwiaXNMaW5rZWQiLCJsaW5rZWRQYXJlbnQiLCJ0aWNrUm90Q29yciIsInJlc2VydmVTcGFjZURlZmF1bHQiLCJsYWJlbE9mZnNldCIsImxhYmVsQWxpZ24iLCJzaWRlIiwiaG9yaXoiLCJ0aWNrbWFya09mZnNldCIsImdldExhYmVsU2l6ZSIsImdldE1hcmtQYXRoIiwiaGFuZGxlT3ZlcmZsb3ciLCJsYWJlbExlZnQiLCJsYWJlbFJpZ2h0IiwiaXNSYWRpYWwiLCJsZW4iLCJhdXRvUm90YXRpb24iLCJ0aWNrcyIsImlzTmV3IiwibGFiZWxQb3MiLCJ4eSIsInJlbmRlciIsIm5ld09wYWNpdHkiLCJpc0FjdGl2ZSIsInJlbmRlckdyaWRMaW5lIiwicmVuZGVyTWFyayIsInJlbmRlckxhYmVsIiwiZ3JpZExpbmUiLCJkYXNoc3R5bGUiLCJncmlkR3JvdXAiLCJnZXRQbG90TGluZVBhdGgiLCJmb3JjZSIsIm9sZCIsImFjcm9zc1BhbmVzIiwidGlja1NpemUiLCJpc1hBeGlzIiwibWFyayIsImF4aXNHcm91cCIsImlzTmV3TGFiZWwiLCJyZXBsYWNlTW92ZWRMYWJlbCIsImlzRGlydHkiLCJSIiwieiIsInRpY2tBbW91bnQiLCJOIiwiaW5pdCIsImNvbGwiLCJpc1pBeGlzIiwiaW52ZXJ0ZWQiLCJ1c2VyT3B0aW9ucyIsIm1pblBpeGVsUGFkZGluZyIsImhhc05hbWVzIiwicGxvdExpbmVzQW5kQmFuZHNHcm91cHMiLCJwb3NpdGl2ZVZhbHVlc09ubHkiLCJsaW5rZWRUbyIsImxhYmVsRWRnZSIsIm1pbm9yVGlja3MiLCJwbG90TGluZXNBbmRCYW5kcyIsImFsdGVybmF0ZUJhbmRzIiwibWluUmFuZ2UiLCJ1c2VyTWluUmFuZ2UiLCJtYXhab29tIiwiY3Jvc3NoYWlyIiwiY3Jvc3NoYWlycyIsImF4ZXMiLCJvcmRlckl0ZW1zIiwibGFiZWxSb3RhdGlvbiIsIm51bWVyaWNTeW1ib2xNYWduaXR1ZGUiLCJnZXRTZXJpZXNFeHRyZW1lcyIsImhhc1Zpc2libGVTZXJpZXMiLCJkYXRhTWluIiwiZGF0YU1heCIsInRocmVzaG9sZCIsInNvZnRUaHJlc2hvbGQiLCJ4RGF0YSIsImdldFhFeHRyZW1lcyIsImFwcGx5RXh0cmVtZXMiLCJpc09yZGluYWwiLCJicm9rZW5BeGlzIiwiaGFzQnJlYWtzIiwibGluMnZhbCIsInNlY3RvciIsInZhbDJsaW4iLCJ0b1BpeGVscyIsInRvVmFsdWUiLCJ0cmFuc2xhdGVkVmFsdWUiLCJnZXRMaW5lYXJUaWNrUG9zaXRpb25zIiwic2luZ2xlIiwiZ2V0TWlub3JUaWNrSW50ZXJ2YWwiLCJtaW5vclRpY2tJbnRlcnZhbCIsImdldE1pbm9yVGlja1Bvc2l0aW9ucyIsInBvaW50UmFuZ2VQYWRkaW5nIiwicGFkZGVkVGlja3MiLCJnZXRMb2dUaWNrUG9zaXRpb25zIiwibm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCIsInRyaW1UaWNrcyIsImFkanVzdEZvck1pblJhbmdlIiwiY2VpbGluZyIsInhJbmNyZW1lbnQiLCJsb2cybGluIiwiZ2V0Q2xvc2VzdCIsImNsb3Nlc3RQb2ludFJhbmdlIiwibm9TaGFyZWRUb29sdGlwIiwibmFtZVRvWCIsInJlcXVpcmVTb3J0aW5nIiwiYXV0b0luY3JlbWVudCIsInVwZGF0ZU5hbWVzIiwicG9pbnRzIiwiaXNEaXJ0eURhdGEiLCJwcm9jZXNzRGF0YSIsImdlbmVyYXRlUG9pbnRzIiwiZGF0YSIsInNldEF4aXNUcmFuc2xhdGlvbiIsImF4aXNQb2ludFJhbmdlIiwibWluUG9pbnRPZmZzZXQiLCJwb2ludFJhbmdlIiwicG9pbnRQbGFjZW1lbnQiLCJpcyIsIm9yZGluYWwiLCJzbG9wZSIsInRyYW5zbGF0aW9uU2xvcGUiLCJzdGF0aWNTY2FsZSIsIm1pbkZyb21SYW5nZSIsInNldFRpY2tJbnRlcnZhbCIsInNvZnRNYXgiLCJzb2Z0TWluIiwiZ2V0VGlja0Ftb3VudCIsInVzZXJNaW4iLCJ1c2VyTWF4IiwiZ2V0RXh0cmVtZXMiLCJzdGFja2luZyIsInVzZVBlcmNlbnRhZ2UiLCJwb2xhciIsImZvcmNlQ3JvcCIsImZvcmNlQ3JvcHBpbmciLCJoYXNFeHRyZW1lc0NoYW5nZWQiLCJtaW5UaWNrSW50ZXJ2YWwiLCJ1bnNxdWlzaCIsInNldFRpY2tQb3NpdGlvbnMiLCJ0aWNrUG9zaXRpb25lciIsImhhc1ZlcnRpY2FsUGFubmluZyIsInBvc2l0aW9ucyIsInVuaXRzIiwiYWRqdXN0VGlja0Ftb3VudCIsImFsaWduVG9PdGhlcnMiLCJ0aHJlc2hvbGRBbGlnbm1lbnQiLCJwYW5lIiwiZ2V0VGhyZXNob2xkQWxpZ25tZW50IiwiZmluYWxUaWNrQW10IiwiaGFzRGF0YSIsInNldFNjYWxlIiwic2V0QXhpc1NpemUiLCJmb3JjZVJlZHJhdyIsImJ1aWxkU3RhY2tzIiwiY2xlYW5TdGFja3MiLCJwYW5uaW5nU3RhdGUiLCJzZXRFeHRyZW1lcyIsImtkVHJlZSIsImV2ZW50QXJncyIsInJlZHJhdyIsInpvb20iLCJuZXdNaW4iLCJuZXdNYXgiLCJhbGxvd1pvb21PdXRzaWRlIiwiZGlzcGxheUJ0biIsInRyaWdnZXIiLCJ6b29tZWQiLCJvZmZzZXRzIiwicGxvdFdpZHRoIiwicGxvdEhlaWdodCIsInBsb3RUb3AiLCJwbG90TGVmdCIsImdldFRocmVzaG9sZCIsImF1dG9MYWJlbEFsaWduIiwibGFiZWxNZXRyaWNzIiwiTUFYX1ZBTFVFIiwic2xvdFdpZHRoIiwicmVuZGVyVW5zcXVpc2giLCJtYXhMYWJlbExlbmd0aCIsInNwZWNpZmljVGV4dE92ZXJmbG93IiwiYWRkVGl0bGUiLCJheGlzVGl0bGUiLCJsb3ciLCJtaWRkbGUiLCJoaWdoIiwiZ2VuZXJhdGVUaWNrIiwiY3JlYXRlR3JvdXBzIiwiYXhpc1BhcmVudCIsImdldE9mZnNldCIsImNyb3NzaW5nIiwiYXhpc09mZnNldCIsImNsaXBPZmZzZXQiLCJzaG93QXhpcyIsInRpdGxlT2Zmc2V0IiwicmVuZGVyTGluZSIsImF4aXNUaXRsZU1hcmdpbiIsImdldE1heExhYmVsRGltZW5zaW9ucyIsIm1heExhYmVsRGltZW5zaW9ucyIsImF4aXNMaW5lIiwiZ2V0TGluZVBhdGgiLCJnZXRUaXRsZVBvc2l0aW9uIiwidGl0bGVQb3NpdGlvbiIsInJlbmRlck1pbm9yVGljayIsInJlbmRlclRpY2siLCJpc0NvbHVtbiIsImFsdGVybmF0ZUdyaWRDb2xvciIsIm92ZXJsYXAiLCJoYXNSZW5kZXJlZCIsIlBsb3RMaW5lT3JCYW5kIiwicGxvdExpbmVzIiwicGxvdEJhbmRzIiwiYWRkUGxvdEJhbmRPckxpbmUiLCJpc1BsYWNlZCIsInJlbmRlclN0YWNrVG90YWxzIiwiZ2V0S2VlcFByb3BzIiwia2VlcFByb3BzIiwia2VlcEV2ZW50cyIsImRyYXdDcm9zc2hhaXIiLCJjcm9zcyIsImNyb3NzaGFpclBvcyIsInBsb3RYIiwicGxvdFkiLCJjaGFydFgiLCJjaGFydFkiLCJzdGFja1kiLCJpc0Nyb3NzaGFpciIsImhpZGVDcm9zc2hhaXIiLCJkYXNoU3R5bGUiLCJpc0RpcnR5Qm94IiwicmVtb3ZlIiwic2V0VGl0bGUiLCJzZXRDYXRlZ29yaWVzIiwiQWRkaXRpb25zIiwibWlub3JBdXRvSW50ZXJ2YWwiLCJpc0ZsYXQiLCJyZW1vdmVQbG90QmFuZE9yTGluZSIsImFkZFBsb3RCYW5kIiwiYWRkUGxvdExpbmUiLCJnZXRQbG90QmFuZFBhdGgiLCJyZW1vdmVQbG90QmFuZCIsInJlbW92ZVBsb3RMaW5lIiwic3ZnRWxlbSIsImV2ZW50c0FkZGVkIiwiZ2V0TGFiZWxUZXh0IiwieEJvdW5kcyIsInlCb3VuZHMiLCJib2R5Rm9ybWF0dGVyIiwidG9vbHRpcE9wdGlvbnMiLCJmb3JtYXRQcmVmaXgiLCJ0b29sdGlwRm9ybWF0dGVyIiwiY2xlYW5TcGxpdCIsInR0IiwiZGVmYXVsdEZvcm1hdHRlciIsInRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIiLCJjb250YWluZXIiLCJoaWRlVGltZXIiLCJ0b29sdGlwVGltZW91dCIsImdldEFuY2hvciIsInBvaW50ZXIiLCJmb2xsb3dQb2ludGVyIiwibm9ybWFsaXplIiwidG9vbHRpcFBvcyIsImdldENsYXNzTmFtZSIsImNvbG9ySW5kZXgiLCJnZXRMYWJlbCIsImFsbG93U2hhcmVkIiwib3V0c2lkZSIsInNob3VsZFN0aWNrT25Db250YWN0IiwiZ2V0UGxheWluZ0ZpZWxkIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJnZXRDaGFydFBvc2l0aW9uIiwibmVnYXRpdmUiLCJob3ZlclNlcmllcyIsInR0QmVsb3ciLCJzY3JvbGxhYmxlUGl4ZWxzWCIsInNjcm9sbGFibGVQaXhlbHNZIiwiaW5DbGFzcyIsIm1vdmUiLCJkcmF3VHJhY2tlciIsInJlZnJlc2giLCJhcHBseUluYWN0aXZlU3RhdGUiLCJnZXRMYWJlbENvbmZpZyIsInJlbmRlclNwbGl0IiwiaXNEaXJlY3RUb3VjaCIsInNob3VsZFNob3dUb29sdGlwIiwic3BhY2luZ0JveCIsInVwZGF0ZVBvc2l0aW9uIiwic2Nyb2xsaW5nQ29udGFpbmVyIiwicG9zaXRpb25lciIsImlzSGVhZGVyIiwiaWdub3JlWCIsImJveFdpZHRoIiwiVyIsInRyYWNrZXIiLCJob3ZlclBvaW50cyIsImhvdmVyUG9pbnQiLCJzdHlsZWRNb2RlRm9ybWF0IiwiaXNGb290ZXIiLCJsYWJlbENvbmZpZyIsInhEYXRlRm9ybWF0Iiwia2V5IiwidG9vbHRpcERhdGVLZXlzIiwiaXNTdGlja3kiLCJhbmltYXRlQmVmb3JlRGVzdHJveSIsInN0YXJ0WFBvcyIsImdldEdyYXBoaWNhbFByb3BzIiwic2luZ3VsYXIiLCJzdGFydFlQb3MiLCJwbHVyYWwiLCJhcHBseU9wdGlvbnMiLCJwb2ludFZhbEtleSIsIm9wdGlvbnNUb09iamVjdCIsImdyb3VwIiwiZGF0YUxhYmVscyIsInNlbGVjdGVkIiwicmVsYXRpdmVYVmFsdWUiLCJpc051bGwiLCJpc1ZhbGlkIiwiZGVzdHJveWVkIiwiZGF0YVNvcnRpbmciLCJncmFwaGljIiwiZ3JhcGhpY3MiLCJkYXRhTGFiZWwiLCJkZXN0cm95RWxlbWVudHMiLCJsZWdlbmRJdGVtIiwiZGVzdHJveUl0ZW0iLCJvbk1vdXNlT3V0IiwicG9pbnRDb3VudCIsImZpcmVQb2ludEV2ZW50IiwiaW1wb3J0RXZlbnRzIiwiYWxsb3dQb2ludFNlbGVjdCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ6b25lIiwicGVyY2VudGFnZSIsInN0YWNrVG90YWwiLCJnZXRab25lIiwiem9uZXMiLCJ6b25lQXhpcyIsIm5vblpvbmVkQ29sb3IiLCJoYXNOZXdTaGFwZVR5cGUiLCJzaGFwZVR5cGUiLCJwb2ludEFycmF5TWFwIiwic2V0TmVzdGVkUHJvcGVydHkiLCJoYXNEYXRhTGFiZWxzIiwibWFya2VyIiwiX2hhc1BvaW50TWFya2VycyIsInJlc29sdmVDb2xvciIsImNvbG9yQnlQb2ludCIsImNvbG9yQ291bnRlciIsInNob3VsZERyYXciLCJ2YWx1ZURlY2ltYWxzIiwidmFsdWVQcmVmaXgiLCJ2YWx1ZVN1ZmZpeCIsImhhc01vY2tHcmFwaGljIiwidXBkYXRlUGFyYWxsZWxBcnJheXMiLCJmaXhlZEJveCIsImhhc0NhcnRlc2lhblNlcmllcyIsImxlZ2VuZFR5cGUiLCJpc0RpcnR5TGVnZW5kIiwicmVtb3ZlUG9pbnQiLCJzZWxlY3RlZFN0YWdpbmciLCJhY2N1bXVsYXRlIiwiZ2V0U2VsZWN0ZWRQb2ludHMiLCJpbmFjdGl2ZU90aGVyUG9pbnRzIiwib25Nb3VzZU92ZXIiLCJnZXRDaGFydENvb3JkaW5hdGVzRnJvbVBvaW50IiwicnVuUG9pbnRBY3Rpb25zIiwiaGFzSW1wb3J0ZWRFdmVudHMiLCJtYXJrZXJBdHRyaWJzIiwiaGFsbyIsInN0YXRlTWFya2VyR3JhcGhpYyIsInBvaW50QXR0cmlicyIsImN1cnJlbnRTeW1ib2wiLCJtYXJrZXJHcm91cCIsImlzSW5zaWRlIiwiaXNDbHVzdGVyIiwiaGFsb1BhdGgiLCJsaW5rZWRTZXJpZXMiLCJuYXZpZ2F0b3JTZXJpZXMiLCJzZXRBbGxQb2ludHNUb1N0YXRlIiwiZXZlbnRzVG9VbmJpbmQiLCJ1bmJpbmREb2N1bWVudE1vdXNlVXAiLCJ1bmJpbmREb2N1bWVudFRvdWNoRW5kIiwiY2xlYXJJbnRlcnZhbCIsImdldFNlbGVjdGlvbk1hcmtlckF0dHJzIiwiYXR0cnMiLCJtb3VzZURvd25YIiwibW91c2VEb3duWSIsInpvb21Ib3IiLCJ6b29tVmVydCIsImRyYWciLCJwYW5LZXkiLCJzZWxlY3Rpb25NYXJrZXIiLCJ0b3VjaCIsImhhc0RyYWdnZWQiLCJzcXJ0IiwiaXNJbnNpZGVQbG90IiwidmlzaWJsZVBsb3RPbmx5IiwibWFwVmlldyIsInpvb21YIiwiem9vbVkiLCJzZWxlY3Rpb25NYXJrZXJGaWxsIiwicGFuIiwiZHJhZ1N0YXJ0IiwibW91c2VJc0Rvd24iLCJjYW5jZWxDbGljayIsImdldFNlbGVjdGlvbkJveCIsInJlc3VsdCIsImRyb3AiLCJoYXNQaW5jaGVkIiwib3JpZ2luYWxFdmVudCIsInNjYWxlR3JvdXBzIiwiX2N1cnNvciIsInBpbmNoRG93biIsImZpbmROZWFyZXN0S0RQb2ludCIsImZpbmROZWFyZXN0UG9pbnRCeSIsInNlYXJjaFBvaW50IiwiZGlzdFgiLCJkaXN0Iiwic2hhcGVBcmdzIiwiY2xpZW50WCIsImlzTm9kZSIsImNoYXJ0UG9zaXRpb24iLCJnZXRDb29yZGluYXRlcyIsImdldEhvdmVyRGF0YSIsImRpcmVjdFRvdWNoIiwiZW5hYmxlTW91c2VUcmFja2luZyIsInN0aWNreVRyYWNraW5nIiwiYm9vc3RlZCIsImJvb3N0IiwiZ2V0UG9pbnQiLCJnZXRQb2ludEZyb21FdmVudCIsIm9uVHJhY2tlck1vdXNlT3V0IiwicmVsYXRlZFRhcmdldCIsInRvdWNoZXMiLCJpdGVtIiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwib25Db250YWluZXJDbGljayIsIm9uQ29udGFpbmVyTW91c2VEb3duIiwiYnV0dG9ucyIsIm9uQ29udGFpbmVyTW91c2VNb3ZlIiwiem9vbU9wdGlvbiIsIm9uQ29udGFpbmVyTW91c2VMZWF2ZSIsImhvdmVyQ2hhcnRJbmRleCIsInJlc2V0Iiwib25Db250YWluZXJNb3VzZUVudGVyIiwic2V0SG92ZXJDaGFydEluZGV4IiwidG91Y2hTZWxlY3QiLCJvcGVuTWVudSIsIm9uRG9jdW1lbnRUb3VjaEVuZCIsIm9uQ29udGFpbmVyVG91Y2hNb3ZlIiwib25Db250YWluZXJUb3VjaFN0YXJ0Iiwib25Eb2N1bWVudE1vdXNlTW92ZSIsIm9uRG9jdW1lbnRNb3VzZVVwIiwicGluY2giLCJsYXN0VmFsaWRUb3VjaCIsImhhc1pvb20iLCJydW5DaGFydENsaWNrIiwiZm9sbG93VG91Y2hNb3ZlIiwiaW5pdGlhdGVkIiwiY2FuY2VsYWJsZSIsImJvdW5kcyIsInJlcyIsInBpbmNoVHJhbnNsYXRlIiwicGluY2hUcmFuc2xhdGVEaXJlY3Rpb24iLCJpc0NhcnRlc2lhbiIsInVuRG9jTW91c2VNb3ZlIiwiaG92ZXJYIiwib3duZXJEb2N1bWVudCIsImdldFBsb3RCb3giLCJkYXRhTGFiZWxzR3JvdXAiLCJjbGlwQm94Iiwic2V0RE9NRXZlbnRzIiwib25tb3VzZWRvd24iLCJiaW5kIiwicmVuZGVyVG8iLCJwaW5jaFR5cGUiLCJjbGljayIsImluaXRpYWxJdGVtWSIsInN5bWJvbFdpZHRoIiwicGFnZXMiLCJwcm94aW1hdGUiLCJjb2xvcml6ZUl0ZW0iLCJhcmVhIiwibGluZSIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiaXNNYXJrZXIiLCJwb3NpdGlvbkl0ZW1zIiwiYWxsSXRlbXMiLCJwb3NpdGlvbkl0ZW0iLCJpc1Jlc2l6aW5nIiwicG9zaXRpb25DaGVja2JveGVzIiwicnRsIiwiY2hlY2tib3giLCJsZWdlbmRXaWR0aCIsImdldEFsbEl0ZW1zIiwiY2xpcEhlaWdodCIsImxlZ2VuZEhlaWdodCIsInRpdGxlSGVpZ2h0Iiwic2Nyb2xsT2Zmc2V0IiwiY2hlY2tib3hPZmZzZXQiLCJyZW5kZXJUaXRsZSIsIm1heExlZ2VuZFdpZHRoIiwiY29udGVudEdyb3VwIiwic2V0VGV4dCIsImxhYmVsRm9ybWF0IiwicmVuZGVySXRlbSIsIml0ZW1EaXN0YW5jZSIsImRyYXdMZWdlbmRTeW1ib2wiLCJjcmVhdGVDaGVja2JveEZvckl0ZW0iLCJzaG93Q2hlY2tib3giLCJzY3JvbGxHcm91cCIsInN5bWJvbEhlaWdodCIsInNldEl0ZW1FdmVudHMiLCJpdGVtV2lkdGgiLCJ3aWR0aE9wdGlvbiIsImxhYmVsV2lkdGgiLCJtYXhJdGVtV2lkdGgiLCJ0b3RhbEl0ZW1XaWR0aCIsIml0ZW1IZWlnaHQiLCJsYWJlbEhlaWdodCIsImxheW91dEl0ZW0iLCJpdGVtWCIsImxhc3RMaW5lSGVpZ2h0IiwiaXRlbVkiLCJsYXN0SXRlbVkiLCJzaG93SW5MZWdlbmQiLCJnZXRBbGlnbm1lbnQiLCJmbG9hdGluZyIsImFkanVzdE1hcmdpbnMiLCJwcm94aW1hdGVQb3NpdGlvbnMiLCJsZWdlbmRJbmRleCIsIm1heEhlaWdodCIsImFycm93U2l6ZSIsIm5hdiIsImN1cnJlbnRQYWdlIiwiZnVsbEhlaWdodCIsInBhZ2VJeCIsInVwIiwic2Nyb2xsIiwicGFnZXIiLCJkb3duIiwidXBUcmFja2VyIiwiZG93blRyYWNrZXIiLCJzZXRWaXNpYmxlIiwiYnJvd3NlckV2ZW50IiwiY2hlY2tlZCIsImRlZmF1bHRDaGVja2VkIiwibGluZWNhcCIsInJhZGl1cyIsImNvbnRleHQiLCJhcmVhTWFya2VyIiwibGluZU1hcmtlciIsInJlY3RhbmdsZSIsInN5bWJvbFJhZGl1cyIsImVuYWJsZWRUaHJlc2hvbGQiLCJub3JtYWwiLCJyYWRpdXNQbHVzIiwibGluZVdpZHRoUGx1cyIsImNyb3BUaHJlc2hvbGQiLCJpbmFjdGl2ZSIsInR1cmJvVGhyZXNob2xkIiwicG9pbnRDbGFzcyIsInJlZ2lzdGVyU2VyaWVzVHlwZSIsInNlcmllc1R5cGUiLCJHIiwiWCIsImJpbmRBeGVzIiwiZ2V0Q29sb3IiLCJnZXRTeW1ib2wiLCJwYXJhbGxlbEFycmF5cyIsInNldERhdGFTb3J0aW5nT3B0aW9ucyIsInNldERhdGEiLCJheGlzVHlwZXMiLCJvcHRpb25hbEF4aXMiLCJ0b1lEYXRhIiwieURhdGEiLCJoYXNNYXJrZXJDaGFuZ2VkIiwicG9pbnRJbnRlcnZhbFVuaXQiLCJwb2ludFN0YXJ0IiwicG9pbnRJbnRlcnZhbCIsInNvcnRlZCIsImVuYWJsZWREYXRhU29ydGluZyIsImFsbG93REciLCJuZWdhdGl2ZUNvbG9yIiwibmVnYXRpdmVGaWxsQ29sb3IiLCJnZXROYW1lIiwiZ2V0Q3ljbGljIiwiZ2V0UG9pbnRzQ29sbGVjdGlvbiIsImhhc0dyb3VwZWREYXRhIiwiZmluZFBvaW50SW5kZXgiLCJ0b3VjaGVkIiwibWF0Y2hCeU5hbWUiLCJjcm9wcGVkIiwiY3JvcFN0YXJ0IiwidXBkYXRlRGF0YSIsImhhc0Rlcml2ZWREYXRhIiwiYWRkUG9pbnQiLCJzb3J0RGF0YSIsImdldEZpcnN0VmFsaWRQb2ludCIsInNvcnRLZXkiLCJnZXRQcm9jZXNzZWREYXRhIiwiZ2V0RXh0cmVtZXNGcm9tQWxsIiwiY3JvcERhdGEiLCJwcm9jZXNzZWRYRGF0YSIsInByb2Nlc3NlZFlEYXRhIiwiYmFzZVBvaW50UmFuZ2UiLCJwcm9jZXNzZWREYXRhIiwiZGF0YUdyb3VwaW5nIiwiZ3JvdXBBbGwiLCJkYXRhR3JvdXAiLCJncm91cE1hcCIsInN0YWNrZWRZRGF0YSIsImFjdGl2ZVlEYXRhIiwiZGF0YUV4dHJlbWVzIiwicG9pbnRQbGFjZW1lbnRUb1hWYWx1ZSIsInN0YXJ0RnJvbVRocmVzaG9sZCIsInN0YWNrcyIsIm5lZ1N0YWNrcyIsInN0YWNrS2V5IiwiZ2V0U3RhY2tJbmRpY2F0b3IiLCJiYXNlIiwiaXJyZWd1bGFyV2lkdGhzIiwic2V0T2Zmc2V0IiwicG9pbnRYT2Zmc2V0IiwiYmFyVyIsInlCb3R0b20iLCJkYXRhTW9kaWZ5IiwibW9kaWZ5VmFsdWUiLCJpc1BvaW50SW5zaWRlIiwiY2xvc2VzdFBvaW50UmFuZ2VQeCIsImdldFZhbGlkUG9pbnRzIiwiZ2V0Q2xpcEJveCIsInBsb3RTaXplWCIsInBsb3RTaXplWSIsImdldFNoYXJlZENsaXBLZXkiLCJzaGFyZWRDbGlwS2V5Iiwic2V0Q2xpcCIsInNoYXJlZENsaXBzIiwiYWZ0ZXJBbmltYXRlIiwiZmluaXNoZWRBbmltYXRpbmciLCJkcmF3UG9pbnRzIiwiY29sb3JBeGlzIiwic3BlY2lhbEdyb3VwIiwiaGFzSW1hZ2UiLCJrZWVwRXZlbnRzRm9yVXBkYXRlIiwicmVtb3ZlRXZlbnRzIiwiYW5pbWF0aW9uVGltZW91dCIsInN1cnZpdmUiLCJhcHBseVpvbmVzIiwiZ3JhcGgiLCJ0cmFuc2xhdGVkIiwibGluZUNsaXAiLCJzaG93TGluZSIsInNpbXBsZUNsaXAiLCJwbG90R3JvdXAiLCJpbnZlcnRpYmxlIiwic2VyaWVzR3JvdXAiLCJkcmF3R3JhcGgiLCJkcmF3RGF0YUxhYmVscyIsInJlZHJhd1BvaW50cyIsInNlYXJjaEtEVHJlZSIsImJ1aWxkS0RUcmVlIiwiYnVpbGRpbmdLZFRyZWUiLCJrZEF4aXNBcnJheSIsImtkTm93IiwiaXNCdWJibGUiLCJ0cmFja0J5QXJlYSIsImFyZWFQYXRoIiwiZ3JhcGhQYXRoIiwibGlua1NlcmllcyIsImluaXRpYWxUeXBlIiwiam9pbkJ5IiwibWFwRGF0YSIsImhhc09wdGlvbkNoYW5nZWQiLCJzZXRQcm90b3R5cGVPZiIsIm1pc3NpbmdNb2R1bGVGb3IiLCJzZXRTb3J0ZWREYXRhIiwic2V0TmFtZSIsIm1vdXNlT3ZlciIsIm1vdXNlT3V0IiwibGFiZWxCeVNlcmllcyIsImxlZ2VuZFN5bWJvbCIsInR5cGVzIiwicmVnaXN0ZXJUeXBlIiwiRiIsIlUiLCIkIiwiWiIsIl8iLCJxIiwiSyIsIkoiLCJzZXRab29tT3B0aW9ucyIsInpvb21UeXBlIiwiem9vbUtleSIsInpvb21CeVNpbmdsZVRvdWNoIiwibGFiZWxDb2xsZWN0b3JzIiwiY2FsbGJhY2siLCJzaG93QXhlcyIsInN5bWJvbENvdW50ZXIiLCJmaXJzdFJlbmRlciIsImluaXRTZXJpZXMiLCJnZXRTZXJpZXNPcmRlckJ5TGlua3MiLCJzY3JvbGxhYmxlUGxvdEJveCIsInBhbmVDb29yZGluYXRlcyIsImlnbm9yZVkiLCJzZXRSZXNwb25zaXZlIiwidGVtcG9yYXJ5RGlzcGxheSIsImxheU91dFRpdGxlcyIsImNlbnRlckluQ2F0ZWdvcnkiLCJ1cGRhdGVUb3RhbHMiLCJnZXRTdGFja3MiLCJnZXRNYXJnaW5zIiwiZXh0S2V5IiwiZHJhd0NoYXJ0Qm94IiwiZ2V0QXhlcyIsImdldFNlbGVjdGVkU2VyaWVzIiwiYXBwbHlEZXNjcmlwdGlvbiIsImlzU3RvY2siLCJnZXRDb250YWluZXJCb3giLCJnZXRDaGFydFNpemUiLCJjb250YWluZXJCb3giLCJoY09yaWdTdHlsZSIsImhjT3JpZ0RldGFjaGVkIiwiY29udGFpbnMiLCJoY09yaWNEZXRhY2hlZCIsInNldFByb3BlcnR5Iiwic2V0Q2xhc3NOYW1lIiwiZ2V0Q29udGFpbmVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJza2lwQ2xvbmUiLCJ1c2VyU2VsZWN0Iiwib3V0bGluZSIsImV4cG9ydGluZyIsInJlc2V0TWFyZ2lucyIsIm1hcmdpbkJvdHRvbSIsImdldEF4aXNNYXJnaW5zIiwic2V0Q2hhcnRTaXplIiwiaXNQcmludGluZyIsInJlZmxvd1RpbWVvdXQiLCJzZXRSZWZsb3ciLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJtYXJnaW5SaWdodCIsInBsb3RCb3JkZXJXaWR0aCIsInNraXBBeGVzIiwicGxvdEJHSW1hZ2UiLCJwbG90QmFja2dyb3VuZENvbG9yIiwicGxvdEJhY2tncm91bmRJbWFnZSIsImNoYXJ0QmFja2dyb3VuZCIsInBsb3RCYWNrZ3JvdW5kIiwicGxvdEJvcmRlciIsInBsb3RTaGFkb3ciLCJwcm9wRnJvbVNlcmllcyIsImlzVXBkYXRpbmciLCJyZW5kZXJTZXJpZXMiLCJheGlzTGF5b3V0UnVucyIsInNlcmllc0dyb3VwU2hhZG93IiwiYWRkQ3JlZGl0cyIsIm1hcENyZWRpdHMiLCJzY3JvbGxlciIsImNhbGxiYWNrcyIsIndhcm5JZkExMXlNb2R1bGVOb3RMb2FkZWQiLCJhY2Nlc3NpYmlsaXR5Iiwicm9sZSIsImFkZFNlcmllcyIsImFkZEF4aXMiLCJjcmVhdGVBeGlzIiwiYWRkQ29sb3JBeGlzIiwic2hvd0xvYWRpbmciLCJsb2FkaW5nRGl2IiwibG9hZGluZ1NwYW4iLCJsb2FkaW5nU2hvd24iLCJzaG93RHVyYXRpb24iLCJoaWRlTG9hZGluZyIsImhpZGVEdXJhdGlvbiIsImlzUmVzcG9uc2l2ZU9wdGlvbnMiLCJwcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXMiLCJwcm9wc1JlcXVpcmVEaXJ0eUJveCIsInByb3BzUmVxdWlyZVJlZmxvdyIsImNvbGxlY3Rpb25zV2l0aFVwZGF0ZSIsImNvbGxlY3Rpb25zV2l0aEluaXQiLCJzZXRTdWJ0aXRsZSIsInNldENhcHRpb24iLCJzaG93UmVzZXRab29tIiwicmVsYXRpdmVUbyIsInpvb21PdXQiLCJyZXNldFNlbGVjdGlvbiIsInN0YXJ0TWluIiwic3RhcnRNYXgiLCJmaXhlZERpdiIsInNjcm9sbGFibGVQbG90QXJlYSIsInNjcm9sbFBvc2l0aW9uWCIsInNjcm9sbFBvc2l0aW9uWSIsImZpeGVkUmVuZGVyZXIiLCJzY3JvbGxhYmxlTWFzayIsIm1vdmVGaXhlZEVsZW1lbnRzIiwic2Nyb2xsYWJsZURpcnR5IiwicmVkcmF3VHJpZ2dlciIsIldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwic2Nyb2xsaW5nUGFyZW50IiwiaW5uZXJDb250YWluZXIiLCJzZXRVcFNjcm9sbGluZyIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwiYXBwbHlGaXhlZCIsImxhYmVscmFuayIsImdldFN0YWNrQm94IiwieE9mZnNldCIsImJveEJvdHRvbSIsImJveFRvcCIsImRlZmF1bHRYIiwiYWRqdXN0U3RhY2tQb3NpdGlvbiIsImxhYmVsQm94IiwianVzdGlmeURhdGFMYWJlbCIsImlzTmVnYXRpdmUiLCJjdW11bGF0aXZlIiwiaGFzVmFsaWRQb2ludHMiLCJzdGFjayIsImxlZnRDbGlmZiIsInJpZ2h0Q2xpZmYiLCJvbGRTdGFja3MiLCJzdGFja1RvdGFsR3JvdXAiLCJzZXRTdGFja2VkUG9pbnRzIiwicmVzZXRTdGFja3MiLCJzdGFja3NUb3VjaGVkIiwic2luZ2xlU3RhY2tzIiwic2V0R3JvdXBlZFBvaW50cyIsIm1vZGlmeVN0YWNrcyIsInBlcmNlbnRTdGFja2VyIiwiZ2FwcGVkUGF0aCIsImdldEdyYXBoUGF0aCIsInByZXZlbnRHcmFwaEFuaW1hdGlvbiIsInhNYXAiLCJmaWxsR3JhcGgiLCJjb25uZWN0TnVsbHMiLCJnZXRQb2ludFNwbGluZSIsInNoaWZ0VW5pdCIsImlzQ2xpZmYiLCJkb0N1cnZlIiwiZ2V0U3RhY2tQb2ludHMiLCJsZWZ0TnVsbCIsInJpZ2h0TnVsbCIsInJlY3RQbG90WCIsInJpZ2h0Q29udFgiLCJyaWdodENvbnRZIiwiY29udHJvbFBvaW50cyIsImdyb3VwUGFkZGluZyIsInBvaW50UGFkZGluZyIsIm1pblBvaW50TGVuZ3RoIiwiYnJpZ2h0bmVzcyIsImdldENvbHVtbk1ldHJpY3MiLCJncm91cGluZyIsImNvbHVtbkluZGV4IiwibWF4UG9pbnRXaWR0aCIsInBvaW50V2lkdGgiLCJjb2x1bW5NZXRyaWNzIiwicGFkZGVkV2lkdGgiLCJjb2x1bW5Db3VudCIsImNyaXNwQ29sIiwiYWRqdXN0Rm9yTWlzc2luZ0NvbHVtbnMiLCJkZW5zZSIsInRyYW5zbGF0ZWRUaHJlc2hvbGQiLCJzdGFja0JveCIsImJhclgiLCJwb2ludEF0dHJUb09wdGlvbnMiLCJhbmltYXRpb25MaW1pdCIsImFsbG93U2hhZG93IiwiX2hhc1RyYWNraW5nIiwidHJhY2tlckdyb3VwcyIsInNldERhdGFMYWJlbFN0YXJ0UG9zIiwiZm9yY2VETCIsImluc2lkZSIsImluaXREYXRhTGFiZWxzR3JvdXAiLCJpbml0RGF0YUxhYmVscyIsImRsT3B0aW9ucyIsImRhdGFMYWJlbE9uTnVsbCIsIm9wZXJhdG9yIiwicHJvcGVydHkiLCJjb250cmFzdENvbG9yIiwiZ2V0RGF0YUxhYmVsUGF0aCIsImRhdGFMYWJlbFBhdGgiLCJhbGlnbkRhdGFMYWJlbCIsImRsQm94IiwiYmVsb3ciLCJqaXR0ZXIiLCJjb2x1bW4iLCJhcHBseUppdHRlciIsImlzTG9nIiwiZ2V0Q2VudGVyIiwic2xpY2VkT2Zmc2V0IiwidGhpY2tuZXNzIiwiaW5uZXJTaXplIiwiYW5ndWxhciIsImdldFN0YXJ0QW5kRW5kUmFkaWFucyIsImdldENvbm5lY3RvclBhdGgiLCJkYXRhTGFiZWxQb3NpdGlvbiIsImNvbm5lY3RvclNoYXBlIiwiY29ubmVjdG9yU2hhcGVzIiwiY29tcHV0ZWQiLCJhbGlnbm1lbnQiLCJjb25uZWN0b3JQb3NpdGlvbiIsImdldFRyYW5zbGF0ZSIsInNsaWNlZCIsInNsaWNlZFRyYW5zbGF0aW9uIiwiaGFsZiIsImZpeGVkT2Zmc2V0IiwiYnJlYWtBdCIsInRvdWNoaW5nU2xpY2VBdCIsInNvZnRDb25uZWN0b3IiLCJzdHJhaWdodCIsImNyb29rZWRMaW5lIiwiY3Jvb2tEaXN0YW5jZSIsInRhbiIsImFuZ2xlIiwiY29ubmVjdG9yUGFkZGluZyIsImlnbm9yZUhpZGRlblBvaW50Iiwic3RhcnRBbmdsZVJhZCIsInN0YXJ0UiIsImRyYXdFbXB0eSIsImVuZEFuZ2xlUmFkIiwiZGVsYXllZFJlbmRlcmluZyIsImdldFgiLCJyYWRpaSIsImFzaW4iLCJzb3J0QnlBbmdsZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInJhZGlhbERpc3RyaWJ1dGlvblkiLCJkaXN0cmlidXRlQm94IiwicmFkaWFsRGlzdHJpYnV0aW9uWCIsImp1c3RpZnkiLCJhbGlnblRvUGxvdEVkZ2VzIiwiYWxpZ25Ub0Nvbm5lY3RvcnMiLCJuYXR1cmFsIiwiZGF0YUxhYmVsUG9zaXRpb25lcnMiLCJzaG9ydGVuZWQiLCJnZXREYXRhTGFiZWxQb3NpdGlvbiIsImF0dHJpYnMiLCJwb3NBdHRyaWJzIiwic2lkZU92ZXJmbG93IiwidmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3ciLCJwbGFjZURhdGFMYWJlbHMiLCJjb25uZWN0b3JDb2xvciIsImNvbm5lY3RvcldpZHRoIiwibW92ZWQiLCJtaW5TaXplIiwib2xkT3BhY2l0eSIsImFic29sdXRlQm94IiwiaXNPbGQiLCJoaWRlT3ZlcmxhcHBpbmdMYWJlbHMiLCJzY29wZSIsIndoZXJlIiwiaXMzZCIsImJyQm94SGVpZ2h0IiwiYnJCb3hZIiwiY29uZGl0aW9uIiwibWF4V2lkdGgiLCJfaWQiLCJyZXNwb25zaXZlIiwiY3VycmVudFJlc3BvbnNpdmUiLCJydWxlcyIsIm1hdGNoUmVzcG9uc2l2ZVJ1bGUiLCJjaGFydE9wdGlvbnMiLCJydWxlSWRzIiwidW5kb09wdGlvbnMiLCJtZXJnZWRPcHRpb25zIiwiQVNUIiwiQXhpcyIsIkNoYXJ0IiwiRngiLCJMZWdlbmQiLCJQb2ludGVyIiwiU2VyaWVzIiwiU3RhY2tJdGVtIiwiU1ZHRWxlbWVudCIsIlNWR1JlbmRlcmVyIiwiVGVtcGxhdGluZyIsIlRpY2siLCJUaW1lIiwiVG9vbHRpcCIsIl9tb2R1bGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/highcharts/highcharts.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/BiWeeklyContainer.tsx":
/*!**********************************************!*\
  !*** ./app/components/BiWeeklyContainer.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ BiWeeklyContainer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction BiWeeklyContainer(param) {\n    let { monthlyPayment, monthlyPayOffDate, totalInterest } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"biweekly-container\",\n        className: \"main-squares justify-self-start lg:w-[calc(25vw)]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-left bg-slate-50 border-b-2 p-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"text-2xl font-bold p-2\",\n                    children: \"Monthly vs Bi-Weekly Payment\"\n                }, void 0, false, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                    lineNumber: 20,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                lineNumber: 19,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                        className: \"biweekly-table w-full text-2xl\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: monthlyPayment.toLocaleString(\"en-US\", {\n                                                    style: \"currency\",\n                                                    currency: \"USD\"\n                                                })\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 28,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"biweekly-label\",\n                                                children: \"Monthly Payment\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 34,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                        lineNumber: 27,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: (monthlyPayment / 2).toLocaleString(\"en-US\", {\n                                                    style: \"currency\",\n                                                    currency: \"USD\"\n                                                })\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 37,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"biweekly-label\",\n                                                children: \"Bi-Weekly Payment\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 43,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                        lineNumber: 36,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                lineNumber: 26,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: monthlyPayOffDate\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 48,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"biweekly-label\",\n                                                children: \"Monthly Pay-off Date\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 49,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                        lineNumber: 47,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \"Jan, 1970\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 54,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"biweekly-label\",\n                                                children: \"Bi-Weekly Pay-off Date\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 55,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                        lineNumber: 53,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                lineNumber: 46,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: totalInterest.toLocaleString(\"en-US\", {\n                                                    style: \"currency\",\n                                                    currency: \"USD\"\n                                                })\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 62,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"biweekly-label\",\n                                                children: \"Total Interest Paid\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 68,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                        lineNumber: 61,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \"$12,345.67\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 73,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"biweekly-label\",\n                                                children: \"Total Interest Paid\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                                lineNumber: 74,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                        lineNumber: 72,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                                lineNumber: 60,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                        lineNumber: 25,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-center p-2 text-lg\",\n                        children: \"Total Interest Savings: $12,345.67\"\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                        lineNumber: 80,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n                lineNumber: 24,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/BiWeeklyContainer.tsx\",\n        lineNumber: 15,\n        columnNumber: 9\n    }, this);\n}\n_c = BiWeeklyContainer;\nvar _c;\n$RefreshReg$(_c, \"BiWeeklyContainer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0JpV2Vla2x5Q29udGFpbmVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQjtBQVFYLFNBQVNDLGtCQUFrQixLQUlqQjtRQUppQixFQUN0Q0MsY0FBYyxFQUNkQyxpQkFBaUIsRUFDakJDLGFBQWEsRUFDUSxHQUppQjtJQUt0QyxxQkFDSSw4REFBQ0M7UUFDR0MsSUFBRztRQUNIQyxXQUFVOzswQkFFViw4REFBQ0Y7Z0JBQUlFLFdBQVU7MEJBQ1gsNEVBQUNDO29CQUFLRCxXQUFVOzhCQUF5Qjs7Ozs7Ozs7Ozs7MEJBSTdDLDhEQUFDRjtnQkFBSUUsV0FBVTs7a0NBQ1gsOERBQUNFO3dCQUFNRixXQUFVOzswQ0FDYiw4REFBQ0c7O2tEQUNHLDhEQUFDQzs7MERBQ0csOERBQUNDOzBEQUNJVixlQUFlVyxjQUFjLENBQUMsU0FBUztvREFDcENDLE9BQU87b0RBQ1BDLFVBQVU7Z0RBQ2Q7Ozs7OzswREFFSiw4REFBQ0g7Z0RBQUVMLFdBQVU7MERBQWlCOzs7Ozs7Ozs7Ozs7a0RBRWxDLDhEQUFDSTs7MERBQ0csOERBQUNDOzBEQUNJLENBQUNWLGlCQUFpQixHQUFHVyxjQUFjLENBQUMsU0FBUztvREFDMUNDLE9BQU87b0RBQ1BDLFVBQVU7Z0RBQ2Q7Ozs7OzswREFFSiw4REFBQ0g7Z0RBQUVMLFdBQVU7MERBQWlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBR3RDLDhEQUFDRzs7a0RBQ0csOERBQUNDOzswREFDRyw4REFBQ0M7MERBQUdUOzs7Ozs7MERBQ0osOERBQUNTO2dEQUFFTCxXQUFVOzBEQUFpQjs7Ozs7Ozs7Ozs7O2tEQUlsQyw4REFBQ0k7OzBEQUNHLDhEQUFDQzswREFBRTs7Ozs7OzBEQUNILDhEQUFDQTtnREFBRUwsV0FBVTswREFBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FLdEMsOERBQUNHOztrREFDRyw4REFBQ0M7OzBEQUNHLDhEQUFDQzswREFDSVIsY0FBY1MsY0FBYyxDQUFDLFNBQVM7b0RBQ25DQyxPQUFPO29EQUNQQyxVQUFVO2dEQUNkOzs7Ozs7MERBRUosOERBQUNIO2dEQUFFTCxXQUFVOzBEQUFpQjs7Ozs7Ozs7Ozs7O2tEQUlsQyw4REFBQ0k7OzBEQUNHLDhEQUFDQzswREFBRTs7Ozs7OzBEQUNILDhEQUFDQTtnREFBRUwsV0FBVTswREFBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FNMUMsOERBQUNLO3dCQUFFTCxXQUFVO2tDQUEwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXZEO0tBN0V3Qk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvQmlXZWVrbHlDb250YWluZXIudHN4PzAyMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgQmlXZWVrbHlDb250YWluZXJQcm9wcyB7XG4gICAgbW9udGhseVBheW1lbnQ6IG51bWJlcjtcbiAgICBtb250aGx5UGF5T2ZmRGF0ZTogc3RyaW5nO1xuICAgIHRvdGFsSW50ZXJlc3Q6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmlXZWVrbHlDb250YWluZXIoe1xuICAgIG1vbnRobHlQYXltZW50LFxuICAgIG1vbnRobHlQYXlPZmZEYXRlLFxuICAgIHRvdGFsSW50ZXJlc3QsXG59OiBCaVdlZWtseUNvbnRhaW5lclByb3BzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgaWQ9XCJiaXdlZWtseS1jb250YWluZXJcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWFpbi1zcXVhcmVzIGp1c3RpZnktc2VsZi1zdGFydCBsZzp3LVtjYWxjKDI1dncpXVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1sZWZ0IGJnLXNsYXRlLTUwIGJvcmRlci1iLTIgcC0yXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIHAtMlwiPlxuICAgICAgICAgICAgICAgICAgICBNb250aGx5IHZzIEJpLVdlZWtseSBQYXltZW50XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNFwiPlxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJiaXdlZWtseS10YWJsZSB3LWZ1bGwgdGV4dC0yeGxcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bW9udGhseVBheW1lbnQudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJjdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IFwiVVNEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJiaXdlZWtseS1sYWJlbFwiPk1vbnRobHkgUGF5bWVudDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsobW9udGhseVBheW1lbnQgLyAyKS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImJpd2Vla2x5LWxhYmVsXCI+QmktV2Vla2x5IFBheW1lbnQ8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+e21vbnRobHlQYXlPZmZEYXRlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJiaXdlZWtseS1sYWJlbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb250aGx5IFBheS1vZmYgRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+SmFuLCAxOTcwPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImJpd2Vla2x5LWxhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJpLVdlZWtseSBQYXktb2ZmIERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0b3RhbEludGVyZXN0LnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwiY3VycmVuY3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiYml3ZWVrbHktbGFiZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG90YWwgSW50ZXJlc3QgUGFpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+JDEyLDM0NS42NzwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJiaXdlZWtseS1sYWJlbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb3RhbCBJbnRlcmVzdCBQYWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHAtMiB0ZXh0LWxnXCI+XG4gICAgICAgICAgICAgICAgICAgIFRvdGFsIEludGVyZXN0IFNhdmluZ3M6ICQxMiwzNDUuNjdcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkJpV2Vla2x5Q29udGFpbmVyIiwibW9udGhseVBheW1lbnQiLCJtb250aGx5UGF5T2ZmRGF0ZSIsInRvdGFsSW50ZXJlc3QiLCJkaXYiLCJpZCIsImNsYXNzTmFtZSIsInNwYW4iLCJ0YWJsZSIsInRyIiwidGQiLCJwIiwidG9Mb2NhbGVTdHJpbmciLCJzdHlsZSIsImN1cnJlbmN5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/BiWeeklyContainer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/DateInput.tsx":
/*!**************************************!*\
  !*** ./app/components/DateInput.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DateInput; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction DateInput(param) {\n    let { label, currentMonth, currentYear, onChangeSelect, onChangeInput } = param;\n    const months = [\n        \"January\",\n        \"February\",\n        \"March\",\n        \"April\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"August\",\n        \"September\",\n        \"October\",\n        \"November\",\n        \"December\"\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex justify-between m-1 mb-5\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"grow max-w-[25%] text-left\",\n                children: [\n                    label,\n                    \":\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n                lineNumber: 35,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grow max-w-[73%] border border-gray-300 m-1 rounded-md\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                            className: \"rounded-l-md px-2 flex-grow bg-white border-r-[1px] border-gray-300 w-[calc(100%-40%)]\",\n                            onChange: onChangeSelect,\n                            children: months.map((month, index)=>{\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                    value: index + 1,\n                                    selected: currentMonth === index + 1 ? true : false,\n                                    children: month\n                                }, index, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n                                    lineNumber: 44,\n                                    columnNumber: 33\n                                }, this);\n                            })\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n                            lineNumber: 38,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            className: \"rounded-r-md px-2 flex-grow w-[calc(100%-60%)]\",\n                            type: \"number\",\n                            value: currentYear,\n                            onChange: onChangeInput\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n                            lineNumber: 58,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n                    lineNumber: 37,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n                lineNumber: 36,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/DateInput.tsx\",\n        lineNumber: 34,\n        columnNumber: 9\n    }, this);\n}\n_c = DateInput;\nvar _c;\n$RefreshReg$(_c, \"DateInput\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0RhdGVJbnB1dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFVWCxTQUFTQyxVQUFVLEtBTWpCO1FBTmlCLEVBQzlCQyxLQUFLLEVBQ0xDLFlBQVksRUFDWkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2RDLGFBQWEsRUFDQSxHQU5pQjtJQU85QixNQUFNQyxTQUFTO1FBQ1g7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFFRCxxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNDO2dCQUFHRCxXQUFVOztvQkFBOEJQO29CQUFNOzs7Ozs7OzBCQUNsRCw4REFBQ007Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUNEO29CQUFJQyxXQUFVOztzQ0FDWCw4REFBQ0U7NEJBQ0dGLFdBQVU7NEJBQ1ZHLFVBQVVQO3NDQUVURSxPQUFPTSxHQUFHLENBQUMsQ0FBQ0MsT0FBT0M7Z0NBQ2hCLHFCQUNJLDhEQUFDQztvQ0FFR0MsT0FBT0YsUUFBUTtvQ0FDZkcsVUFDSWYsaUJBQWlCWSxRQUFRLElBQ25CLE9BQ0E7OENBR1REO21DQVJJQzs7Ozs7NEJBV2pCOzs7Ozs7c0NBRUosOERBQUNJOzRCQUNHVixXQUFVOzRCQUNWVyxNQUFLOzRCQUNMSCxPQUFPYjs0QkFDUFEsVUFBVU47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWxDO0tBekR3QkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvRGF0ZUlucHV0LnRzeD8wNmQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIERhdGVJbnB1dFByb3BzIHtcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIGN1cnJlbnRNb250aDogbnVtYmVyO1xuICAgIGN1cnJlbnRZZWFyOiBudW1iZXI7XG4gICAgb25DaGFuZ2VTZWxlY3Q/OiAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFNlbGVjdEVsZW1lbnQ+KSA9PiB2b2lkO1xuICAgIG9uQ2hhbmdlSW5wdXQ/OiAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGVJbnB1dCh7XG4gICAgbGFiZWwsXG4gICAgY3VycmVudE1vbnRoLFxuICAgIGN1cnJlbnRZZWFyLFxuICAgIG9uQ2hhbmdlU2VsZWN0LFxuICAgIG9uQ2hhbmdlSW5wdXQsXG59OiBEYXRlSW5wdXRQcm9wcykge1xuICAgIGNvbnN0IG1vbnRocyA9IFtcbiAgICAgICAgXCJKYW51YXJ5XCIsXG4gICAgICAgIFwiRmVicnVhcnlcIixcbiAgICAgICAgXCJNYXJjaFwiLFxuICAgICAgICBcIkFwcmlsXCIsXG4gICAgICAgIFwiTWF5XCIsXG4gICAgICAgIFwiSnVuZVwiLFxuICAgICAgICBcIkp1bHlcIixcbiAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgXCJTZXB0ZW1iZXJcIixcbiAgICAgICAgXCJPY3RvYmVyXCIsXG4gICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgXCJEZWNlbWJlclwiLFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIG0tMSBtYi01XCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwiZ3JvdyBtYXgtdy1bMjUlXSB0ZXh0LWxlZnRcIj57bGFiZWx9OjwvaDI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyb3cgbWF4LXctWzczJV0gYm9yZGVyIGJvcmRlci1ncmF5LTMwMCBtLTEgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleFwiPlxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWwtbWQgcHgtMiBmbGV4LWdyb3cgYmctd2hpdGUgYm9yZGVyLXItWzFweF0gYm9yZGVyLWdyYXktMzAwIHctW2NhbGMoMTAwJS00MCUpXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VTZWxlY3R9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHttb250aHMubWFwKChtb250aCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2luZGV4ICsgMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW9udGggPT09IGluZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bW9udGh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicm91bmRlZC1yLW1kIHB4LTIgZmxleC1ncm93IHctW2NhbGMoMTAwJS02MCUpXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtjdXJyZW50WWVhcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUlucHV0fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJEYXRlSW5wdXQiLCJsYWJlbCIsImN1cnJlbnRNb250aCIsImN1cnJlbnRZZWFyIiwib25DaGFuZ2VTZWxlY3QiLCJvbkNoYW5nZUlucHV0IiwibW9udGhzIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJzZWxlY3QiLCJvbkNoYW5nZSIsIm1hcCIsIm1vbnRoIiwiaW5kZXgiLCJvcHRpb24iLCJ2YWx1ZSIsInNlbGVjdGVkIiwiaW5wdXQiLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/DateInput.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/GraphContainer.tsx":
/*!*******************************************!*\
  !*** ./app/components/GraphContainer.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GraphContainer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_Calculations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Calculations */ \"(app-pages-browser)/./app/utils/Calculations.tsx\");\n/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! highcharts */ \"(app-pages-browser)/./node_modules/highcharts/highcharts.js\");\n/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(highcharts__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var highcharts_react_official__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! highcharts-react-official */ \"(app-pages-browser)/./node_modules/highcharts-react-official/dist/highcharts-react.min.js\");\n/* harmony import */ var highcharts_react_official__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(highcharts_react_official__WEBPACK_IMPORTED_MODULE_4__);\n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction GraphContainer(props) {\n    _s();\n    const chartComponentRef = react__WEBPACK_IMPORTED_MODULE_1___default().useRef(null);\n    const { homeValue, loanAmount, interestRate, loanTerm, startDateMonth, startDateYear, propertyTax, PMI, homeInsurance, monthlyPayment } = props;\n    const hasPMI = loanAmount > homeValue * 0.8;\n    const PMILength = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calcPMILength)(homeValue, loanAmount, interestRate, loanTerm);\n    const extendedProps = {\n        ...props,\n        PMILength: PMILength\n    };\n    const optionsObject = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.createOptionsObject)(extendedProps);\n    const options = {\n        title: {\n            text: \"Loan Breakdown\"\n        },\n        series: [\n            {\n                type: \"pie\",\n                data: [\n                    {\n                        name: \"Principal\",\n                        y: optionsObject.principal\n                    },\n                    {\n                        name: \"Interest\",\n                        y: optionsObject.interest\n                    },\n                    {\n                        name: \"Property Tax\",\n                        y: optionsObject.propertyTax\n                    },\n                    {\n                        name: \"HOA and Insurance\",\n                        y: optionsObject.HOAandInsurance\n                    },\n                    {\n                        name: \"Down Payment\",\n                        y: optionsObject.downPayment\n                    }\n                ]\n            }\n        ]\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"main-squares h-fit relative lg:w-[calc(25vw)] justify-self-start\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col text-left h-[15%] bg-slate-50 border-b-2 p-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-2xl font-bold\",\n                        children: monthlyPayment.toLocaleString(\"en-US\", {\n                            style: \"currency\",\n                            currency: \"USD\"\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                        lineNumber: 93,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-lg font-medium\",\n                        children: [\n                            \"Your estimated monthly payment\",\n                            hasPMI ? \" with PMI.\" : \".\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                        lineNumber: 99,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                lineNumber: 92,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                    className: \"table-auto w-full loan-breakdown-table\",\n                    children: [\n                        hasPMI ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"PMI:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 107,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: [\n                                        \"$\",\n                                        (PMI / 100 * loanAmount / 12).toFixed(2)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 108,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                            lineNumber: 106,\n                            columnNumber: 25\n                        }, this) : null,\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Monthly Tax Paid:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 114,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: [\n                                        \"$\",\n                                        (propertyTax / 12).toFixed(2)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 115,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                            lineNumber: 113,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Monthly Home Insurance:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: [\n                                        \"$\",\n                                        (homeInsurance / 12).toFixed(2)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 119,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                            lineNumber: 117,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                colSpan: 2,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {}, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 123,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                lineNumber: 122,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                            lineNumber: 121,\n                            columnNumber: 21\n                        }, this),\n                        hasPMI ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            children: \"PMI End Date:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                            lineNumber: 129,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            children: (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.PMIEndDate)(startDateMonth, startDateYear, PMILength)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                            lineNumber: 130,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 128,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            children: \"Total PMI Payments:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                            lineNumber: 139,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            children: PMILength\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                            lineNumber: 140,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 138,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            children: \"Monthly Payment after Mar, 2026:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                            lineNumber: 143,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            children: (monthlyPayment - (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calcPMI)(loanAmount, PMI)).toLocaleString(\"en-US\", {\n                                                style: \"currency\",\n                                                currency: \"USD\"\n                                            })\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                            lineNumber: 144,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                                    lineNumber: 142,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true) : null\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                    lineNumber: 104,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                lineNumber: 103,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((highcharts_react_official__WEBPACK_IMPORTED_MODULE_4___default()), {\n                highcharts: highcharts__WEBPACK_IMPORTED_MODULE_3__,\n                options: options,\n                ref: chartComponentRef\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n                lineNumber: 159,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/GraphContainer.tsx\",\n        lineNumber: 91,\n        columnNumber: 9\n    }, this);\n}\n_s(GraphContainer, \"R7Hd/+wolDIvpdiCofVuJ5Trjmg=\");\n_c = GraphContainer;\nvar _c;\n$RefreshReg$(_c, \"GraphContainer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0dyYXBoQ29udGFpbmVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwQjtBQU9LO0FBRVU7QUFDZTtBQWtCekMsU0FBU08sZUFBZUMsS0FBMEI7O0lBQzdELE1BQU1DLG9CQUFvQlQsbURBQVksQ0FBNEI7SUFDbEUsTUFBTSxFQUNGVyxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsWUFBWSxFQUNaQyxRQUFRLEVBQ1JDLGNBQWMsRUFDZEMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLEdBQUcsRUFDSEMsYUFBYSxFQUNiQyxjQUFjLEVBQ2pCLEdBQUdaO0lBRUosTUFBTWEsU0FBU1QsYUFBYUQsWUFBWTtJQUN4QyxNQUFNVyxZQUFZbkIsa0VBQWFBLENBQzNCUSxXQUNBQyxZQUNBQyxjQUNBQztJQUdKLE1BQU1TLGdCQUFnQjtRQUNsQixHQUFHZixLQUFLO1FBQ1JjLFdBQVdBO0lBQ2Y7SUFDQSxNQUFNRSxnQkFBZ0J0Qix3RUFBbUJBLENBQUNxQjtJQUMxQyxNQUFNRSxVQUE4QjtRQUNoQ0MsT0FBTztZQUNIQyxNQUFNO1FBQ1Y7UUFDQUMsUUFBUTtZQUNKO2dCQUNJQyxNQUFNO2dCQUNOQyxNQUFNO29CQUNGO3dCQUNJQyxNQUFNO3dCQUNOQyxHQUFHUixjQUFjUyxTQUFTO29CQUM5QjtvQkFDQTt3QkFDSUYsTUFBTTt3QkFDTkMsR0FBR1IsY0FBY1UsUUFBUTtvQkFDN0I7b0JBQ0E7d0JBQ0lILE1BQU07d0JBQ05DLEdBQUdSLGNBQWNQLFdBQVc7b0JBQ2hDO29CQUNBO3dCQUNJYyxNQUFNO3dCQUNOQyxHQUFHUixjQUFjVyxlQUFlO29CQUNwQztvQkFDQTt3QkFDSUosTUFBTTt3QkFDTkMsR0FBR1IsY0FBY1ksV0FBVztvQkFDaEM7aUJBQ0g7WUFDTDtTQUNIO0lBQ0w7SUFFQSxxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0M7d0JBQUtELFdBQVU7a0NBQ1hsQixlQUFlb0IsY0FBYyxDQUFDLFNBQVM7NEJBQ3BDQyxPQUFPOzRCQUNQQyxVQUFVO3dCQUNkOzs7Ozs7a0NBRUosOERBQUNIO3dCQUFLRCxXQUFVOzs0QkFBc0I7NEJBQ0hqQixTQUFTLGVBQWU7Ozs7Ozs7Ozs7Ozs7MEJBRy9ELDhEQUFDZ0I7Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUNLO29CQUFNTCxXQUFVOzt3QkFDWmpCLHVCQUNHLDhEQUFDdUI7OzhDQUNHLDhEQUFDQzs4Q0FBRzs7Ozs7OzhDQUNKLDhEQUFDQTs7d0NBQUc7d0NBQ0csT0FBUSxNQUFPakMsYUFBYyxFQUFDLEVBQUdrQyxPQUFPLENBQUM7Ozs7Ozs7Ozs7OzttQ0FHcEQ7c0NBQ0osOERBQUNGOzs4Q0FDRyw4REFBQ0M7OENBQUc7Ozs7Ozs4Q0FDSiw4REFBQ0E7O3dDQUFHO3dDQUFHNUIsQ0FBQUEsY0FBYyxFQUFDLEVBQUc2QixPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7c0NBRXJDLDhEQUFDRjs7OENBQ0csOERBQUNDOzhDQUFHOzs7Ozs7OENBQ0osOERBQUNBOzt3Q0FBRzt3Q0FBRzFCLENBQUFBLGdCQUFnQixFQUFDLEVBQUcyQixPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7c0NBRXZDLDhEQUFDRjtzQ0FDRyw0RUFBQ0M7Z0NBQUdFLFNBQVM7MENBQ1QsNEVBQUNDOzs7Ozs7Ozs7Ozs7Ozs7d0JBR1IzQix1QkFDRzs7OENBQ0ksOERBQUN1Qjs7c0RBQ0csOERBQUNDO3NEQUFHOzs7Ozs7c0RBQ0osOERBQUNBO3NEQUNJekMsK0RBQVVBLENBQ1BXLGdCQUNBQyxlQUNBTTs7Ozs7Ozs7Ozs7OzhDQUlaLDhEQUFDc0I7O3NEQUNHLDhEQUFDQztzREFBRzs7Ozs7O3NEQUNKLDhEQUFDQTtzREFBSXZCOzs7Ozs7Ozs7Ozs7OENBRVQsOERBQUNzQjs7c0RBQ0csOERBQUNDO3NEQUFHOzs7Ozs7c0RBQ0osOERBQUNBO3NEQUNJLENBQ0d6QixpQkFDQW5CLDREQUFPQSxDQUFDVyxZQUFZTSxJQUFHLEVBQ3pCc0IsY0FBYyxDQUFDLFNBQVM7Z0RBQ3RCQyxPQUFPO2dEQUNQQyxVQUFVOzRDQUNkOzs7Ozs7Ozs7Ozs7OzJDQUlaOzs7Ozs7Ozs7Ozs7MEJBSVosOERBQUNwQyxrRUFBZUE7Z0JBQ1oyQyxZQUFZNUMsdUNBQVVBO2dCQUN0Qm9CLFNBQVNBO2dCQUNUeUIsS0FBS3pDOzs7Ozs7Ozs7Ozs7QUFJckI7R0F6SXdCRjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9HcmFwaENvbnRhaW5lci50c3g/NGI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7XG4gICAgY2FsY1BNSSxcbiAgICBjcmVhdGVPcHRpb25zT2JqZWN0LFxuICAgIGNhbGNQTUlMZW5ndGgsXG4gICAgUE1JRW5kRGF0ZSxcbn0gZnJvbSBcIi4uL3V0aWxzL0NhbGN1bGF0aW9uc1wiO1xuXG5pbXBvcnQgKiBhcyBIaWdoY2hhcnRzIGZyb20gXCJoaWdoY2hhcnRzXCI7XG5pbXBvcnQgSGlnaGNoYXJ0c1JlYWN0IGZyb20gXCJoaWdoY2hhcnRzLXJlYWN0LW9mZmljaWFsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGhDb250YWluZXJQcm9wcyB7XG4gICAgaG9tZVZhbHVlOiBudW1iZXI7XG4gICAgbG9hbkFtb3VudDogbnVtYmVyO1xuICAgIGludGVyZXN0UmF0ZTogbnVtYmVyO1xuICAgIGxvYW5UZXJtOiBudW1iZXI7XG4gICAgc3RhcnREYXRlTW9udGg6IG51bWJlcjtcbiAgICBzdGFydERhdGVZZWFyOiBudW1iZXI7XG4gICAgcHJvcGVydHlUYXg6IG51bWJlcjtcbiAgICBQTUk6IG51bWJlcjtcbiAgICBob21lSW5zdXJhbmNlOiBudW1iZXI7XG4gICAgbW9udGhseUhPQTogbnVtYmVyO1xuICAgIGRvd25QYXltZW50OiBudW1iZXI7XG4gICAgbW9udGhseVBheW1lbnQ6IG51bWJlcjtcbiAgICBQTUlMZW5ndGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyYXBoQ29udGFpbmVyKHByb3BzOiBHcmFwaENvbnRhaW5lclByb3BzKSB7XG4gICAgY29uc3QgY2hhcnRDb21wb25lbnRSZWYgPSBSZWFjdC51c2VSZWY8SGlnaGNoYXJ0c1JlYWN0LlJlZk9iamVjdD4obnVsbCk7XG4gICAgY29uc3Qge1xuICAgICAgICBob21lVmFsdWUsXG4gICAgICAgIGxvYW5BbW91bnQsXG4gICAgICAgIGludGVyZXN0UmF0ZSxcbiAgICAgICAgbG9hblRlcm0sXG4gICAgICAgIHN0YXJ0RGF0ZU1vbnRoLFxuICAgICAgICBzdGFydERhdGVZZWFyLFxuICAgICAgICBwcm9wZXJ0eVRheCxcbiAgICAgICAgUE1JLFxuICAgICAgICBob21lSW5zdXJhbmNlLFxuICAgICAgICBtb250aGx5UGF5bWVudCxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBjb25zdCBoYXNQTUkgPSBsb2FuQW1vdW50ID4gaG9tZVZhbHVlICogMC44O1xuICAgIGNvbnN0IFBNSUxlbmd0aCA9IGNhbGNQTUlMZW5ndGgoXG4gICAgICAgIGhvbWVWYWx1ZSxcbiAgICAgICAgbG9hbkFtb3VudCxcbiAgICAgICAgaW50ZXJlc3RSYXRlLFxuICAgICAgICBsb2FuVGVybVxuICAgICk7XG5cbiAgICBjb25zdCBleHRlbmRlZFByb3BzID0ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgUE1JTGVuZ3RoOiBQTUlMZW5ndGgsXG4gICAgfTtcbiAgICBjb25zdCBvcHRpb25zT2JqZWN0ID0gY3JlYXRlT3B0aW9uc09iamVjdChleHRlbmRlZFByb3BzKTtcbiAgICBjb25zdCBvcHRpb25zOiBIaWdoY2hhcnRzLk9wdGlvbnMgPSB7XG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiBcIkxvYW4gQnJlYWtkb3duXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicGllXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlByaW5jaXBhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogb3B0aW9uc09iamVjdC5wcmluY2lwYWwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSW50ZXJlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9wdGlvbnNPYmplY3QuaW50ZXJlc3QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUHJvcGVydHkgVGF4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBvcHRpb25zT2JqZWN0LnByb3BlcnR5VGF4LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkhPQSBhbmQgSW5zdXJhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBvcHRpb25zT2JqZWN0LkhPQWFuZEluc3VyYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEb3duIFBheW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9wdGlvbnNPYmplY3QuZG93blBheW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFpbi1zcXVhcmVzIGgtZml0IHJlbGF0aXZlIGxnOnctW2NhbGMoMjV2dyldIGp1c3RpZnktc2VsZi1zdGFydFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHRleHQtbGVmdCBoLVsxNSVdIGJnLXNsYXRlLTUwIGJvcmRlci1iLTIgcC0yXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkXCI+XG4gICAgICAgICAgICAgICAgICAgIHttb250aGx5UGF5bWVudC50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1tZWRpdW1cIj5cbiAgICAgICAgICAgICAgICAgICAgWW91ciBlc3RpbWF0ZWQgbW9udGhseSBwYXltZW50e2hhc1BNSSA/IFwiIHdpdGggUE1JLlwiIDogXCIuXCJ9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNFwiPlxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZS1hdXRvIHctZnVsbCBsb2FuLWJyZWFrZG93bi10YWJsZVwiPlxuICAgICAgICAgICAgICAgICAgICB7aGFzUE1JID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5QTUk6PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7KCgoUE1JIC8gMTAwKSAqIGxvYW5BbW91bnQpIC8gMTIpLnRvRml4ZWQoMil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+TW9udGhseSBUYXggUGFpZDo8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPiR7KHByb3BlcnR5VGF4IC8gMTIpLnRvRml4ZWQoMil9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPk1vbnRobHkgSG9tZSBJbnN1cmFuY2U6PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD4keyhob21lSW5zdXJhbmNlIC8gMTIpLnRvRml4ZWQoMil9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbFNwYW49ezJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj48L2hyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAge2hhc1BNSSA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+UE1JIEVuZCBEYXRlOjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtQTUlFbmREYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZU1vbnRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZVllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUE1JTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+VG90YWwgUE1JIFBheW1lbnRzOjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57UE1JTGVuZ3RofTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5Nb250aGx5IFBheW1lbnQgYWZ0ZXIgTWFyLCAyMDI2OjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhseVBheW1lbnQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNQTUkobG9hbkFtb3VudCwgUE1JKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJjdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxIaWdoY2hhcnRzUmVhY3RcbiAgICAgICAgICAgICAgICBoaWdoY2hhcnRzPXtIaWdoY2hhcnRzfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgICAgICAgICAgcmVmPXtjaGFydENvbXBvbmVudFJlZn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjYWxjUE1JIiwiY3JlYXRlT3B0aW9uc09iamVjdCIsImNhbGNQTUlMZW5ndGgiLCJQTUlFbmREYXRlIiwiSGlnaGNoYXJ0cyIsIkhpZ2hjaGFydHNSZWFjdCIsIkdyYXBoQ29udGFpbmVyIiwicHJvcHMiLCJjaGFydENvbXBvbmVudFJlZiIsInVzZVJlZiIsImhvbWVWYWx1ZSIsImxvYW5BbW91bnQiLCJpbnRlcmVzdFJhdGUiLCJsb2FuVGVybSIsInN0YXJ0RGF0ZU1vbnRoIiwic3RhcnREYXRlWWVhciIsInByb3BlcnR5VGF4IiwiUE1JIiwiaG9tZUluc3VyYW5jZSIsIm1vbnRobHlQYXltZW50IiwiaGFzUE1JIiwiUE1JTGVuZ3RoIiwiZXh0ZW5kZWRQcm9wcyIsIm9wdGlvbnNPYmplY3QiLCJvcHRpb25zIiwidGl0bGUiLCJ0ZXh0Iiwic2VyaWVzIiwidHlwZSIsImRhdGEiLCJuYW1lIiwieSIsInByaW5jaXBhbCIsImludGVyZXN0IiwiSE9BYW5kSW5zdXJhbmNlIiwiZG93blBheW1lbnQiLCJkaXYiLCJjbGFzc05hbWUiLCJzcGFuIiwidG9Mb2NhbGVTdHJpbmciLCJzdHlsZSIsImN1cnJlbmN5IiwidGFibGUiLCJ0ciIsInRkIiwidG9GaXhlZCIsImNvbFNwYW4iLCJociIsImhpZ2hjaGFydHMiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/GraphContainer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/Input.tsx":
/*!**********************************!*\
  !*** ./app/components/Input.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Input; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Input(param) {\n    let { label, symbol, value, inverted, roundTo, onChange } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex justify-between m-1 mb-5\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"grow max-w-[25%] text-left\",\n                children: [\n                    label,\n                    \":\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                lineNumber: 22,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grow max-w-[73%] border border-gray-300 m-1 rounded-md\",\n                children: inverted ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            className: \"rounded-l-md px-2 z-10 grow w-[calc(100%-40%)]\",\n                            type: \"number\",\n                            value: value.toFixed(roundTo !== null && roundTo !== void 0 ? roundTo : 0),\n                            onChange: onChange\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-200 px-2 border-l-[1px] border-gray-300 rounded-r-md\",\n                            children: symbol\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                            lineNumber: 32,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 21\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-200 px-2 rounded-l-md border-r-[1px] border-gray-300\",\n                            children: symbol\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                            lineNumber: 38,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            className: \"rounded-r-md px-2 grow w-[calc(100%-40%)]\",\n                            type: \"number\",\n                            value: value.toFixed(roundTo !== null && roundTo !== void 0 ? roundTo : 0),\n                            onChange: onChange\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                            lineNumber: 41,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                    lineNumber: 37,\n                    columnNumber: 21\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n                lineNumber: 23,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/Input.tsx\",\n        lineNumber: 21,\n        columnNumber: 9\n    }, this);\n}\n_c = Input;\nvar _c;\n$RefreshReg$(_c, \"Input\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0lucHV0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQjtBQVdYLFNBQVNDLE1BQU0sS0FPakI7UUFQaUIsRUFDMUJDLEtBQUssRUFDTEMsTUFBTSxFQUNOQyxLQUFLLEVBQ0xDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxRQUFRLEVBQ0MsR0FQaUI7SUFRMUIscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNYLDhEQUFDQztnQkFBR0QsV0FBVTs7b0JBQThCUDtvQkFBTTs7Ozs7OzswQkFDbEQsOERBQUNNO2dCQUFJQyxXQUFVOzBCQUNWSix5QkFDRyw4REFBQ0c7b0JBQUlDLFdBQVU7O3NDQUNYLDhEQUFDRTs0QkFDR0YsV0FBVTs0QkFDVkcsTUFBSzs0QkFDTFIsT0FBT0EsTUFBTVMsT0FBTyxDQUFDUCxvQkFBQUEscUJBQUFBLFVBQVc7NEJBQ2hDQyxVQUFVQTs7Ozs7O3NDQUVkLDhEQUFDQzs0QkFBSUMsV0FBVTtzQ0FDVk47Ozs7Ozs7Ozs7O3lDQUlULDhEQUFDSztvQkFBSUMsV0FBVTs7c0NBQ1gsOERBQUNEOzRCQUFJQyxXQUFVO3NDQUNWTjs7Ozs7O3NDQUVMLDhEQUFDUTs0QkFDR0YsV0FBVTs0QkFDVkcsTUFBSzs0QkFDTFIsT0FBT0EsTUFBTVMsT0FBTyxDQUFDUCxvQkFBQUEscUJBQUFBLFVBQVc7NEJBQ2hDQyxVQUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPdEM7S0F4Q3dCTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9JbnB1dC50c3g/ZDBkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBJbnB1dFByb3BzIHtcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIHZhbHVlOiBudW1iZXI7XG4gICAgcm91bmRUbz86IG51bWJlcjtcbiAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgb25DaGFuZ2U/OiAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIElucHV0KHtcbiAgICBsYWJlbCxcbiAgICBzeW1ib2wsXG4gICAgdmFsdWUsXG4gICAgaW52ZXJ0ZWQsXG4gICAgcm91bmRUbyxcbiAgICBvbkNoYW5nZSxcbn06IElucHV0UHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIG0tMSBtYi01XCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwiZ3JvdyBtYXgtdy1bMjUlXSB0ZXh0LWxlZnRcIj57bGFiZWx9OjwvaDI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyb3cgbWF4LXctWzczJV0gYm9yZGVyIGJvcmRlci1ncmF5LTMwMCBtLTEgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAgICAgIHtpbnZlcnRlZCA/IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWwtbWQgcHgtMiB6LTEwIGdyb3cgdy1bY2FsYygxMDAlLTQwJSldXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWUudG9GaXhlZChyb3VuZFRvID8/IDApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktMjAwIHB4LTIgYm9yZGVyLWwtWzFweF0gYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQtci1tZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzeW1ib2x9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktMjAwIHB4LTIgcm91bmRlZC1sLW1kIGJvcmRlci1yLVsxcHhdIGJvcmRlci1ncmF5LTMwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzeW1ib2x9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtci1tZCBweC0yIGdyb3cgdy1bY2FsYygxMDAlLTQwJSldXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWUudG9GaXhlZChyb3VuZFRvID8/IDApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIklucHV0IiwibGFiZWwiLCJzeW1ib2wiLCJ2YWx1ZSIsImludmVydGVkIiwicm91bmRUbyIsIm9uQ2hhbmdlIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJpbnB1dCIsInR5cGUiLCJ0b0ZpeGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Input.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/InputContainer.tsx":
/*!*******************************************!*\
  !*** ./app/components/InputContainer.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ InputContainer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Input */ \"(app-pages-browser)/./app/components/Input.tsx\");\n/* harmony import */ var _SlidingInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SlidingInput */ \"(app-pages-browser)/./app/components/SlidingInput.tsx\");\n/* harmony import */ var _DateInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DateInput */ \"(app-pages-browser)/./app/components/DateInput.tsx\");\n/* harmony import */ var _utils_Calculations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/Calculations */ \"(app-pages-browser)/./app/utils/Calculations.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction InputContainer(param) {\n    let { homeValue, setHomeValue, downPayment, setDownPayment, downPaymentPercent, setDownPaymentPercent, loanAmount, setLoanAmount, interestRate, setInterestRate, loanTerm, setLoanTerm, startDateMonth, setStartDateMonth, startDateYear, setStartDateYear, propertyTax, setPropertyTax, PMI, setPMI, homeInsurance, setHomeInsurance, monthlyHOA, setMonthlyHOA, monthlyPayment, setMonthlyPayment } = param;\n    _s();\n    function updateDownPaymentPercent(newDownPayment) {\n        console.log(\"New Down Payment: \" + newDownPayment);\n        let newDownPaymentPercent = newDownPayment / homeValue * 100;\n        if (newDownPaymentPercent > 100) {\n            newDownPaymentPercent = 100;\n            if (newDownPayment > homeValue) {\n                setDownPayment(homeValue);\n            }\n        } else if (newDownPaymentPercent < 0) {\n            newDownPaymentPercent = 0;\n            if (newDownPayment < 0) {\n                setDownPayment(0);\n            }\n        }\n        if (newDownPaymentPercent !== downPaymentPercent) {\n            setDownPaymentPercent(newDownPaymentPercent);\n        }\n    }\n    function updateDownPayment(newDownPaymentPercent) {\n        let newDownPayment = newDownPaymentPercent / 100 * homeValue;\n        if (newDownPayment > homeValue) {\n            newDownPayment = homeValue;\n            if (newDownPaymentPercent > 100) {\n                setDownPaymentPercent(100);\n            }\n        } else if (newDownPayment < 0) {\n            newDownPayment = 0;\n            if (newDownPaymentPercent < 0) {\n                setDownPaymentPercent(0);\n            }\n        }\n        if (newDownPayment !== downPayment) {\n            setDownPayment(newDownPayment);\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDownPayment(downPaymentPercent / 100.0 * homeValue);\n        const newLoanAmount = homeValue - downPayment;\n        if (newLoanAmount !== loanAmount) {\n            setLoanAmount(newLoanAmount);\n        }\n        const newMonthlyPayment = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_5__.calculateMonthlyPayment)(newLoanAmount, interestRate, loanTerm, PMI, propertyTax, homeInsurance, monthlyHOA, downPaymentPercent);\n        if (newMonthlyPayment !== monthlyPayment) {\n            setMonthlyPayment(newMonthlyPayment);\n        }\n    }, [\n        downPayment,\n        downPaymentPercent,\n        homeValue,\n        interestRate,\n        loanTerm,\n        startDateMonth,\n        startDateYear,\n        propertyTax,\n        PMI,\n        homeInsurance,\n        monthlyHOA\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"input\",\n        className: \"main-squares p-3 justify-self-end shadow-none\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SlidingInput__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                label: \"Home Value\",\n                symbol: \"$\",\n                value: homeValue,\n                max: 1000000,\n                onChange: (e)=>setHomeValue(parseFloat(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 154,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SlidingInput__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                label: \"Down Payment\",\n                symbol: \"$\",\n                secondSymbol: \"%\",\n                value: downPayment,\n                secondValue: downPaymentPercent,\n                split: true,\n                step: 1,\n                onChange: (e)=>{\n                    const newDownPayment = parseFloat(e.target.value);\n                    setDownPayment(newDownPayment);\n                    updateDownPaymentPercent(newDownPayment);\n                // console.log(newDownPayment);\n                },\n                secondOnChange: (e)=>{\n                    const newDownPaymentPercent = parseFloat(e.target.value);\n                    setDownPaymentPercent(newDownPaymentPercent);\n                    updateDownPayment(newDownPaymentPercent);\n                // console.log(parseInt(e.target.value));\n                }\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 161,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Input__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                label: \"Loan Amount\",\n                symbol: \"$\",\n                value: loanAmount\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 182,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SlidingInput__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                label: \"Interest Rate\",\n                symbol: \"%\",\n                value: interestRate,\n                max: 30.0,\n                onChange: (e)=>setInterestRate(parseFloat(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 183,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Input__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                label: \"Loan Term\",\n                symbol: \"years\",\n                value: loanTerm,\n                inverted: true,\n                onChange: (e)=>setLoanTerm(parseInt(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 190,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DateInput__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                label: \"Start Date\",\n                currentMonth: startDateMonth,\n                onChangeSelect: (e)=>setStartDateMonth(parseInt(e.target.value)),\n                currentYear: startDateYear,\n                onChangeInput: (e)=>setStartDateYear(parseInt(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 197,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Input__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                label: \"Property Tax\",\n                symbol: \"$/year\",\n                value: propertyTax,\n                inverted: true,\n                onChange: (e)=>setPropertyTax(parseInt(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 208,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SlidingInput__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                label: \"PMI\",\n                symbol: \"%\",\n                value: PMI,\n                max: 10.0,\n                onChange: (e)=>setPMI(parseFloat(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 215,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Input__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                label: \"Home Insurance\",\n                symbol: \"$/year\",\n                value: homeInsurance,\n                inverted: true,\n                onChange: (e)=>setHomeInsurance(parseInt(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 222,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Input__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                label: \"Monthly HOA\",\n                symbol: \"$\",\n                value: monthlyHOA,\n                onChange: (e)=>setMonthlyHOA(parseInt(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 229,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Input__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                label: \"Monthly Payment\",\n                symbol: \"$\",\n                value: monthlyPayment,\n                roundTo: 2,\n                onChange: (e)=>setMonthlyPayment(parseInt(e.target.value))\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n                lineNumber: 235,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/InputContainer.tsx\",\n        lineNumber: 144,\n        columnNumber: 9\n    }, this);\n}\n_s(InputContainer, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = InputContainer;\nvar _c;\n$RefreshReg$(_c, \"InputContainer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0lucHV0Q29udGFpbmVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRTBCO0FBQ1E7QUFDTjtBQUNjO0FBQ047QUFDNEI7QUErQmpELFNBQVNNLGVBQWUsS0EyQmpCO1FBM0JpQixFQUNuQ0MsU0FBUyxFQUNUQyxZQUFZLEVBQ1pDLFdBQVcsRUFDWEMsY0FBYyxFQUNkQyxrQkFBa0IsRUFDbEJDLHFCQUFxQixFQUNyQkMsVUFBVSxFQUNWQyxhQUFhLEVBQ2JDLFlBQVksRUFDWkMsZUFBZSxFQUNmQyxRQUFRLEVBQ1JDLFdBQVcsRUFDWEMsY0FBYyxFQUNkQyxpQkFBaUIsRUFDakJDLGFBQWEsRUFDYkMsZ0JBQWdCLEVBQ2hCQyxXQUFXLEVBQ1hDLGNBQWMsRUFDZEMsR0FBRyxFQUNIQyxNQUFNLEVBQ05DLGFBQWEsRUFDYkMsZ0JBQWdCLEVBQ2hCQyxVQUFVLEVBQ1ZDLGFBQWEsRUFDYkMsY0FBYyxFQUNkQyxpQkFBaUIsRUFDQyxHQTNCaUI7O0lBNEJuQyxTQUFTQyx5QkFBeUJDLGNBQXNCO1FBQ3BEQyxRQUFRQyxHQUFHLENBQUMsdUJBQXVCRjtRQUVuQyxJQUFJRyx3QkFBd0IsaUJBQWtCOUIsWUFBYTtRQUUzRCxJQUFJOEIsd0JBQXdCLEtBQUs7WUFDN0JBLHdCQUF3QjtZQUN4QixJQUFJSCxpQkFBaUIzQixXQUFXO2dCQUM1QkcsZUFBZUg7WUFDbkI7UUFDSixPQUFPLElBQUk4Qix3QkFBd0IsR0FBRztZQUNsQ0Esd0JBQXdCO1lBQ3hCLElBQUlILGlCQUFpQixHQUFHO2dCQUNwQnhCLGVBQWU7WUFDbkI7UUFDSjtRQUVBLElBQUkyQiwwQkFBMEIxQixvQkFBb0I7WUFDOUNDLHNCQUFzQnlCO1FBQzFCO0lBQ0o7SUFFQSxTQUFTQyxrQkFBa0JELHFCQUE2QjtRQUNwRCxJQUFJSCxpQkFBaUIsd0JBQXlCLE1BQU8zQjtRQUNyRCxJQUFJMkIsaUJBQWlCM0IsV0FBVztZQUM1QjJC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Q1BDLE9BQU9yQjtnQkFDUHNCLEtBQUs7Z0JBQ0xDLFVBQVUsQ0FBQ0MsSUFBTXZCLE9BQU93QixXQUFXRCxFQUFFRSxNQUFNLENBQUNMLEtBQUs7Ozs7OzswQkFFckQsOERBQUM1Qyw4Q0FBS0E7Z0JBQ0YwQyxPQUFNO2dCQUNOQyxRQUFPO2dCQUNQQyxPQUFPbkI7Z0JBQ1A4QixVQUFVO2dCQUNWVCxVQUFVLENBQUNDLElBQU1yQixpQkFBaUI4QixTQUFTVCxFQUFFRSxNQUFNLENBQUNMLEtBQUs7Ozs7OzswQkFFN0QsOERBQUM1Qyw4Q0FBS0E7Z0JBQ0YwQyxPQUFNO2dCQUNOQyxRQUFPO2dCQUNQQyxPQUFPakI7Z0JBQ1BtQixVQUFVLENBQUNDLElBQU1uQixjQUFjNEIsU0FBU1QsRUFBRUUsTUFBTSxDQUFDTCxLQUFLOzs7Ozs7MEJBRTFELDhEQUFDNUMsOENBQUtBO2dCQUNGMEMsT0FBTTtnQkFDTkMsUUFBTztnQkFDUEMsT0FBT2Y7Z0JBQ1BnQyxTQUFTO2dCQUNUZixVQUFVLENBQUNDLElBQU1qQixrQkFBa0IwQixTQUFTVCxFQUFFRSxNQUFNLENBQUNMLEtBQUs7Ozs7Ozs7Ozs7OztBQUkxRTtHQTdNd0J4QztLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9JbnB1dENvbnRhaW5lci50c3g/NWE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4vSW5wdXRcIjtcbmltcG9ydCBTbGlkaW5nSW5wdXQgZnJvbSBcIi4vU2xpZGluZ0lucHV0XCI7XG5pbXBvcnQgRGF0ZUlucHV0IGZyb20gXCIuL0RhdGVJbnB1dFwiO1xuaW1wb3J0IHsgY2FsY3VsYXRlTW9udGhseVBheW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvQ2FsY3VsYXRpb25zXCI7XG5cbmludGVyZmFjZSBJbnB1dENvbnRhaW5lclByb3BzIHtcbiAgICBob21lVmFsdWU6IG51bWJlcjtcbiAgICBzZXRIb21lVmFsdWU6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAgIGRvd25QYXltZW50OiBudW1iZXI7XG4gICAgc2V0RG93blBheW1lbnQ6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAgIGRvd25QYXltZW50UGVyY2VudDogbnVtYmVyO1xuICAgIHNldERvd25QYXltZW50UGVyY2VudDogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgbG9hbkFtb3VudDogbnVtYmVyO1xuICAgIHNldExvYW5BbW91bnQ6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAgIGludGVyZXN0UmF0ZTogbnVtYmVyO1xuICAgIHNldEludGVyZXN0UmF0ZTogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgbG9hblRlcm06IG51bWJlcjtcbiAgICBzZXRMb2FuVGVybTogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgc3RhcnREYXRlTW9udGg6IG51bWJlcjtcbiAgICBzZXRTdGFydERhdGVNb250aDogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgc3RhcnREYXRlWWVhcjogbnVtYmVyO1xuICAgIHNldFN0YXJ0RGF0ZVllYXI6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAgIHByb3BlcnR5VGF4OiBudW1iZXI7XG4gICAgc2V0UHJvcGVydHlUYXg6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAgIFBNSTogbnVtYmVyO1xuICAgIHNldFBNSTogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgaG9tZUluc3VyYW5jZTogbnVtYmVyO1xuICAgIHNldEhvbWVJbnN1cmFuY2U6ICh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAgIG1vbnRobHlIT0E6IG51bWJlcjtcbiAgICBzZXRNb250aGx5SE9BOiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcbiAgICBtb250aGx5UGF5bWVudDogbnVtYmVyO1xuICAgIHNldE1vbnRobHlQYXltZW50OiAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW5wdXRDb250YWluZXIoe1xuICAgIGhvbWVWYWx1ZSxcbiAgICBzZXRIb21lVmFsdWUsXG4gICAgZG93blBheW1lbnQsXG4gICAgc2V0RG93blBheW1lbnQsXG4gICAgZG93blBheW1lbnRQZXJjZW50LFxuICAgIHNldERvd25QYXltZW50UGVyY2VudCxcbiAgICBsb2FuQW1vdW50LFxuICAgIHNldExvYW5BbW91bnQsXG4gICAgaW50ZXJlc3RSYXRlLFxuICAgIHNldEludGVyZXN0UmF0ZSxcbiAgICBsb2FuVGVybSxcbiAgICBzZXRMb2FuVGVybSxcbiAgICBzdGFydERhdGVNb250aCxcbiAgICBzZXRTdGFydERhdGVNb250aCxcbiAgICBzdGFydERhdGVZZWFyLFxuICAgIHNldFN0YXJ0RGF0ZVllYXIsXG4gICAgcHJvcGVydHlUYXgsXG4gICAgc2V0UHJvcGVydHlUYXgsXG4gICAgUE1JLFxuICAgIHNldFBNSSxcbiAgICBob21lSW5zdXJhbmNlLFxuICAgIHNldEhvbWVJbnN1cmFuY2UsXG4gICAgbW9udGhseUhPQSxcbiAgICBzZXRNb250aGx5SE9BLFxuICAgIG1vbnRobHlQYXltZW50LFxuICAgIHNldE1vbnRobHlQYXltZW50LFxufTogSW5wdXRDb250YWluZXJQcm9wcykge1xuICAgIGZ1bmN0aW9uIHVwZGF0ZURvd25QYXltZW50UGVyY2VudChuZXdEb3duUGF5bWVudDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTmV3IERvd24gUGF5bWVudDogXCIgKyBuZXdEb3duUGF5bWVudCk7XG5cbiAgICAgICAgbGV0IG5ld0Rvd25QYXltZW50UGVyY2VudCA9IChuZXdEb3duUGF5bWVudCAvIGhvbWVWYWx1ZSkgKiAxMDA7XG5cbiAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50UGVyY2VudCA+IDEwMCkge1xuICAgICAgICAgICAgbmV3RG93blBheW1lbnRQZXJjZW50ID0gMTAwO1xuICAgICAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50ID4gaG9tZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0RG93blBheW1lbnQoaG9tZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXdEb3duUGF5bWVudFBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICBuZXdEb3duUGF5bWVudFBlcmNlbnQgPSAwO1xuICAgICAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHNldERvd25QYXltZW50KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50UGVyY2VudCAhPT0gZG93blBheW1lbnRQZXJjZW50KSB7XG4gICAgICAgICAgICBzZXREb3duUGF5bWVudFBlcmNlbnQobmV3RG93blBheW1lbnRQZXJjZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURvd25QYXltZW50KG5ld0Rvd25QYXltZW50UGVyY2VudDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBuZXdEb3duUGF5bWVudCA9IChuZXdEb3duUGF5bWVudFBlcmNlbnQgLyAxMDApICogaG9tZVZhbHVlO1xuICAgICAgICBpZiAobmV3RG93blBheW1lbnQgPiBob21lVmFsdWUpIHtcbiAgICAgICAgICAgIG5ld0Rvd25QYXltZW50ID0gaG9tZVZhbHVlO1xuICAgICAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50UGVyY2VudCA+IDEwMCkge1xuICAgICAgICAgICAgICAgIHNldERvd25QYXltZW50UGVyY2VudCgxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0Rvd25QYXltZW50IDwgMCkge1xuICAgICAgICAgICAgbmV3RG93blBheW1lbnQgPSAwO1xuICAgICAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50UGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBzZXREb3duUGF5bWVudFBlcmNlbnQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0Rvd25QYXltZW50ICE9PSBkb3duUGF5bWVudCkge1xuICAgICAgICAgICAgc2V0RG93blBheW1lbnQobmV3RG93blBheW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0RG93blBheW1lbnQoKGRvd25QYXltZW50UGVyY2VudCAvIDEwMC4wKSAqIGhvbWVWYWx1ZSk7XG5cbiAgICAgICAgY29uc3QgbmV3TG9hbkFtb3VudCA9IGhvbWVWYWx1ZSAtIGRvd25QYXltZW50O1xuICAgICAgICBpZiAobmV3TG9hbkFtb3VudCAhPT0gbG9hbkFtb3VudCkge1xuICAgICAgICAgICAgc2V0TG9hbkFtb3VudChuZXdMb2FuQW1vdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld01vbnRobHlQYXltZW50ID0gY2FsY3VsYXRlTW9udGhseVBheW1lbnQoXG4gICAgICAgICAgICBuZXdMb2FuQW1vdW50LFxuICAgICAgICAgICAgaW50ZXJlc3RSYXRlLFxuICAgICAgICAgICAgbG9hblRlcm0sXG4gICAgICAgICAgICBQTUksXG4gICAgICAgICAgICBwcm9wZXJ0eVRheCxcbiAgICAgICAgICAgIGhvbWVJbnN1cmFuY2UsXG4gICAgICAgICAgICBtb250aGx5SE9BLFxuICAgICAgICAgICAgZG93blBheW1lbnRQZXJjZW50XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG5ld01vbnRobHlQYXltZW50ICE9PSBtb250aGx5UGF5bWVudCkge1xuICAgICAgICAgICAgc2V0TW9udGhseVBheW1lbnQobmV3TW9udGhseVBheW1lbnQpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBkb3duUGF5bWVudCxcbiAgICAgICAgZG93blBheW1lbnRQZXJjZW50LFxuICAgICAgICBob21lVmFsdWUsXG4gICAgICAgIGludGVyZXN0UmF0ZSxcbiAgICAgICAgbG9hblRlcm0sXG4gICAgICAgIHN0YXJ0RGF0ZU1vbnRoLFxuICAgICAgICBzdGFydERhdGVZZWFyLFxuICAgICAgICBwcm9wZXJ0eVRheCxcbiAgICAgICAgUE1JLFxuICAgICAgICBob21lSW5zdXJhbmNlLFxuICAgICAgICBtb250aGx5SE9BLFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgaWQ9XCJpbnB1dFwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtYWluLXNxdWFyZXMgcC0zIGp1c3RpZnktc2VsZi1lbmQgc2hhZG93LW5vbmVcIlxuICAgICAgICA+XG4gICAgICAgICAgICB7LyogPElucHV0XG4gICAgICAgICAgICAgICAgbGFiZWw9XCJIb21lIFZhbHVlXCJcbiAgICAgICAgICAgICAgICBzeW1ib2w9XCIkXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17aG9tZVZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SG9tZVZhbHVlKHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAvPiAqL31cbiAgICAgICAgICAgIDxTbGlkaW5nSW5wdXRcbiAgICAgICAgICAgICAgICBsYWJlbD1cIkhvbWUgVmFsdWVcIlxuICAgICAgICAgICAgICAgIHN5bWJvbD1cIiRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtob21lVmFsdWV9XG4gICAgICAgICAgICAgICAgbWF4PXsxMDAwMDAwfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SG9tZVZhbHVlKHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8U2xpZGluZ0lucHV0XG4gICAgICAgICAgICAgICAgbGFiZWw9XCJEb3duIFBheW1lbnRcIlxuICAgICAgICAgICAgICAgIHN5bWJvbD1cIiRcIlxuICAgICAgICAgICAgICAgIHNlY29uZFN5bWJvbD1cIiVcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtkb3duUGF5bWVudH1cbiAgICAgICAgICAgICAgICBzZWNvbmRWYWx1ZT17ZG93blBheW1lbnRQZXJjZW50fVxuICAgICAgICAgICAgICAgIHNwbGl0PXt0cnVlfVxuICAgICAgICAgICAgICAgIHN0ZXA9ezF9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rvd25QYXltZW50ID0gcGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldERvd25QYXltZW50KG5ld0Rvd25QYXltZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRG93blBheW1lbnRQZXJjZW50KG5ld0Rvd25QYXltZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmV3RG93blBheW1lbnQpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgc2Vjb25kT25DaGFuZ2U9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rvd25QYXltZW50UGVyY2VudCA9IHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXREb3duUGF5bWVudFBlcmNlbnQobmV3RG93blBheW1lbnRQZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRG93blBheW1lbnQobmV3RG93blBheW1lbnRQZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxJbnB1dCBsYWJlbD1cIkxvYW4gQW1vdW50XCIgc3ltYm9sPVwiJFwiIHZhbHVlPXtsb2FuQW1vdW50fSAvPlxuICAgICAgICAgICAgPFNsaWRpbmdJbnB1dFxuICAgICAgICAgICAgICAgIGxhYmVsPVwiSW50ZXJlc3QgUmF0ZVwiXG4gICAgICAgICAgICAgICAgc3ltYm9sPVwiJVwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e2ludGVyZXN0UmF0ZX1cbiAgICAgICAgICAgICAgICBtYXg9ezMwLjB9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnRlcmVzdFJhdGUocGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSkpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgIGxhYmVsPVwiTG9hbiBUZXJtXCJcbiAgICAgICAgICAgICAgICBzeW1ib2w9XCJ5ZWFyc1wiXG4gICAgICAgICAgICAgICAgdmFsdWU9e2xvYW5UZXJtfVxuICAgICAgICAgICAgICAgIGludmVydGVkPXt0cnVlfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0TG9hblRlcm0ocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8RGF0ZUlucHV0XG4gICAgICAgICAgICAgICAgbGFiZWw9XCJTdGFydCBEYXRlXCJcbiAgICAgICAgICAgICAgICBjdXJyZW50TW9udGg9e3N0YXJ0RGF0ZU1vbnRofVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlU2VsZWN0PXsoZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhcnREYXRlTW9udGgocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50WWVhcj17c3RhcnREYXRlWWVhcn1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZUlucHV0PXsoZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhcnREYXRlWWVhcihwYXJzZUludChlLnRhcmdldC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgIGxhYmVsPVwiUHJvcGVydHkgVGF4XCJcbiAgICAgICAgICAgICAgICBzeW1ib2w9XCIkL3llYXJcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtwcm9wZXJ0eVRheH1cbiAgICAgICAgICAgICAgICBpbnZlcnRlZD17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFByb3BlcnR5VGF4KHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPFNsaWRpbmdJbnB1dFxuICAgICAgICAgICAgICAgIGxhYmVsPVwiUE1JXCJcbiAgICAgICAgICAgICAgICBzeW1ib2w9XCIlXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17UE1JfVxuICAgICAgICAgICAgICAgIG1heD17MTAuMH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFBNSShwYXJzZUZsb2F0KGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgbGFiZWw9XCJIb21lIEluc3VyYW5jZVwiXG4gICAgICAgICAgICAgICAgc3ltYm9sPVwiJC95ZWFyXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17aG9tZUluc3VyYW5jZX1cbiAgICAgICAgICAgICAgICBpbnZlcnRlZD17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEhvbWVJbnN1cmFuY2UocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICBsYWJlbD1cIk1vbnRobHkgSE9BXCJcbiAgICAgICAgICAgICAgICBzeW1ib2w9XCIkXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bW9udGhseUhPQX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldE1vbnRobHlIT0EocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICBsYWJlbD1cIk1vbnRobHkgUGF5bWVudFwiXG4gICAgICAgICAgICAgICAgc3ltYm9sPVwiJFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e21vbnRobHlQYXltZW50fVxuICAgICAgICAgICAgICAgIHJvdW5kVG89ezJ9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRNb250aGx5UGF5bWVudChwYXJzZUludChlLnRhcmdldC52YWx1ZSkpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIklucHV0IiwiU2xpZGluZ0lucHV0IiwiRGF0ZUlucHV0IiwiY2FsY3VsYXRlTW9udGhseVBheW1lbnQiLCJJbnB1dENvbnRhaW5lciIsImhvbWVWYWx1ZSIsInNldEhvbWVWYWx1ZSIsImRvd25QYXltZW50Iiwic2V0RG93blBheW1lbnQiLCJkb3duUGF5bWVudFBlcmNlbnQiLCJzZXREb3duUGF5bWVudFBlcmNlbnQiLCJsb2FuQW1vdW50Iiwic2V0TG9hbkFtb3VudCIsImludGVyZXN0UmF0ZSIsInNldEludGVyZXN0UmF0ZSIsImxvYW5UZXJtIiwic2V0TG9hblRlcm0iLCJzdGFydERhdGVNb250aCIsInNldFN0YXJ0RGF0ZU1vbnRoIiwic3RhcnREYXRlWWVhciIsInNldFN0YXJ0RGF0ZVllYXIiLCJwcm9wZXJ0eVRheCIsInNldFByb3BlcnR5VGF4IiwiUE1JIiwic2V0UE1JIiwiaG9tZUluc3VyYW5jZSIsInNldEhvbWVJbnN1cmFuY2UiLCJtb250aGx5SE9BIiwic2V0TW9udGhseUhPQSIsIm1vbnRobHlQYXltZW50Iiwic2V0TW9udGhseVBheW1lbnQiLCJ1cGRhdGVEb3duUGF5bWVudFBlcmNlbnQiLCJuZXdEb3duUGF5bWVudCIsImNvbnNvbGUiLCJsb2ciLCJuZXdEb3duUGF5bWVudFBlcmNlbnQiLCJ1cGRhdGVEb3duUGF5bWVudCIsIm5ld0xvYW5BbW91bnQiLCJuZXdNb250aGx5UGF5bWVudCIsImRpdiIsImlkIiwiY2xhc3NOYW1lIiwibGFiZWwiLCJzeW1ib2wiLCJ2YWx1ZSIsIm1heCIsIm9uQ2hhbmdlIiwiZSIsInBhcnNlRmxvYXQiLCJ0YXJnZXQiLCJzZWNvbmRTeW1ib2wiLCJzZWNvbmRWYWx1ZSIsInNwbGl0Iiwic3RlcCIsInNlY29uZE9uQ2hhbmdlIiwiaW52ZXJ0ZWQiLCJwYXJzZUludCIsImN1cnJlbnRNb250aCIsIm9uQ2hhbmdlU2VsZWN0IiwiY3VycmVudFllYXIiLCJvbkNoYW5nZUlucHV0Iiwicm91bmRUbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/InputContainer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/MortgageDetailContainer.tsx":
/*!****************************************************!*\
  !*** ./app/components/MortgageDetailContainer.tsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MortgageDetailContainer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_Calculations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Calculations */ \"(app-pages-browser)/./app/utils/Calculations.tsx\");\n\n\n\nfunction MortgageDetailContainer(props) {\n    const { homeValue, loanAmount, startDateMonth, startDateYear, interestRate, loanTerm, propertyTax, PMI, homeInsurance, downPayment, downPaymentPercent, monthlyHOA } = props;\n    const hasPMI = loanAmount > homeValue * 0.8;\n    const PMILength = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calcPMILength)(homeValue, loanAmount, interestRate, loanTerm);\n    const totalInterest = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calculateTotalInterest)(loanAmount, interestRate, loanTerm);\n    const totalPMI = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calcTotalPMIPaid)(homeValue, loanAmount, PMI, interestRate, loanTerm);\n    const totalPropertyTax = loanTerm * propertyTax;\n    const totalHomeInsurance = loanTerm * (homeInsurance + monthlyHOA * 12);\n    const totalPayment = (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calculateTotalPayment)(props);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"mortgage-detail-container\",\n        className: \"main-squares justify-self-end\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-left bg-slate-50 border-b-2 p-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"text-2xl font-bold p-2\",\n                    children: \"Mortgage Details\"\n                }, void 0, false, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                    lineNumber: 74,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                lineNumber: 73,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-3\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                    className: \"w-full mortgage-detail-table\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"colgroup\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"col\", {\n                                    className: \"w-1/3\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 79,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"col\", {\n                                    className: \"w-1/3\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 80,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"col\", {\n                                    className: \"w-1/3\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 81,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Loan Amount:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 84,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: loanAmount.toLocaleString(\"en-US\", {\n                                        style: \"currency\",\n                                        currency: \"USD\"\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 85,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex bg-black\",\n                                                style: {\n                                                    width: loanAmount / totalPayment * 80\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 93,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"pl-1\",\n                                                children: [\n                                                    (loanAmount / totalPayment * 100).toFixed(2),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 99,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                        lineNumber: 92,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 83,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Down Payment:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 110,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: [\n                                        downPayment.toLocaleString(\"en-US\", {\n                                            style: \"currency\",\n                                            currency: \"USD\"\n                                        }),\n                                        \" \",\n                                        \"(\",\n                                        downPaymentPercent.toFixed(2),\n                                        \"%)\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 111,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex bg-black\",\n                                                style: {\n                                                    width: downPayment / totalPayment * 80\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 120,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"pl-1\",\n                                                children: [\n                                                    (downPayment / totalPayment * 100).toFixed(2),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 127,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                        lineNumber: 119,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 109,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Total Interest Paid:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 138,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: totalInterest.toLocaleString(\"en-US\", {\n                                        style: \"currency\",\n                                        currency: \"USD\"\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 139,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex bg-black\",\n                                                style: {\n                                                    width: totalInterest / totalPayment * 80\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 147,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"pl-1\",\n                                                children: [\n                                                    (totalInterest / totalPayment * 100).toFixed(2),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 154,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                        lineNumber: 146,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 145,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 137,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: [\n                                        \"Total PMI\",\n                                        hasPMI ? \" to \" + (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.PMIEndDate)(startDateMonth, startDateYear, PMILength) + \":\" : null\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 165,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: totalPMI.toLocaleString(\"en-US\", {\n                                        style: \"currency\",\n                                        currency: \"USD\"\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 177,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex bg-black\",\n                                                style: {\n                                                    width: totalPMI / totalPayment * 80\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 185,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"pl-1\",\n                                                children: [\n                                                    (totalPMI / totalPayment * 100).toFixed(2),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 191,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                        lineNumber: 184,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 183,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 164,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Total Tax Paid:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 201,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: totalPropertyTax.toLocaleString(\"en-US\", {\n                                        style: \"currency\",\n                                        currency: \"USD\"\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 202,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex bg-black\",\n                                                style: {\n                                                    width: totalPropertyTax / totalPayment * 80\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 210,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"pl-1\",\n                                                children: [\n                                                    (totalPropertyTax / totalPayment * 100).toFixed(2),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 218,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                        lineNumber: 209,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 208,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 200,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Total Home Insurance:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 229,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: totalHomeInsurance.toLocaleString(\"en-US\", {\n                                        style: \"currency\",\n                                        currency: \"USD\"\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 230,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex bg-black\",\n                                                style: {\n                                                    width: totalHomeInsurance / totalPayment * 80\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 238,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"pl-1\",\n                                                children: [\n                                                    (totalHomeInsurance / totalPayment * 100).toFixed(2),\n                                                    \"%\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                                lineNumber: 247,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                        lineNumber: 237,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 236,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 228,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                colSpan: 2,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {\n                                    className: \"my-5\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 259,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                lineNumber: 258,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 257,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: [\n                                        \"Total of \",\n                                        loanTerm * 12,\n                                        \" Payments:\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 263,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: totalPayment.toLocaleString(\"en-US\", {\n                                        style: \"currency\",\n                                        currency: \"USD\"\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 264,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 262,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: \"Loan pay-off date:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 272,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                    children: (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.loanEndDate)(startDateMonth, startDateYear, loanTerm)\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                                    lineNumber: 273,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                            lineNumber: 271,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                    lineNumber: 77,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n                lineNumber: 76,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/MortgageDetailContainer.tsx\",\n        lineNumber: 69,\n        columnNumber: 9\n    }, this);\n}\n_c = MortgageDetailContainer;\nvar _c;\n$RefreshReg$(_c, \"MortgageDetailContainer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL01vcnRnYWdlRGV0YWlsQ29udGFpbmVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEI7QUFTSztBQWtCaEIsU0FBU08sd0JBQXdCQyxLQUE2QjtJQUN6RSxNQUFNLEVBQ0ZDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxjQUFjLEVBQ2RDLGFBQWEsRUFDYkMsWUFBWSxFQUNaQyxRQUFRLEVBQ1JDLFdBQVcsRUFDWEMsR0FBRyxFQUNIQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsa0JBQWtCLEVBQ2xCQyxVQUFVLEVBQ2IsR0FBR1o7SUFFSixNQUFNYSxTQUFTWCxhQUFhRCxZQUFZO0lBQ3hDLE1BQU1hLFlBQVluQixrRUFBYUEsQ0FDM0JNLFdBQ0FDLFlBQ0FHLGNBQ0FDO0lBR0osTUFBTVMsZ0JBQWdCdEIsMkVBQXNCQSxDQUN4Q1MsWUFDQUcsY0FDQUM7SUFFSixNQUFNVSxXQUFXdEIscUVBQWdCQSxDQUM3Qk8sV0FDQUMsWUFDQU0sS0FDQUgsY0FDQUM7SUFFSixNQUFNVyxtQkFBbUJYLFdBQVdDO0lBQ3BDLE1BQU1XLHFCQUFxQlosV0FBWUcsQ0FBQUEsZ0JBQWdCRyxhQUFhLEVBQUM7SUFDckUsTUFBTU8sZUFBZXRCLDBFQUFxQkEsQ0FBQ0c7SUFFM0MscUJBQ0ksOERBQUNvQjtRQUNHQyxJQUFHO1FBQ0hDLFdBQVU7OzBCQUVWLDhEQUFDRjtnQkFBSUUsV0FBVTswQkFDWCw0RUFBQ0M7b0JBQUtELFdBQVU7OEJBQXlCOzs7Ozs7Ozs7OzswQkFFN0MsOERBQUNGO2dCQUFJRSxXQUFVOzBCQUNYLDRFQUFDRTtvQkFBTUYsV0FBVTs7c0NBQ2IsOERBQUNHOzs4Q0FDRyw4REFBQ0M7b0NBQUlKLFdBQVU7Ozs7Ozs4Q0FDZiw4REFBQ0k7b0NBQUlKLFdBQVU7Ozs7Ozs4Q0FDZiw4REFBQ0k7b0NBQUlKLFdBQVU7Ozs7Ozs7Ozs7OztzQ0FFbkIsOERBQUNLOzs4Q0FDRyw4REFBQ0M7OENBQUc7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b0NBQ2Q7Ozs7Ozs4Q0FFSiw4REFBQ0g7OENBQ0csNEVBQUNSO3dDQUFJRSxXQUFVOzswREFDWCw4REFBQ0Y7Z0RBQ0dFLFdBQVU7Z0RBQ1ZRLE9BQU87b0RBQ0hFLE9BQ0kscUJBQ0liLGVBQ0o7Z0RBQ1I7Ozs7OzswREFFSiw4REFBQ0M7Z0RBQUlFLFdBQVU7O29EQUVQLHNCQUFzQkgsZUFDdEIsR0FBRSxFQUNKYyxPQUFPLENBQUM7b0RBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0FNN0IsOERBQUNOO3NDQUNHLDRFQUFDQztnQ0FBR00sU0FBUzswQ0FDVCw0RUFBQ0M7b0NBQUdiLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBR3RCLDhEQUFDSzs7OENBQ0csOERBQUNDOzt3Q0FBRzt3Q0FBVXRCLFdBQVc7d0NBQUc7Ozs7Ozs7OENBQzVCLDhEQUFDc0I7OENBQ0lULGFBQWFVLGNBQWMsQ0FBQyxTQUFTO3dDQUNsQ0MsT0FBTzt3Q0FDUEMsVUFBVTtvQ0FDZDs7Ozs7Ozs7Ozs7O3NDQUdSLDhEQUFDSjs7OENBQ0csOERBQUNDOzhDQUFHOzs7Ozs7OENBQ0osOERBQUNBOzhDQUNJOUIsZ0VBQVdBLENBQ1JLLGdCQUNBQyxlQUNBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRaEM7S0FqUXdCUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9Nb3J0Z2FnZURldGFpbENvbnRhaW5lci50c3g/YTBjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlVG90YWxJbnRlcmVzdCxcbiAgICBjYWxjVG90YWxQTUlQYWlkLFxuICAgIGNhbGNQTUlMZW5ndGgsXG4gICAgUE1JRW5kRGF0ZSxcbiAgICBjYWxjdWxhdGVUb3RhbFBheW1lbnQsXG4gICAgbG9hbkVuZERhdGUsXG59IGZyb20gXCIuLi91dGlscy9DYWxjdWxhdGlvbnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNb3J0Z2FnZUNvbnRhaW5lclByb3BzIHtcbiAgICBob21lVmFsdWU6IG51bWJlcjtcbiAgICBsb2FuQW1vdW50OiBudW1iZXI7XG4gICAgc3RhcnREYXRlTW9udGg6IG51bWJlcjtcbiAgICBzdGFydERhdGVZZWFyOiBudW1iZXI7XG4gICAgaW50ZXJlc3RSYXRlOiBudW1iZXI7XG4gICAgbG9hblRlcm06IG51bWJlcjtcbiAgICBwcm9wZXJ0eVRheDogbnVtYmVyO1xuICAgIFBNSTogbnVtYmVyO1xuICAgIGhvbWVJbnN1cmFuY2U6IG51bWJlcjtcbiAgICBkb3duUGF5bWVudDogbnVtYmVyO1xuICAgIGRvd25QYXltZW50UGVyY2VudDogbnVtYmVyO1xuICAgIG1vbnRobHlIT0E6IG51bWJlcjtcbiAgICBQTUlMZW5ndGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vcnRnYWdlRGV0YWlsQ29udGFpbmVyKHByb3BzOiBNb3J0Z2FnZUNvbnRhaW5lclByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBob21lVmFsdWUsXG4gICAgICAgIGxvYW5BbW91bnQsXG4gICAgICAgIHN0YXJ0RGF0ZU1vbnRoLFxuICAgICAgICBzdGFydERhdGVZZWFyLFxuICAgICAgICBpbnRlcmVzdFJhdGUsXG4gICAgICAgIGxvYW5UZXJtLFxuICAgICAgICBwcm9wZXJ0eVRheCxcbiAgICAgICAgUE1JLFxuICAgICAgICBob21lSW5zdXJhbmNlLFxuICAgICAgICBkb3duUGF5bWVudCxcbiAgICAgICAgZG93blBheW1lbnRQZXJjZW50LFxuICAgICAgICBtb250aGx5SE9BLFxuICAgIH0gPSBwcm9wcztcblxuICAgIGNvbnN0IGhhc1BNSSA9IGxvYW5BbW91bnQgPiBob21lVmFsdWUgKiAwLjg7XG4gICAgY29uc3QgUE1JTGVuZ3RoID0gY2FsY1BNSUxlbmd0aChcbiAgICAgICAgaG9tZVZhbHVlLFxuICAgICAgICBsb2FuQW1vdW50LFxuICAgICAgICBpbnRlcmVzdFJhdGUsXG4gICAgICAgIGxvYW5UZXJtXG4gICAgKTtcblxuICAgIGNvbnN0IHRvdGFsSW50ZXJlc3QgPSBjYWxjdWxhdGVUb3RhbEludGVyZXN0KFxuICAgICAgICBsb2FuQW1vdW50LFxuICAgICAgICBpbnRlcmVzdFJhdGUsXG4gICAgICAgIGxvYW5UZXJtXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbFBNSSA9IGNhbGNUb3RhbFBNSVBhaWQoXG4gICAgICAgIGhvbWVWYWx1ZSxcbiAgICAgICAgbG9hbkFtb3VudCxcbiAgICAgICAgUE1JLFxuICAgICAgICBpbnRlcmVzdFJhdGUsXG4gICAgICAgIGxvYW5UZXJtXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbFByb3BlcnR5VGF4ID0gbG9hblRlcm0gKiBwcm9wZXJ0eVRheDtcbiAgICBjb25zdCB0b3RhbEhvbWVJbnN1cmFuY2UgPSBsb2FuVGVybSAqIChob21lSW5zdXJhbmNlICsgbW9udGhseUhPQSAqIDEyKTtcbiAgICBjb25zdCB0b3RhbFBheW1lbnQgPSBjYWxjdWxhdGVUb3RhbFBheW1lbnQocHJvcHMpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgaWQ9XCJtb3J0Z2FnZS1kZXRhaWwtY29udGFpbmVyXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1haW4tc3F1YXJlcyBqdXN0aWZ5LXNlbGYtZW5kXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWxlZnQgYmctc2xhdGUtNTAgYm9yZGVyLWItMiBwLTJcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgcC0yXCI+TW9ydGdhZ2UgRGV0YWlsczwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTNcIj5cbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwidy1mdWxsIG1vcnRnYWdlLWRldGFpbC10YWJsZVwiPlxuICAgICAgICAgICAgICAgICAgICA8Y29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29sIGNsYXNzTmFtZT1cInctMS8zXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2wgY2xhc3NOYW1lPVwidy0xLzNcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvbCBjbGFzc05hbWU9XCJ3LTEvM1wiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvY29sZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5Mb2FuIEFtb3VudDo8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsb2FuQW1vdW50LnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJjdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggYmctYmxhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogKGxvYW5BbW91bnQgLyB0b3RhbFBheW1lbnQpICogODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGwtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9hbkFtb3VudCAvIHRvdGFsUGF5bWVudCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5Eb3duIFBheW1lbnQ6PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZG93blBheW1lbnQudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoe2Rvd25QYXltZW50UGVyY2VudC50b0ZpeGVkKDIpfSUpXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4IGJnLWJsYWNrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb3duUGF5bWVudCAvIHRvdGFsUGF5bWVudCkgKiA4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwbC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb3duUGF5bWVudCAvIHRvdGFsUGF5bWVudCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5Ub3RhbCBJbnRlcmVzdCBQYWlkOjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RvdGFsSW50ZXJlc3QudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBiZy1ibGFja1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG90YWxJbnRlcmVzdCAvIHRvdGFsUGF5bWVudCkgKiA4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwbC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b3RhbEludGVyZXN0IC8gdG90YWxQYXltZW50KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnRvRml4ZWQoMil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvdGFsIFBNSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtoYXNQTUlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUE1JRW5kRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlTW9udGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZVllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBNSUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RvdGFsUE1JLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJjdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggYmctYmxhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogKHRvdGFsUE1JIC8gdG90YWxQYXltZW50KSAqIDgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBsLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsoKHRvdGFsUE1JIC8gdG90YWxQYXltZW50KSAqIDEwMCkudG9GaXhlZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5Ub3RhbCBUYXggUGFpZDo8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0b3RhbFByb3BlcnR5VGF4LnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJjdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggYmctYmxhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRvdGFsUHJvcGVydHlUYXggLyB0b3RhbFBheW1lbnQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGwtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG90YWxQcm9wZXJ0eVRheCAvIHRvdGFsUGF5bWVudCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50b0ZpeGVkKDIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5Ub3RhbCBIb21lIEluc3VyYW5jZTo8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0b3RhbEhvbWVJbnN1cmFuY2UudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBiZy1ibGFja1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG90YWxIb21lSW5zdXJhbmNlIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGF5bWVudCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwbC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b3RhbEhvbWVJbnN1cmFuY2UgLyB0b3RhbFBheW1lbnQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkudG9GaXhlZCgyKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sU3Bhbj17Mn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyIGNsYXNzTmFtZT1cIm15LTVcIj48L2hyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlRvdGFsIG9mIHtsb2FuVGVybSAqIDEyfSBQYXltZW50czo8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0b3RhbFBheW1lbnQudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPkxvYW4gcGF5LW9mZiBkYXRlOjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2xvYW5FbmREYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGVNb250aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlWWVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hblRlcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjYWxjdWxhdGVUb3RhbEludGVyZXN0IiwiY2FsY1RvdGFsUE1JUGFpZCIsImNhbGNQTUlMZW5ndGgiLCJQTUlFbmREYXRlIiwiY2FsY3VsYXRlVG90YWxQYXltZW50IiwibG9hbkVuZERhdGUiLCJNb3J0Z2FnZURldGFpbENvbnRhaW5lciIsInByb3BzIiwiaG9tZVZhbHVlIiwibG9hbkFtb3VudCIsInN0YXJ0RGF0ZU1vbnRoIiwic3RhcnREYXRlWWVhciIsImludGVyZXN0UmF0ZSIsImxvYW5UZXJtIiwicHJvcGVydHlUYXgiLCJQTUkiLCJob21lSW5zdXJhbmNlIiwiZG93blBheW1lbnQiLCJkb3duUGF5bWVudFBlcmNlbnQiLCJtb250aGx5SE9BIiwiaGFzUE1JIiwiUE1JTGVuZ3RoIiwidG90YWxJbnRlcmVzdCIsInRvdGFsUE1JIiwidG90YWxQcm9wZXJ0eVRheCIsInRvdGFsSG9tZUluc3VyYW5jZSIsInRvdGFsUGF5bWVudCIsImRpdiIsImlkIiwiY2xhc3NOYW1lIiwic3BhbiIsInRhYmxlIiwiY29sZ3JvdXAiLCJjb2wiLCJ0ciIsInRkIiwidG9Mb2NhbGVTdHJpbmciLCJzdHlsZSIsImN1cnJlbmN5Iiwid2lkdGgiLCJ0b0ZpeGVkIiwiY29sU3BhbiIsImhyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/MortgageDetailContainer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/SlidingInput.tsx":
/*!*****************************************!*\
  !*** ./app/components/SlidingInput.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SlidingInput; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\n\nfunction SlidingInput(param) {\n    let { label, symbol, secondSymbol, value, secondValue, split, min, max, step, onChange, secondOnChange } = param;\n    _s();\n    const [onFocusOne, setOnFocusOne] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [onFocusTwo, setOnFocusTwo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [localValue, setLocalValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(value);\n    const [secondLocalValue, setSecondLocalValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(secondValue);\n    var _ref;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex justify-between m-1 mb-5\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"grow max-w-[25%] text-left\",\n                    children: [\n                        label,\n                        \":\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                    lineNumber: 40,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grow max-w-[73%] border border-gray-300 m-1 rounded-md\",\n                    children: [\n                        split ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex border rounded-md\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"bg-gray-200 px-2 rounded-l-md border-r-[1px] border-gray-300\",\n                                    children: symbol\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                    lineNumber: 44,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    className: \"pl-2 grow w-[calc(100%-40%)]\",\n                                    type: \"number\",\n                                    value: onFocusOne ? localValue : value.toFixed(2),\n                                    onChange: (e)=>{\n                                        onChange === null || onChange === void 0 ? void 0 : onChange(e);\n                                        setLocalValue(parseFloat(e.target.value));\n                                    },\n                                    onFocus: ()=>{\n                                        setOnFocusOne(true);\n                                        var _value_toFixed;\n                                        setLocalValue(parseFloat(((_value_toFixed = value === null || value === void 0 ? void 0 : value.toFixed(2)) !== null && _value_toFixed !== void 0 ? _value_toFixed : 0).toString()));\n                                    },\n                                    onBlur: ()=>{\n                                        setOnFocusOne(false);\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                    lineNumber: 47,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex justify-between\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                            className: \"mx-[2px] pl-2 border-l-[1px] border-gray-300 grow w-[calc(100%-40%)]\",\n                                            type: \"number\",\n                                            value: (_ref = onFocusTwo ? secondLocalValue : secondValue === null || secondValue === void 0 ? void 0 : secondValue.toFixed(2)) !== null && _ref !== void 0 ? _ref : 0,\n                                            onChange: (e)=>{\n                                                secondOnChange === null || secondOnChange === void 0 ? void 0 : secondOnChange(e);\n                                                setSecondLocalValue(parseFloat(e.target.value));\n                                            },\n                                            onFocus: ()=>{\n                                                setOnFocusTwo(true);\n                                                var _secondValue_toFixed;\n                                                setSecondLocalValue(parseFloat(((_secondValue_toFixed = secondValue === null || secondValue === void 0 ? void 0 : secondValue.toFixed(2)) !== null && _secondValue_toFixed !== void 0 ? _secondValue_toFixed : 0).toString()));\n                                            },\n                                            onBlur: ()=>{\n                                                setOnFocusTwo(false);\n                                            }\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                            lineNumber: 70,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"bg-gray-200 px-2 rounded-r-md border-l-[1px] border-gray-300\",\n                                            children: secondSymbol\n                                        }, void 0, false, {\n                                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                            lineNumber: 98,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                    lineNumber: 69,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                            lineNumber: 43,\n                            columnNumber: 25\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-between border rounded-md\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    className: \"mx-[2px] pl-2 border-gray-300 grow rounded-md w-[calc(100%-40%)]\",\n                                    type: \"number\",\n                                    value: onFocusOne ? localValue : value.toFixed(2),\n                                    onChange: (e)=>{\n                                        onChange === null || onChange === void 0 ? void 0 : onChange(e);\n                                        setLocalValue(parseFloat(e.target.value));\n                                    },\n                                    onFocus: ()=>{\n                                        setOnFocusOne(true);\n                                        var _value_toFixed;\n                                        setLocalValue(parseFloat(((_value_toFixed = value === null || value === void 0 ? void 0 : value.toFixed(2)) !== null && _value_toFixed !== void 0 ? _value_toFixed : 0).toString()));\n                                    },\n                                    onBlur: ()=>{\n                                        setOnFocusOne(false);\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                    lineNumber: 105,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"bg-gray-200 px-2 rounded-r-md border-l-[1px] border-gray-300\",\n                                    children: symbol\n                                }, void 0, false, {\n                                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                    lineNumber: 127,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                            lineNumber: 104,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex p-2\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                className: \"grow w-full\",\n                                type: \"range\",\n                                min: min !== null && min !== void 0 ? min : 0,\n                                max: max !== null && max !== void 0 ? max : 100,\n                                step: step !== null && step !== void 0 ? step : 0.1,\n                                value: secondValue !== null && secondValue !== void 0 ? secondValue : value,\n                                onChange: split ? secondOnChange : onChange\n                            }, void 0, false, {\n                                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                                lineNumber: 133,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                            lineNumber: 132,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n                    lineNumber: 41,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n            lineNumber: 39,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/components/SlidingInput.tsx\",\n        lineNumber: 38,\n        columnNumber: 9\n    }, this);\n}\n_s(SlidingInput, \"ZTY3JyA/kkdGeueL+Qb/rVgWbEQ=\");\n_c = SlidingInput;\nvar _c;\n$RefreshReg$(_c, \"SlidingInput\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1NsaWRpbmdJbnB1dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBCO0FBQ087QUFpQmxCLFNBQVNFLGFBQWEsS0FZakI7UUFaaUIsRUFDakNDLEtBQUssRUFDTEMsTUFBTSxFQUNOQyxZQUFZLEVBQ1pDLEtBQUssRUFDTEMsV0FBVyxFQUNYQyxLQUFLLEVBQ0xDLEdBQUcsRUFDSEMsR0FBRyxFQUNIQyxJQUFJLEVBQ0pDLFFBQVEsRUFDUkMsY0FBYyxFQUNFLEdBWmlCOztJQWFqQyxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR2QsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDZSxZQUFZQyxjQUFjLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUNpQixZQUFZQyxjQUFjLEdBQUdsQiwrQ0FBUUEsQ0FBQ0s7SUFDN0MsTUFBTSxDQUFDYyxrQkFBa0JDLG9CQUFvQixHQUFHcEIsK0NBQVFBLENBQUNNO1FBdUNwQlM7SUFyQ3JDLHFCQUNJLDhEQUFDTTtrQkFDRyw0RUFBQ0E7WUFBSUMsV0FBVTs7OEJBQ1gsOERBQUNDO29CQUFHRCxXQUFVOzt3QkFBOEJwQjt3QkFBTTs7Ozs7Ozs4QkFDbEQsOERBQUNtQjtvQkFBSUMsV0FBVTs7d0JBQ1ZmLHNCQUNHLDhEQUFDYzs0QkFBSUMsV0FBVTs7OENBQ1gsOERBQUNEO29DQUFJQyxXQUFVOzhDQUNWbkI7Ozs7Ozs4Q0FFTCw4REFBQ3FCO29DQUNHRixXQUFVO29DQUNWRyxNQUFLO29DQUNMcEIsT0FDSVEsYUFBYUksYUFBYVosTUFBTXFCLE9BQU8sQ0FBQztvQ0FFNUNmLFVBQVUsQ0FBQ2dCO3dDQUNQaEIscUJBQUFBLCtCQUFBQSxTQUFXZ0I7d0NBQ1hULGNBQWNVLFdBQVdELEVBQUVFLE1BQU0sQ0FBQ3hCLEtBQUs7b0NBQzNDO29DQUNBeUIsU0FBUzt3Q0FDTGhCLGNBQWM7NENBR0xUO3dDQUZUYSxjQUNJVSxXQUNJLENBQUN2QixDQUFBQSxpQkFBQUEsa0JBQUFBLDRCQUFBQSxNQUFPcUIsT0FBTyxDQUFDLGdCQUFmckIsNEJBQUFBLGlCQUFxQixHQUFHMEIsUUFBUTtvQ0FHN0M7b0NBQ0FDLFFBQVE7d0NBQ0psQixjQUFjO29DQUNsQjs7Ozs7OzhDQUVKLDhEQUFDTztvQ0FBSUMsV0FBVTs7c0RBQ1gsOERBQUNFOzRDQUNHRixXQUFVOzRDQUNWRyxNQUFLOzRDQUNMcEIsT0FDSSxDQUFDVSxPQUFBQSxhQUNLSSxtQkFDQWIsd0JBQUFBLGtDQUFBQSxZQUFhb0IsT0FBTyxDQUFDLGdCQUYxQlgsa0JBQUFBLE9BRWlDOzRDQUV0Q0osVUFBVSxDQUFDZ0I7Z0RBQ1BmLDJCQUFBQSxxQ0FBQUEsZUFBaUJlO2dEQUNqQlAsb0JBQ0lRLFdBQVdELEVBQUVFLE1BQU0sQ0FBQ3hCLEtBQUs7NENBRWpDOzRDQUNBeUIsU0FBUztnREFDTGQsY0FBYztvREFJRlY7Z0RBSFpjLG9CQUNJUSxXQUNJLENBQ0l0QixDQUFBQSx1QkFBQUEsd0JBQUFBLGtDQUFBQSxZQUFhb0IsT0FBTyxDQUFDLGdCQUFyQnBCLGtDQUFBQSx1QkFBMkIsR0FDN0J5QixRQUFROzRDQUd0Qjs0Q0FDQUMsUUFBUTtnREFDSmhCLGNBQWM7NENBQ2xCOzs7Ozs7c0RBRUosOERBQUNLOzRDQUFJQyxXQUFVO3NEQUNWbEI7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQUtiLDhEQUFDaUI7NEJBQUlDLFdBQVU7OzhDQUNYLDhEQUFDRTtvQ0FDR0YsV0FBVTtvQ0FDVkcsTUFBSztvQ0FDTHBCLE9BQ0lRLGFBQWFJLGFBQWFaLE1BQU1xQixPQUFPLENBQUM7b0NBRTVDZixVQUFVLENBQUNnQjt3Q0FDUGhCLHFCQUFBQSwrQkFBQUEsU0FBV2dCO3dDQUNYVCxjQUFjVSxXQUFXRCxFQUFFRSxNQUFNLENBQUN4QixLQUFLO29DQUMzQztvQ0FDQXlCLFNBQVM7d0NBQ0xoQixjQUFjOzRDQUdMVDt3Q0FGVGEsY0FDSVUsV0FDSSxDQUFDdkIsQ0FBQUEsaUJBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT3FCLE9BQU8sQ0FBQyxnQkFBZnJCLDRCQUFBQSxpQkFBcUIsR0FBRzBCLFFBQVE7b0NBRzdDO29DQUNBQyxRQUFRO3dDQUNKbEIsY0FBYztvQ0FDbEI7Ozs7Ozs4Q0FFSiw4REFBQ087b0NBQUlDLFdBQVU7OENBQ1ZuQjs7Ozs7Ozs7Ozs7O3NDQUliLDhEQUFDa0I7NEJBQUlDLFdBQVU7c0NBQ1gsNEVBQUNFO2dDQUNHRixXQUFVO2dDQUNWRyxNQUFLO2dDQUNMakIsS0FBS0EsZ0JBQUFBLGlCQUFBQSxNQUFPO2dDQUNaQyxLQUFLQSxnQkFBQUEsaUJBQUFBLE1BQU87Z0NBQ1pDLE1BQU1BLGlCQUFBQSxrQkFBQUEsT0FBUTtnQ0FDZEwsT0FBT0Msd0JBQUFBLHlCQUFBQSxjQUFlRDtnQ0FDdEJNLFVBQVVKLFFBQVFLLGlCQUFpQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPL0Q7R0FoSXdCVjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9TbGlkaW5nSW5wdXQudHN4PzZiZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIFNsaWRpbmdJbnB1dFByb3BzIHtcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIHNlY29uZFN5bWJvbD86IHN0cmluZztcbiAgICB2YWx1ZTogbnVtYmVyO1xuICAgIHNlY29uZFZhbHVlPzogbnVtYmVyO1xuICAgIHNwbGl0PzogYm9vbGVhbjtcbiAgICBtaW4/OiBudW1iZXI7XG4gICAgbWF4PzogbnVtYmVyO1xuICAgIHN0ZXA/OiBudW1iZXI7XG4gICAgb25DaGFuZ2U/OiAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHZvaWQ7XG4gICAgc2Vjb25kT25DaGFuZ2U/OiAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHZvaWQ7XG4gICAgdGhpcmRPbkNoYW5nZT86IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2xpZGluZ0lucHV0KHtcbiAgICBsYWJlbCxcbiAgICBzeW1ib2wsXG4gICAgc2Vjb25kU3ltYm9sLFxuICAgIHZhbHVlLFxuICAgIHNlY29uZFZhbHVlLFxuICAgIHNwbGl0LFxuICAgIG1pbixcbiAgICBtYXgsXG4gICAgc3RlcCxcbiAgICBvbkNoYW5nZSxcbiAgICBzZWNvbmRPbkNoYW5nZSxcbn06IFNsaWRpbmdJbnB1dFByb3BzKSB7XG4gICAgY29uc3QgW29uRm9jdXNPbmUsIHNldE9uRm9jdXNPbmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtvbkZvY3VzVHdvLCBzZXRPbkZvY3VzVHdvXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbG9jYWxWYWx1ZSwgc2V0TG9jYWxWYWx1ZV0gPSB1c2VTdGF0ZSh2YWx1ZSk7XG4gICAgY29uc3QgW3NlY29uZExvY2FsVmFsdWUsIHNldFNlY29uZExvY2FsVmFsdWVdID0gdXNlU3RhdGUoc2Vjb25kVmFsdWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gbS0xIG1iLTVcIj5cbiAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwiZ3JvdyBtYXgtdy1bMjUlXSB0ZXh0LWxlZnRcIj57bGFiZWx9OjwvaDI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncm93IG1heC13LVs3MyVdIGJvcmRlciBib3JkZXItZ3JheS0zMDAgbS0xIHJvdW5kZWQtbWRcIj5cbiAgICAgICAgICAgICAgICAgICAge3NwbGl0ID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGJvcmRlciByb3VuZGVkLW1kXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTIwMCBweC0yIHJvdW5kZWQtbC1tZCBib3JkZXItci1bMXB4XSBib3JkZXItZ3JheS0zMDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N5bWJvbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicGwtMiBncm93IHctW2NhbGMoMTAwJS00MCUpXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzT25lID8gbG9jYWxWYWx1ZSA6IHZhbHVlLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPy4oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRMb2NhbFZhbHVlKHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Gb2N1cz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T25Gb2N1c09uZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldExvY2FsVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlPy50b0ZpeGVkKDIpID8/IDApLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkJsdXI9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE9uRm9jdXNPbmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm14LVsycHhdIHBsLTIgYm9yZGVyLWwtWzFweF0gYm9yZGVyLWdyYXktMzAwIGdyb3cgdy1bY2FsYygxMDAlLTQwJSldXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkZvY3VzVHdvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2Vjb25kTG9jYWxWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlY29uZFZhbHVlPy50b0ZpeGVkKDIpKSA/PyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRPbkNoYW5nZT8uKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlY29uZExvY2FsVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T25Gb2N1c1R3byh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWNvbmRMb2NhbFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFZhbHVlPy50b0ZpeGVkKDIpID8/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkJsdXI9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRPbkZvY3VzVHdvKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS0yMDAgcHgtMiByb3VuZGVkLXItbWQgYm9yZGVyLWwtWzFweF0gYm9yZGVyLWdyYXktMzAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2Vjb25kU3ltYm9sfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBib3JkZXIgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteC1bMnB4XSBwbC0yIGJvcmRlci1ncmF5LTMwMCBncm93IHJvdW5kZWQtbWQgdy1bY2FsYygxMDAlLTQwJSldXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRm9jdXNPbmUgPyBsb2NhbFZhbHVlIDogdmFsdWUudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U/LihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldExvY2FsVmFsdWUocGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRPbkZvY3VzT25lKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TG9jYWxWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsdWU/LnRvRml4ZWQoMikgPz8gMCkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQmx1cj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T25Gb2N1c09uZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktMjAwIHB4LTIgcm91bmRlZC1yLW1kIGJvcmRlci1sLVsxcHhdIGJvcmRlci1ncmF5LTMwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3ltYm9sfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdyb3cgdy1mdWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbj17bWluID8/IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXttYXggPz8gMTAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9e3N0ZXAgPz8gMC4xfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWNvbmRWYWx1ZSA/PyB2YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c3BsaXQgPyBzZWNvbmRPbkNoYW5nZSA6IG9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwiU2xpZGluZ0lucHV0IiwibGFiZWwiLCJzeW1ib2wiLCJzZWNvbmRTeW1ib2wiLCJ2YWx1ZSIsInNlY29uZFZhbHVlIiwic3BsaXQiLCJtaW4iLCJtYXgiLCJzdGVwIiwib25DaGFuZ2UiLCJzZWNvbmRPbkNoYW5nZSIsIm9uRm9jdXNPbmUiLCJzZXRPbkZvY3VzT25lIiwib25Gb2N1c1R3byIsInNldE9uRm9jdXNUd28iLCJsb2NhbFZhbHVlIiwic2V0TG9jYWxWYWx1ZSIsInNlY29uZExvY2FsVmFsdWUiLCJzZXRTZWNvbmRMb2NhbFZhbHVlIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJpbnB1dCIsInR5cGUiLCJ0b0ZpeGVkIiwiZSIsInBhcnNlRmxvYXQiLCJ0YXJnZXQiLCJvbkZvY3VzIiwidG9TdHJpbmciLCJvbkJsdXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/SlidingInput.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_Calculations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/Calculations */ \"(app-pages-browser)/./app/utils/Calculations.tsx\");\n/* harmony import */ var _components_InputContainer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/InputContainer */ \"(app-pages-browser)/./app/components/InputContainer.tsx\");\n/* harmony import */ var _components_GraphContainer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/GraphContainer */ \"(app-pages-browser)/./app/components/GraphContainer.tsx\");\n/* harmony import */ var _components_MortgageDetailContainer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/MortgageDetailContainer */ \"(app-pages-browser)/./app/components/MortgageDetailContainer.tsx\");\n/* harmony import */ var _components_BiWeeklyContainer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/BiWeeklyContainer */ \"(app-pages-browser)/./app/components/BiWeeklyContainer.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction Home() {\n    _s();\n    const [homeValue, setHomeValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(300000);\n    const [downPayment, setDownPayment] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(50000);\n    const [downPaymentPercent, setDownPaymentPercent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(downPayment / homeValue * 100);\n    const [loanAmount, setLoanAmount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(homeValue - downPayment);\n    const [interestRate, setInterestRate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(4.0);\n    const [loanTerm, setLoanTerm] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(30);\n    const [startDateMonth, setStartDateMonth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [startDateYear, setStartDateYear] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(2024);\n    const [propertyTax, setPropertyTax] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(2400);\n    const [PMI, setPMI] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1.0);\n    const [homeInsurance, setHomeInsurance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1000);\n    const [monthlyHOA, setMonthlyHOA] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [monthlyPayment, setMonthlyPayment] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"page\",\n        className: \"flex flex-col justify-center text-black\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"text-center p-10 text-7xl\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"font-bold\",\n                    children: \"Mortgage Calculator\"\n                }, void 0, false, {\n                    fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                    lineNumber: 36,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                lineNumber: 35,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"outter-container\",\n                className: \"grid sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-2 text-xs gap-5 justify-items-center ml-[10dvw]\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_InputContainer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        homeValue: homeValue,\n                        setHomeValue: setHomeValue,\n                        downPayment: downPayment,\n                        setDownPayment: setDownPayment,\n                        downPaymentPercent: downPaymentPercent,\n                        setDownPaymentPercent: setDownPaymentPercent,\n                        loanAmount: loanAmount,\n                        setLoanAmount: setLoanAmount,\n                        interestRate: interestRate,\n                        setInterestRate: setInterestRate,\n                        loanTerm: loanTerm,\n                        setLoanTerm: setLoanTerm,\n                        startDateMonth: startDateMonth,\n                        setStartDateMonth: setStartDateMonth,\n                        startDateYear: startDateYear,\n                        setStartDateYear: setStartDateYear,\n                        propertyTax: propertyTax,\n                        setPropertyTax: setPropertyTax,\n                        PMI: PMI,\n                        setPMI: setPMI,\n                        homeInsurance: homeInsurance,\n                        setHomeInsurance: setHomeInsurance,\n                        monthlyHOA: monthlyHOA,\n                        setMonthlyHOA: setMonthlyHOA,\n                        monthlyPayment: monthlyPayment,\n                        setMonthlyPayment: setMonthlyPayment\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                        lineNumber: 43,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_GraphContainer__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        homeValue: homeValue,\n                        loanAmount: loanAmount,\n                        interestRate: interestRate,\n                        loanTerm: loanTerm,\n                        startDateMonth: startDateMonth,\n                        startDateYear: startDateYear,\n                        propertyTax: propertyTax,\n                        PMI: PMI,\n                        homeInsurance: homeInsurance,\n                        monthlyHOA: monthlyHOA,\n                        downPayment: downPayment,\n                        monthlyPayment: monthlyPayment\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                        lineNumber: 72,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_MortgageDetailContainer__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        homeValue: homeValue,\n                        loanAmount: loanAmount,\n                        interestRate: interestRate,\n                        loanTerm: loanTerm,\n                        startDateMonth: startDateMonth,\n                        startDateYear: startDateYear,\n                        propertyTax: propertyTax,\n                        PMI: PMI,\n                        homeInsurance: homeInsurance,\n                        downPayment: downPayment,\n                        downPaymentPercent: downPaymentPercent,\n                        monthlyHOA: monthlyHOA\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                        lineNumber: 87,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_BiWeeklyContainer__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                        monthlyPayment: monthlyPayment - (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calcPMI)(loanAmount, PMI),\n                        monthlyPayOffDate: (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.loanEndDate)(startDateMonth, startDateYear, loanTerm),\n                        totalInterest: (0,_utils_Calculations__WEBPACK_IMPORTED_MODULE_2__.calculateTotalInterest)(loanAmount, interestRate, loanTerm)\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                        lineNumber: 102,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                        lineNumber: 116,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"h-dvh\"\n                    }, void 0, false, {\n                        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                        lineNumber: 117,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n                lineNumber: 39,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/estevaolordeiro/GitHub/mortgage-calculator/app/page.tsx\",\n        lineNumber: 34,\n        columnNumber: 9\n    }, this);\n}\n_s(Home, \"qaFE0VLn/ZrpW4WOov34glaJPP8=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBV0EsQ0FDMUJvQixnQkFDQUUsZUFDQUo7d0JBRUpzQixlQUFldkMsMkVBQXNCQSxDQUNqQ2EsWUFDQUUsY0FDQUU7Ozs7OztrQ0FJUiw4REFBQ2dCOzs7OztrQ0FDRCw4REFBQ0E7d0JBQUlFLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUkvQjtHQXpHd0I3QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBsb2FuRW5kRGF0ZSxcbiAgICBjYWxjdWxhdGVUb3RhbEludGVyZXN0LFxuICAgIGNhbGNQTUksXG59IGZyb20gXCIuL3V0aWxzL0NhbGN1bGF0aW9uc1wiO1xuaW1wb3J0IElucHV0Q29udGFpbmVyIGZyb20gXCIuL2NvbXBvbmVudHMvSW5wdXRDb250YWluZXJcIjtcbmltcG9ydCBHcmFwaENvbnRhaW5lciBmcm9tIFwiLi9jb21wb25lbnRzL0dyYXBoQ29udGFpbmVyXCI7XG5pbXBvcnQgTW9ydGdhZ2VEZXRhaWxDb250YWluZXIgZnJvbSBcIi4vY29tcG9uZW50cy9Nb3J0Z2FnZURldGFpbENvbnRhaW5lclwiO1xuaW1wb3J0IEJpV2Vla2x5Q29udGFpbmVyIGZyb20gXCIuL2NvbXBvbmVudHMvQmlXZWVrbHlDb250YWluZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgICBjb25zdCBbaG9tZVZhbHVlLCBzZXRIb21lVmFsdWVdID0gdXNlU3RhdGUoMzAwMDAwKTtcbiAgICBjb25zdCBbZG93blBheW1lbnQsIHNldERvd25QYXltZW50XSA9IHVzZVN0YXRlKDUwMDAwKTtcbiAgICBjb25zdCBbZG93blBheW1lbnRQZXJjZW50LCBzZXREb3duUGF5bWVudFBlcmNlbnRdID0gdXNlU3RhdGUoXG4gICAgICAgIChkb3duUGF5bWVudCAvIGhvbWVWYWx1ZSkgKiAxMDBcbiAgICApO1xuICAgIGNvbnN0IFtsb2FuQW1vdW50LCBzZXRMb2FuQW1vdW50XSA9IHVzZVN0YXRlKGhvbWVWYWx1ZSAtIGRvd25QYXltZW50KTtcbiAgICBjb25zdCBbaW50ZXJlc3RSYXRlLCBzZXRJbnRlcmVzdFJhdGVdID0gdXNlU3RhdGUoNC4wKTtcbiAgICBjb25zdCBbbG9hblRlcm0sIHNldExvYW5UZXJtXSA9IHVzZVN0YXRlKDMwKTtcbiAgICBjb25zdCBbc3RhcnREYXRlTW9udGgsIHNldFN0YXJ0RGF0ZU1vbnRoXSA9IHVzZVN0YXRlKDEpO1xuICAgIGNvbnN0IFtzdGFydERhdGVZZWFyLCBzZXRTdGFydERhdGVZZWFyXSA9IHVzZVN0YXRlKDIwMjQpO1xuICAgIGNvbnN0IFtwcm9wZXJ0eVRheCwgc2V0UHJvcGVydHlUYXhdID0gdXNlU3RhdGUoMjQwMCk7XG4gICAgY29uc3QgW1BNSSwgc2V0UE1JXSA9IHVzZVN0YXRlKDEuMCk7XG4gICAgY29uc3QgW2hvbWVJbnN1cmFuY2UsIHNldEhvbWVJbnN1cmFuY2VdID0gdXNlU3RhdGUoMTAwMCk7XG4gICAgY29uc3QgW21vbnRobHlIT0EsIHNldE1vbnRobHlIT0FdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW21vbnRobHlQYXltZW50LCBzZXRNb250aGx5UGF5bWVudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgaWQ9XCJwYWdlXCIgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlciB0ZXh0LWJsYWNrXCI+XG4gICAgICAgICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHAtMTAgdGV4dC03eGxcIj5cbiAgICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwiZm9udC1ib2xkXCI+TW9ydGdhZ2UgQ2FsY3VsYXRvcjwvaDE+XG4gICAgICAgICAgICA8L2hlYWRlcj5cblxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGlkPVwib3V0dGVyLWNvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ3JpZCBzbTpncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMSBsZzpncmlkLWNvbHMtMiB0ZXh0LXhzIGdhcC01IGp1c3RpZnktaXRlbXMtY2VudGVyIG1sLVsxMGR2d11cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxJbnB1dENvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBob21lVmFsdWU9e2hvbWVWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgc2V0SG9tZVZhbHVlPXtzZXRIb21lVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGRvd25QYXltZW50PXtkb3duUGF5bWVudH1cbiAgICAgICAgICAgICAgICAgICAgc2V0RG93blBheW1lbnQ9e3NldERvd25QYXltZW50fVxuICAgICAgICAgICAgICAgICAgICBkb3duUGF5bWVudFBlcmNlbnQ9e2Rvd25QYXltZW50UGVyY2VudH1cbiAgICAgICAgICAgICAgICAgICAgc2V0RG93blBheW1lbnRQZXJjZW50PXtzZXREb3duUGF5bWVudFBlcmNlbnR9XG4gICAgICAgICAgICAgICAgICAgIGxvYW5BbW91bnQ9e2xvYW5BbW91bnR9XG4gICAgICAgICAgICAgICAgICAgIHNldExvYW5BbW91bnQ9e3NldExvYW5BbW91bnR9XG4gICAgICAgICAgICAgICAgICAgIGludGVyZXN0UmF0ZT17aW50ZXJlc3RSYXRlfVxuICAgICAgICAgICAgICAgICAgICBzZXRJbnRlcmVzdFJhdGU9e3NldEludGVyZXN0UmF0ZX1cbiAgICAgICAgICAgICAgICAgICAgbG9hblRlcm09e2xvYW5UZXJtfVxuICAgICAgICAgICAgICAgICAgICBzZXRMb2FuVGVybT17c2V0TG9hblRlcm19XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZU1vbnRoPXtzdGFydERhdGVNb250aH1cbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhcnREYXRlTW9udGg9e3NldFN0YXJ0RGF0ZU1vbnRofVxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGVZZWFyPXtzdGFydERhdGVZZWFyfVxuICAgICAgICAgICAgICAgICAgICBzZXRTdGFydERhdGVZZWFyPXtzZXRTdGFydERhdGVZZWFyfVxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVRheD17cHJvcGVydHlUYXh9XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3BlcnR5VGF4PXtzZXRQcm9wZXJ0eVRheH1cbiAgICAgICAgICAgICAgICAgICAgUE1JPXtQTUl9XG4gICAgICAgICAgICAgICAgICAgIHNldFBNST17c2V0UE1JfVxuICAgICAgICAgICAgICAgICAgICBob21lSW5zdXJhbmNlPXtob21lSW5zdXJhbmNlfVxuICAgICAgICAgICAgICAgICAgICBzZXRIb21lSW5zdXJhbmNlPXtzZXRIb21lSW5zdXJhbmNlfVxuICAgICAgICAgICAgICAgICAgICBtb250aGx5SE9BPXttb250aGx5SE9BfVxuICAgICAgICAgICAgICAgICAgICBzZXRNb250aGx5SE9BPXtzZXRNb250aGx5SE9BfVxuICAgICAgICAgICAgICAgICAgICBtb250aGx5UGF5bWVudD17bW9udGhseVBheW1lbnR9XG4gICAgICAgICAgICAgICAgICAgIHNldE1vbnRobHlQYXltZW50PXtzZXRNb250aGx5UGF5bWVudH1cbiAgICAgICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICAgICAgPEdyYXBoQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIGhvbWVWYWx1ZT17aG9tZVZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBsb2FuQW1vdW50PXtsb2FuQW1vdW50fVxuICAgICAgICAgICAgICAgICAgICBpbnRlcmVzdFJhdGU9e2ludGVyZXN0UmF0ZX1cbiAgICAgICAgICAgICAgICAgICAgbG9hblRlcm09e2xvYW5UZXJtfVxuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGVNb250aD17c3RhcnREYXRlTW9udGh9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZVllYXI9e3N0YXJ0RGF0ZVllYXJ9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VGF4PXtwcm9wZXJ0eVRheH1cbiAgICAgICAgICAgICAgICAgICAgUE1JPXtQTUl9XG4gICAgICAgICAgICAgICAgICAgIGhvbWVJbnN1cmFuY2U9e2hvbWVJbnN1cmFuY2V9XG4gICAgICAgICAgICAgICAgICAgIG1vbnRobHlIT0E9e21vbnRobHlIT0F9XG4gICAgICAgICAgICAgICAgICAgIGRvd25QYXltZW50PXtkb3duUGF5bWVudH1cbiAgICAgICAgICAgICAgICAgICAgbW9udGhseVBheW1lbnQ9e21vbnRobHlQYXltZW50fVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgICAgICA8TW9ydGdhZ2VEZXRhaWxDb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgaG9tZVZhbHVlPXtob21lVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGxvYW5BbW91bnQ9e2xvYW5BbW91bnR9XG4gICAgICAgICAgICAgICAgICAgIGludGVyZXN0UmF0ZT17aW50ZXJlc3RSYXRlfVxuICAgICAgICAgICAgICAgICAgICBsb2FuVGVybT17bG9hblRlcm19XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZU1vbnRoPXtzdGFydERhdGVNb250aH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlWWVhcj17c3RhcnREYXRlWWVhcn1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlUYXg9e3Byb3BlcnR5VGF4fVxuICAgICAgICAgICAgICAgICAgICBQTUk9e1BNSX1cbiAgICAgICAgICAgICAgICAgICAgaG9tZUluc3VyYW5jZT17aG9tZUluc3VyYW5jZX1cbiAgICAgICAgICAgICAgICAgICAgZG93blBheW1lbnQ9e2Rvd25QYXltZW50fVxuICAgICAgICAgICAgICAgICAgICBkb3duUGF5bWVudFBlcmNlbnQ9e2Rvd25QYXltZW50UGVyY2VudH1cbiAgICAgICAgICAgICAgICAgICAgbW9udGhseUhPQT17bW9udGhseUhPQX1cbiAgICAgICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICAgICAgPEJpV2Vla2x5Q29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRobHlQYXltZW50PXttb250aGx5UGF5bWVudCAtIGNhbGNQTUkobG9hbkFtb3VudCwgUE1JKX1cbiAgICAgICAgICAgICAgICAgICAgbW9udGhseVBheU9mZkRhdGU9e2xvYW5FbmREYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlTW9udGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGVZZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hblRlcm1cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgdG90YWxJbnRlcmVzdD17Y2FsY3VsYXRlVG90YWxJbnRlcmVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYW5BbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmVzdFJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FuVGVybVxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1kdmhcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJsb2FuRW5kRGF0ZSIsImNhbGN1bGF0ZVRvdGFsSW50ZXJlc3QiLCJjYWxjUE1JIiwiSW5wdXRDb250YWluZXIiLCJHcmFwaENvbnRhaW5lciIsIk1vcnRnYWdlRGV0YWlsQ29udGFpbmVyIiwiQmlXZWVrbHlDb250YWluZXIiLCJIb21lIiwiaG9tZVZhbHVlIiwic2V0SG9tZVZhbHVlIiwiZG93blBheW1lbnQiLCJzZXREb3duUGF5bWVudCIsImRvd25QYXltZW50UGVyY2VudCIsInNldERvd25QYXltZW50UGVyY2VudCIsImxvYW5BbW91bnQiLCJzZXRMb2FuQW1vdW50IiwiaW50ZXJlc3RSYXRlIiwic2V0SW50ZXJlc3RSYXRlIiwibG9hblRlcm0iLCJzZXRMb2FuVGVybSIsInN0YXJ0RGF0ZU1vbnRoIiwic2V0U3RhcnREYXRlTW9udGgiLCJzdGFydERhdGVZZWFyIiwic2V0U3RhcnREYXRlWWVhciIsInByb3BlcnR5VGF4Iiwic2V0UHJvcGVydHlUYXgiLCJQTUkiLCJzZXRQTUkiLCJob21lSW5zdXJhbmNlIiwic2V0SG9tZUluc3VyYW5jZSIsIm1vbnRobHlIT0EiLCJzZXRNb250aGx5SE9BIiwibW9udGhseVBheW1lbnQiLCJzZXRNb250aGx5UGF5bWVudCIsImRpdiIsImlkIiwiY2xhc3NOYW1lIiwiaGVhZGVyIiwiaDEiLCJtb250aGx5UGF5T2ZmRGF0ZSIsInRvdGFsSW50ZXJlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/utils/Calculations.tsx":
/*!************************************!*\
  !*** ./app/utils/Calculations.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PMIEndDate: function() { return /* binding */ PMIEndDate; },\n/* harmony export */   calcPMI: function() { return /* binding */ calcPMI; },\n/* harmony export */   calcPMILength: function() { return /* binding */ calcPMILength; },\n/* harmony export */   calcTotalPMIPaid: function() { return /* binding */ calcTotalPMIPaid; },\n/* harmony export */   calculateMonthlyPayment: function() { return /* binding */ calculateMonthlyPayment; },\n/* harmony export */   calculateTotalInterest: function() { return /* binding */ calculateTotalInterest; },\n/* harmony export */   calculateTotalPayment: function() { return /* binding */ calculateTotalPayment; },\n/* harmony export */   createOptionsObject: function() { return /* binding */ createOptionsObject; },\n/* harmony export */   loanEndDate: function() { return /* binding */ loanEndDate; }\n/* harmony export */ });\nconst MONTHS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nfunction loanEndDate(startDateMonth, startDateYear, loanTerm) {\n    const endMonth = startDateMonth - 1;\n    const endYear = startDateYear + loanTerm - (endMonth < 1 ? 1 : 0);\n    const endMonthAdjusted = endMonth < 1 ? endMonth + 12 : endMonth;\n    return \"\".concat(MONTHS[endMonthAdjusted - 1], \", \").concat(endYear);\n}\nfunction PMIEndDate(startDateMonth, startDateYear, length) {\n    const years = Math.floor(length / 12);\n    const months = length % 12;\n    const endMonth = startDateMonth + months;\n    const endYear = startDateYear + years + (endMonth > 12 ? 1 : 0);\n    const endMonthAdjusted = endMonth > 12 ? endMonth - 12 : endMonth;\n    return \"\".concat(MONTHS[endMonthAdjusted - 1], \", \").concat(endYear);\n}\n_c = PMIEndDate;\nfunction createOptionsObject(props) {\n    const { loanAmount, interestRate, loanTerm, propertyTax, homeInsurance, monthlyHOA, downPayment } = props;\n    const principal = loanAmount;\n    const interest = calculateTotalInterest(loanAmount, interestRate, loanTerm);\n    const totalPropertyTax = propertyTax * loanTerm;\n    const HOAandInsurance = homeInsurance * loanTerm + monthlyHOA * loanTerm * 12;\n    const total = calculateTotalPayment(props);\n    return {\n        principal: parseFloat((principal / total * 100).toFixed(2)),\n        interest: parseFloat((interest / total * 100).toFixed(2)),\n        propertyTax: parseFloat((totalPropertyTax / total * 100).toFixed(2)),\n        HOAandInsurance: parseFloat((HOAandInsurance / total * 100).toFixed(2)),\n        downPayment: parseFloat((downPayment / total * 100).toFixed(2))\n    };\n}\nfunction calcPMI(loanAmount, PMI) {\n    return PMI / 100 * loanAmount / 12;\n}\nfunction calcPMILength(homeValue, loanAmount, interestRate, loanTerm) {\n    if (loanAmount <= homeValue * 0.8) {\n        return 0;\n    }\n    const monthlyInterestRate = interestRate / 100 / 12;\n    const pureMonthlyPayment = calculatePureMonthlyPayment(interestRate, loanAmount, loanTerm);\n    let i = -1;\n    while(loanAmount > homeValue * 0.8){\n        const monthlyInterestPaid = loanAmount * monthlyInterestRate;\n        const principalPaid = pureMonthlyPayment - monthlyInterestPaid;\n        loanAmount -= principalPaid;\n        i++;\n    }\n    return i;\n}\nfunction calcTotalPMIPaid(homeValue, loanAmount, PMI, interestRate, loanTerm) {\n    const monthlyPMI = calcPMI(loanAmount, PMI);\n    const monthlyInterestRate = interestRate / 100 / 12;\n    const pureMonthlyPayment = calculatePureMonthlyPayment(interestRate, loanAmount, loanTerm);\n    let i = -1;\n    while(loanAmount > homeValue * 0.8){\n        const monthlyInterestPaid = loanAmount * monthlyInterestRate;\n        const principalPaid = pureMonthlyPayment - monthlyInterestPaid;\n        loanAmount -= principalPaid;\n        i++;\n    }\n    return i > 0 ? monthlyPMI * i : 0;\n}\nfunction calculateTotalInterest(loanAmount, interestRate, loanTerm) {\n    const monthlyRate = interestRate / 100 / 12;\n    const monthlyPayment = monthlyRate * loanAmount / (1 - (1 + monthlyRate) ** -(loanTerm * 12));\n    let totalInterestPaid = 0;\n    for(let i = 0; i < loanTerm * 12; i++){\n        const monthlyInterestPaid = loanAmount * monthlyRate;\n        const principalPaid = monthlyPayment - monthlyInterestPaid;\n        loanAmount -= principalPaid;\n        totalInterestPaid += monthlyInterestPaid;\n    }\n    return totalInterestPaid;\n}\nfunction calculateMonthlyPayment(loanAmount, interestRate, loanTerm, PMI, propertyTax, homeInsurance, monthlyHOA, downPaymentPercent) {\n    const monthlyInterestRate = interestRate / 100 / 12;\n    const numberOfPayments = loanTerm * 12;\n    let monthlyPayment = loanAmount * monthlyInterestRate / (1 - Math.pow(1 + monthlyInterestRate, -numberOfPayments));\n    const monthlyPropertyTax = propertyTax / 12;\n    const monthlyPMI = PMI / 100 * loanAmount / 12;\n    const monthlyHomeInsurance = homeInsurance / 12;\n    monthlyPayment += monthlyPropertyTax + (downPaymentPercent < 20 ? monthlyPMI : 0) + monthlyHomeInsurance + monthlyHOA;\n    return monthlyPayment;\n}\nfunction calculateTotalPayment(param) {\n    let { homeValue, interestRate, loanAmount, loanTerm, PMI, propertyTax, homeInsurance, monthlyHOA } = param;\n    const totalInterestPaid = calculateTotalInterest(loanAmount, interestRate, loanTerm);\n    const totalPMIPaid = calcTotalPMIPaid(homeValue, loanAmount, PMI, interestRate, loanTerm);\n    const totalPropertyTax = propertyTax * loanTerm;\n    const totalHomeInsurance = homeInsurance * loanTerm;\n    const totalHOA = monthlyHOA * loanTerm * 12;\n    return loanAmount + totalInterestPaid + totalPMIPaid + totalPropertyTax + totalHomeInsurance + totalHOA;\n}\nfunction calculatePureMonthlyPayment(interestRate, loanAmount, loanTerm) {\n    const monthlyRate = interestRate / 100 / 12;\n    const monthlyPayment = monthlyRate * loanAmount / (1 - (1 + monthlyRate) ** -(loanTerm * 12));\n    return monthlyPayment;\n} // function calculateMonthlyPaymentWithPMI(\n //     interestRate: number,\n //     loanAmount: number,\n //     loanTerm: number,\n //     PMI: number\n // ): number {\n //     const monthlyRate = interestRate / 100 / 12;\n //     const monthlyPayment =\n //         (monthlyRate * loanAmount) /\n //         (1 - (1 + monthlyRate) ** -(loanTerm * 12));\n //     const monthlyPMI = ((PMI / 100) * loanAmount) / 12;\n //     return monthlyPayment + monthlyPMI;\n // }\nvar _c;\n$RefreshReg$(_c, \"PMIEndDate\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy9DYWxjdWxhdGlvbnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVVBLE1BQU1BLFNBQVM7SUFDWDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUVNLFNBQVNDLFlBQ1pDLGNBQXNCLEVBQ3RCQyxhQUFxQixFQUNyQkMsUUFBZ0I7SUFFaEIsTUFBTUMsV0FBV0gsaUJBQWlCO0lBQ2xDLE1BQU1JLFVBQVVILGdCQUFnQkMsV0FBWUMsQ0FBQUEsV0FBVyxJQUFJLElBQUk7SUFDL0QsTUFBTUUsbUJBQW1CRixXQUFXLElBQUlBLFdBQVcsS0FBS0E7SUFDeEQsT0FBTyxHQUFvQ0MsT0FBakNOLE1BQU0sQ0FBQ08sbUJBQW1CLEVBQUUsRUFBQyxNQUFZLE9BQVJEO0FBQy9DO0FBRU8sU0FBU0UsV0FDWk4sY0FBc0IsRUFDdEJDLGFBQXFCLEVBQ3JCTSxNQUFjO0lBRWQsTUFBTUMsUUFBUUMsS0FBS0MsS0FBSyxDQUFDSCxTQUFTO0lBQ2xDLE1BQU1JLFNBQVNKLFNBQVM7SUFDeEIsTUFBTUosV0FBV0gsaUJBQWlCVztJQUNsQyxNQUFNUCxVQUFVSCxnQkFBZ0JPLFFBQVNMLENBQUFBLFdBQVcsS0FBSyxJQUFJO0lBQzdELE1BQU1FLG1CQUFtQkYsV0FBVyxLQUFLQSxXQUFXLEtBQUtBO0lBQ3pELE9BQU8sR0FBb0NDLE9BQWpDTixNQUFNLENBQUNPLG1CQUFtQixFQUFFLEVBQUMsTUFBWSxPQUFSRDtBQUMvQztLQVhnQkU7QUFhVCxTQUFTTSxvQkFBb0JDLEtBQTBCO0lBQzFELE1BQU0sRUFDRkMsVUFBVSxFQUNWQyxZQUFZLEVBQ1piLFFBQVEsRUFDUmMsV0FBVyxFQUNYQyxhQUFhLEVBQ2JDLFVBQVUsRUFDVkMsV0FBVyxFQUNkLEdBQUdOO0lBRUosTUFBTU8sWUFBWU47SUFDbEIsTUFBTU8sV0FBV0MsdUJBQXVCUixZQUFZQyxjQUFj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MTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR3JhcGhDb250YWluZXJQcm9wcyB9IGZyb20gXCIuLi9jb21wb25lbnRzL0dyYXBoQ29udGFpbmVyXCI7XG5pbXBvcnQgeyBNb3J0Z2FnZUNvbnRhaW5lclByb3BzIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvTW9ydGdhZ2VEZXRhaWxDb250YWluZXJcIjtcblxuaW50ZXJmYWNlIG9wdGlvbnNPYmplY3Qge1xuICAgIHByaW5jaXBhbDogbnVtYmVyO1xuICAgIGludGVyZXN0OiBudW1iZXI7XG4gICAgcHJvcGVydHlUYXg6IG51bWJlcjtcbiAgICBIT0FhbmRJbnN1cmFuY2U6IG51bWJlcjtcbiAgICBkb3duUGF5bWVudDogbnVtYmVyO1xufVxuY29uc3QgTU9OVEhTID0gW1xuICAgIFwiSmFuXCIsXG4gICAgXCJGZWJcIixcbiAgICBcIk1hclwiLFxuICAgIFwiQXByXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1blwiLFxuICAgIFwiSnVsXCIsXG4gICAgXCJBdWdcIixcbiAgICBcIlNlcFwiLFxuICAgIFwiT2N0XCIsXG4gICAgXCJOb3ZcIixcbiAgICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYW5FbmREYXRlKFxuICAgIHN0YXJ0RGF0ZU1vbnRoOiBudW1iZXIsXG4gICAgc3RhcnREYXRlWWVhcjogbnVtYmVyLFxuICAgIGxvYW5UZXJtOiBudW1iZXJcbikge1xuICAgIGNvbnN0IGVuZE1vbnRoID0gc3RhcnREYXRlTW9udGggLSAxO1xuICAgIGNvbnN0IGVuZFllYXIgPSBzdGFydERhdGVZZWFyICsgbG9hblRlcm0gLSAoZW5kTW9udGggPCAxID8gMSA6IDApO1xuICAgIGNvbnN0IGVuZE1vbnRoQWRqdXN0ZWQgPSBlbmRNb250aCA8IDEgPyBlbmRNb250aCArIDEyIDogZW5kTW9udGg7XG4gICAgcmV0dXJuIGAke01PTlRIU1tlbmRNb250aEFkanVzdGVkIC0gMV19LCAke2VuZFllYXJ9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBNSUVuZERhdGUoXG4gICAgc3RhcnREYXRlTW9udGg6IG51bWJlcixcbiAgICBzdGFydERhdGVZZWFyOiBudW1iZXIsXG4gICAgbGVuZ3RoOiBudW1iZXJcbikge1xuICAgIGNvbnN0IHllYXJzID0gTWF0aC5mbG9vcihsZW5ndGggLyAxMik7XG4gICAgY29uc3QgbW9udGhzID0gbGVuZ3RoICUgMTI7XG4gICAgY29uc3QgZW5kTW9udGggPSBzdGFydERhdGVNb250aCArIG1vbnRocztcbiAgICBjb25zdCBlbmRZZWFyID0gc3RhcnREYXRlWWVhciArIHllYXJzICsgKGVuZE1vbnRoID4gMTIgPyAxIDogMCk7XG4gICAgY29uc3QgZW5kTW9udGhBZGp1c3RlZCA9IGVuZE1vbnRoID4gMTIgPyBlbmRNb250aCAtIDEyIDogZW5kTW9udGg7XG4gICAgcmV0dXJuIGAke01PTlRIU1tlbmRNb250aEFkanVzdGVkIC0gMV19LCAke2VuZFllYXJ9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnNPYmplY3QocHJvcHM6IEdyYXBoQ29udGFpbmVyUHJvcHMpOiBvcHRpb25zT2JqZWN0IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGxvYW5BbW91bnQsXG4gICAgICAgIGludGVyZXN0UmF0ZSxcbiAgICAgICAgbG9hblRlcm0sXG4gICAgICAgIHByb3BlcnR5VGF4LFxuICAgICAgICBob21lSW5zdXJhbmNlLFxuICAgICAgICBtb250aGx5SE9BLFxuICAgICAgICBkb3duUGF5bWVudCxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBjb25zdCBwcmluY2lwYWwgPSBsb2FuQW1vdW50O1xuICAgIGNvbnN0IGludGVyZXN0ID0gY2FsY3VsYXRlVG90YWxJbnRlcmVzdChsb2FuQW1vdW50LCBpbnRlcmVzdFJhdGUsIGxvYW5UZXJtKTtcbiAgICBjb25zdCB0b3RhbFByb3BlcnR5VGF4ID0gcHJvcGVydHlUYXggKiBsb2FuVGVybTtcbiAgICBjb25zdCBIT0FhbmRJbnN1cmFuY2UgPVxuICAgICAgICBob21lSW5zdXJhbmNlICogbG9hblRlcm0gKyBtb250aGx5SE9BICogbG9hblRlcm0gKiAxMjtcblxuICAgIGNvbnN0IHRvdGFsID0gY2FsY3VsYXRlVG90YWxQYXltZW50KHByb3BzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmluY2lwYWw6IHBhcnNlRmxvYXQoKChwcmluY2lwYWwgLyB0b3RhbCkgKiAxMDApLnRvRml4ZWQoMikpLFxuICAgICAgICBpbnRlcmVzdDogcGFyc2VGbG9hdCgoKGludGVyZXN0IC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpKSxcbiAgICAgICAgcHJvcGVydHlUYXg6IHBhcnNlRmxvYXQoKCh0b3RhbFByb3BlcnR5VGF4IC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpKSxcbiAgICAgICAgSE9BYW5kSW5zdXJhbmNlOiBwYXJzZUZsb2F0KFxuICAgICAgICAgICAgKChIT0FhbmRJbnN1cmFuY2UgLyB0b3RhbCkgKiAxMDApLnRvRml4ZWQoMilcbiAgICAgICAgKSxcbiAgICAgICAgZG93blBheW1lbnQ6IHBhcnNlRmxvYXQoKChkb3duUGF5bWVudCAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgyKSksXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNQTUkobG9hbkFtb3VudDogbnVtYmVyLCBQTUk6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuICgoUE1JIC8gMTAwKSAqIGxvYW5BbW91bnQpIC8gMTI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjUE1JTGVuZ3RoKFxuICAgIGhvbWVWYWx1ZTogbnVtYmVyLFxuICAgIGxvYW5BbW91bnQ6IG51bWJlcixcbiAgICBpbnRlcmVzdFJhdGU6IG51bWJlcixcbiAgICBsb2FuVGVybTogbnVtYmVyXG4pIHtcbiAgICBpZiAobG9hbkFtb3VudCA8PSBob21lVmFsdWUgKiAwLjgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgbW9udGhseUludGVyZXN0UmF0ZSA9IGludGVyZXN0UmF0ZSAvIDEwMCAvIDEyO1xuICAgIGNvbnN0IHB1cmVNb250aGx5UGF5bWVudCA9IGNhbGN1bGF0ZVB1cmVNb250aGx5UGF5bWVudChcbiAgICAgICAgaW50ZXJlc3RSYXRlLFxuICAgICAgICBsb2FuQW1vdW50LFxuICAgICAgICBsb2FuVGVybVxuICAgICk7XG5cbiAgICBsZXQgaSA9IC0xO1xuICAgIHdoaWxlIChsb2FuQW1vdW50ID4gaG9tZVZhbHVlICogMC44KSB7XG4gICAgICAgIGNvbnN0IG1vbnRobHlJbnRlcmVzdFBhaWQgPSBsb2FuQW1vdW50ICogbW9udGhseUludGVyZXN0UmF0ZTtcbiAgICAgICAgY29uc3QgcHJpbmNpcGFsUGFpZCA9IHB1cmVNb250aGx5UGF5bWVudCAtIG1vbnRobHlJbnRlcmVzdFBhaWQ7XG4gICAgICAgIGxvYW5BbW91bnQgLT0gcHJpbmNpcGFsUGFpZDtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb3RhbFBNSVBhaWQoXG4gICAgaG9tZVZhbHVlOiBudW1iZXIsXG4gICAgbG9hbkFtb3VudDogbnVtYmVyLFxuICAgIFBNSTogbnVtYmVyLFxuICAgIGludGVyZXN0UmF0ZTogbnVtYmVyLFxuICAgIGxvYW5UZXJtOiBudW1iZXJcbik6IG51bWJlciB7XG4gICAgY29uc3QgbW9udGhseVBNSSA9IGNhbGNQTUkobG9hbkFtb3VudCwgUE1JKTtcbiAgICBjb25zdCBtb250aGx5SW50ZXJlc3RSYXRlID0gaW50ZXJlc3RSYXRlIC8gMTAwIC8gMTI7XG4gICAgY29uc3QgcHVyZU1vbnRobHlQYXltZW50ID0gY2FsY3VsYXRlUHVyZU1vbnRobHlQYXltZW50KFxuICAgICAgICBpbnRlcmVzdFJhdGUsXG4gICAgICAgIGxvYW5BbW91bnQsXG4gICAgICAgIGxvYW5UZXJtXG4gICAgKTtcblxuICAgIGxldCBpID0gLTE7XG4gICAgd2hpbGUgKGxvYW5BbW91bnQgPiBob21lVmFsdWUgKiAwLjgpIHtcbiAgICAgICAgY29uc3QgbW9udGhseUludGVyZXN0UGFpZCA9IGxvYW5BbW91bnQgKiBtb250aGx5SW50ZXJlc3RSYXRlO1xuICAgICAgICBjb25zdCBwcmluY2lwYWxQYWlkID0gcHVyZU1vbnRobHlQYXltZW50IC0gbW9udGhseUludGVyZXN0UGFpZDtcbiAgICAgICAgbG9hbkFtb3VudCAtPSBwcmluY2lwYWxQYWlkO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBpID4gMCA/IG1vbnRobHlQTUkgKiBpIDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVRvdGFsSW50ZXJlc3QoXG4gICAgbG9hbkFtb3VudDogbnVtYmVyLFxuICAgIGludGVyZXN0UmF0ZTogbnVtYmVyLFxuICAgIGxvYW5UZXJtOiBudW1iZXJcbik6IG51bWJlciB7XG4gICAgY29uc3QgbW9udGhseVJhdGUgPSBpbnRlcmVzdFJhdGUgLyAxMDAgLyAxMjtcbiAgICBjb25zdCBtb250aGx5UGF5bWVudCA9XG4gICAgICAgIChtb250aGx5UmF0ZSAqIGxvYW5BbW91bnQpIC9cbiAgICAgICAgKDEgLSAoMSArIG1vbnRobHlSYXRlKSAqKiAtKGxvYW5UZXJtICogMTIpKTtcbiAgICBsZXQgdG90YWxJbnRlcmVzdFBhaWQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2FuVGVybSAqIDEyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbW9udGhseUludGVyZXN0UGFpZCA9IGxvYW5BbW91bnQgKiBtb250aGx5UmF0ZTtcbiAgICAgICAgY29uc3QgcHJpbmNpcGFsUGFpZCA9IG1vbnRobHlQYXltZW50IC0gbW9udGhseUludGVyZXN0UGFpZDtcbiAgICAgICAgbG9hbkFtb3VudCAtPSBwcmluY2lwYWxQYWlkO1xuICAgICAgICB0b3RhbEludGVyZXN0UGFpZCArPSBtb250aGx5SW50ZXJlc3RQYWlkO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbEludGVyZXN0UGFpZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1vbnRobHlQYXltZW50KFxuICAgIGxvYW5BbW91bnQ6IG51bWJlcixcbiAgICBpbnRlcmVzdFJhdGU6IG51bWJlcixcbiAgICBsb2FuVGVybTogbnVtYmVyLFxuICAgIFBNSTogbnVtYmVyLFxuICAgIHByb3BlcnR5VGF4OiBudW1iZXIsXG4gICAgaG9tZUluc3VyYW5jZTogbnVtYmVyLFxuICAgIG1vbnRobHlIT0E6IG51bWJlcixcbiAgICBkb3duUGF5bWVudFBlcmNlbnQ6IG51bWJlclxuKSB7XG4gICAgY29uc3QgbW9udGhseUludGVyZXN0UmF0ZSA9IGludGVyZXN0UmF0ZSAvIDEwMCAvIDEyO1xuICAgIGNvbnN0IG51bWJlck9mUGF5bWVudHMgPSBsb2FuVGVybSAqIDEyO1xuICAgIGxldCBtb250aGx5UGF5bWVudCA9XG4gICAgICAgIChsb2FuQW1vdW50ICogbW9udGhseUludGVyZXN0UmF0ZSkgL1xuICAgICAgICAoMSAtIE1hdGgucG93KDEgKyBtb250aGx5SW50ZXJlc3RSYXRlLCAtbnVtYmVyT2ZQYXltZW50cykpO1xuXG4gICAgY29uc3QgbW9udGhseVByb3BlcnR5VGF4ID0gcHJvcGVydHlUYXggLyAxMjtcbiAgICBjb25zdCBtb250aGx5UE1JID0gKChQTUkgLyAxMDApICogbG9hbkFtb3VudCkgLyAxMjtcbiAgICBjb25zdCBtb250aGx5SG9tZUluc3VyYW5jZSA9IGhvbWVJbnN1cmFuY2UgLyAxMjtcbiAgICBtb250aGx5UGF5bWVudCArPVxuICAgICAgICBtb250aGx5UHJvcGVydHlUYXggK1xuICAgICAgICAoZG93blBheW1lbnRQZXJjZW50IDwgMjAgPyBtb250aGx5UE1JIDogMCkgK1xuICAgICAgICBtb250aGx5SG9tZUluc3VyYW5jZSArXG4gICAgICAgIG1vbnRobHlIT0E7XG4gICAgcmV0dXJuIG1vbnRobHlQYXltZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVG90YWxQYXltZW50KHtcbiAgICBob21lVmFsdWUsXG4gICAgaW50ZXJlc3RSYXRlLFxuICAgIGxvYW5BbW91bnQsXG4gICAgbG9hblRlcm0sXG4gICAgUE1JLFxuICAgIHByb3BlcnR5VGF4LFxuICAgIGhvbWVJbnN1cmFuY2UsXG4gICAgbW9udGhseUhPQSxcbn06IEdyYXBoQ29udGFpbmVyUHJvcHMgfCBNb3J0Z2FnZUNvbnRhaW5lclByb3BzKTogbnVtYmVyIHtcbiAgICBjb25zdCB0b3RhbEludGVyZXN0UGFpZCA9IGNhbGN1bGF0ZVRvdGFsSW50ZXJlc3QoXG4gICAgICAgIGxvYW5BbW91bnQsXG4gICAgICAgIGludGVyZXN0UmF0ZSxcbiAgICAgICAgbG9hblRlcm1cbiAgICApO1xuXG4gICAgY29uc3QgdG90YWxQTUlQYWlkID0gY2FsY1RvdGFsUE1JUGFpZChcbiAgICAgICAgaG9tZVZhbHVlLFxuICAgICAgICBsb2FuQW1vdW50LFxuICAgICAgICBQTUksXG4gICAgICAgIGludGVyZXN0UmF0ZSxcbiAgICAgICAgbG9hblRlcm1cbiAgICApO1xuXG4gICAgY29uc3QgdG90YWxQcm9wZXJ0eVRheCA9IHByb3BlcnR5VGF4ICogbG9hblRlcm07XG4gICAgY29uc3QgdG90YWxIb21lSW5zdXJhbmNlID0gaG9tZUluc3VyYW5jZSAqIGxvYW5UZXJtO1xuICAgIGNvbnN0IHRvdGFsSE9BID0gbW9udGhseUhPQSAqIGxvYW5UZXJtICogMTI7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBsb2FuQW1vdW50ICtcbiAgICAgICAgdG90YWxJbnRlcmVzdFBhaWQgK1xuICAgICAgICB0b3RhbFBNSVBhaWQgK1xuICAgICAgICB0b3RhbFByb3BlcnR5VGF4ICtcbiAgICAgICAgdG90YWxIb21lSW5zdXJhbmNlICtcbiAgICAgICAgdG90YWxIT0FcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQdXJlTW9udGhseVBheW1lbnQoXG4gICAgaW50ZXJlc3RSYXRlOiBudW1iZXIsXG4gICAgbG9hbkFtb3VudDogbnVtYmVyLFxuICAgIGxvYW5UZXJtOiBudW1iZXJcbik6IG51bWJlciB7XG4gICAgY29uc3QgbW9udGhseVJhdGUgPSBpbnRlcmVzdFJhdGUgLyAxMDAgLyAxMjtcbiAgICBjb25zdCBtb250aGx5UGF5bWVudCA9XG4gICAgICAgIChtb250aGx5UmF0ZSAqIGxvYW5BbW91bnQpIC9cbiAgICAgICAgKDEgLSAoMSArIG1vbnRobHlSYXRlKSAqKiAtKGxvYW5UZXJtICogMTIpKTtcblxuICAgIHJldHVybiBtb250aGx5UGF5bWVudDtcbn1cblxuLy8gZnVuY3Rpb24gY2FsY3VsYXRlTW9udGhseVBheW1lbnRXaXRoUE1JKFxuLy8gICAgIGludGVyZXN0UmF0ZTogbnVtYmVyLFxuLy8gICAgIGxvYW5BbW91bnQ6IG51bWJlcixcbi8vICAgICBsb2FuVGVybTogbnVtYmVyLFxuLy8gICAgIFBNSTogbnVtYmVyXG4vLyApOiBudW1iZXIge1xuLy8gICAgIGNvbnN0IG1vbnRobHlSYXRlID0gaW50ZXJlc3RSYXRlIC8gMTAwIC8gMTI7XG4vLyAgICAgY29uc3QgbW9udGhseVBheW1lbnQgPVxuLy8gICAgICAgICAobW9udGhseVJhdGUgKiBsb2FuQW1vdW50KSAvXG4vLyAgICAgICAgICgxIC0gKDEgKyBtb250aGx5UmF0ZSkgKiogLShsb2FuVGVybSAqIDEyKSk7XG4vLyAgICAgY29uc3QgbW9udGhseVBNSSA9ICgoUE1JIC8gMTAwKSAqIGxvYW5BbW91bnQpIC8gMTI7XG5cbi8vICAgICByZXR1cm4gbW9udGhseVBheW1lbnQgKyBtb250aGx5UE1JO1xuLy8gfVxuIl0sIm5hbWVzIjpbIk1PTlRIUyIsImxvYW5FbmREYXRlIiwic3RhcnREYXRlTW9udGgiLCJzdGFydERhdGVZZWFyIiwibG9hblRlcm0iLCJlbmRNb250aCIsImVuZFllYXIiLCJlbmRNb250aEFkanVzdGVkIiwiUE1JRW5kRGF0ZSIsImxlbmd0aCIsInllYXJzIiwiTWF0aCIsImZsb29yIiwibW9udGhzIiwiY3JlYXRlT3B0aW9uc09iamVjdCIsInByb3BzIiwibG9hbkFtb3VudCIsImludGVyZXN0UmF0ZSIsInByb3BlcnR5VGF4IiwiaG9tZUluc3VyYW5jZSIsIm1vbnRobHlIT0EiLCJkb3duUGF5bWVudCIsInByaW5jaXBhbCIsImludGVyZXN0IiwiY2FsY3VsYXRlVG90YWxJbnRlcmVzdCIsInRvdGFsUHJvcGVydHlUYXgiLCJIT0FhbmRJbnN1cmFuY2UiLCJ0b3RhbCIsImNhbGN1bGF0ZVRvdGFsUGF5bWVudCIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiY2FsY1BNSSIsIlBNSSIsImNhbGNQTUlMZW5ndGgiLCJob21lVmFsdWUiLCJtb250aGx5SW50ZXJlc3RSYXRlIiwicHVyZU1vbnRobHlQYXltZW50IiwiY2FsY3VsYXRlUHVyZU1vbnRobHlQYXltZW50IiwiaSIsIm1vbnRobHlJbnRlcmVzdFBhaWQiLCJwcmluY2lwYWxQYWlkIiwiY2FsY1RvdGFsUE1JUGFpZCIsIm1vbnRobHlQTUkiLCJtb250aGx5UmF0ZSIsIm1vbnRobHlQYXltZW50IiwidG90YWxJbnRlcmVzdFBhaWQiLCJjYWxjdWxhdGVNb250aGx5UGF5bWVudCIsImRvd25QYXltZW50UGVyY2VudCIsIm51bWJlck9mUGF5bWVudHMiLCJwb3ciLCJtb250aGx5UHJvcGVydHlUYXgiLCJtb250aGx5SG9tZUluc3VyYW5jZSIsInRvdGFsUE1JUGFpZCIsInRvdGFsSG9tZUluc3VyYW5jZSIsInRvdGFsSE9BIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/Calculations.tsx\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Festevaolordeiro%2FGitHub%2Fmortgage-calculator%2Fapp%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);